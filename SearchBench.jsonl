{"diff_sorted_id": "1", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[12, 55, '_'], [35, 97, 43], [17, 25, 9]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[55, 97, 35, 12, 97, 55, 43, 9, 25, 17, 12, 35, 9, 25, 17, 9, 25, 17]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.04202771186828613", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[12, 55, \"_\"], [35, 97, 43], [17, 25, 9]]]", "is_correct_args": "[[[12, 55, \"_\"], [35, 97, 43], [17, 25, 9]]]", "A*_args": "[\"[[12, 55, '_'], [35, 97, 43], [17, 25, 9]]\"]"}
{"diff_sorted_id": "1", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: cam, hill, pray, doer   The initial board: [['i', 'c', 'a', 'm'], ['h', 'p', 'l', 'o'], ['_', 'r', 'a', 'y'], ['d', 'l', 'e', 'r']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.21660590171813965", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"i\", \"c\", \"a\", \"m\"], [\"h\", \"p\", \"l\", \"o\"], [\"_\", \"r\", \"a\", \"y\"], [\"d\", \"l\", \"e\", \"r\"]]]", "is_correct_args": "[[[\"i\", \"c\", \"a\", \"m\"], [\"h\", \"p\", \"l\", \"o\"], [\"_\", \"r\", \"a\", \"y\"], [\"d\", \"l\", \"e\", \"r\"]], [\"cam\", \"hill\", \"pray\", \"doer\"]]", "A*_args": "[\"[['i', 'c', 'a', 'm'], ['h', 'p', 'l', 'o'], ['_', 'r', 'a', 'y'], ['d', 'l', 'e', 'r']]\", \"['cam', 'hill', 'pray', 'doer']\"]"}
{"diff_sorted_id": "1", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'W'. Our task is to visit city A and city H excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from H and A, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  G D X N Y W A P V H \nG 0 0 0 0 0 0 0 0 0 1 \nD 0 0 0 0 0 0 0 1 0 0 \nX 1 0 0 0 1 1 0 0 0 0 \nN 0 0 0 0 0 1 1 0 0 1 \nY 0 0 1 1 0 0 1 0 0 0 \nW 0 0 1 0 0 0 0 0 0 0 \nA 1 1 1 0 0 0 0 0 1 0 \nP 1 0 0 0 1 0 0 0 0 1 \nV 1 0 0 0 0 0 0 1 0 0 \nH 1 1 0 1 0 0 1 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[\"W\", \"X\", \"G\", \"H\", \"A\", \"D\", \"P\", \"H\", \"A\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.020942211151123047", "solution_depth": "9", "max_successor_states": "10", "num_vars_per_state": "13", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 1], [0, 0, 1, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 1, 0, 0, 1, 1, 0, 0]], [\"G\", \"D\", \"X\", \"N\", \"Y\", \"W\", \"A\", \"P\", \"V\", \"H\"], \"A\", \"H\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 1], [0, 0, 1, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 1, 0, 0, 1, 1, 0, 0]], [\"G\", \"D\", \"X\", \"N\", \"Y\", \"W\", \"A\", \"P\", \"V\", \"H\"], \"W\", \"A\", \"H\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 1], [0, 0, 1, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 1, 0, 0, 1, 1, 0, 0]]\", \"['G', 'D', 'X', 'N', 'Y', 'W', 'A', 'P', 'V', 'H']\", \"['W']\", \"['A', 'H']\"]"}
{"diff_sorted_id": "1", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [14, 2, 5, 8, 65, 5, 16, 2, 5, 2, 12, 17, 16, 15, 20, 4, 19, 9, 10, 64, 2, 10, 14, 2, 17], such that the sum of the chosen coins adds up to 208. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {20: 13, 4: 2, 17: 16, 19: 8, 64: 4, 5: 3, 14: 10, 10: 9, 65: 11, 16: 2, 12: 7, 8: 5, 2: 2, 15: 14, 9: 8}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "15", "opt_solution": "[64, 16, 4, 5, 5, 19, 65, 16, 12, 2]", "opt_solution_cost": "44", "opt_solution_compute_t": "0.03430962562561035", "solution_depth": "10", "max_successor_states": "25", "num_vars_per_state": "25", "is_feasible_args": "[[14, 2, 5, 8, 65, 5, 16, 2, 5, 2, 12, 17, 16, 15, 20, 4, 19, 9, 10, 64, 2, 10, 14, 2, 17]]", "is_correct_args": "[[14, 2, 5, 8, 65, 5, 16, 2, 5, 2, 12, 17, 16, 15, 20, 4, 19, 9, 10, 64, 2, 10, 14, 2, 17], {\"20\": 13, \"4\": 2, \"17\": 16, \"19\": 8, \"64\": 4, \"5\": 3, \"14\": 10, \"10\": 9, \"65\": 11, \"16\": 2, \"12\": 7, \"8\": 5, \"2\": 2, \"15\": 14, \"9\": 8}, 208]", "A*_args": "[\"[14, 2, 5, 8, 65, 5, 16, 2, 5, 2, 12, 17, 16, 15, 20, 4, 19, 9, 10, 64, 2, 10, 14, 2, 17]\", \"{20: 13, 4: 2, 17: 16, 19: 8, 64: 4, 5: 3, 14: 10, 10: 9, 65: 11, 16: 2, 12: 7, 8: 5, 2: 2, 15: 14, 9: 8}\", \"208\"]"}
{"diff_sorted_id": "1", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Red', 'Green', 'Red'], ['Blue', 'Blue', 'Red', 'Green'], ['Red', 'Blue', 'Green', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[0, 1], [0, 2], [0, 1], [2, 0], [2, 0], [1, 0], [1, 0], [2, 1], [2, 0], [1, 2], [1, 2], [1, 2], [1, 2], [0, 1], [0, 1], [0, 1], [2, 0]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.9051551818847656", "solution_depth": "17", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Red\", \"Green\", \"Red\"], [\"Blue\", \"Blue\", \"Red\", \"Green\"], [\"Red\", \"Blue\", \"Green\", \"Blue\"]], 6]", "is_correct_args": "[[[\"Green\", \"Red\", \"Green\", \"Red\"], [\"Blue\", \"Blue\", \"Red\", \"Green\"], [\"Red\", \"Blue\", \"Green\", \"Blue\"]], 6]", "A*_args": "[\"[['Green', 'Red', 'Green', 'Red'], ['Blue', 'Blue', 'Red', 'Green'], ['Red', 'Blue', 'Green', 'Blue']]\", \"6\"]"}
{"diff_sorted_id": "1", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 13 to 46 (13 included in the range but 46 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['16' 'x' '41']\n ['x' '30' 'x']\n ['x' '29' '30']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 1, 31], [1, 0, 14], [1, 2, 32], [2, 0, 13]]", "opt_solution_cost": "267", "opt_solution_compute_t": "0.23554539680480957", "solution_depth": "4", "max_successor_states": "33", "num_vars_per_state": "9", "is_feasible_args": "[\"[['16', '', '41'], ['', '30', ''], ['', '29', '30']]\", 13, 46]", "is_correct_args": "[\"[['16', '', '41'], ['', '30', ''], ['', '29', '30']]\", 13, 46]", "A*_args": "[\"[['16', '', '41'], ['', '30', ''], ['', '29', '30']]\", \"13\", \"46\"]"}
{"diff_sorted_id": "1", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 29 to 48. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 107, and sum of row 1 must be 103. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 124. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['35' 'x' '46']\n ['x' 'x' 'x']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 1, 31], [1, 0, 29], [1, 1, 44], [1, 2, 30], [2, 0, 34], [2, 1, 32], [2, 2, 33]]", "opt_solution_cost": "314", "opt_solution_compute_t": "0.3927474021911621", "solution_depth": "7", "max_successor_states": "19", "num_vars_per_state": "9", "is_feasible_args": "[\"[['35', '', '46'], ['', '', ''], ['', '', '']]\", 3, 29, 48]", "is_correct_args": "[\"[['35', '', '46'], ['', '', ''], ['', '', '']]\", 29, 48, [1, 2], [1, 2], [107], [103], 124]", "A*_args": "[\"[['35', '', '46'], ['', '', ''], ['', '', '']]\", \"29\", \"48\", \"[None, 107, None]\", \"[None, 103, None]\", \"124\"]"}
{"diff_sorted_id": "1", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 5, 1: 5, 2: 3, 3: 1, 4: 5, 5: 1}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], [], ['Blue', 'Yellow', 'Blue', 'Blue'], ['Red', 'Green', 'Yellow', 'Green'], ['Red', 'Red', 'Yellow', 'Green']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[4, 0], [5, 0], [5, 0], [3, 1], [3, 2], [5, 2], [4, 5], [4, 2], [1, 3], [4, 5]]", "opt_solution_cost": "32", "opt_solution_compute_t": "0.06039690971374512", "solution_depth": "10", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[], [], [], [\"Blue\", \"Yellow\", \"Blue\", \"Blue\"], [\"Red\", \"Green\", \"Yellow\", \"Green\"], [\"Red\", \"Red\", \"Yellow\", \"Green\"]], 4, {\"0\": 5, \"1\": 5, \"2\": 3, \"3\": 1, \"4\": 5, \"5\": 1}]", "is_correct_args": "[[[], [], [], [\"Blue\", \"Yellow\", \"Blue\", \"Blue\"], [\"Red\", \"Green\", \"Yellow\", \"Green\"], [\"Red\", \"Red\", \"Yellow\", \"Green\"]], 4, {\"0\": 5, \"1\": 5, \"2\": 3, \"3\": 1, \"4\": 5, \"5\": 1}, 3]", "A*_args": "[\"[[], [], [], ['Blue', 'Yellow', 'Blue', 'Blue'], ['Red', 'Green', 'Yellow', 'Green'], ['Red', 'Red', 'Yellow', 'Green']]\", \"{0: 5, 1: 5, 2: 3, 3: 1, 4: 5, 5: 1}\", \"4\", \"3\"]"}
{"diff_sorted_id": "1", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (5, 7) to his destination workshop at index (2, 1), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 4, and district 3 covering rows 5 to 8. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[13 x x 3 10 20 3 x 5]\n[x x x x 20 16 x x 17]\n[3 14 18 8 1 20 14 x 7]\n[13 3 6 10 7 4 6 6 1]\n[10 12 2 x 11 x 10 8 11]\n[x x x 11 6 18 13 20 17]\n[x x 16 x 4 17 7 10 15]\n[x 7 16 6 19 4 7 x x]\n[x 11 18 x x x 3 8 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "1", "opt_solution": "[[5, 7], [4, 7], [3, 7], [3, 6], [3, 5], [3, 4], [3, 3], [3, 2], [3, 1], [2, 1]]", "opt_solution_cost": "64", "opt_solution_compute_t": "0.030263185501098633", "solution_depth": "10", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"13\", \"x\", \"x\", \"3\", \"10\", \"20\", \"3\", \"x\", \"5\"], [\"x\", \"x\", \"x\", \"x\", \"20\", \"16\", \"x\", \"x\", \"17\"], [\"3\", \"14\", \"18\", \"8\", \"1\", \"20\", \"14\", \"x\", \"7\"], [\"13\", \"3\", \"6\", \"10\", \"7\", \"4\", \"6\", \"6\", \"1\"], [\"10\", \"12\", \"2\", \"x\", \"11\", \"x\", \"10\", \"8\", \"11\"], [\"x\", \"x\", \"x\", \"11\", \"6\", \"18\", \"13\", \"20\", \"17\"], [\"x\", \"x\", \"16\", \"x\", \"4\", \"17\", \"7\", \"10\", \"15\"], [\"x\", \"7\", \"16\", \"6\", \"19\", \"4\", \"7\", \"x\", \"x\"], [\"x\", \"11\", \"18\", \"x\", \"x\", \"x\", \"3\", \"8\", \"x\"]]]", "is_correct_args": "[[[\"13\", \"x\", \"x\", \"3\", \"10\", \"20\", \"3\", \"x\", \"5\"], [\"x\", \"x\", \"x\", \"x\", \"20\", \"16\", \"x\", \"x\", \"17\"], [\"3\", \"14\", \"18\", \"8\", \"1\", \"20\", \"14\", \"x\", \"7\"], [\"13\", \"3\", \"6\", \"10\", \"7\", \"4\", \"6\", \"6\", \"1\"], [\"10\", \"12\", \"2\", \"x\", \"11\", \"x\", \"10\", \"8\", \"11\"], [\"x\", \"x\", \"x\", \"11\", \"6\", \"18\", \"13\", \"20\", \"17\"], [\"x\", \"x\", \"16\", \"x\", \"4\", \"17\", \"7\", \"10\", \"15\"], [\"x\", \"7\", \"16\", \"6\", \"19\", \"4\", \"7\", \"x\", \"x\"], [\"x\", \"11\", \"18\", \"x\", \"x\", \"x\", \"3\", \"8\", \"x\"]], [5, 7], [2, 1], 2, 4]", "A*_args": "[\"[['13', 'x', 'x', '3', '10', '20', '3', 'x', '5'], ['x', 'x', 'x', 'x', '20', '16', 'x', 'x', '17'], ['3', '14', '18', '8', '1', '20', '14', 'x', '7'], ['13', '3', '6', '10', '7', '4', '6', '6', '1'], ['10', '12', '2', 'x', '11', 'x', '10', '8', '11'], ['x', 'x', 'x', '11', '6', '18', '13', '20', '17'], ['x', 'x', '16', 'x', '4', '17', '7', '10', '15'], ['x', '7', '16', '6', '19', '4', '7', 'x', 'x'], ['x', '11', '18', 'x', 'x', 'x', '3', '8', 'x']]\", \"(5, 7)\", \"(2, 1)\", \"2\", \"4\"]"}
{"diff_sorted_id": "1", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 9x9. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (8, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (2, 7). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 0 1 0 1 1 1 1\n0 0 1 1 0 0 0 0 1\n0 0 0 1 1 1 0 0 1\n0 0 0 0 0 0 0 1 0\n0 0 0 0 0 1 1 1 1\n0 0 1 1 1 1 0 1 1\n0 0 0 1 1 1 1 1 0\n1 0 1 1 1 1 1 0 1\n0 1 1 1 1 1 0 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "9", "opt_solution": "[[8, 0], [7, 1], [6, 1], [5, 1], [4, 1], [4, 2], [4, 3], [4, 4], [3, 5], [3, 6], [2, 7]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.03385114669799805", "solution_depth": "11", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 0, 1, 0, 1, 1, 1, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 0, 1, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 1, 1, 1, 1, 0, 1, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0], [1, 0, 1, 1, 1, 1, 1, 0, 1], [0, 1, 1, 1, 1, 1, 0, 1, 0]]\", 3]", "is_correct_args": "[\"[[0, 1, 0, 1, 0, 1, 1, 1, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 0, 1, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 1, 1, 1, 1, 0, 1, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0], [1, 0, 1, 1, 1, 1, 1, 0, 1], [0, 1, 1, 1, 1, 1, 0, 1, 0]]\", [8, 0], [2, 7], 3]", "A*_args": "[\"[[0, 1, 0, 1, 0, 1, 1, 1, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 0, 1, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 1, 1, 1, 1, 0, 1, 1], [0, 0, 0, 1, 1, 1, 1, 1, 0], [1, 0, 1, 1, 1, 1, 1, 0, 1], [0, 1, 1, 1, 1, 1, 0, 1, 0]]\", \"(8, 0)\", \"(2, 7)\", \"3\"]"}
{"diff_sorted_id": "1", "problem_statement": "Given 5 labeled water jugs with capacities 41, 26, 44, 75, 40, 136 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 274, 297, 343 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 40, 3], [\"+\", 75, 3], [\"+\", 136, 3], [\"-\", 44, 3], [\"+\", 136, 3], [\"+\", 26, 2], [\"+\", 40, 2], [\"+\", 136, 2], [\"-\", 41, 2], [\"+\", 136, 2], [\"+\", 40, 1], [\"+\", 40, 1], [\"+\", 44, 1], [\"+\", 75, 1], [\"+\", 75, 1]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.05471658706665039", "solution_depth": "15", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[41, 26, 44, 75, 40, 136], [274, 297, 343]]", "is_correct_args": "[[41, 26, 44, 75, 40, 136], [274, 297, 343]]", "A*_args": "[\"[41, 26, 44, 75, 40, 136]\", \"[274, 297, 343]\"]"}
{"diff_sorted_id": "2", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[99, 69, 19], [53, '_', 30], [100, 63, 40]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[53, 100, 63, 40, 30, 19, 69, 53, 40, 30, 19, 40, 53, 99, 100, 63, 30, 19]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.03798794746398926", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[99, 69, 19], [53, \"_\", 30], [100, 63, 40]]]", "is_correct_args": "[[[99, 69, 19], [53, \"_\", 30], [100, 63, 40]]]", "A*_args": "[\"[[99, 69, 19], [53, '_', 30], [100, 63, 40]]\"]"}
{"diff_sorted_id": "2", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: ako, pole, raff, mudd   The initial board: [['o', 'a', 'u', 'o'], ['p', 'r', 'l', 'e'], ['f', 'a', '_', 'f'], ['m', 'k', 'd', 'd']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.23615717887878418", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"o\", \"a\", \"u\", \"o\"], [\"p\", \"r\", \"l\", \"e\"], [\"f\", \"a\", \"_\", \"f\"], [\"m\", \"k\", \"d\", \"d\"]]]", "is_correct_args": "[[[\"o\", \"a\", \"u\", \"o\"], [\"p\", \"r\", \"l\", \"e\"], [\"f\", \"a\", \"_\", \"f\"], [\"m\", \"k\", \"d\", \"d\"]], [\"ako\", \"pole\", \"raff\", \"mudd\"]]", "A*_args": "[\"[['o', 'a', 'u', 'o'], ['p', 'r', 'l', 'e'], ['f', 'a', '_', 'f'], ['m', 'k', 'd', 'd']]\", \"['ako', 'pole', 'raff', 'mudd']\"]"}
{"diff_sorted_id": "2", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'D'. Our task is to visit city K and city Q excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from Q and K, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  S U X D I Z R M K Q \nS 0 0 0 0 1 0 0 0 0 1 \nU 0 0 1 0 0 0 0 0 0 0 \nX 0 0 0 0 0 0 1 0 1 0 \nD 0 1 0 0 0 1 0 0 0 0 \nI 0 1 0 0 0 0 0 0 0 1 \nZ 0 0 0 0 1 0 0 0 1 0 \nR 1 1 0 0 0 0 0 0 0 0 \nM 0 0 1 0 1 0 0 0 0 0 \nK 0 0 0 0 0 0 1 1 0 0 \nQ 0 1 0 1 1 1 0 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[\"D\", \"Z\", \"I\", \"Q\", \"K\", \"R\", \"S\", \"Q\", \"K\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.027526378631591797", "solution_depth": "9", "max_successor_states": "10", "num_vars_per_state": "13", "is_feasible_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 1, 0, 0, 1, 0]], [\"S\", \"U\", \"X\", \"D\", \"I\", \"Z\", \"R\", \"M\", \"K\", \"Q\"], \"K\", \"Q\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 1, 0, 0, 1, 0]], [\"S\", \"U\", \"X\", \"D\", \"I\", \"Z\", \"R\", \"M\", \"K\", \"Q\"], \"D\", \"K\", \"Q\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 1, 0, 0, 1, 0]]\", \"['S', 'U', 'X', 'D', 'I', 'Z', 'R', 'M', 'K', 'Q']\", \"['D']\", \"['K', 'Q']\"]"}
{"diff_sorted_id": "2", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [13, 10, 12, 10, 16, 7, 9, 14, 13, 18, 36, 11, 7, 14, 7, 8, 19, 7, 39, 13, 3, 18, 20, 4, 3, 18, 15, 2, 19, 16], such that the sum of the chosen coins adds up to 203. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {15: 5, 36: 15, 39: 9, 9: 8, 13: 3, 2: 2, 18: 10, 12: 12, 3: 3, 8: 8, 11: 6, 10: 4, 4: 4, 14: 10, 7: 3, 16: 16, 20: 18, 19: 17}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "16", "opt_solution": "[7, 7, 7, 13, 13, 39, 36, 10, 15, 10, 11, 13, 2, 7, 4, 9]", "opt_solution_cost": "78", "opt_solution_compute_t": "0.03766942024230957", "solution_depth": "16", "max_successor_states": "30", "num_vars_per_state": "30", "is_feasible_args": "[[13, 10, 12, 10, 16, 7, 9, 14, 13, 18, 36, 11, 7, 14, 7, 8, 19, 7, 39, 13, 3, 18, 20, 4, 3, 18, 15, 2, 19, 16]]", "is_correct_args": "[[13, 10, 12, 10, 16, 7, 9, 14, 13, 18, 36, 11, 7, 14, 7, 8, 19, 7, 39, 13, 3, 18, 20, 4, 3, 18, 15, 2, 19, 16], {\"15\": 5, \"36\": 15, \"39\": 9, \"9\": 8, \"13\": 3, \"2\": 2, \"18\": 10, \"12\": 12, \"3\": 3, \"8\": 8, \"11\": 6, \"10\": 4, \"4\": 4, \"14\": 10, \"7\": 3, \"16\": 16, \"20\": 18, \"19\": 17}, 203]", "A*_args": "[\"[13, 10, 12, 10, 16, 7, 9, 14, 13, 18, 36, 11, 7, 14, 7, 8, 19, 7, 39, 13, 3, 18, 20, 4, 3, 18, 15, 2, 19, 16]\", \"{15: 5, 36: 15, 39: 9, 9: 8, 13: 3, 2: 2, 18: 10, 12: 12, 3: 3, 8: 8, 11: 6, 10: 4, 4: 4, 14: 10, 7: 3, 16: 16, 20: 18, 19: 17}\", \"203\"]"}
{"diff_sorted_id": "2", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Blue', 'Blue', 'Blue'], ['Green', 'Green', 'Red', 'Green'], ['Green', 'Blue', 'Red', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[1, 2], [1, 2], [1, 0], [2, 1], [2, 1], [2, 1], [2, 1], [0, 2], [0, 2], [1, 0]]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.05974388122558594", "solution_depth": "10", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Blue\"], [\"Green\", \"Green\", \"Red\", \"Green\"], [\"Green\", \"Blue\", \"Red\", \"Red\"]], 6]", "is_correct_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Blue\"], [\"Green\", \"Green\", \"Red\", \"Green\"], [\"Green\", \"Blue\", \"Red\", \"Red\"]], 6]", "A*_args": "[\"[['Red', 'Blue', 'Blue', 'Blue'], ['Green', 'Green', 'Red', 'Green'], ['Green', 'Blue', 'Red', 'Red']]\", \"6\"]"}
{"diff_sorted_id": "2", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 8 to 41 (8 included in the range but 41 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['10' '15' '39']\n ['x' '27' '29']\n ['x' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[1, 0, 11], [2, 0, 30], [2, 1, 28], [2, 2, 8]]", "opt_solution_cost": "185", "opt_solution_compute_t": "0.6896023750305176", "solution_depth": "4", "max_successor_states": "33", "num_vars_per_state": "9", "is_feasible_args": "[\"[['10', '15', '39'], ['', '27', '29'], ['', '', '']]\", 8, 41]", "is_correct_args": "[\"[['10', '15', '39'], ['', '27', '29'], ['', '', '']]\", 8, 41]", "A*_args": "[\"[['10', '15', '39'], ['', '27', '29'], ['', '', '']]\", \"8\", \"41\"]"}
{"diff_sorted_id": "2", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 20 to 39. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 82, and sum of row 1 must be 87. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 94. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x']\n ['30' 'x' 'x']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 0, 20], [0, 1, 22], [0, 2, 25], [1, 1, 36], [1, 2, 21], [2, 0, 33], [2, 1, 24], [2, 2, 23]]", "opt_solution_cost": "234", "opt_solution_compute_t": "3.1459109783172607", "solution_depth": "8", "max_successor_states": "19", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['30', '', ''], ['', '', '']]\", 3, 20, 39]", "is_correct_args": "[\"[['', '', ''], ['30', '', ''], ['', '', '']]\", 20, 39, [1, 2], [1, 2], [82], [87], 94]", "A*_args": "[\"[['', '', ''], ['30', '', ''], ['', '', '']]\", \"20\", \"39\", \"[None, 82, None]\", \"[None, 87, None]\", \"94\"]"}
{"diff_sorted_id": "2", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 5, 1: 3, 2: 3, 3: 1, 4: 3, 5: 2}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Red', 'Green', 'Red', 'Blue'], ['Red', 'Yellow', 'Yellow', 'Green'], [], ['Blue', 'Yellow', 'Green', 'Blue'], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[1, 2], [0, 2], [1, 5], [1, 5], [0, 1], [0, 2], [3, 4], [3, 5], [3, 1], [0, 3], [4, 3]]", "opt_solution_cost": "26", "opt_solution_compute_t": "0.10936236381530762", "solution_depth": "11", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Green\", \"Red\", \"Blue\"], [\"Red\", \"Yellow\", \"Yellow\", \"Green\"], [], [\"Blue\", \"Yellow\", \"Green\", \"Blue\"], [], []], 4, {\"0\": 5, \"1\": 3, \"2\": 3, \"3\": 1, \"4\": 3, \"5\": 2}]", "is_correct_args": "[[[\"Red\", \"Green\", \"Red\", \"Blue\"], [\"Red\", \"Yellow\", \"Yellow\", \"Green\"], [], [\"Blue\", \"Yellow\", \"Green\", \"Blue\"], [], []], 4, {\"0\": 5, \"1\": 3, \"2\": 3, \"3\": 1, \"4\": 3, \"5\": 2}, 3]", "A*_args": "[\"[['Red', 'Green', 'Red', 'Blue'], ['Red', 'Yellow', 'Yellow', 'Green'], [], ['Blue', 'Yellow', 'Green', 'Blue'], [], []]\", \"{0: 5, 1: 3, 2: 3, 3: 1, 4: 3, 5: 2}\", \"4\", \"3\"]"}
{"diff_sorted_id": "2", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (2, 2) to his destination workshop at index (5, 8), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 4, and district 3 covering rows 5 to 8. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 13 9 x x 16 6 18 7]\n[x 3 11 x x 5 7 x 19]\n[8 x 2 5 6 12 9 10 7]\n[12 1 6 20 19 18 12 x 14]\n[16 5 10 3 x x x 1 9]\n[x 3 x x x x x x 4]\n[7 10 x 1 x x 17 x 8]\n[x 5 x x x 17 x 9 x]\n[13 16 8 15 x 2 x 1 2]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "1", "opt_solution": "[[2, 2], [2, 3], [2, 4], [2, 5], [1, 5], [1, 6], [2, 6], [2, 7], [2, 8], [3, 8], [4, 8], [5, 8]]", "opt_solution_cost": "88", "opt_solution_compute_t": "0.027752399444580078", "solution_depth": "12", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"13\", \"9\", \"x\", \"x\", \"16\", \"6\", \"18\", \"7\"], [\"x\", \"3\", \"11\", \"x\", \"x\", \"5\", \"7\", \"x\", \"19\"], [\"8\", \"x\", \"2\", \"5\", \"6\", \"12\", \"9\", \"10\", \"7\"], [\"12\", \"1\", \"6\", \"20\", \"19\", \"18\", \"12\", \"x\", \"14\"], [\"16\", \"5\", \"10\", \"3\", \"x\", \"x\", \"x\", \"1\", \"9\"], [\"x\", \"3\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"4\"], [\"7\", \"10\", \"x\", \"1\", \"x\", \"x\", \"17\", \"x\", \"8\"], [\"x\", \"5\", \"x\", \"x\", \"x\", \"17\", \"x\", \"9\", \"x\"], [\"13\", \"16\", \"8\", \"15\", \"x\", \"2\", \"x\", \"1\", \"2\"]]]", "is_correct_args": "[[[\"x\", \"13\", \"9\", \"x\", \"x\", \"16\", \"6\", \"18\", \"7\"], [\"x\", \"3\", \"11\", \"x\", \"x\", \"5\", \"7\", \"x\", \"19\"], [\"8\", \"x\", \"2\", \"5\", \"6\", \"12\", \"9\", \"10\", \"7\"], [\"12\", \"1\", \"6\", \"20\", \"19\", \"18\", \"12\", \"x\", \"14\"], [\"16\", \"5\", \"10\", \"3\", \"x\", \"x\", \"x\", \"1\", \"9\"], [\"x\", \"3\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"4\"], [\"7\", \"10\", \"x\", \"1\", \"x\", \"x\", \"17\", \"x\", \"8\"], [\"x\", \"5\", \"x\", \"x\", \"x\", \"17\", \"x\", \"9\", \"x\"], [\"13\", \"16\", \"8\", \"15\", \"x\", \"2\", \"x\", \"1\", \"2\"]], [2, 2], [5, 8], 1, 4]", "A*_args": "[\"[['x', '13', '9', 'x', 'x', '16', '6', '18', '7'], ['x', '3', '11', 'x', 'x', '5', '7', 'x', '19'], ['8', 'x', '2', '5', '6', '12', '9', '10', '7'], ['12', '1', '6', '20', '19', '18', '12', 'x', '14'], ['16', '5', '10', '3', 'x', 'x', 'x', '1', '9'], ['x', '3', 'x', 'x', 'x', 'x', 'x', 'x', '4'], ['7', '10', 'x', '1', 'x', 'x', '17', 'x', '8'], ['x', '5', 'x', 'x', 'x', '17', 'x', '9', 'x'], ['13', '16', '8', '15', 'x', '2', 'x', '1', '2']]\", \"(2, 2)\", \"(5, 8)\", \"1\", \"4\"]"}
{"diff_sorted_id": "2", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 9x9. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 4) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (8, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 0 1 0 0 1 1 1\n1 1 1 0 1 0 1 1 1\n0 1 0 1 1 0 0 0 0\n1 1 1 0 1 1 0 1 0\n0 1 0 1 1 0 0 1 1\n0 0 0 0 0 0 1 0 1\n0 1 0 1 1 0 1 0 0\n1 0 0 1 1 0 0 1 0\n0 0 0 0 0 0 0 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "9", "opt_solution": "[[0, 4], [0, 5], [1, 5], [2, 5], [2, 6], [3, 6], [4, 5], [5, 4], [5, 3], [5, 2], [6, 2], [7, 1], [8, 1], [8, 0]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.03374505043029785", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 0, 1, 0, 0, 1, 1, 1], [1, 1, 1, 0, 1, 0, 1, 1, 1], [0, 1, 0, 1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 0, 1, 0], [0, 1, 0, 1, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 1, 1, 0, 1, 0, 0], [1, 0, 0, 1, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0]]\", 3]", "is_correct_args": "[\"[[1, 1, 0, 1, 0, 0, 1, 1, 1], [1, 1, 1, 0, 1, 0, 1, 1, 1], [0, 1, 0, 1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 0, 1, 0], [0, 1, 0, 1, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 1, 1, 0, 1, 0, 0], [1, 0, 0, 1, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0]]\", [0, 4], [8, 0], 3]", "A*_args": "[\"[[1, 1, 0, 1, 0, 0, 1, 1, 1], [1, 1, 1, 0, 1, 0, 1, 1, 1], [0, 1, 0, 1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 0, 1, 0], [0, 1, 0, 1, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 1, 1, 0, 1, 0, 0], [1, 0, 0, 1, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0]]\", \"(0, 4)\", \"(8, 0)\", \"3\"]"}
{"diff_sorted_id": "2", "problem_statement": "Given 5 labeled water jugs with capacities 31, 102, 53, 33, 32, 24 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 188, 198, 289 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 32, 3], [\"+\", 102, 3], [\"+\", 102, 3], [\"+\", 53, 3], [\"+\", 31, 2], [\"+\", 32, 2], [\"+\", 33, 2], [\"+\", 102, 2], [\"+\", 33, 1], [\"+\", 53, 1], [\"+\", 102, 1]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.04619026184082031", "solution_depth": "11", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[31, 102, 53, 33, 32, 24], [188, 198, 289]]", "is_correct_args": "[[31, 102, 53, 33, 32, 24], [188, 198, 289]]", "A*_args": "[\"[31, 102, 53, 33, 32, 24]\", \"[188, 198, 289]\"]"}
{"diff_sorted_id": "3", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[87, 50, 82], [68, '_', 74], [23, 61, 11]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[50, 82, 74, 50, 61, 11]", "opt_solution_cost": "6", "opt_solution_compute_t": "0.028201580047607422", "solution_depth": "6", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[87, 50, 82], [68, \"_\", 74], [23, 61, 11]]]", "is_correct_args": "[[[87, 50, 82], [68, \"_\", 74], [23, 61, 11]]]", "A*_args": "[\"[[87, 50, 82], [68, '_', 74], [23, 61, 11]]\"]"}
{"diff_sorted_id": "3", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: twi, ovey, udic, diem   The initial board: [['v', 't', 'u', 'i'], ['o', 'w', 'e', 'i'], ['y', 'd', '_', 'c'], ['d', 'i', 'e', 'm']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-left\"]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.22588300704956055", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"v\", \"t\", \"u\", \"i\"], [\"o\", \"w\", \"e\", \"i\"], [\"y\", \"d\", \"_\", \"c\"], [\"d\", \"i\", \"e\", \"m\"]]]", "is_correct_args": "[[[\"v\", \"t\", \"u\", \"i\"], [\"o\", \"w\", \"e\", \"i\"], [\"y\", \"d\", \"_\", \"c\"], [\"d\", \"i\", \"e\", \"m\"]], [\"twi\", \"ovey\", \"udic\", \"diem\"]]", "A*_args": "[\"[['v', 't', 'u', 'i'], ['o', 'w', 'e', 'i'], ['y', 'd', '_', 'c'], ['d', 'i', 'e', 'm']]\", \"['twi', 'ovey', 'udic', 'diem']\"]"}
{"diff_sorted_id": "3", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'M'. Our task is to visit city A and city R excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from R and A, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  O T I F A M X Y R G \nO 0 0 0 0 1 0 0 0 0 0 \nT 1 0 1 0 0 0 0 0 0 0 \nI 0 0 0 0 1 1 0 0 1 1 \nF 0 0 1 0 0 0 0 0 0 1 \nA 1 1 0 0 0 0 1 0 0 0 \nM 0 0 0 1 0 0 0 0 0 1 \nX 0 0 1 1 1 0 0 1 0 0 \nY 1 1 0 0 0 0 1 0 1 1 \nR 1 1 0 1 0 0 0 1 0 0 \nG 0 0 0 1 1 0 0 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[\"M\", \"G\", \"R\", \"Y\", \"R\", \"O\", \"A\", \"X\", \"A\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.0287935733795166", "solution_depth": "9", "max_successor_states": "10", "num_vars_per_state": "13", "is_feasible_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 1, 1], [1, 1, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 1, 0]], [\"O\", \"T\", \"I\", \"F\", \"A\", \"M\", \"X\", \"Y\", \"R\", \"G\"], \"A\", \"R\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 1, 1], [1, 1, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 1, 0]], [\"O\", \"T\", \"I\", \"F\", \"A\", \"M\", \"X\", \"Y\", \"R\", \"G\"], \"M\", \"A\", \"R\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 1, 1], [1, 1, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 1, 0]]\", \"['O', 'T', 'I', 'F', 'A', 'M', 'X', 'Y', 'R', 'G']\", \"['M']\", \"['A', 'R']\"]"}
{"diff_sorted_id": "3", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [13, 19, 9, 4, 18, 17, 2, 14, 17, 17, 8, 6, 4, 10, 19, 37, 20, 19, 14, 7, 6, 11, 21, 9, 3, 10, 21, 20, 2, 17, 2], such that the sum of the chosen coins adds up to 215. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {14: 2, 18: 9, 11: 10, 9: 6, 10: 9, 13: 10, 37: 9, 6: 5, 2: 2, 4: 1, 8: 3, 19: 10, 17: 7, 7: 6, 3: 3, 21: 3, 20: 4}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "17", "opt_solution": "[14, 21, 20, 4, 37, 4, 21, 20, 18, 8, 17, 14, 17]", "opt_solution_cost": "55", "opt_solution_compute_t": "0.0338587760925293", "solution_depth": "13", "max_successor_states": "31", "num_vars_per_state": "31", "is_feasible_args": "[[13, 19, 9, 4, 18, 17, 2, 14, 17, 17, 8, 6, 4, 10, 19, 37, 20, 19, 14, 7, 6, 11, 21, 9, 3, 10, 21, 20, 2, 17, 2]]", "is_correct_args": "[[13, 19, 9, 4, 18, 17, 2, 14, 17, 17, 8, 6, 4, 10, 19, 37, 20, 19, 14, 7, 6, 11, 21, 9, 3, 10, 21, 20, 2, 17, 2], {\"14\": 2, \"18\": 9, \"11\": 10, \"9\": 6, \"10\": 9, \"13\": 10, \"37\": 9, \"6\": 5, \"2\": 2, \"4\": 1, \"8\": 3, \"19\": 10, \"17\": 7, \"7\": 6, \"3\": 3, \"21\": 3, \"20\": 4}, 215]", "A*_args": "[\"[13, 19, 9, 4, 18, 17, 2, 14, 17, 17, 8, 6, 4, 10, 19, 37, 20, 19, 14, 7, 6, 11, 21, 9, 3, 10, 21, 20, 2, 17, 2]\", \"{14: 2, 18: 9, 11: 10, 9: 6, 10: 9, 13: 10, 37: 9, 6: 5, 2: 2, 4: 1, 8: 3, 19: 10, 17: 7, 7: 6, 3: 3, 21: 3, 20: 4}\", \"215\"]"}
{"diff_sorted_id": "3", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Blue', 'Blue', 'Red'], ['Red', 'Blue', 'Blue', 'Green'], ['Green', 'Green', 'Red', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[0, 1], [2, 0], [2, 0], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 2], [1, 0], [2, 1], [2, 1], [2, 1], [0, 2], [0, 1]]", "opt_solution_cost": "19", "opt_solution_compute_t": "2.109553337097168", "solution_depth": "19", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Red\"], [\"Red\", \"Blue\", \"Blue\", \"Green\"], [\"Green\", \"Green\", \"Red\", \"Green\"]], 6]", "is_correct_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Red\"], [\"Red\", \"Blue\", \"Blue\", \"Green\"], [\"Green\", \"Green\", \"Red\", \"Green\"]], 6]", "A*_args": "[\"[['Red', 'Blue', 'Blue', 'Red'], ['Red', 'Blue', 'Blue', 'Green'], ['Green', 'Green', 'Red', 'Green']]\", \"6\"]"}
{"diff_sorted_id": "3", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 20 to 53 (20 included in the range but 53 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['22' 'x' '48']\n ['27' 'x' 'x']\n ['x' '42' '52']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 1, 23], [1, 1, 28], [1, 2, 49], [2, 0, 29]]", "opt_solution_cost": "344", "opt_solution_compute_t": "0.18951058387756348", "solution_depth": "4", "max_successor_states": "33", "num_vars_per_state": "9", "is_feasible_args": "[\"[['22', '', '48'], ['27', '', ''], ['', '42', '52']]\", 20, 53]", "is_correct_args": "[\"[['22', '', '48'], ['27', '', ''], ['', '42', '52']]\", 20, 53]", "A*_args": "[\"[['22', '', '48'], ['27', '', ''], ['', '42', '52']]\", \"20\", \"53\"]"}
{"diff_sorted_id": "3", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 20 to 39. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 99, and sum of row 1 must be 86. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 76. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['25' 'x' 'x']\n ['x' 'x' 'x']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 1, 26], [0, 2, 20], [1, 0, 23], [1, 1, 35], [1, 2, 28], [2, 0, 21], [2, 1, 38], [2, 2, 22]]", "opt_solution_cost": "238", "opt_solution_compute_t": "6.525880575180054", "solution_depth": "8", "max_successor_states": "19", "num_vars_per_state": "9", "is_feasible_args": "[\"[['25', '', ''], ['', '', ''], ['', '', '']]\", 3, 20, 39]", "is_correct_args": "[\"[['25', '', ''], ['', '', ''], ['', '', '']]\", 20, 39, [1, 2], [1, 2], [99], [86], 76]", "A*_args": "[\"[['25', '', ''], ['', '', ''], ['', '', '']]\", \"20\", \"39\", \"[None, 99, None]\", \"[None, 86, None]\", \"76\"]"}
{"diff_sorted_id": "3", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 3, 1: 6, 2: 5, 3: 6, 4: 1, 5: 1}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Yellow', 'Green', 'Red', 'Red'], ['Blue', 'Green', 'Red', 'Green'], ['Yellow', 'Blue', 'Yellow', 'Blue'], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[1, 0], [1, 4], [2, 5], [2, 4], [2, 1], [3, 0], [3, 5], [3, 0], [2, 4], [3, 5]]", "opt_solution_cost": "21", "opt_solution_compute_t": "0.11831974983215332", "solution_depth": "10", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[], [\"Yellow\", \"Green\", \"Red\", \"Red\"], [\"Blue\", \"Green\", \"Red\", \"Green\"], [\"Yellow\", \"Blue\", \"Yellow\", \"Blue\"], [], []], 4, {\"0\": 3, \"1\": 6, \"2\": 5, \"3\": 6, \"4\": 1, \"5\": 1}]", "is_correct_args": "[[[], [\"Yellow\", \"Green\", \"Red\", \"Red\"], [\"Blue\", \"Green\", \"Red\", \"Green\"], [\"Yellow\", \"Blue\", \"Yellow\", \"Blue\"], [], []], 4, {\"0\": 3, \"1\": 6, \"2\": 5, \"3\": 6, \"4\": 1, \"5\": 1}, 3]", "A*_args": "[\"[[], ['Yellow', 'Green', 'Red', 'Red'], ['Blue', 'Green', 'Red', 'Green'], ['Yellow', 'Blue', 'Yellow', 'Blue'], [], []]\", \"{0: 3, 1: 6, 2: 5, 3: 6, 4: 1, 5: 1}\", \"4\", \"3\"]"}
{"diff_sorted_id": "3", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (7, 7) to his destination workshop at index (1, 2), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 6, and district 3 covering rows 7 to 8. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[10 14 4 16 x 17 5 x x]\n[5 20 16 3 1 8 x 16 19]\n[1 x 5 13 3 15 19 15 x]\n[x 16 13 20 x 8 x x x]\n[x 16 x 17 11 1 x 15 x]\n[10 x 14 11 5 7 12 x 5]\n[7 x 15 x 15 8 3 6 7]\n[x 12 14 x x x 16 3 13]\n[19 5 10 x x x 9 7 14]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "1", "opt_solution": "[[7, 7], [6, 7], [6, 6], [6, 5], [5, 5], [4, 5], [3, 5], [2, 5], [2, 4], [1, 4], [1, 3], [1, 2]]", "opt_solution_cost": "71", "opt_solution_compute_t": "0.02632451057434082", "solution_depth": "12", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"10\", \"14\", \"4\", \"16\", \"x\", \"17\", \"5\", \"x\", \"x\"], [\"5\", \"20\", \"16\", \"3\", \"1\", \"8\", \"x\", \"16\", \"19\"], [\"1\", \"x\", \"5\", \"13\", \"3\", \"15\", \"19\", \"15\", \"x\"], [\"x\", \"16\", \"13\", \"20\", \"x\", \"8\", \"x\", \"x\", \"x\"], [\"x\", \"16\", \"x\", \"17\", \"11\", \"1\", \"x\", \"15\", \"x\"], [\"10\", \"x\", \"14\", \"11\", \"5\", \"7\", \"12\", \"x\", \"5\"], [\"7\", \"x\", \"15\", \"x\", \"15\", \"8\", \"3\", \"6\", \"7\"], [\"x\", \"12\", \"14\", \"x\", \"x\", \"x\", \"16\", \"3\", \"13\"], [\"19\", \"5\", \"10\", \"x\", \"x\", \"x\", \"9\", \"7\", \"14\"]]]", "is_correct_args": "[[[\"10\", \"14\", \"4\", \"16\", \"x\", \"17\", \"5\", \"x\", \"x\"], [\"5\", \"20\", \"16\", \"3\", \"1\", \"8\", \"x\", \"16\", \"19\"], [\"1\", \"x\", \"5\", \"13\", \"3\", \"15\", \"19\", \"15\", \"x\"], [\"x\", \"16\", \"13\", \"20\", \"x\", \"8\", \"x\", \"x\", \"x\"], [\"x\", \"16\", \"x\", \"17\", \"11\", \"1\", \"x\", \"15\", \"x\"], [\"10\", \"x\", \"14\", \"11\", \"5\", \"7\", \"12\", \"x\", \"5\"], [\"7\", \"x\", \"15\", \"x\", \"15\", \"8\", \"3\", \"6\", \"7\"], [\"x\", \"12\", \"14\", \"x\", \"x\", \"x\", \"16\", \"3\", \"13\"], [\"19\", \"5\", \"10\", \"x\", \"x\", \"x\", \"9\", \"7\", \"14\"]], [7, 7], [1, 2], 1, 6]", "A*_args": "[\"[['10', '14', '4', '16', 'x', '17', '5', 'x', 'x'], ['5', '20', '16', '3', '1', '8', 'x', '16', '19'], ['1', 'x', '5', '13', '3', '15', '19', '15', 'x'], ['x', '16', '13', '20', 'x', '8', 'x', 'x', 'x'], ['x', '16', 'x', '17', '11', '1', 'x', '15', 'x'], ['10', 'x', '14', '11', '5', '7', '12', 'x', '5'], ['7', 'x', '15', 'x', '15', '8', '3', '6', '7'], ['x', '12', '14', 'x', 'x', 'x', '16', '3', '13'], ['19', '5', '10', 'x', 'x', 'x', '9', '7', '14']]\", \"(7, 7)\", \"(1, 2)\", \"1\", \"6\"]"}
{"diff_sorted_id": "3", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 9x9. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (8, 6) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (0, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 1 0 1 1 1 1 0\n0 0 0 0 0 0 1 1 1\n0 0 0 0 0 0 0 0 0\n1 1 0 1 0 0 0 1 1\n0 1 1 1 1 1 0 0 1\n1 0 0 1 1 0 0 0 0\n1 0 1 1 1 0 0 0 0\n0 1 1 0 1 0 1 0 1\n1 1 1 1 1 0 0 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "9", "opt_solution": "[[8, 6], [7, 5], [6, 5], [5, 5], [4, 6], [3, 5], [3, 4], [2, 4], [2, 3], [2, 2], [1, 2], [1, 1], [1, 0], [0, 0]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.03221940994262695", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 1, 0, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 0, 0, 1], [1, 0, 0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 1, 0, 1], [1, 1, 1, 1, 1, 0, 0, 0, 0]]\", 3]", "is_correct_args": "[\"[[0, 1, 1, 0, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 0, 0, 1], [1, 0, 0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 1, 0, 1], [1, 1, 1, 1, 1, 0, 0, 0, 0]]\", [8, 6], [0, 0], 3]", "A*_args": "[\"[[0, 1, 1, 0, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 0, 0, 1], [1, 0, 0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 1, 0, 1], [1, 1, 1, 1, 1, 0, 0, 0, 0]]\", \"(8, 6)\", \"(0, 0)\", \"3\"]"}
{"diff_sorted_id": "3", "problem_statement": "Given 5 labeled water jugs with capacities 43, 149, 131, 132, 70, 104 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 284, 297, 436 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 131, 3], [\"+\", 131, 3], [\"+\", 70, 3], [\"+\", 104, 3], [\"+\", 131, 2], [\"+\", 132, 2], [\"-\", 70, 2], [\"+\", 104, 2], [\"+\", 104, 1], [\"+\", 104, 1], [\"-\", 132, 1], [\"+\", 104, 1], [\"+\", 104, 1]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.038121938705444336", "solution_depth": "13", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[43, 149, 131, 132, 70, 104], [284, 297, 436]]", "is_correct_args": "[[43, 149, 131, 132, 70, 104], [284, 297, 436]]", "A*_args": "[\"[43, 149, 131, 132, 70, 104]\", \"[284, 297, 436]\"]"}
{"diff_sorted_id": "4", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[66, 89, 70], [25, 42, 83], ['_', 24, 71]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[24, 42, 89, 70, 83, 71, 42, 24, 25, 66, 70, 89, 66, 70, 89, 83, 71, 42]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.03897857666015625", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[66, 89, 70], [25, 42, 83], [\"_\", 24, 71]]]", "is_correct_args": "[[[66, 89, 70], [25, 42, 83], [\"_\", 24, 71]]]", "A*_args": "[\"[[66, 89, 70], [25, 42, 83], ['_', 24, 71]]\"]"}
{"diff_sorted_id": "4", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: map, cere, drub, velo   The initial board: [['_', 'm', 'u', 'p'], ['c', 'e', 'r', 'a'], ['d', 'r', 'e', 'b'], ['v', 'e', 'l', 'o']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"down-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "6", "opt_solution_compute_t": "0.2581043243408203", "solution_depth": "6", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"_\", \"m\", \"u\", \"p\"], [\"c\", \"e\", \"r\", \"a\"], [\"d\", \"r\", \"e\", \"b\"], [\"v\", \"e\", \"l\", \"o\"]]]", "is_correct_args": "[[[\"_\", \"m\", \"u\", \"p\"], [\"c\", \"e\", \"r\", \"a\"], [\"d\", \"r\", \"e\", \"b\"], [\"v\", \"e\", \"l\", \"o\"]], [\"map\", \"cere\", \"drub\", \"velo\"]]", "A*_args": "[\"[['_', 'm', 'u', 'p'], ['c', 'e', 'r', 'a'], ['d', 'r', 'e', 'b'], ['v', 'e', 'l', 'o']]\", \"['map', 'cere', 'drub', 'velo']\"]"}
{"diff_sorted_id": "4", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'L'. Our task is to visit city D and city N excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from N and D, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  D E Z R N I K G L B \nD 0 1 1 1 0 0 0 1 1 1 \nE 0 0 1 0 0 1 0 0 0 0 \nZ 0 0 0 0 1 0 0 0 0 0 \nR 1 0 1 0 0 0 0 0 0 1 \nN 0 1 0 0 0 1 1 1 0 0 \nI 1 0 0 0 1 0 1 0 1 0 \nK 0 0 1 0 1 0 0 0 0 0 \nG 0 0 1 1 0 1 0 0 0 0 \nL 0 0 1 0 0 0 0 1 0 0 \nB 0 1 0 0 0 1 1 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[\"L\", \"Z\", \"N\", \"K\", \"N\", \"I\", \"D\", \"R\", \"D\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.026905059814453125", "solution_depth": "9", "max_successor_states": "10", "num_vars_per_state": "13", "is_feasible_args": "[[[0, 1, 1, 1, 0, 0, 0, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0, 1, 0, 1, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 1, 1, 0, 0, 0]], [\"D\", \"E\", \"Z\", \"R\", \"N\", \"I\", \"K\", \"G\", \"L\", \"B\"], \"D\", \"N\"]", "is_correct_args": "[[[0, 1, 1, 1, 0, 0, 0, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0, 1, 0, 1, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 1, 1, 0, 0, 0]], [\"D\", \"E\", \"Z\", \"R\", \"N\", \"I\", \"K\", \"G\", \"L\", \"B\"], \"L\", \"D\", \"N\"]", "A*_args": "[\"[[0, 1, 1, 1, 0, 0, 0, 1, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0, 1, 0, 1, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 1, 1, 0, 0, 0]]\", \"['D', 'E', 'Z', 'R', 'N', 'I', 'K', 'G', 'L', 'B']\", \"['L']\", \"['D', 'N']\"]"}
{"diff_sorted_id": "4", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [14, 19, 3, 8, 5, 107, 4, 10, 9, 2, 11, 7, 11, 11, 4, 10, 17, 14, 18, 10, 21, 13, 2, 13, 19, 5, 8, 4, 7, 6, 10], such that the sum of the chosen coins adds up to 215. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {17: 9, 107: 7, 13: 11, 10: 7, 19: 12, 9: 2, 4: 4, 14: 8, 21: 14, 6: 2, 5: 3, 2: 2, 3: 3, 7: 6, 18: 6, 8: 4, 11: 11}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "18", "opt_solution": "[18, 6, 9, 8, 2, 5, 5, 17, 14, 8, 107, 14, 2]", "opt_solution_cost": "60", "opt_solution_compute_t": "0.03795170783996582", "solution_depth": "13", "max_successor_states": "31", "num_vars_per_state": "31", "is_feasible_args": "[[14, 19, 3, 8, 5, 107, 4, 10, 9, 2, 11, 7, 11, 11, 4, 10, 17, 14, 18, 10, 21, 13, 2, 13, 19, 5, 8, 4, 7, 6, 10]]", "is_correct_args": "[[14, 19, 3, 8, 5, 107, 4, 10, 9, 2, 11, 7, 11, 11, 4, 10, 17, 14, 18, 10, 21, 13, 2, 13, 19, 5, 8, 4, 7, 6, 10], {\"17\": 9, \"107\": 7, \"13\": 11, \"10\": 7, \"19\": 12, \"9\": 2, \"4\": 4, \"14\": 8, \"21\": 14, \"6\": 2, \"5\": 3, \"2\": 2, \"3\": 3, \"7\": 6, \"18\": 6, \"8\": 4, \"11\": 11}, 215]", "A*_args": "[\"[14, 19, 3, 8, 5, 107, 4, 10, 9, 2, 11, 7, 11, 11, 4, 10, 17, 14, 18, 10, 21, 13, 2, 13, 19, 5, 8, 4, 7, 6, 10]\", \"{17: 9, 107: 7, 13: 11, 10: 7, 19: 12, 9: 2, 4: 4, 14: 8, 21: 14, 6: 2, 5: 3, 2: 2, 3: 3, 7: 6, 18: 6, 8: 4, 11: 11}\", \"215\"]"}
{"diff_sorted_id": "4", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Red', 'Blue', 'Blue'], ['Red', 'Blue', 'Red', 'Green'], ['Green', 'Blue', 'Green', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[1, 0], [1, 2], [1, 0], [1, 2], [0, 1], [0, 1], [0, 1], [0, 1], [2, 1], [2, 0], [2, 1], [2, 0], [1, 2], [1, 2]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.22463750839233398", "solution_depth": "14", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Red\", \"Blue\", \"Blue\"], [\"Red\", \"Blue\", \"Red\", \"Green\"], [\"Green\", \"Blue\", \"Green\", \"Green\"]], 6]", "is_correct_args": "[[[\"Red\", \"Red\", \"Blue\", \"Blue\"], [\"Red\", \"Blue\", \"Red\", \"Green\"], [\"Green\", \"Blue\", \"Green\", \"Green\"]], 6]", "A*_args": "[\"[['Red', 'Red', 'Blue', 'Blue'], ['Red', 'Blue', 'Red', 'Green'], ['Green', 'Blue', 'Green', 'Green']]\", \"6\"]"}
{"diff_sorted_id": "4", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 20 to 53 (20 included in the range but 53 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '32' '37']\n ['29' 'x' 'x']\n ['x' '46' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 20], [1, 1, 33], [1, 2, 34], [2, 0, 47], [2, 2, 21]]", "opt_solution_cost": "255", "opt_solution_compute_t": "0.18683171272277832", "solution_depth": "5", "max_successor_states": "33", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '32', '37'], ['29', '', ''], ['', '46', '']]\", 20, 53]", "is_correct_args": "[\"[['', '32', '37'], ['29', '', ''], ['', '46', '']]\", 20, 53]", "A*_args": "[\"[['', '32', '37'], ['29', '', ''], ['', '46', '']]\", \"20\", \"53\"]"}
{"diff_sorted_id": "4", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 20 to 39. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 72, and sum of row 1 must be 95. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 71. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['21' 'x' 'x']\n ['x' 'x' 'x']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 1, 22], [0, 2, 20], [1, 0, 30], [1, 1, 27], [1, 2, 38], [2, 0, 24], [2, 1, 23], [2, 2, 25]]", "opt_solution_cost": "230", "opt_solution_compute_t": "0.5546069145202637", "solution_depth": "8", "max_successor_states": "19", "num_vars_per_state": "9", "is_feasible_args": "[\"[['21', '', ''], ['', '', ''], ['', '', '']]\", 3, 20, 39]", "is_correct_args": "[\"[['21', '', ''], ['', '', ''], ['', '', '']]\", 20, 39, [1, 2], [1, 2], [72], [95], 71]", "A*_args": "[\"[['21', '', ''], ['', '', ''], ['', '', '']]\", \"20\", \"39\", \"[None, 72, None]\", \"[None, 95, None]\", \"71\"]"}
{"diff_sorted_id": "4", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 2, 1: 6, 2: 5, 3: 2, 4: 5, 5: 7}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Red', 'Green', 'Yellow', 'Blue'], [], ['Yellow', 'Green', 'Blue', 'Red'], [], ['Green', 'Red', 'Blue', 'Yellow'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[0, 3], [0, 1], [4, 1], [4, 3], [0, 5], [4, 0], [2, 4], [2, 1], [2, 0], [5, 4], [2, 3]]", "opt_solution_cost": "45", "opt_solution_compute_t": "0.024616003036499023", "solution_depth": "11", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Green\", \"Yellow\", \"Blue\"], [], [\"Yellow\", \"Green\", \"Blue\", \"Red\"], [], [\"Green\", \"Red\", \"Blue\", \"Yellow\"], []], 4, {\"0\": 2, \"1\": 6, \"2\": 5, \"3\": 2, \"4\": 5, \"5\": 7}]", "is_correct_args": "[[[\"Red\", \"Green\", \"Yellow\", \"Blue\"], [], [\"Yellow\", \"Green\", \"Blue\", \"Red\"], [], [\"Green\", \"Red\", \"Blue\", \"Yellow\"], []], 4, {\"0\": 2, \"1\": 6, \"2\": 5, \"3\": 2, \"4\": 5, \"5\": 7}, 3]", "A*_args": "[\"[['Red', 'Green', 'Yellow', 'Blue'], [], ['Yellow', 'Green', 'Blue', 'Red'], [], ['Green', 'Red', 'Blue', 'Yellow'], []]\", \"{0: 2, 1: 6, 2: 5, 3: 2, 4: 5, 5: 7}\", \"4\", \"3\"]"}
{"diff_sorted_id": "4", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (2, 0) to his destination workshop at index (5, 6), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 4, and district 3 covering rows 5 to 8. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[18 9 2 x 9 14 x 1 x]\n[3 14 18 7 x 3 x 2 19]\n[6 18 20 3 13 x 6 10 x]\n[20 x 12 4 14 6 x x x]\n[7 18 8 5 19 3 x x 7]\n[15 9 14 16 5 14 6 x x]\n[x 5 13 x x 19 x x 2]\n[x x 8 x x x x 17 12]\n[x 1 x x 3 19 x 2 18]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "1", "opt_solution": "[[2, 0], [2, 1], [2, 2], [2, 3], [3, 3], [3, 4], [3, 5], [4, 5], [5, 5], [5, 6]]", "opt_solution_cost": "88", "opt_solution_compute_t": "0.02671647071838379", "solution_depth": "10", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"18\", \"9\", \"2\", \"x\", \"9\", \"14\", \"x\", \"1\", \"x\"], [\"3\", \"14\", \"18\", \"7\", \"x\", \"3\", \"x\", \"2\", \"19\"], [\"6\", \"18\", \"20\", \"3\", \"13\", \"x\", \"6\", \"10\", \"x\"], [\"20\", \"x\", \"12\", \"4\", \"14\", \"6\", \"x\", \"x\", \"x\"], [\"7\", \"18\", \"8\", \"5\", \"19\", \"3\", \"x\", \"x\", \"7\"], [\"15\", \"9\", \"14\", \"16\", \"5\", \"14\", \"6\", \"x\", \"x\"], [\"x\", \"5\", \"13\", \"x\", \"x\", \"19\", \"x\", \"x\", \"2\"], [\"x\", \"x\", \"8\", \"x\", \"x\", \"x\", \"x\", \"17\", \"12\"], [\"x\", \"1\", \"x\", \"x\", \"3\", \"19\", \"x\", \"2\", \"18\"]]]", "is_correct_args": "[[[\"18\", \"9\", \"2\", \"x\", \"9\", \"14\", \"x\", \"1\", \"x\"], [\"3\", \"14\", \"18\", \"7\", \"x\", \"3\", \"x\", \"2\", \"19\"], [\"6\", \"18\", \"20\", \"3\", \"13\", \"x\", \"6\", \"10\", \"x\"], [\"20\", \"x\", \"12\", \"4\", \"14\", \"6\", \"x\", \"x\", \"x\"], [\"7\", \"18\", \"8\", \"5\", \"19\", \"3\", \"x\", \"x\", \"7\"], [\"15\", \"9\", \"14\", \"16\", \"5\", \"14\", \"6\", \"x\", \"x\"], [\"x\", \"5\", \"13\", \"x\", \"x\", \"19\", \"x\", \"x\", \"2\"], [\"x\", \"x\", \"8\", \"x\", \"x\", \"x\", \"x\", \"17\", \"12\"], [\"x\", \"1\", \"x\", \"x\", \"3\", \"19\", \"x\", \"2\", \"18\"]], [2, 0], [5, 6], 2, 4]", "A*_args": "[\"[['18', '9', '2', 'x', '9', '14', 'x', '1', 'x'], ['3', '14', '18', '7', 'x', '3', 'x', '2', '19'], ['6', '18', '20', '3', '13', 'x', '6', '10', 'x'], ['20', 'x', '12', '4', '14', '6', 'x', 'x', 'x'], ['7', '18', '8', '5', '19', '3', 'x', 'x', '7'], ['15', '9', '14', '16', '5', '14', '6', 'x', 'x'], ['x', '5', '13', 'x', 'x', '19', 'x', 'x', '2'], ['x', 'x', '8', 'x', 'x', 'x', 'x', '17', '12'], ['x', '1', 'x', 'x', '3', '19', 'x', '2', '18']]\", \"(2, 0)\", \"(5, 6)\", \"2\", \"4\"]"}
{"diff_sorted_id": "4", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 9x9. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (8, 1) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (0, 5). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 1 0 0 0 0 0 1\n0 1 0 1 1 0 0 0 0\n1 1 1 1 1 1 1 1 0\n1 1 0 1 1 0 0 0 0\n1 0 1 0 1 0 1 1 1\n1 0 1 0 0 0 1 0 1\n0 1 0 0 0 1 1 0 1\n0 0 1 0 1 1 1 1 1\n1 0 0 1 1 0 0 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "9", "opt_solution": "[[8, 1], [7, 1], [6, 2], [5, 3], [5, 4], [4, 5], [3, 5], [3, 6], [3, 7], [3, 8], [2, 8], [1, 8], [1, 7], [1, 6], [0, 6], [0, 5]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.026789426803588867", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 1, 0, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 0, 1, 1, 0, 1], [0, 0, 1, 0, 1, 1, 1, 1, 1], [1, 0, 0, 1, 1, 0, 0, 1, 1]]\", 3]", "is_correct_args": "[\"[[0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 1, 0, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 0, 1, 1, 0, 1], [0, 0, 1, 0, 1, 1, 1, 1, 1], [1, 0, 0, 1, 1, 0, 0, 1, 1]]\", [8, 1], [0, 5], 3]", "A*_args": "[\"[[0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 1, 0, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 0, 1, 1, 0, 1], [0, 0, 1, 0, 1, 1, 1, 1, 1], [1, 0, 0, 1, 1, 0, 0, 1, 1]]\", \"(8, 1)\", \"(0, 5)\", \"3\"]"}
{"diff_sorted_id": "4", "problem_statement": "Given 5 labeled water jugs with capacities 36, 88, 132, 70, 87, 111 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 225, 237, 243 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 111, 3], [\"+\", 132, 3], [\"+\", 87, 2], [\"+\", 132, 2], [\"-\", 70, 2], [\"+\", 88, 2], [\"+\", 70, 1], [\"+\", 132, 1], [\"-\", 88, 1], [\"+\", 111, 1]]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.033365726470947266", "solution_depth": "10", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[36, 88, 132, 70, 87, 111], [225, 237, 243]]", "is_correct_args": "[[36, 88, 132, 70, 87, 111], [225, 237, 243]]", "A*_args": "[\"[36, 88, 132, 70, 87, 111]\", \"[225, 237, 243]\"]"}
{"diff_sorted_id": "5", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[78, 98, 89], [38, '_', 7], [58, 95, 70]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[95, 58, 38, 78, 98, 95, 7, 70, 58, 7, 70, 58]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.029888629913330078", "solution_depth": "12", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[78, 98, 89], [38, \"_\", 7], [58, 95, 70]]]", "is_correct_args": "[[[78, 98, 89], [38, \"_\", 7], [58, 95, 70]]]", "A*_args": "[\"[[78, 98, 89], [38, '_', 7], [58, 95, 70]]\"]"}
{"diff_sorted_id": "5", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: sax, tass, turp, cade   The initial board: [['a', 's', 't', 'x'], ['t', 'r', 's', 'a'], ['s', 'u', '_', 'p'], ['c', 'a', 'd', 'e']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.1913444995880127", "solution_depth": "12", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"a\", \"s\", \"t\", \"x\"], [\"t\", \"r\", \"s\", \"a\"], [\"s\", \"u\", \"_\", \"p\"], [\"c\", \"a\", \"d\", \"e\"]]]", "is_correct_args": "[[[\"a\", \"s\", \"t\", \"x\"], [\"t\", \"r\", \"s\", \"a\"], [\"s\", \"u\", \"_\", \"p\"], [\"c\", \"a\", \"d\", \"e\"]], [\"sax\", \"tass\", \"turp\", \"cade\"]]", "A*_args": "[\"[['a', 's', 't', 'x'], ['t', 'r', 's', 'a'], ['s', 'u', '_', 'p'], ['c', 'a', 'd', 'e']]\", \"['sax', 'tass', 'turp', 'cade']\"]"}
{"diff_sorted_id": "5", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'H'. Our task is to visit city Z and city K excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from K and Z, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  K B Z S X H O E U V \nK 0 0 1 1 0 0 1 1 0 1 \nB 0 0 0 0 0 0 0 1 0 1 \nZ 0 1 0 1 0 1 1 0 0 1 \nS 0 1 1 0 1 0 0 0 0 0 \nX 1 1 0 0 0 0 0 0 0 1 \nH 0 0 0 1 0 0 1 0 1 0 \nO 0 0 1 1 1 0 0 0 0 0 \nE 1 0 0 0 0 0 1 0 0 1 \nU 0 0 0 0 0 0 1 0 0 0 \nV 0 0 0 0 1 0 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[\"H\", \"O\", \"X\", \"K\", \"E\", \"K\", \"Z\", \"S\", \"Z\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.03679943084716797", "solution_depth": "9", "max_successor_states": "10", "num_vars_per_state": "13", "is_feasible_args": "[[[0, 0, 1, 1, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]], [\"K\", \"B\", \"Z\", \"S\", \"X\", \"H\", \"O\", \"E\", \"U\", \"V\"], \"Z\", \"K\"]", "is_correct_args": "[[[0, 0, 1, 1, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]], [\"K\", \"B\", \"Z\", \"S\", \"X\", \"H\", \"O\", \"E\", \"U\", \"V\"], \"H\", \"Z\", \"K\"]", "A*_args": "[\"[[0, 0, 1, 1, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]]\", \"['K', 'B', 'Z', 'S', 'X', 'H', 'O', 'E', 'U', 'V']\", \"['H']\", \"['Z', 'K']\"]"}
{"diff_sorted_id": "5", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [20, 10, 16, 21, 15, 21, 13, 6, 19, 9, 7, 5, 2, 6, 9, 22, 4, 13, 3, 16, 22, 18, 6, 5, 14, 7, 7, 2, 17, 9, 8, 83, 14], such that the sum of the chosen coins adds up to 239. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {22: 18, 21: 1, 14: 12, 10: 8, 8: 6, 17: 9, 6: 4, 7: 6, 9: 3, 20: 13, 19: 12, 5: 3, 13: 8, 4: 3, 83: 14, 3: 2, 18: 1, 2: 1, 16: 2, 15: 3}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "19", "opt_solution": "[18, 21, 16, 2, 15, 2, 9, 9, 21, 83, 16, 6, 4, 17]", "opt_solution_cost": "48", "opt_solution_compute_t": "0.03824257850646973", "solution_depth": "14", "max_successor_states": "33", "num_vars_per_state": "33", "is_feasible_args": "[[20, 10, 16, 21, 15, 21, 13, 6, 19, 9, 7, 5, 2, 6, 9, 22, 4, 13, 3, 16, 22, 18, 6, 5, 14, 7, 7, 2, 17, 9, 8, 83, 14]]", "is_correct_args": "[[20, 10, 16, 21, 15, 21, 13, 6, 19, 9, 7, 5, 2, 6, 9, 22, 4, 13, 3, 16, 22, 18, 6, 5, 14, 7, 7, 2, 17, 9, 8, 83, 14], {\"22\": 18, \"21\": 1, \"14\": 12, \"10\": 8, \"8\": 6, \"17\": 9, \"6\": 4, \"7\": 6, \"9\": 3, \"20\": 13, \"19\": 12, \"5\": 3, \"13\": 8, \"4\": 3, \"83\": 14, \"3\": 2, \"18\": 1, \"2\": 1, \"16\": 2, \"15\": 3}, 239]", "A*_args": "[\"[20, 10, 16, 21, 15, 21, 13, 6, 19, 9, 7, 5, 2, 6, 9, 22, 4, 13, 3, 16, 22, 18, 6, 5, 14, 7, 7, 2, 17, 9, 8, 83, 14]\", \"{22: 18, 21: 1, 14: 12, 10: 8, 8: 6, 17: 9, 6: 4, 7: 6, 9: 3, 20: 13, 19: 12, 5: 3, 13: 8, 4: 3, 83: 14, 3: 2, 18: 1, 2: 1, 16: 2, 15: 3}\", \"239\"]"}
{"diff_sorted_id": "5", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Blue', 'Blue', 'Blue'], ['Red', 'Green', 'Red', 'Red'], ['Green', 'Red', 'Green', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[1, 2], [1, 0], [2, 1], [2, 0], [2, 1], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [1, 0], [1, 2]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.08999156951904297", "solution_depth": "12", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Blue\", \"Blue\", \"Blue\"], [\"Red\", \"Green\", \"Red\", \"Red\"], [\"Green\", \"Red\", \"Green\", \"Blue\"]], 6]", "is_correct_args": "[[[\"Green\", \"Blue\", \"Blue\", \"Blue\"], [\"Red\", \"Green\", \"Red\", \"Red\"], [\"Green\", \"Red\", \"Green\", \"Blue\"]], 6]", "A*_args": "[\"[['Green', 'Blue', 'Blue', 'Blue'], ['Red', 'Green', 'Red', 'Red'], ['Green', 'Red', 'Green', 'Blue']]\", \"6\"]"}
{"diff_sorted_id": "5", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 44 to 77 (44 included in the range but 77 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['66' 'x' '74']\n ['x' '60' '62']\n ['x' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 1, 67], [1, 0, 47], [2, 0, 46], [2, 1, 45], [2, 2, 44]]", "opt_solution_cost": "557", "opt_solution_compute_t": "0.45664143562316895", "solution_depth": "5", "max_successor_states": "33", "num_vars_per_state": "9", "is_feasible_args": "[\"[['66', '', '74'], ['', '60', '62'], ['', '', '']]\", 44, 77]", "is_correct_args": "[\"[['66', '', '74'], ['', '60', '62'], ['', '', '']]\", 44, 77]", "A*_args": "[\"[['66', '', '74'], ['', '60', '62'], ['', '', '']]\", \"44\", \"77\"]"}
{"diff_sorted_id": "5", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 20 to 39. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 82, and sum of row 1 must be 82. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 82. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x']\n ['x' 'x' 'x']\n ['22' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 20], [0, 1, 23], [0, 2, 27], [1, 0, 24], [1, 1, 33], [1, 2, 25], [2, 1, 26], [2, 2, 21]]", "opt_solution_cost": "221", "opt_solution_compute_t": "0.6350831985473633", "solution_depth": "8", "max_successor_states": "19", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '', ''], ['22', '', '']]\", 3, 20, 39]", "is_correct_args": "[\"[['', '', ''], ['', '', ''], ['22', '', '']]\", 20, 39, [1, 2], [1, 2], [82], [82], 82]", "A*_args": "[\"[['', '', ''], ['', '', ''], ['22', '', '']]\", \"20\", \"39\", \"[None, 82, None]\", \"[None, 82, None]\", \"82\"]"}
{"diff_sorted_id": "5", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 4, 1: 1, 2: 7, 3: 3, 4: 2, 5: 2}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Red', 'Green', 'Green', 'Yellow'], [], ['Blue', 'Blue', 'Green', 'Red'], [], ['Blue', 'Yellow', 'Red', 'Yellow'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[4, 3], [0, 1], [0, 5], [0, 5], [4, 0], [4, 1], [4, 0], [2, 3], [2, 3], [2, 5], [2, 1]]", "opt_solution_cost": "26", "opt_solution_compute_t": "0.1328294277191162", "solution_depth": "11", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Green\", \"Green\", \"Yellow\"], [], [\"Blue\", \"Blue\", \"Green\", \"Red\"], [], [\"Blue\", \"Yellow\", \"Red\", \"Yellow\"], []], 4, {\"0\": 4, \"1\": 1, \"2\": 7, \"3\": 3, \"4\": 2, \"5\": 2}]", "is_correct_args": "[[[\"Red\", \"Green\", \"Green\", \"Yellow\"], [], [\"Blue\", \"Blue\", \"Green\", \"Red\"], [], [\"Blue\", \"Yellow\", \"Red\", \"Yellow\"], []], 4, {\"0\": 4, \"1\": 1, \"2\": 7, \"3\": 3, \"4\": 2, \"5\": 2}, 3]", "A*_args": "[\"[['Red', 'Green', 'Green', 'Yellow'], [], ['Blue', 'Blue', 'Green', 'Red'], [], ['Blue', 'Yellow', 'Red', 'Yellow'], []]\", \"{0: 4, 1: 1, 2: 7, 3: 3, 4: 2, 5: 2}\", \"4\", \"3\"]"}
{"diff_sorted_id": "5", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (5, 0) to his destination workshop at index (3, 7), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 4, and district 3 covering rows 5 to 8. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[8 x 4 7 10 x 12 5 x]\n[x x 4 11 16 4 12 15 x]\n[3 x 16 16 4 x x x x]\n[11 6 3 12 8 2 19 14 x]\n[20 18 19 x 4 18 x 15 13]\n[8 15 x 16 11 x 10 14 1]\n[x x x 19 x x x x x]\n[7 x x x x x 1 7 8]\n[15 3 x x x x x x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "1", "opt_solution": "[[5, 0], [4, 0], [3, 0], [3, 1], [3, 2], [3, 3], [3, 4], [3, 5], [3, 6], [3, 7]]", "opt_solution_cost": "95", "opt_solution_compute_t": "0.022897005081176758", "solution_depth": "10", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"8\", \"x\", \"4\", \"7\", \"10\", \"x\", \"12\", \"5\", \"x\"], [\"x\", \"x\", \"4\", \"11\", \"16\", \"4\", \"12\", \"15\", \"x\"], [\"3\", \"x\", \"16\", \"16\", \"4\", \"x\", \"x\", \"x\", \"x\"], [\"11\", \"6\", \"3\", \"12\", \"8\", \"2\", \"19\", \"14\", \"x\"], [\"20\", \"18\", \"19\", \"x\", \"4\", \"18\", \"x\", \"15\", \"13\"], [\"8\", \"15\", \"x\", \"16\", \"11\", \"x\", \"10\", \"14\", \"1\"], [\"x\", \"x\", \"x\", \"19\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"7\", \"x\", \"x\", \"x\", \"x\", \"x\", \"1\", \"7\", \"8\"], [\"15\", \"3\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"8\", \"x\", \"4\", \"7\", \"10\", \"x\", \"12\", \"5\", \"x\"], [\"x\", \"x\", \"4\", \"11\", \"16\", \"4\", \"12\", \"15\", \"x\"], [\"3\", \"x\", \"16\", \"16\", \"4\", \"x\", \"x\", \"x\", \"x\"], [\"11\", \"6\", \"3\", \"12\", \"8\", \"2\", \"19\", \"14\", \"x\"], [\"20\", \"18\", \"19\", \"x\", \"4\", \"18\", \"x\", \"15\", \"13\"], [\"8\", \"15\", \"x\", \"16\", \"11\", \"x\", \"10\", \"14\", \"1\"], [\"x\", \"x\", \"x\", \"19\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"7\", \"x\", \"x\", \"x\", \"x\", \"x\", \"1\", \"7\", \"8\"], [\"15\", \"3\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"]], [5, 0], [3, 7], 3, 4]", "A*_args": "[\"[['8', 'x', '4', '7', '10', 'x', '12', '5', 'x'], ['x', 'x', '4', '11', '16', '4', '12', '15', 'x'], ['3', 'x', '16', '16', '4', 'x', 'x', 'x', 'x'], ['11', '6', '3', '12', '8', '2', '19', '14', 'x'], ['20', '18', '19', 'x', '4', '18', 'x', '15', '13'], ['8', '15', 'x', '16', '11', 'x', '10', '14', '1'], ['x', 'x', 'x', '19', 'x', 'x', 'x', 'x', 'x'], ['7', 'x', 'x', 'x', 'x', 'x', '1', '7', '8'], ['15', '3', 'x', 'x', 'x', 'x', 'x', 'x', 'x']]\", \"(5, 0)\", \"(3, 7)\", \"3\", \"4\"]"}
{"diff_sorted_id": "5", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 9x9. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (5, 7). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 0 0 1 1 0 1 0\n0 0 0 0 0 0 0 1 1\n0 1 1 1 1 0 0 0 1\n1 1 1 1 1 0 0 1 0\n1 1 0 1 1 0 0 0 0\n0 1 1 0 1 0 0 0 0\n0 1 1 1 1 0 0 1 1\n0 0 0 1 1 0 0 1 1\n1 0 1 0 1 1 0 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "9", "opt_solution": "[[0, 0], [0, 1], [0, 2], [0, 3], [1, 3], [1, 4], [2, 5], [3, 5], [4, 6], [5, 7]]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.031831979751586914", "solution_depth": "10", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 0, 0, 0, 1], [1, 1, 1, 1, 1, 0, 0, 1, 0], [1, 1, 0, 1, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 1, 1], [0, 0, 0, 1, 1, 0, 0, 1, 1], [1, 0, 1, 0, 1, 1, 0, 1, 1]]\", 3]", "is_correct_args": "[\"[[0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 0, 0, 0, 1], [1, 1, 1, 1, 1, 0, 0, 1, 0], [1, 1, 0, 1, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 1, 1], [0, 0, 0, 1, 1, 0, 0, 1, 1], [1, 0, 1, 0, 1, 1, 0, 1, 1]]\", [0, 0], [5, 7], 3]", "A*_args": "[\"[[0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 0, 0, 0, 1], [1, 1, 1, 1, 1, 0, 0, 1, 0], [1, 1, 0, 1, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 1, 1], [0, 0, 0, 1, 1, 0, 0, 1, 1], [1, 0, 1, 0, 1, 1, 0, 1, 1]]\", \"(0, 0)\", \"(5, 7)\", \"3\"]"}
{"diff_sorted_id": "5", "problem_statement": "Given 5 labeled water jugs with capacities 145, 101, 17, 75, 102, 129 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 260, 287, 413 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 17, 3], [\"+\", 101, 3], [\"+\", 145, 3], [\"+\", 75, 3], [\"+\", 75, 3], [\"+\", 101, 2], [\"+\", 101, 2], [\"-\", 17, 2], [\"+\", 102, 2], [\"+\", 101, 1], [\"-\", 17, 1], [\"+\", 75, 1], [\"+\", 101, 1]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.04054903984069824", "solution_depth": "13", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[145, 101, 17, 75, 102, 129], [260, 287, 413]]", "is_correct_args": "[[145, 101, 17, 75, 102, 129], [260, 287, 413]]", "A*_args": "[\"[145, 101, 17, 75, 102, 129]\", \"[260, 287, 413]\"]"}
{"diff_sorted_id": "6", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[46, 82, 90], [36, 41, 38], [28, 55, '_']]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[38, 41, 82, 90, 41, 82, 55, 28, 36, 46, 90, 41, 82, 55, 41, 82, 55, 38]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.046418190002441406", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[46, 82, 90], [36, 41, 38], [28, 55, \"_\"]]]", "is_correct_args": "[[[46, 82, 90], [36, 41, 38], [28, 55, \"_\"]]]", "A*_args": "[\"[[46, 82, 90], [36, 41, 38], [28, 55, '_']]\"]"}
{"diff_sorted_id": "6", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: cho, slod, syce, halt   The initial board: [['l', 'c', '_', 'o'], ['s', 'c', 'o', 'h'], ['d', 'y', 'a', 'e'], ['h', 's', 'l', 't']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.16235899925231934", "solution_depth": "10", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"l\", \"c\", \"_\", \"o\"], [\"s\", \"c\", \"o\", \"h\"], [\"d\", \"y\", \"a\", \"e\"], [\"h\", \"s\", \"l\", \"t\"]]]", "is_correct_args": "[[[\"l\", \"c\", \"_\", \"o\"], [\"s\", \"c\", \"o\", \"h\"], [\"d\", \"y\", \"a\", \"e\"], [\"h\", \"s\", \"l\", \"t\"]], [\"cho\", \"slod\", \"syce\", \"halt\"]]", "A*_args": "[\"[['l', 'c', '_', 'o'], ['s', 'c', 'o', 'h'], ['d', 'y', 'a', 'e'], ['h', 's', 'l', 't']]\", \"['cho', 'slod', 'syce', 'halt']\"]"}
{"diff_sorted_id": "6", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'N'. Our task is to visit city D and city F excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from F and D, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  F I O J K D N R M B \nF 0 0 0 1 1 0 0 0 1 0 \nI 1 0 0 0 0 0 0 0 0 1 \nO 0 0 0 1 0 1 0 0 1 1 \nJ 1 0 1 0 0 0 0 0 0 0 \nK 0 0 1 0 0 1 0 0 0 0 \nD 0 1 1 0 0 0 0 1 0 0 \nN 0 1 0 0 0 0 0 1 0 0 \nR 0 0 0 1 0 0 0 0 1 0 \nM 1 1 0 1 0 0 0 0 0 0 \nB 1 0 0 1 0 1 0 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[\"N\", \"I\", \"F\", \"J\", \"F\", \"K\", \"D\", \"O\", \"D\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.028170108795166016", "solution_depth": "9", "max_successor_states": "10", "num_vars_per_state": "13", "is_feasible_args": "[[[0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 1, 0, 0, 1, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 0, 0, 1, 0]], [\"F\", \"I\", \"O\", \"J\", \"K\", \"D\", \"N\", \"R\", \"M\", \"B\"], \"D\", \"F\"]", "is_correct_args": "[[[0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 1, 0, 0, 1, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 0, 0, 1, 0]], [\"F\", \"I\", \"O\", \"J\", \"K\", \"D\", \"N\", \"R\", \"M\", \"B\"], \"N\", \"D\", \"F\"]", "A*_args": "[\"[[0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 1, 0, 0, 1, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 0, 0, 1, 0]]\", \"['F', 'I', 'O', 'J', 'K', 'D', 'N', 'R', 'M', 'B']\", \"['N']\", \"['D', 'F']\"]"}
{"diff_sorted_id": "6", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [20, 25, 10, 4, 13, 3, 10, 17, 5, 25, 17, 2, 19, 24, 25, 10, 19, 8, 2, 20, 15, 84, 23, 87, 19, 8, 12, 17, 23, 6], such that the sum of the chosen coins adds up to 250. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {12: 12, 19: 8, 84: 20, 24: 1, 5: 1, 3: 1, 4: 2, 87: 7, 10: 5, 25: 7, 6: 5, 20: 5, 15: 7, 23: 17, 13: 4, 17: 16, 2: 1, 8: 5}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "20", "opt_solution": "[3, 5, 87, 84, 24, 20, 25, 2]", "opt_solution_cost": "43", "opt_solution_compute_t": "0.036344051361083984", "solution_depth": "8", "max_successor_states": "30", "num_vars_per_state": "30", "is_feasible_args": "[[20, 25, 10, 4, 13, 3, 10, 17, 5, 25, 17, 2, 19, 24, 25, 10, 19, 8, 2, 20, 15, 84, 23, 87, 19, 8, 12, 17, 23, 6]]", "is_correct_args": "[[20, 25, 10, 4, 13, 3, 10, 17, 5, 25, 17, 2, 19, 24, 25, 10, 19, 8, 2, 20, 15, 84, 23, 87, 19, 8, 12, 17, 23, 6], {\"12\": 12, \"19\": 8, \"84\": 20, \"24\": 1, \"5\": 1, \"3\": 1, \"4\": 2, \"87\": 7, \"10\": 5, \"25\": 7, \"6\": 5, \"20\": 5, \"15\": 7, \"23\": 17, \"13\": 4, \"17\": 16, \"2\": 1, \"8\": 5}, 250]", "A*_args": "[\"[20, 25, 10, 4, 13, 3, 10, 17, 5, 25, 17, 2, 19, 24, 25, 10, 19, 8, 2, 20, 15, 84, 23, 87, 19, 8, 12, 17, 23, 6]\", \"{12: 12, 19: 8, 84: 20, 24: 1, 5: 1, 3: 1, 4: 2, 87: 7, 10: 5, 25: 7, 6: 5, 20: 5, 15: 7, 23: 17, 13: 4, 17: 16, 2: 1, 8: 5}\", \"250\"]"}
{"diff_sorted_id": "6", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Blue', 'Red'], ['Red', 'Blue', 'Green', 'Red'], ['Green', 'Green', 'Blue', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[0, 1], [0, 2], [0, 1], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [2, 0], [1, 2], [1, 0], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [0, 2], [0, 2], [0, 1], [0, 2], [1, 0], [1, 0]]", "opt_solution_cost": "22", "opt_solution_compute_t": "7.465789318084717", "solution_depth": "22", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Blue\", \"Red\"], [\"Red\", \"Blue\", \"Green\", \"Red\"], [\"Green\", \"Green\", \"Blue\", \"Red\"]], 6]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Blue\", \"Red\"], [\"Red\", \"Blue\", \"Green\", \"Red\"], [\"Green\", \"Green\", \"Blue\", \"Red\"]], 6]", "A*_args": "[\"[['Blue', 'Green', 'Blue', 'Red'], ['Red', 'Blue', 'Green', 'Red'], ['Green', 'Green', 'Blue', 'Red']]\", \"6\"]"}
{"diff_sorted_id": "6", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 41 to 74 (41 included in the range but 74 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['41' '48' 'x']\n ['x' 'x' '63']\n ['x' 'x' '67']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 2, 49], [1, 0, 42], [1, 1, 45], [2, 0, 43], [2, 1, 44]]", "opt_solution_cost": "470", "opt_solution_compute_t": "0.18347549438476562", "solution_depth": "5", "max_successor_states": "33", "num_vars_per_state": "9", "is_feasible_args": "[\"[['41', '48', ''], ['', '', '63'], ['', '', '67']]\", 41, 74]", "is_correct_args": "[\"[['41', '48', ''], ['', '', '63'], ['', '', '67']]\", 41, 74]", "A*_args": "[\"[['41', '48', ''], ['', '', '63'], ['', '', '67']]\", \"41\", \"74\"]"}
{"diff_sorted_id": "6", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 19 to 43. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 82, and sum of row 1 must be 82. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 96. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '20' 'x']\n ['x' 'x' 'x']\n ['x' 'x' '33']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 19], [0, 2, 25], [1, 0, 21], [1, 1, 39], [1, 2, 22], [2, 0, 32], [2, 1, 23]]", "opt_solution_cost": "234", "opt_solution_compute_t": "7.9251344203948975", "solution_depth": "7", "max_successor_states": "19", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '20', ''], ['', '', ''], ['', '', '33']]\", 3, 19, 43]", "is_correct_args": "[\"[['', '20', ''], ['', '', ''], ['', '', '33']]\", 19, 43, [1, 2], [1, 2], [82], [82], 96]", "A*_args": "[\"[['', '20', ''], ['', '', ''], ['', '', '33']]\", \"19\", \"43\", \"[None, 82, None]\", \"[None, 82, None]\", \"96\"]"}
{"diff_sorted_id": "6", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 7, 1: 3, 2: 5, 3: 5, 4: 1, 5: 3}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Yellow', 'Blue', 'Blue', 'Green'], [], ['Yellow', 'Green', 'Red', 'Red'], ['Green', 'Red', 'Yellow', 'Blue'], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[0, 5], [2, 5], [2, 4], [3, 4], [3, 2], [0, 1], [0, 1], [3, 5], [3, 1], [0, 4]]", "opt_solution_cost": "26", "opt_solution_compute_t": "0.06659841537475586", "solution_depth": "10", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Yellow\", \"Blue\", \"Blue\", \"Green\"], [], [\"Yellow\", \"Green\", \"Red\", \"Red\"], [\"Green\", \"Red\", \"Yellow\", \"Blue\"], [], []], 4, {\"0\": 7, \"1\": 3, \"2\": 5, \"3\": 5, \"4\": 1, \"5\": 3}]", "is_correct_args": "[[[\"Yellow\", \"Blue\", \"Blue\", \"Green\"], [], [\"Yellow\", \"Green\", \"Red\", \"Red\"], [\"Green\", \"Red\", \"Yellow\", \"Blue\"], [], []], 4, {\"0\": 7, \"1\": 3, \"2\": 5, \"3\": 5, \"4\": 1, \"5\": 3}, 3]", "A*_args": "[\"[['Yellow', 'Blue', 'Blue', 'Green'], [], ['Yellow', 'Green', 'Red', 'Red'], ['Green', 'Red', 'Yellow', 'Blue'], [], []]\", \"{0: 7, 1: 3, 2: 5, 3: 5, 4: 1, 5: 3}\", \"4\", \"3\"]"}
{"diff_sorted_id": "6", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (5, 5) to his destination workshop at index (1, 0), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 4, and district 3 covering rows 5 to 8. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[6 16 x x 15 x 14 11 x]\n[5 2 1 x 3 x 4 13 x]\n[x 7 x x 13 x 10 14 5]\n[6 16 x 13 6 x 16 x x]\n[x 1 17 x 6 3 x x 3]\n[11 10 7 19 15 8 12 6 x]\n[18 x x 9 8 9 x x 13]\n[4 x x x 18 20 x x x]\n[x x 8 x 18 2 6 13 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "1", "opt_solution": "[[5, 5], [5, 4], [5, 3], [5, 2], [5, 1], [4, 1], [3, 1], [2, 1], [1, 1], [1, 0]]", "opt_solution_cost": "82", "opt_solution_compute_t": "0.027018070220947266", "solution_depth": "10", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"6\", \"16\", \"x\", \"x\", \"15\", \"x\", \"14\", \"11\", \"x\"], [\"5\", \"2\", \"1\", \"x\", \"3\", \"x\", \"4\", \"13\", \"x\"], [\"x\", \"7\", \"x\", \"x\", \"13\", \"x\", \"10\", \"14\", \"5\"], [\"6\", \"16\", \"x\", \"13\", \"6\", \"x\", \"16\", \"x\", \"x\"], [\"x\", \"1\", \"17\", \"x\", \"6\", \"3\", \"x\", \"x\", \"3\"], [\"11\", \"10\", \"7\", \"19\", \"15\", \"8\", \"12\", \"6\", \"x\"], [\"18\", \"x\", \"x\", \"9\", \"8\", \"9\", \"x\", \"x\", \"13\"], [\"4\", \"x\", \"x\", \"x\", \"18\", \"20\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"8\", \"x\", \"18\", \"2\", \"6\", \"13\", \"x\"]]]", "is_correct_args": "[[[\"6\", \"16\", \"x\", \"x\", \"15\", \"x\", \"14\", \"11\", \"x\"], [\"5\", \"2\", \"1\", \"x\", \"3\", \"x\", \"4\", \"13\", \"x\"], [\"x\", \"7\", \"x\", \"x\", \"13\", \"x\", \"10\", \"14\", \"5\"], [\"6\", \"16\", \"x\", \"13\", \"6\", \"x\", \"16\", \"x\", \"x\"], [\"x\", \"1\", \"17\", \"x\", \"6\", \"3\", \"x\", \"x\", \"3\"], [\"11\", \"10\", \"7\", \"19\", \"15\", \"8\", \"12\", \"6\", \"x\"], [\"18\", \"x\", \"x\", \"9\", \"8\", \"9\", \"x\", \"x\", \"13\"], [\"4\", \"x\", \"x\", \"x\", \"18\", \"20\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"8\", \"x\", \"18\", \"2\", \"6\", \"13\", \"x\"]], [5, 5], [1, 0], 1, 4]", "A*_args": "[\"[['6', '16', 'x', 'x', '15', 'x', '14', '11', 'x'], ['5', '2', '1', 'x', '3', 'x', '4', '13', 'x'], ['x', '7', 'x', 'x', '13', 'x', '10', '14', '5'], ['6', '16', 'x', '13', '6', 'x', '16', 'x', 'x'], ['x', '1', '17', 'x', '6', '3', 'x', 'x', '3'], ['11', '10', '7', '19', '15', '8', '12', '6', 'x'], ['18', 'x', 'x', '9', '8', '9', 'x', 'x', '13'], ['4', 'x', 'x', 'x', '18', '20', 'x', 'x', 'x'], ['x', 'x', '8', 'x', '18', '2', '6', '13', 'x']]\", \"(5, 5)\", \"(1, 0)\", \"1\", \"4\"]"}
{"diff_sorted_id": "6", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 9x9. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 6) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (8, 2). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 1 0 0 1 0 1 0\n1 1 1 0 1 1 0 0 1\n1 1 1 1 1 0 0 1 0\n1 0 1 1 1 0 1 1 0\n0 0 1 1 0 0 1 0 0\n1 1 0 0 0 0 0 0 1\n1 0 0 0 0 0 0 1 1\n1 1 0 0 0 1 0 1 0\n0 1 0 0 0 1 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "9", "opt_solution": "[[0, 6], [1, 6], [2, 5], [3, 5], [4, 4], [5, 3], [6, 3], [7, 3], [7, 2], [8, 2]]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.02278614044189453", "solution_depth": "10", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 1, 0, 0, 1, 0, 1, 0], [1, 1, 1, 0, 1, 1, 0, 0, 1], [1, 1, 1, 1, 1, 0, 0, 1, 0], [1, 0, 1, 1, 1, 0, 1, 1, 0], [0, 0, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 0, 1, 1, 1, 1]]\", 3]", "is_correct_args": "[\"[[1, 0, 1, 0, 0, 1, 0, 1, 0], [1, 1, 1, 0, 1, 1, 0, 0, 1], [1, 1, 1, 1, 1, 0, 0, 1, 0], [1, 0, 1, 1, 1, 0, 1, 1, 0], [0, 0, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 0, 1, 1, 1, 1]]\", [0, 6], [8, 2], 3]", "A*_args": "[\"[[1, 0, 1, 0, 0, 1, 0, 1, 0], [1, 1, 1, 0, 1, 1, 0, 0, 1], [1, 1, 1, 1, 1, 0, 0, 1, 0], [1, 0, 1, 1, 1, 0, 1, 1, 0], [0, 0, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 0, 1, 1, 1, 1]]\", \"(0, 6)\", \"(8, 2)\", \"3\"]"}
{"diff_sorted_id": "6", "problem_statement": "Given 5 labeled water jugs with capacities 76, 135, 134, 19, 10, 30 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 390, 420, 439 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 76, 3], [\"+\", 76, 3], [\"+\", 134, 3], [\"+\", 19, 3], [\"+\", 134, 3], [\"+\", 134, 2], [\"+\", 134, 2], [\"+\", 76, 2], [\"+\", 76, 2], [\"+\", 76, 1], [\"+\", 76, 1], [\"+\", 134, 1], [\"-\", 30, 1], [\"+\", 134, 1]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.05055570602416992", "solution_depth": "14", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[76, 135, 134, 19, 10, 30], [390, 420, 439]]", "is_correct_args": "[[76, 135, 134, 19, 10, 30], [390, 420, 439]]", "A*_args": "[\"[76, 135, 134, 19, 10, 30]\", \"[390, 420, 439]\"]"}
{"diff_sorted_id": "7", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[36, 16, 48], [86, '_', 13], [89, 31, 37]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[31, 37, 13, 31, 16, 36, 86, 89, 37, 16, 36, 86, 89, 37, 16, 13]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.03079676628112793", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[36, 16, 48], [86, \"_\", 13], [89, 31, 37]]]", "is_correct_args": "[[[36, 16, 48], [86, \"_\", 13], [89, 31, 37]]]", "A*_args": "[\"[[36, 16, 48], [86, '_', 13], [89, 31, 37]]\"]"}
{"diff_sorted_id": "7", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: cry, dune, rump, knee   The initial board: [['u', 'c', 'r', 'y'], ['d', 'n', 'n', 'r'], ['_', 'u', 'm', 'p'], ['k', 'e', 'e', 'e']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"up-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.1806955337524414", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"u\", \"c\", \"r\", \"y\"], [\"d\", \"n\", \"n\", \"r\"], [\"_\", \"u\", \"m\", \"p\"], [\"k\", \"e\", \"e\", \"e\"]]]", "is_correct_args": "[[[\"u\", \"c\", \"r\", \"y\"], [\"d\", \"n\", \"n\", \"r\"], [\"_\", \"u\", \"m\", \"p\"], [\"k\", \"e\", \"e\", \"e\"]], [\"cry\", \"dune\", \"rump\", \"knee\"]]", "A*_args": "[\"[['u', 'c', 'r', 'y'], ['d', 'n', 'n', 'r'], ['_', 'u', 'm', 'p'], ['k', 'e', 'e', 'e']]\", \"['cry', 'dune', 'rump', 'knee']\"]"}
{"diff_sorted_id": "7", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'Z'. Our task is to visit city B and city H excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from H and B, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  R B F Z N H A P M J \nR 0 1 1 0 1 0 0 0 0 0 \nB 0 0 1 0 0 0 1 0 0 0 \nF 0 0 0 1 1 0 0 0 1 0 \nZ 0 0 0 0 0 0 1 0 0 1 \nN 0 1 0 0 0 0 0 0 0 0 \nH 0 0 0 0 1 0 0 0 0 1 \nA 1 0 0 0 1 0 0 1 0 0 \nP 0 0 1 1 0 1 0 0 1 0 \nM 1 0 0 0 0 1 1 0 0 0 \nJ 1 0 0 1 0 0 1 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[\"Z\", \"A\", \"P\", \"H\", \"J\", \"R\", \"B\", \"F\", \"M\", \"H\", \"N\", \"B\"]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.02784132957458496", "solution_depth": "12", "max_successor_states": "10", "num_vars_per_state": "13", "is_feasible_args": "[[[0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 0]], [\"R\", \"B\", \"F\", \"Z\", \"N\", \"H\", \"A\", \"P\", \"M\", \"J\"], \"B\", \"H\"]", "is_correct_args": "[[[0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 0]], [\"R\", \"B\", \"F\", \"Z\", \"N\", \"H\", \"A\", \"P\", \"M\", \"J\"], \"Z\", \"B\", \"H\"]", "A*_args": "[\"[[0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 0]]\", \"['R', 'B', 'F', 'Z', 'N', 'H', 'A', 'P', 'M', 'J']\", \"['Z']\", \"['B', 'H']\"]"}
{"diff_sorted_id": "7", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [41, 4, 22, 8, 5, 5, 20, 4, 3, 19, 4, 13, 3, 18, 20, 9, 15, 3, 3, 14, 3, 14, 9, 4, 15, 19, 6, 15, 22, 19, 3, 3, 20, 9, 20, 11, 22, 15, 20], such that the sum of the chosen coins adds up to 220. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {20: 11, 15: 13, 9: 7, 8: 3, 3: 1, 6: 3, 5: 2, 13: 11, 4: 4, 22: 11, 19: 19, 11: 1, 14: 2, 41: 16, 18: 18}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "21", "opt_solution": "[14, 8, 6, 11, 41, 22, 20, 14, 4, 5, 5, 9, 9, 9, 13, 15, 15]", "opt_solution_cost": "115", "opt_solution_compute_t": "0.03900480270385742", "solution_depth": "17", "max_successor_states": "39", "num_vars_per_state": "39", "is_feasible_args": "[[41, 4, 22, 8, 5, 5, 20, 4, 3, 19, 4, 13, 3, 18, 20, 9, 15, 3, 3, 14, 3, 14, 9, 4, 15, 19, 6, 15, 22, 19, 3, 3, 20, 9, 20, 11, 22, 15, 20]]", "is_correct_args": "[[41, 4, 22, 8, 5, 5, 20, 4, 3, 19, 4, 13, 3, 18, 20, 9, 15, 3, 3, 14, 3, 14, 9, 4, 15, 19, 6, 15, 22, 19, 3, 3, 20, 9, 20, 11, 22, 15, 20], {\"20\": 11, \"15\": 13, \"9\": 7, \"8\": 3, \"3\": 1, \"6\": 3, \"5\": 2, \"13\": 11, \"4\": 4, \"22\": 11, \"19\": 19, \"11\": 1, \"14\": 2, \"41\": 16, \"18\": 18}, 220]", "A*_args": "[\"[41, 4, 22, 8, 5, 5, 20, 4, 3, 19, 4, 13, 3, 18, 20, 9, 15, 3, 3, 14, 3, 14, 9, 4, 15, 19, 6, 15, 22, 19, 3, 3, 20, 9, 20, 11, 22, 15, 20]\", \"{20: 11, 15: 13, 9: 7, 8: 3, 3: 1, 6: 3, 5: 2, 13: 11, 4: 4, 22: 11, 19: 19, 11: 1, 14: 2, 41: 16, 18: 18}\", \"220\"]"}
{"diff_sorted_id": "7", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Red', 'Blue', 'Green'], ['Blue', 'Red', 'Blue', 'Green'], ['Blue', 'Green', 'Red', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[1, 2], [1, 0], [1, 2], [1, 0], [2, 1], [2, 1], [2, 1], [0, 1], [2, 1], [2, 0], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [2, 1]]", "opt_solution_cost": "20", "opt_solution_compute_t": "2.5152063369750977", "solution_depth": "20", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Red\", \"Blue\", \"Green\"], [\"Blue\", \"Red\", \"Blue\", \"Green\"], [\"Blue\", \"Green\", \"Red\", \"Green\"]], 6]", "is_correct_args": "[[[\"Red\", \"Red\", \"Blue\", \"Green\"], [\"Blue\", \"Red\", \"Blue\", \"Green\"], [\"Blue\", \"Green\", \"Red\", \"Green\"]], 6]", "A*_args": "[\"[['Red', 'Red', 'Blue', 'Green'], ['Blue', 'Red', 'Blue', 'Green'], ['Blue', 'Green', 'Red', 'Green']]\", \"6\"]"}
{"diff_sorted_id": "7", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 25 to 58 (25 included in the range but 58 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' '42']\n ['x' '46' 'x']\n ['x' 'x' '55']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 0, 25], [0, 1, 26], [1, 0, 47], [1, 2, 43], [2, 0, 48], [2, 1, 49]]", "opt_solution_cost": "359", "opt_solution_compute_t": "0.5126192569732666", "solution_depth": "6", "max_successor_states": "33", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', '42'], ['', '46', ''], ['', '', '55']]\", 25, 58]", "is_correct_args": "[\"[['', '', '42'], ['', '46', ''], ['', '', '55']]\", 25, 58]", "A*_args": "[\"[['', '', '42'], ['', '46', ''], ['', '', '55']]\", \"25\", \"58\"]"}
{"diff_sorted_id": "7", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 19 to 43. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 111, and sum of row 1 must be 94. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 82. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['37' 'x' '26']\n ['x' 'x' 'x']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 1, 33], [1, 0, 23], [1, 1, 36], [1, 2, 35], [2, 0, 20], [2, 1, 42], [2, 2, 19]]", "opt_solution_cost": "271", "opt_solution_compute_t": "1.7812092304229736", "solution_depth": "7", "max_successor_states": "19", "num_vars_per_state": "9", "is_feasible_args": "[\"[['37', '', '26'], ['', '', ''], ['', '', '']]\", 3, 19, 43]", "is_correct_args": "[\"[['37', '', '26'], ['', '', ''], ['', '', '']]\", 19, 43, [1, 2], [1, 2], [111], [94], 82]", "A*_args": "[\"[['37', '', '26'], ['', '', ''], ['', '', '']]\", \"19\", \"43\", \"[None, 111, None]\", \"[None, 94, None]\", \"82\"]"}
{"diff_sorted_id": "7", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 5, 1: 3, 2: 5, 3: 6, 4: 5, 5: 7}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], [], ['Yellow', 'Green', 'Blue', 'Blue'], ['Red', 'Blue', 'Green', 'Green'], ['Red', 'Red', 'Yellow', 'Yellow']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[4, 1], [5, 1], [5, 1], [3, 0], [3, 2], [4, 3], [0, 5], [2, 4]]", "opt_solution_cost": "37", "opt_solution_compute_t": "0.026184558868408203", "solution_depth": "8", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[], [], [], [\"Yellow\", \"Green\", \"Blue\", \"Blue\"], [\"Red\", \"Blue\", \"Green\", \"Green\"], [\"Red\", \"Red\", \"Yellow\", \"Yellow\"]], 4, {\"0\": 5, \"1\": 3, \"2\": 5, \"3\": 6, \"4\": 5, \"5\": 7}]", "is_correct_args": "[[[], [], [], [\"Yellow\", \"Green\", \"Blue\", \"Blue\"], [\"Red\", \"Blue\", \"Green\", \"Green\"], [\"Red\", \"Red\", \"Yellow\", \"Yellow\"]], 4, {\"0\": 5, \"1\": 3, \"2\": 5, \"3\": 6, \"4\": 5, \"5\": 7}, 3]", "A*_args": "[\"[[], [], [], ['Yellow', 'Green', 'Blue', 'Blue'], ['Red', 'Blue', 'Green', 'Green'], ['Red', 'Red', 'Yellow', 'Yellow']]\", \"{0: 5, 1: 3, 2: 5, 3: 6, 4: 5, 5: 7}\", \"4\", \"3\"]"}
{"diff_sorted_id": "7", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (6, 1) to his destination workshop at index (2, 6), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 5, and district 3 covering rows 6 to 8. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 7 7 12 7 x 13 1 18]\n[9 18 x 4 19 8 x 15 10]\n[9 x 10 5 5 9 8 x x]\n[14 4 19 9 14 x x 7 9]\n[9 4 11 15 7 x 17 3 x]\n[11 x 2 18 15 15 x x x]\n[x 5 10 x x 13 x 9 x]\n[3 x 2 x 12 x x x 4]\n[x x 7 x 19 x x x 9]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "1", "opt_solution": "[[6, 1], [6, 2], [5, 2], [4, 2], [4, 3], [3, 3], [2, 3], [2, 4], [2, 5], [2, 6]]", "opt_solution_cost": "74", "opt_solution_compute_t": "0.021251201629638672", "solution_depth": "10", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"7\", \"7\", \"12\", \"7\", \"x\", \"13\", \"1\", \"18\"], [\"9\", \"18\", \"x\", \"4\", \"19\", \"8\", \"x\", \"15\", \"10\"], [\"9\", \"x\", \"10\", \"5\", \"5\", \"9\", \"8\", \"x\", \"x\"], [\"14\", \"4\", \"19\", \"9\", \"14\", \"x\", \"x\", \"7\", \"9\"], [\"9\", \"4\", \"11\", \"15\", \"7\", \"x\", \"17\", \"3\", \"x\"], [\"11\", \"x\", \"2\", \"18\", \"15\", \"15\", \"x\", \"x\", \"x\"], [\"x\", \"5\", \"10\", \"x\", \"x\", \"13\", \"x\", \"9\", \"x\"], [\"3\", \"x\", \"2\", \"x\", \"12\", \"x\", \"x\", \"x\", \"4\"], [\"x\", \"x\", \"7\", \"x\", \"19\", \"x\", \"x\", \"x\", \"9\"]]]", "is_correct_args": "[[[\"x\", \"7\", \"7\", \"12\", \"7\", \"x\", \"13\", \"1\", \"18\"], [\"9\", \"18\", \"x\", \"4\", \"19\", \"8\", \"x\", \"15\", \"10\"], [\"9\", \"x\", \"10\", \"5\", \"5\", \"9\", \"8\", \"x\", \"x\"], [\"14\", \"4\", \"19\", \"9\", \"14\", \"x\", \"x\", \"7\", \"9\"], [\"9\", \"4\", \"11\", \"15\", \"7\", \"x\", \"17\", \"3\", \"x\"], [\"11\", \"x\", \"2\", \"18\", \"15\", \"15\", \"x\", \"x\", \"x\"], [\"x\", \"5\", \"10\", \"x\", \"x\", \"13\", \"x\", \"9\", \"x\"], [\"3\", \"x\", \"2\", \"x\", \"12\", \"x\", \"x\", \"x\", \"4\"], [\"x\", \"x\", \"7\", \"x\", \"19\", \"x\", \"x\", \"x\", \"9\"]], [6, 1], [2, 6], 2, 5]", "A*_args": "[\"[['x', '7', '7', '12', '7', 'x', '13', '1', '18'], ['9', '18', 'x', '4', '19', '8', 'x', '15', '10'], ['9', 'x', '10', '5', '5', '9', '8', 'x', 'x'], ['14', '4', '19', '9', '14', 'x', 'x', '7', '9'], ['9', '4', '11', '15', '7', 'x', '17', '3', 'x'], ['11', 'x', '2', '18', '15', '15', 'x', 'x', 'x'], ['x', '5', '10', 'x', 'x', '13', 'x', '9', 'x'], ['3', 'x', '2', 'x', '12', 'x', 'x', 'x', '4'], ['x', 'x', '7', 'x', '19', 'x', 'x', 'x', '9']]\", \"(6, 1)\", \"(2, 6)\", \"2\", \"5\"]"}
{"diff_sorted_id": "7", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 9x9. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (8, 2) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (0, 7). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 1 1 1 1 1 0 0\n0 1 1 1 1 1 1 0 0\n1 1 1 1 0 0 0 1 0\n1 1 1 0 0 1 1 0 0\n0 0 1 0 0 1 1 0 0\n1 1 0 0 1 0 1 0 0\n0 1 1 1 1 1 1 1 0\n1 0 0 0 0 1 1 0 0\n0 0 0 0 0 0 0 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "9", "opt_solution": "[[8, 2], [8, 3], [8, 4], [8, 5], [8, 6], [7, 7], [6, 8], [5, 8], [4, 8], [3, 8], [2, 8], [1, 7], [0, 7]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.030285120010375977", "solution_depth": "13", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 0], [1, 1, 1, 1, 0, 0, 0, 1, 0], [1, 1, 1, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 0], [1, 1, 0, 0, 1, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]\", 3]", "is_correct_args": "[\"[[1, 0, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 0], [1, 1, 1, 1, 0, 0, 0, 1, 0], [1, 1, 1, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 0], [1, 1, 0, 0, 1, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]\", [8, 2], [0, 7], 3]", "A*_args": "[\"[[1, 0, 1, 1, 1, 1, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 0], [1, 1, 1, 1, 0, 0, 0, 1, 0], [1, 1, 1, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 0], [1, 1, 0, 0, 1, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]]\", \"(8, 2)\", \"(0, 7)\", \"3\"]"}
{"diff_sorted_id": "7", "problem_statement": "Given 5 labeled water jugs with capacities 22, 48, 29, 111, 92, 28 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 164, 233, 289 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 48, 3], [\"+\", 111, 3], [\"+\", 111, 3], [\"-\", 29, 3], [\"+\", 48, 3], [\"+\", 29, 2], [\"+\", 92, 2], [\"+\", 92, 2], [\"-\", 28, 2], [\"+\", 48, 2], [\"+\", 22, 1], [\"+\", 22, 1], [\"+\", 28, 1], [\"+\", 92, 1]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.03762245178222656", "solution_depth": "14", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[22, 48, 29, 111, 92, 28], [164, 233, 289]]", "is_correct_args": "[[22, 48, 29, 111, 92, 28], [164, 233, 289]]", "A*_args": "[\"[22, 48, 29, 111, 92, 28]\", \"[164, 233, 289]\"]"}
{"diff_sorted_id": "8", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[77, 49, '_'], [56, 72, 74], [96, 33, 59]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[74, 72, 56, 96, 33, 56, 49, 77, 96, 49, 72, 59, 56, 33, 49, 72, 59, 56]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.03490924835205078", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[77, 49, \"_\"], [56, 72, 74], [96, 33, 59]]]", "is_correct_args": "[[[77, 49, \"_\"], [56, 72, 74], [96, 33, 59]]]", "A*_args": "[\"[[77, 49, '_'], [56, 72, 74], [96, 33, 59]]\"]"}
{"diff_sorted_id": "8", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: ken, khat, kill, went   The initial board: [['h', 'k', 't', 'n'], ['k', 'e', 'a', 'k'], ['e', 'i', '_', 'l'], ['w', 'l', 'n', 't']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.16104960441589355", "solution_depth": "8", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"h\", \"k\", \"t\", \"n\"], [\"k\", \"e\", \"a\", \"k\"], [\"e\", \"i\", \"_\", \"l\"], [\"w\", \"l\", \"n\", \"t\"]]]", "is_correct_args": "[[[\"h\", \"k\", \"t\", \"n\"], [\"k\", \"e\", \"a\", \"k\"], [\"e\", \"i\", \"_\", \"l\"], [\"w\", \"l\", \"n\", \"t\"]], [\"ken\", \"khat\", \"kill\", \"went\"]]", "A*_args": "[\"[['h', 'k', 't', 'n'], ['k', 'e', 'a', 'k'], ['e', 'i', '_', 'l'], ['w', 'l', 'n', 't']]\", \"['ken', 'khat', 'kill', 'went']\"]"}
{"diff_sorted_id": "8", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'U'. Our task is to visit city A and city X excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from X and A, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  Y O Q X K R A U M L \nY 0 1 0 0 0 1 1 1 1 1 \nO 0 0 0 0 0 0 1 0 0 0 \nQ 1 0 0 1 0 1 0 0 1 0 \nX 1 0 1 0 0 1 0 0 1 1 \nK 0 1 0 1 0 0 1 0 0 0 \nR 0 0 0 0 1 0 0 0 0 0 \nA 0 0 0 1 0 1 0 0 1 1 \nU 0 0 0 0 0 0 0 0 0 1 \nM 0 0 1 0 0 0 0 0 0 0 \nL 0 1 0 0 0 0 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[\"U\", \"L\", \"O\", \"A\", \"X\", \"Y\", \"A\", \"X\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.029206514358520508", "solution_depth": "8", "max_successor_states": "10", "num_vars_per_state": "13", "is_feasible_args": "[[[0, 1, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 0, 1, 0, 0, 1, 0], [1, 0, 1, 0, 0, 1, 0, 0, 1, 1], [0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]], [\"Y\", \"O\", \"Q\", \"X\", \"K\", \"R\", \"A\", \"U\", \"M\", \"L\"], \"A\", \"X\"]", "is_correct_args": "[[[0, 1, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 0, 1, 0, 0, 1, 0], [1, 0, 1, 0, 0, 1, 0, 0, 1, 1], [0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]], [\"Y\", \"O\", \"Q\", \"X\", \"K\", \"R\", \"A\", \"U\", \"M\", \"L\"], \"U\", \"A\", \"X\"]", "A*_args": "[\"[[0, 1, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 0, 1, 0, 0, 1, 0], [1, 0, 1, 0, 0, 1, 0, 0, 1, 1], [0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0]]\", \"['Y', 'O', 'Q', 'X', 'K', 'R', 'A', 'U', 'M', 'L']\", \"['U']\", \"['A', 'X']\"]"}
{"diff_sorted_id": "8", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [4, 17, 8, 15, 6, 14, 2, 4, 16, 10, 6, 5, 14, 8, 18, 2, 17, 9, 17, 59, 3, 10, 21, 4, 9, 14, 14, 20, 14, 8, 14, 18, 5, 16, 14, 17, 5, 3], such that the sum of the chosen coins adds up to 214. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {15: 6, 5: 5, 17: 1, 14: 4, 2: 2, 8: 2, 10: 9, 59: 9, 16: 8, 4: 3, 18: 10, 20: 11, 21: 8, 6: 6, 9: 9, 3: 3}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "22", "opt_solution": "[17, 17, 17, 14, 8, 59, 14, 8, 17, 14, 8, 21]", "opt_solution_cost": "39", "opt_solution_compute_t": "0.037581682205200195", "solution_depth": "12", "max_successor_states": "38", "num_vars_per_state": "38", "is_feasible_args": "[[4, 17, 8, 15, 6, 14, 2, 4, 16, 10, 6, 5, 14, 8, 18, 2, 17, 9, 17, 59, 3, 10, 21, 4, 9, 14, 14, 20, 14, 8, 14, 18, 5, 16, 14, 17, 5, 3]]", "is_correct_args": "[[4, 17, 8, 15, 6, 14, 2, 4, 16, 10, 6, 5, 14, 8, 18, 2, 17, 9, 17, 59, 3, 10, 21, 4, 9, 14, 14, 20, 14, 8, 14, 18, 5, 16, 14, 17, 5, 3], {\"15\": 6, \"5\": 5, \"17\": 1, \"14\": 4, \"2\": 2, \"8\": 2, \"10\": 9, \"59\": 9, \"16\": 8, \"4\": 3, \"18\": 10, \"20\": 11, \"21\": 8, \"6\": 6, \"9\": 9, \"3\": 3}, 214]", "A*_args": "[\"[4, 17, 8, 15, 6, 14, 2, 4, 16, 10, 6, 5, 14, 8, 18, 2, 17, 9, 17, 59, 3, 10, 21, 4, 9, 14, 14, 20, 14, 8, 14, 18, 5, 16, 14, 17, 5, 3]\", \"{15: 6, 5: 5, 17: 1, 14: 4, 2: 2, 8: 2, 10: 9, 59: 9, 16: 8, 4: 3, 18: 10, 20: 11, 21: 8, 6: 6, 9: 9, 3: 3}\", \"214\"]"}
{"diff_sorted_id": "8", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Blue', 'Red', 'Red'], ['Red', 'Green', 'Green', 'Blue'], ['Red', 'Green', 'Blue', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[1, 2], [1, 0], [1, 0], [1, 2], [0, 1], [0, 1], [0, 1], [0, 1], [2, 1], [2, 0], [2, 0], [2, 0], [1, 2], [1, 2], [0, 1]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.3737452030181885", "solution_depth": "15", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Blue\", \"Red\", \"Red\"], [\"Red\", \"Green\", \"Green\", \"Blue\"], [\"Red\", \"Green\", \"Blue\", \"Blue\"]], 6]", "is_correct_args": "[[[\"Green\", \"Blue\", \"Red\", \"Red\"], [\"Red\", \"Green\", \"Green\", \"Blue\"], [\"Red\", \"Green\", \"Blue\", \"Blue\"]], 6]", "A*_args": "[\"[['Green', 'Blue', 'Red', 'Red'], ['Red', 'Green', 'Green', 'Blue'], ['Red', 'Green', 'Blue', 'Blue']]\", \"6\"]"}
{"diff_sorted_id": "8", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 19 to 52 (19 included in the range but 52 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' 'x']\n ['x' '36' '44']\n ['x' '34' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 0, 19], [0, 1, 37], [0, 2, 45], [1, 0, 21], [2, 0, 35], [2, 2, 20]]", "opt_solution_cost": "285", "opt_solution_compute_t": "6.972386598587036", "solution_depth": "6", "max_successor_states": "33", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '36', '44'], ['', '34', '']]\", 19, 52]", "is_correct_args": "[\"[['', '', ''], ['', '36', '44'], ['', '34', '']]\", 19, 52]", "A*_args": "[\"[['', '', ''], ['', '36', '44'], ['', '34', '']]\", \"19\", \"52\"]"}
{"diff_sorted_id": "8", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 35 to 59. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 130, and sum of row 1 must be 144. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 123. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['52' 'x' 'x']\n ['x' 'x' 'x']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 1, 38], [0, 2, 35], [1, 0, 39], [1, 1, 51], [1, 2, 54], [2, 0, 37], [2, 1, 41], [2, 2, 36]]", "opt_solution_cost": "383", "opt_solution_compute_t": "2.281245708465576", "solution_depth": "8", "max_successor_states": "19", "num_vars_per_state": "9", "is_feasible_args": "[\"[['52', '', ''], ['', '', ''], ['', '', '']]\", 3, 35, 59]", "is_correct_args": "[\"[['52', '', ''], ['', '', ''], ['', '', '']]\", 35, 59, [1, 2], [1, 2], [130], [144], 123]", "A*_args": "[\"[['52', '', ''], ['', '', ''], ['', '', '']]\", \"35\", \"59\", \"[None, 130, None]\", \"[None, 144, None]\", \"123\"]"}
{"diff_sorted_id": "8", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 3, 1: 6, 2: 1, 3: 7, 4: 2, 5: 3}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Blue', 'Green', 'Green', 'Red'], ['Yellow', 'Yellow', 'Green', 'Yellow'], [], [], [], ['Red', 'Blue', 'Red', 'Blue']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[0, 2], [0, 4], [0, 4], [5, 0], [5, 2], [5, 0], [2, 5], [2, 5], [1, 2], [1, 2], [1, 4], [1, 2]]", "opt_solution_cost": "23", "opt_solution_compute_t": "0.13733744621276855", "solution_depth": "12", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Green\", \"Red\"], [\"Yellow\", \"Yellow\", \"Green\", \"Yellow\"], [], [], [], [\"Red\", \"Blue\", \"Red\", \"Blue\"]], 4, {\"0\": 3, \"1\": 6, \"2\": 1, \"3\": 7, \"4\": 2, \"5\": 3}]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Green\", \"Red\"], [\"Yellow\", \"Yellow\", \"Green\", \"Yellow\"], [], [], [], [\"Red\", \"Blue\", \"Red\", \"Blue\"]], 4, {\"0\": 3, \"1\": 6, \"2\": 1, \"3\": 7, \"4\": 2, \"5\": 3}, 3]", "A*_args": "[\"[['Blue', 'Green', 'Green', 'Red'], ['Yellow', 'Yellow', 'Green', 'Yellow'], [], [], [], ['Red', 'Blue', 'Red', 'Blue']]\", \"{0: 3, 1: 6, 2: 1, 3: 7, 4: 2, 5: 3}\", \"4\", \"3\"]"}
{"diff_sorted_id": "8", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (2, 8) to his destination workshop at index (6, 3), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 5, and district 3 covering rows 6 to 8. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x x x 13 x x 3 8]\n[x 18 19 19 2 9 x x x]\n[15 x 6 x x x 13 13 4]\n[7 x 4 10 x 11 10 17 x]\n[2 7 x x 8 16 4 1 4]\n[x x x 5 16 15 x 17 10]\n[x x x 5 14 9 3 15 x]\n[x 6 4 x x x 18 x x]\n[17 x 19 x 1 4 8 x 8]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "1", "opt_solution": "[[2, 8], [2, 7], [3, 7], [4, 7], [4, 6], [4, 5], [4, 4], [5, 4], [5, 3], [6, 3]]", "opt_solution_cost": "85", "opt_solution_compute_t": "0.026849031448364258", "solution_depth": "10", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"x\", \"x\", \"13\", \"x\", \"x\", \"3\", \"8\"], [\"x\", \"18\", \"19\", \"19\", \"2\", \"9\", \"x\", \"x\", \"x\"], [\"15\", \"x\", \"6\", \"x\", \"x\", \"x\", \"13\", \"13\", \"4\"], [\"7\", \"x\", \"4\", \"10\", \"x\", \"11\", \"10\", \"17\", \"x\"], [\"2\", \"7\", \"x\", \"x\", \"8\", \"16\", \"4\", \"1\", \"4\"], [\"x\", \"x\", \"x\", \"5\", \"16\", \"15\", \"x\", \"17\", \"10\"], [\"x\", \"x\", \"x\", \"5\", \"14\", \"9\", \"3\", \"15\", \"x\"], [\"x\", \"6\", \"4\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\"], [\"17\", \"x\", \"19\", \"x\", \"1\", \"4\", \"8\", \"x\", \"8\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"x\", \"x\", \"13\", \"x\", \"x\", \"3\", \"8\"], [\"x\", \"18\", \"19\", \"19\", \"2\", \"9\", \"x\", \"x\", \"x\"], [\"15\", \"x\", \"6\", \"x\", \"x\", \"x\", \"13\", \"13\", \"4\"], [\"7\", \"x\", \"4\", \"10\", \"x\", \"11\", \"10\", \"17\", \"x\"], [\"2\", \"7\", \"x\", \"x\", \"8\", \"16\", \"4\", \"1\", \"4\"], [\"x\", \"x\", \"x\", \"5\", \"16\", \"15\", \"x\", \"17\", \"10\"], [\"x\", \"x\", \"x\", \"5\", \"14\", \"9\", \"3\", \"15\", \"x\"], [\"x\", \"6\", \"4\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\"], [\"17\", \"x\", \"19\", \"x\", \"1\", \"4\", \"8\", \"x\", \"8\"]], [2, 8], [6, 3], 2, 5]", "A*_args": "[\"[['x', 'x', 'x', 'x', '13', 'x', 'x', '3', '8'], ['x', '18', '19', '19', '2', '9', 'x', 'x', 'x'], ['15', 'x', '6', 'x', 'x', 'x', '13', '13', '4'], ['7', 'x', '4', '10', 'x', '11', '10', '17', 'x'], ['2', '7', 'x', 'x', '8', '16', '4', '1', '4'], ['x', 'x', 'x', '5', '16', '15', 'x', '17', '10'], ['x', 'x', 'x', '5', '14', '9', '3', '15', 'x'], ['x', '6', '4', 'x', 'x', 'x', '18', 'x', 'x'], ['17', 'x', '19', 'x', '1', '4', '8', 'x', '8']]\", \"(2, 8)\", \"(6, 3)\", \"2\", \"5\"]"}
{"diff_sorted_id": "8", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 9x9. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 8) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (8, 3). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 1 1 0 0 0 1 0\n0 1 1 0 1 0 1 0 0\n1 0 1 1 1 1 0 0 1\n0 0 1 0 1 1 1 0 1\n1 0 1 1 0 1 1 0 1\n1 1 1 1 1 0 0 0 0\n0 0 1 1 1 0 0 0 1\n1 1 1 0 0 0 0 1 1\n1 1 1 0 0 0 0 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "9", "opt_solution": "[[0, 8], [1, 7], [2, 7], [3, 7], [4, 7], [5, 6], [5, 5], [6, 5], [7, 4], [7, 3], [8, 3]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.03156876564025879", "solution_depth": "11", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 1, 1, 0, 0, 0, 1, 0], [0, 1, 1, 0, 1, 0, 1, 0, 0], [1, 0, 1, 1, 1, 1, 0, 0, 1], [0, 0, 1, 0, 1, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1], [1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 0, 0, 1, 1]]\", 3]", "is_correct_args": "[\"[[0, 1, 1, 1, 0, 0, 0, 1, 0], [0, 1, 1, 0, 1, 0, 1, 0, 0], [1, 0, 1, 1, 1, 1, 0, 0, 1], [0, 0, 1, 0, 1, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1], [1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 0, 0, 1, 1]]\", [0, 8], [8, 3], 3]", "A*_args": "[\"[[0, 1, 1, 1, 0, 0, 0, 1, 0], [0, 1, 1, 0, 1, 0, 1, 0, 0], [1, 0, 1, 1, 1, 1, 0, 0, 1], [0, 0, 1, 0, 1, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1], [1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 0, 0, 1, 1]]\", \"(0, 8)\", \"(8, 3)\", \"3\"]"}
{"diff_sorted_id": "8", "problem_statement": "Given 5 labeled water jugs with capacities 59, 68, 104, 106, 69, 42 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 196, 210, 238 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 106, 3], [\"+\", 106, 3], [\"-\", 42, 3], [\"+\", 68, 3], [\"+\", 104, 2], [\"+\", 106, 2], [\"+\", 59, 1], [\"+\", 68, 1], [\"+\", 69, 1]]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.032889366149902344", "solution_depth": "9", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[59, 68, 104, 106, 69, 42], [196, 210, 238]]", "is_correct_args": "[[59, 68, 104, 106, 69, 42], [196, 210, 238]]", "A*_args": "[\"[59, 68, 104, 106, 69, 42]\", \"[196, 210, 238]\"]"}
{"diff_sorted_id": "9", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[23, 30, 43], [12, 31, 19], [6, 68, '_']]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[19, 31, 68, 6, 12, 23, 30, 68, 23, 30, 68, 43, 31, 19]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.02962183952331543", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[23, 30, 43], [12, 31, 19], [6, 68, \"_\"]]]", "is_correct_args": "[[[23, 30, 43], [12, 31, 19], [6, 68, \"_\"]]]", "A*_args": "[\"[[23, 30, 43], [12, 31, 19], [6, 68, '_']]\"]"}
{"diff_sorted_id": "9", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: sun, quot, chat, lure   The initial board: [['_', 's', 'a', 'n'], ['q', 'u', 'o', 'u'], ['c', 'h', 'u', 't'], ['l', 't', 'r', 'e']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.14909648895263672", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"_\", \"s\", \"a\", \"n\"], [\"q\", \"u\", \"o\", \"u\"], [\"c\", \"h\", \"u\", \"t\"], [\"l\", \"t\", \"r\", \"e\"]]]", "is_correct_args": "[[[\"_\", \"s\", \"a\", \"n\"], [\"q\", \"u\", \"o\", \"u\"], [\"c\", \"h\", \"u\", \"t\"], [\"l\", \"t\", \"r\", \"e\"]], [\"sun\", \"quot\", \"chat\", \"lure\"]]", "A*_args": "[\"[['_', 's', 'a', 'n'], ['q', 'u', 'o', 'u'], ['c', 'h', 'u', 't'], ['l', 't', 'r', 'e']]\", \"['sun', 'quot', 'chat', 'lure']\"]"}
{"diff_sorted_id": "9", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'C'. Our task is to visit city W and city F excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from F and W, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  R T C F S X Y E A W \nR 0 1 1 0 0 0 1 1 0 1 \nT 0 0 1 1 0 0 0 0 0 1 \nC 0 0 0 0 0 0 1 0 0 0 \nF 1 1 0 0 0 1 0 1 1 0 \nS 1 0 0 1 0 0 0 1 0 0 \nX 1 0 1 1 1 0 0 0 0 0 \nY 1 1 0 1 0 0 0 0 0 0 \nE 0 0 1 0 1 0 0 0 0 0 \nA 1 0 0 0 1 1 1 1 0 0 \nW 1 0 0 1 1 1 0 1 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[\"C\", \"Y\", \"F\", \"T\", \"W\", \"R\", \"W\", \"F\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.022681236267089844", "solution_depth": "8", "max_successor_states": "10", "num_vars_per_state": "13", "is_feasible_args": "[[[0, 1, 1, 0, 0, 0, 1, 1, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 1, 1, 0], [1, 0, 0, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 1, 1, 0, 1, 1, 0]], [\"R\", \"T\", \"C\", \"F\", \"S\", \"X\", \"Y\", \"E\", \"A\", \"W\"], \"W\", \"F\"]", "is_correct_args": "[[[0, 1, 1, 0, 0, 0, 1, 1, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 1, 1, 0], [1, 0, 0, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 1, 1, 0, 1, 1, 0]], [\"R\", \"T\", \"C\", \"F\", \"S\", \"X\", \"Y\", \"E\", \"A\", \"W\"], \"C\", \"W\", \"F\"]", "A*_args": "[\"[[0, 1, 1, 0, 0, 0, 1, 1, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 1, 1, 0], [1, 0, 0, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 1, 1, 0, 1, 1, 0]]\", \"['R', 'T', 'C', 'F', 'S', 'X', 'Y', 'E', 'A', 'W']\", \"['C']\", \"['W', 'F']\"]"}
{"diff_sorted_id": "9", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [3, 6, 9, 10, 13, 15, 18, 5, 21, 19, 12, 15, 5, 9, 4, 16, 8, 4, 7, 7, 7, 2, 16, 14, 18, 3, 89, 21, 12, 10, 7, 14, 4, 11, 6, 20], such that the sum of the chosen coins adds up to 229. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {14: 1, 89: 13, 2: 2, 5: 2, 4: 4, 6: 6, 8: 2, 16: 5, 21: 4, 20: 2, 18: 9, 11: 10, 10: 3, 12: 12, 15: 5, 13: 1, 3: 1, 19: 19, 7: 7, 9: 3}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "23", "opt_solution": "[3, 89, 20, 14, 21, 14, 8, 13, 21, 16, 10]", "opt_solution_cost": "37", "opt_solution_compute_t": "0.03856658935546875", "solution_depth": "11", "max_successor_states": "36", "num_vars_per_state": "36", "is_feasible_args": "[[3, 6, 9, 10, 13, 15, 18, 5, 21, 19, 12, 15, 5, 9, 4, 16, 8, 4, 7, 7, 7, 2, 16, 14, 18, 3, 89, 21, 12, 10, 7, 14, 4, 11, 6, 20]]", "is_correct_args": "[[3, 6, 9, 10, 13, 15, 18, 5, 21, 19, 12, 15, 5, 9, 4, 16, 8, 4, 7, 7, 7, 2, 16, 14, 18, 3, 89, 21, 12, 10, 7, 14, 4, 11, 6, 20], {\"14\": 1, \"89\": 13, \"2\": 2, \"5\": 2, \"4\": 4, \"6\": 6, \"8\": 2, \"16\": 5, \"21\": 4, \"20\": 2, \"18\": 9, \"11\": 10, \"10\": 3, \"12\": 12, \"15\": 5, \"13\": 1, \"3\": 1, \"19\": 19, \"7\": 7, \"9\": 3}, 229]", "A*_args": "[\"[3, 6, 9, 10, 13, 15, 18, 5, 21, 19, 12, 15, 5, 9, 4, 16, 8, 4, 7, 7, 7, 2, 16, 14, 18, 3, 89, 21, 12, 10, 7, 14, 4, 11, 6, 20]\", \"{14: 1, 89: 13, 2: 2, 5: 2, 4: 4, 6: 6, 8: 2, 16: 5, 21: 4, 20: 2, 18: 9, 11: 10, 10: 3, 12: 12, 15: 5, 13: 1, 3: 1, 19: 19, 7: 7, 9: 3}\", \"229\"]"}
{"diff_sorted_id": "9", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Blue', 'Green', 'Red'], ['Red', 'Green', 'Blue', 'Red'], ['Blue', 'Red', 'Green', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[0, 2], [1, 0], [1, 2], [1, 0], [1, 0], [2, 1], [2, 1], [0, 1], [2, 0], [2, 1], [2, 1], [0, 2], [0, 2], [0, 1], [0, 2], [0, 2], [1, 0], [1, 2], [1, 0], [1, 0], [2, 1], [2, 1]]", "opt_solution_cost": "22", "opt_solution_compute_t": "7.09385085105896", "solution_depth": "22", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Blue\", \"Green\", \"Red\"], [\"Red\", \"Green\", \"Blue\", \"Red\"], [\"Blue\", \"Red\", \"Green\", \"Blue\"]], 6]", "is_correct_args": "[[[\"Green\", \"Blue\", \"Green\", \"Red\"], [\"Red\", \"Green\", \"Blue\", \"Red\"], [\"Blue\", \"Red\", \"Green\", \"Blue\"]], 6]", "A*_args": "[\"[['Green', 'Blue', 'Green', 'Red'], ['Red', 'Green', 'Blue', 'Red'], ['Blue', 'Red', 'Green', 'Blue']]\", \"6\"]"}
{"diff_sorted_id": "9", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 34 to 67 (34 included in the range but 67 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' 'x']\n ['x' '51' 'x']\n ['x' '61' '64']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 0, 34], [0, 1, 35], [0, 2, 36], [1, 0, 52], [1, 2, 37], [2, 0, 53]]", "opt_solution_cost": "391", "opt_solution_compute_t": "0.19122576713562012", "solution_depth": "6", "max_successor_states": "33", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '51', ''], ['', '61', '64']]\", 34, 67]", "is_correct_args": "[\"[['', '', ''], ['', '51', ''], ['', '61', '64']]\", 34, 67]", "A*_args": "[\"[['', '', ''], ['', '51', ''], ['', '61', '64']]\", \"34\", \"67\"]"}
{"diff_sorted_id": "9", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 35 to 59. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 125, and sum of row 1 must be 157. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 138. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x']\n ['x' 'x' 'x']\n ['37' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 0, 38], [0, 1, 35], [0, 2, 47], [1, 0, 45], [1, 1, 54], [1, 2, 58], [2, 1, 36], [2, 2, 39]]", "opt_solution_cost": "389", "opt_solution_compute_t": "1.5451362133026123", "solution_depth": "8", "max_successor_states": "24", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '', ''], ['37', '', '']]\", 3, 35, 59]", "is_correct_args": "[\"[['', '', ''], ['', '', ''], ['37', '', '']]\", 35, 59, [1, 2], [1, 2], [125], [157], 138]", "A*_args": "[\"[['', '', ''], ['', '', ''], ['37', '', '']]\", \"35\", \"59\", \"[None, 125, None]\", \"[None, 157, None]\", \"138\"]"}
{"diff_sorted_id": "9", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 7, 1: 1, 2: 4, 3: 7, 4: 4, 5: 4}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Yellow', 'Yellow', 'Red', 'Red'], [], ['Blue', 'Yellow', 'Red', 'Green'], [], ['Green', 'Blue', 'Green', 'Blue'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[0, 3], [0, 3], [2, 5], [2, 3], [2, 1], [4, 2], [4, 5], [4, 2], [4, 5], [0, 1], [0, 1]]", "opt_solution_cost": "44", "opt_solution_compute_t": "0.111785888671875", "solution_depth": "11", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Yellow\", \"Yellow\", \"Red\", \"Red\"], [], [\"Blue\", \"Yellow\", \"Red\", \"Green\"], [], [\"Green\", \"Blue\", \"Green\", \"Blue\"], []], 4, {\"0\": 7, \"1\": 1, \"2\": 4, \"3\": 7, \"4\": 4, \"5\": 4}]", "is_correct_args": "[[[\"Yellow\", \"Yellow\", \"Red\", \"Red\"], [], [\"Blue\", \"Yellow\", \"Red\", \"Green\"], [], [\"Green\", \"Blue\", \"Green\", \"Blue\"], []], 4, {\"0\": 7, \"1\": 1, \"2\": 4, \"3\": 7, \"4\": 4, \"5\": 4}, 3]", "A*_args": "[\"[['Yellow', 'Yellow', 'Red', 'Red'], [], ['Blue', 'Yellow', 'Red', 'Green'], [], ['Green', 'Blue', 'Green', 'Blue'], []]\", \"{0: 7, 1: 1, 2: 4, 3: 7, 4: 4, 5: 4}\", \"4\", \"3\"]"}
{"diff_sorted_id": "9", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (1, 8) to his destination workshop at index (4, 0), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 4, and district 3 covering rows 5 to 8. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[6 9 19 x 5 9 x 15 x]\n[8 10 16 x x x 5 11 4]\n[5 11 20 1 14 16 7 1 5]\n[10 5 3 5 12 8 x x 2]\n[16 15 15 14 x 13 10 x 10]\n[6 4 7 13 x x x x 13]\n[x 1 6 3 x x 17 9 5]\n[x 11 x 9 x 5 7 x x]\n[x x x 18 x 2 x x 12]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "1", "opt_solution": "[[1, 8], [2, 8], [2, 7], [2, 6], [2, 5], [2, 4], [2, 3], [3, 3], [3, 2], [3, 1], [4, 1], [5, 1], [5, 0], [4, 0]]", "opt_solution_cost": "98", "opt_solution_compute_t": "0.02410721778869629", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"6\", \"9\", \"19\", \"x\", \"5\", \"9\", \"x\", \"15\", \"x\"], [\"8\", \"10\", \"16\", \"x\", \"x\", \"x\", \"5\", \"11\", \"4\"], [\"5\", \"11\", \"20\", \"1\", \"14\", \"16\", \"7\", \"1\", \"5\"], [\"10\", \"5\", \"3\", \"5\", \"12\", \"8\", \"x\", \"x\", \"2\"], [\"16\", \"15\", \"15\", \"14\", \"x\", \"13\", \"10\", \"x\", \"10\"], [\"6\", \"4\", \"7\", \"13\", \"x\", \"x\", \"x\", \"x\", \"13\"], [\"x\", \"1\", \"6\", \"3\", \"x\", \"x\", \"17\", \"9\", \"5\"], [\"x\", \"11\", \"x\", \"9\", \"x\", \"5\", \"7\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"18\", \"x\", \"2\", \"x\", \"x\", \"12\"]]]", "is_correct_args": "[[[\"6\", \"9\", \"19\", \"x\", \"5\", \"9\", \"x\", \"15\", \"x\"], [\"8\", \"10\", \"16\", \"x\", \"x\", \"x\", \"5\", \"11\", \"4\"], [\"5\", \"11\", \"20\", \"1\", \"14\", \"16\", \"7\", \"1\", \"5\"], [\"10\", \"5\", \"3\", \"5\", \"12\", \"8\", \"x\", \"x\", \"2\"], [\"16\", \"15\", \"15\", \"14\", \"x\", \"13\", \"10\", \"x\", \"10\"], [\"6\", \"4\", \"7\", \"13\", \"x\", \"x\", \"x\", \"x\", \"13\"], [\"x\", \"1\", \"6\", \"3\", \"x\", \"x\", \"17\", \"9\", \"5\"], [\"x\", \"11\", \"x\", \"9\", \"x\", \"5\", \"7\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"18\", \"x\", \"2\", \"x\", \"x\", \"12\"]], [1, 8], [4, 0], 1, 4]", "A*_args": "[\"[['6', '9', '19', 'x', '5', '9', 'x', '15', 'x'], ['8', '10', '16', 'x', 'x', 'x', '5', '11', '4'], ['5', '11', '20', '1', '14', '16', '7', '1', '5'], ['10', '5', '3', '5', '12', '8', 'x', 'x', '2'], ['16', '15', '15', '14', 'x', '13', '10', 'x', '10'], ['6', '4', '7', '13', 'x', 'x', 'x', 'x', '13'], ['x', '1', '6', '3', 'x', 'x', '17', '9', '5'], ['x', '11', 'x', '9', 'x', '5', '7', 'x', 'x'], ['x', 'x', 'x', '18', 'x', '2', 'x', 'x', '12']]\", \"(1, 8)\", \"(4, 0)\", \"1\", \"4\"]"}
{"diff_sorted_id": "9", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 9x9. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 2) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (8, 8). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 1 1 1 0 1 1 1\n0 1 0 0 1 1 1 0 0\n1 0 1 0 1 1 1 0 0\n1 1 1 0 0 0 1 1 0\n1 1 0 1 0 1 0 1 1\n1 0 1 1 0 1 1 1 0\n0 1 0 0 0 1 1 0 0\n0 1 0 0 0 1 0 1 1\n1 1 0 0 0 0 0 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "9", "opt_solution": "[[1, 2], [2, 3], [3, 3], [4, 4], [5, 4], [6, 4], [7, 4], [8, 5], [8, 6], [8, 7], [8, 8]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.034554481506347656", "solution_depth": "11", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 1, 1, 1, 0, 1, 1, 1], [0, 1, 0, 0, 1, 1, 1, 0, 0], [1, 0, 1, 0, 1, 1, 1, 0, 0], [1, 1, 1, 0, 0, 0, 1, 1, 0], [1, 1, 0, 1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 0, 1, 1, 1, 0], [0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 1, 0, 1, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0]]\", 3]", "is_correct_args": "[\"[[1, 0, 1, 1, 1, 0, 1, 1, 1], [0, 1, 0, 0, 1, 1, 1, 0, 0], [1, 0, 1, 0, 1, 1, 1, 0, 0], [1, 1, 1, 0, 0, 0, 1, 1, 0], [1, 1, 0, 1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 0, 1, 1, 1, 0], [0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 1, 0, 1, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0]]\", [1, 2], [8, 8], 3]", "A*_args": "[\"[[1, 0, 1, 1, 1, 0, 1, 1, 1], [0, 1, 0, 0, 1, 1, 1, 0, 0], [1, 0, 1, 0, 1, 1, 1, 0, 0], [1, 1, 1, 0, 0, 0, 1, 1, 0], [1, 1, 0, 1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 0, 1, 1, 1, 0], [0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 1, 0, 1, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0]]\", \"(1, 2)\", \"(8, 8)\", \"3\"]"}
{"diff_sorted_id": "9", "problem_statement": "Given 5 labeled water jugs with capacities 129, 57, 45, 105, 128, 78 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 344, 376, 386 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 128, 3], [\"+\", 129, 3], [\"+\", 129, 3], [\"+\", 105, 2], [\"+\", 105, 2], [\"+\", 128, 2], [\"-\", 45, 2], [\"-\", 45, 2], [\"+\", 128, 2], [\"+\", 78, 1], [\"+\", 105, 1], [\"+\", 128, 1], [\"-\", 45, 1], [\"+\", 78, 1]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.05803990364074707", "solution_depth": "14", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[129, 57, 45, 105, 128, 78], [344, 376, 386]]", "is_correct_args": "[[129, 57, 45, 105, 128, 78], [344, 376, 386]]", "A*_args": "[\"[129, 57, 45, 105, 128, 78]\", \"[344, 376, 386]\"]"}
{"diff_sorted_id": "10", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[93, 88, 60], [28, 18, 24], ['_', 47, 53]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[47, 53, 24, 18, 28, 47, 53, 24, 18, 28, 47, 53, 24, 18]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.022923946380615234", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[93, 88, 60], [28, 18, 24], [\"_\", 47, 53]]]", "is_correct_args": "[[[93, 88, 60], [28, 18, 24], [\"_\", 47, 53]]]", "A*_args": "[\"[[93, 88, 60], [28, 18, 24], ['_', 47, 53]]\"]"}
{"diff_sorted_id": "10", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: kex, turd, wabi, test   The initial board: [['u', 'k', 'd', 'x'], ['t', 'e', 'r', 'b'], ['w', 'a', '_', 'i'], ['t', 'e', 's', 't']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "4", "opt_solution_compute_t": "0.1708054542541504", "solution_depth": "4", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"u\", \"k\", \"d\", \"x\"], [\"t\", \"e\", \"r\", \"b\"], [\"w\", \"a\", \"_\", \"i\"], [\"t\", \"e\", \"s\", \"t\"]]]", "is_correct_args": "[[[\"u\", \"k\", \"d\", \"x\"], [\"t\", \"e\", \"r\", \"b\"], [\"w\", \"a\", \"_\", \"i\"], [\"t\", \"e\", \"s\", \"t\"]], [\"kex\", \"turd\", \"wabi\", \"test\"]]", "A*_args": "[\"[['u', 'k', 'd', 'x'], ['t', 'e', 'r', 'b'], ['w', 'a', '_', 'i'], ['t', 'e', 's', 't']]\", \"['kex', 'turd', 'wabi', 'test']\"]"}
{"diff_sorted_id": "10", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'Q'. Our task is to visit city P and city E excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from E and P, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  Q O P T W E X M D V \nQ 0 0 0 0 0 0 0 1 0 0 \nO 0 0 0 0 0 1 0 0 0 0 \nP 0 0 0 1 1 0 0 1 1 1 \nT 0 0 0 0 1 0 0 1 0 0 \nW 0 1 0 0 0 1 0 0 0 1 \nE 0 0 0 0 0 0 1 0 0 0 \nX 0 0 1 0 0 0 0 0 0 1 \nM 0 1 0 0 0 0 1 0 0 1 \nD 0 1 0 1 0 0 1 1 0 1 \nV 1 1 1 0 0 1 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[\"Q\", \"M\", \"O\", \"E\", \"X\", \"P\", \"V\", \"P\", \"W\", \"E\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.03560161590576172", "solution_depth": "10", "max_successor_states": "10", "num_vars_per_state": "13", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 1, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 1, 0, 0, 1, 1, 0, 1], [1, 1, 1, 0, 0, 1, 0, 0, 0, 0]], [\"Q\", \"O\", \"P\", \"T\", \"W\", \"E\", \"X\", \"M\", \"D\", \"V\"], \"P\", \"E\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 1, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 1, 0, 0, 1, 1, 0, 1], [1, 1, 1, 0, 0, 1, 0, 0, 0, 0]], [\"Q\", \"O\", \"P\", \"T\", \"W\", \"E\", \"X\", \"M\", \"D\", \"V\"], \"Q\", \"P\", \"E\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 1, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 1, 0, 0, 1, 1, 0, 1], [1, 1, 1, 0, 0, 1, 0, 0, 0, 0]]\", \"['Q', 'O', 'P', 'T', 'W', 'E', 'X', 'M', 'D', 'V']\", \"['Q']\", \"['P', 'E']\"]"}
{"diff_sorted_id": "10", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [6, 20, 15, 14, 23, 6, 8, 15, 11, 2, 16, 21, 17, 10, 23, 20, 21, 16, 13, 3, 7, 4, 9, 21, 7, 13, 10, 18, 11, 9, 13, 12, 15, 17, 2, 8, 18, 3, 16, 9, 3, 14, 23, 16], such that the sum of the chosen coins adds up to 236. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {21: 11, 18: 16, 16: 6, 12: 5, 14: 11, 11: 8, 15: 11, 4: 3, 9: 2, 23: 14, 7: 5, 20: 12, 6: 2, 8: 3, 17: 6, 13: 3, 3: 3, 2: 1, 10: 5}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "24", "opt_solution": "[9, 9, 13, 13, 8, 6, 13, 8, 9, 17, 16, 17, 16, 6, 21, 16, 21, 16, 2]", "opt_solution_cost": "84", "opt_solution_compute_t": "0.0525660514831543", "solution_depth": "19", "max_successor_states": "44", "num_vars_per_state": "44", "is_feasible_args": "[[6, 20, 15, 14, 23, 6, 8, 15, 11, 2, 16, 21, 17, 10, 23, 20, 21, 16, 13, 3, 7, 4, 9, 21, 7, 13, 10, 18, 11, 9, 13, 12, 15, 17, 2, 8, 18, 3, 16, 9, 3, 14, 23, 16]]", "is_correct_args": "[[6, 20, 15, 14, 23, 6, 8, 15, 11, 2, 16, 21, 17, 10, 23, 20, 21, 16, 13, 3, 7, 4, 9, 21, 7, 13, 10, 18, 11, 9, 13, 12, 15, 17, 2, 8, 18, 3, 16, 9, 3, 14, 23, 16], {\"21\": 11, \"18\": 16, \"16\": 6, \"12\": 5, \"14\": 11, \"11\": 8, \"15\": 11, \"4\": 3, \"9\": 2, \"23\": 14, \"7\": 5, \"20\": 12, \"6\": 2, \"8\": 3, \"17\": 6, \"13\": 3, \"3\": 3, \"2\": 1, \"10\": 5}, 236]", "A*_args": "[\"[6, 20, 15, 14, 23, 6, 8, 15, 11, 2, 16, 21, 17, 10, 23, 20, 21, 16, 13, 3, 7, 4, 9, 21, 7, 13, 10, 18, 11, 9, 13, 12, 15, 17, 2, 8, 18, 3, 16, 9, 3, 14, 23, 16]\", \"{21: 11, 18: 16, 16: 6, 12: 5, 14: 11, 11: 8, 15: 11, 4: 3, 9: 2, 23: 14, 7: 5, 20: 12, 6: 2, 8: 3, 17: 6, 13: 3, 3: 3, 2: 1, 10: 5}\", \"236\"]"}
{"diff_sorted_id": "10", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Green', 'Red'], ['Red', 'Red', 'Green', 'Blue'], ['Green', 'Blue', 'Blue', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[0, 1], [0, 2], [0, 2], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [1, 2], [1, 0], [1, 2], [1, 2], [1, 2], [0, 1], [0, 1], [0, 1], [2, 0]]", "opt_solution_cost": "18", "opt_solution_compute_t": "1.260277509689331", "solution_depth": "18", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Green\", \"Red\"], [\"Red\", \"Red\", \"Green\", \"Blue\"], [\"Green\", \"Blue\", \"Blue\", \"Red\"]], 6]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Green\", \"Red\"], [\"Red\", \"Red\", \"Green\", \"Blue\"], [\"Green\", \"Blue\", \"Blue\", \"Red\"]], 6]", "A*_args": "[\"[['Blue', 'Green', 'Green', 'Red'], ['Red', 'Red', 'Green', 'Blue'], ['Green', 'Blue', 'Blue', 'Red']]\", \"6\"]"}
{"diff_sorted_id": "10", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 41 to 79 (41 included in the range but 79 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '59' 'x']\n ['47' 'x' '62']\n ['x' '50' '63']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 41], [0, 2, 60], [1, 1, 51], [2, 0, 48]]", "opt_solution_cost": "500", "opt_solution_compute_t": "0.1792917251586914", "solution_depth": "4", "max_successor_states": "38", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '59', ''], ['47', '', '62'], ['', '50', '63']]\", 41, 79]", "is_correct_args": "[\"[['', '59', ''], ['47', '', '62'], ['', '50', '63']]\", 41, 79]", "A*_args": "[\"[['', '59', ''], ['47', '', '62'], ['', '50', '63']]\", \"41\", \"79\"]"}
{"diff_sorted_id": "10", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 35 to 59. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 154, and sum of row 1 must be 151. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 133. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x']\n ['x' 'x' 'x']\n ['x' 'x' '57']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 0, 35], [0, 1, 40], [0, 2, 36], [1, 0, 38], [1, 1, 58], [1, 2, 55], [2, 0, 39], [2, 1, 56]]", "opt_solution_cost": "414", "opt_solution_compute_t": "232.39282536506653", "solution_depth": "8", "max_successor_states": "24", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '', ''], ['', '', '57']]\", 3, 35, 59]", "is_correct_args": "[\"[['', '', ''], ['', '', ''], ['', '', '57']]\", 35, 59, [1, 2], [1, 2], [154], [151], 133]", "A*_args": "[\"[['', '', ''], ['', '', ''], ['', '', '57']]\", \"35\", \"59\", \"[None, 154, None]\", \"[None, 151, None]\", \"133\"]"}
{"diff_sorted_id": "10", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 1, 1: 7, 2: 2, 3: 4, 4: 6, 5: 5}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], ['Green', 'Blue', 'Blue', 'Blue'], ['Yellow', 'Red', 'Yellow', 'Red'], ['Green', 'Red', 'Green', 'Yellow'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[3, 0], [3, 1], [2, 5], [4, 5], [3, 0], [4, 3], [4, 5], [1, 3], [4, 0]]", "opt_solution_cost": "33", "opt_solution_compute_t": "0.05746722221374512", "solution_depth": "9", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[], [], [\"Green\", \"Blue\", \"Blue\", \"Blue\"], [\"Yellow\", \"Red\", \"Yellow\", \"Red\"], [\"Green\", \"Red\", \"Green\", \"Yellow\"], []], 4, {\"0\": 1, \"1\": 7, \"2\": 2, \"3\": 4, \"4\": 6, \"5\": 5}]", "is_correct_args": "[[[], [], [\"Green\", \"Blue\", \"Blue\", \"Blue\"], [\"Yellow\", \"Red\", \"Yellow\", \"Red\"], [\"Green\", \"Red\", \"Green\", \"Yellow\"], []], 4, {\"0\": 1, \"1\": 7, \"2\": 2, \"3\": 4, \"4\": 6, \"5\": 5}, 3]", "A*_args": "[\"[[], [], ['Green', 'Blue', 'Blue', 'Blue'], ['Yellow', 'Red', 'Yellow', 'Red'], ['Green', 'Red', 'Green', 'Yellow'], []]\", \"{0: 1, 1: 7, 2: 2, 3: 4, 4: 6, 5: 5}\", \"4\", \"3\"]"}
{"diff_sorted_id": "10", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 0) to his destination workshop at index (6, 6), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 6, and district 3 covering rows 7 to 8. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x 6 x 7 x 9 4 11]\n[x 3 x 6 5 3 15 x 3]\n[x x x 4 x 9 1 8 x]\n[15 18 1 6 5 10 6 14 8]\n[18 10 7 18 2 x x x 7]\n[11 9 16 x 11 x 11 x 17]\n[7 x 18 x 8 10 20 6 x]\n[15 4 17 x 16 2 12 16 x]\n[9 10 18 17 9 6 7 x 15]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "1", "opt_solution": "[[3, 0], [3, 1], [3, 2], [3, 3], [3, 4], [4, 4], [5, 4], [6, 4], [6, 5], [7, 5], [6, 5], [6, 6]]", "opt_solution_cost": "93", "opt_solution_compute_t": "0.021834135055541992", "solution_depth": "12", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"6\", \"x\", \"7\", \"x\", \"9\", \"4\", \"11\"], [\"x\", \"3\", \"x\", \"6\", \"5\", \"3\", \"15\", \"x\", \"3\"], [\"x\", \"x\", \"x\", \"4\", \"x\", \"9\", \"1\", \"8\", \"x\"], [\"15\", \"18\", \"1\", \"6\", \"5\", \"10\", \"6\", \"14\", \"8\"], [\"18\", \"10\", \"7\", \"18\", \"2\", \"x\", \"x\", \"x\", \"7\"], [\"11\", \"9\", \"16\", \"x\", \"11\", \"x\", \"11\", \"x\", \"17\"], [\"7\", \"x\", \"18\", \"x\", \"8\", \"10\", \"20\", \"6\", \"x\"], [\"15\", \"4\", \"17\", \"x\", \"16\", \"2\", \"12\", \"16\", \"x\"], [\"9\", \"10\", \"18\", \"17\", \"9\", \"6\", \"7\", \"x\", \"15\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"6\", \"x\", \"7\", \"x\", \"9\", \"4\", \"11\"], [\"x\", \"3\", \"x\", \"6\", \"5\", \"3\", \"15\", \"x\", \"3\"], [\"x\", \"x\", \"x\", \"4\", \"x\", \"9\", \"1\", \"8\", \"x\"], [\"15\", \"18\", \"1\", \"6\", \"5\", \"10\", \"6\", \"14\", \"8\"], [\"18\", \"10\", \"7\", \"18\", \"2\", \"x\", \"x\", \"x\", \"7\"], [\"11\", \"9\", \"16\", \"x\", \"11\", \"x\", \"11\", \"x\", \"17\"], [\"7\", \"x\", \"18\", \"x\", \"8\", \"10\", \"20\", \"6\", \"x\"], [\"15\", \"4\", \"17\", \"x\", \"16\", \"2\", \"12\", \"16\", \"x\"], [\"9\", \"10\", \"18\", \"17\", \"9\", \"6\", \"7\", \"x\", \"15\"]], [3, 0], [6, 6], 3, 6]", "A*_args": "[\"[['x', 'x', '6', 'x', '7', 'x', '9', '4', '11'], ['x', '3', 'x', '6', '5', '3', '15', 'x', '3'], ['x', 'x', 'x', '4', 'x', '9', '1', '8', 'x'], ['15', '18', '1', '6', '5', '10', '6', '14', '8'], ['18', '10', '7', '18', '2', 'x', 'x', 'x', '7'], ['11', '9', '16', 'x', '11', 'x', '11', 'x', '17'], ['7', 'x', '18', 'x', '8', '10', '20', '6', 'x'], ['15', '4', '17', 'x', '16', '2', '12', '16', 'x'], ['9', '10', '18', '17', '9', '6', '7', 'x', '15']]\", \"(3, 0)\", \"(6, 6)\", \"3\", \"6\"]"}
{"diff_sorted_id": "10", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 9x9. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (8, 8) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (2, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 0 1 0 1 1 1 0\n1 0 1 0 0 0 1 0 0\n0 0 0 1 1 1 0 1 1\n1 0 0 0 0 1 1 0 1\n0 0 0 0 1 0 0 1 0\n1 0 0 0 1 1 1 0 1\n0 1 0 0 1 0 1 1 0\n0 1 0 0 1 0 0 0 1\n1 1 0 0 0 0 0 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "9", "opt_solution": "[[8, 8], [7, 7], [7, 6], [7, 5], [8, 4], [7, 3], [6, 3], [5, 3], [4, 3], [3, 3], [3, 2], [2, 2], [2, 1]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.029077768325805664", "solution_depth": "13", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 1, 0, 1, 1], [1, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 1, 1, 1, 0, 1], [0, 1, 0, 0, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 1, 0]]\", 3]", "is_correct_args": "[\"[[0, 1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 1, 0, 1, 1], [1, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 1, 1, 1, 0, 1], [0, 1, 0, 0, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 1, 0]]\", [8, 8], [2, 1], 3]", "A*_args": "[\"[[0, 1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 1, 0, 1, 1], [1, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 1, 1, 1, 0, 1], [0, 1, 0, 0, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 1, 0]]\", \"(8, 8)\", \"(2, 1)\", \"3\"]"}
{"diff_sorted_id": "10", "problem_statement": "Given 5 labeled water jugs with capacities 14, 119, 62, 18, 133, 13 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 218, 272, 314 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 119, 3], [\"+\", 119, 3], [\"+\", 62, 3], [\"+\", 14, 3], [\"+\", 133, 2], [\"+\", 133, 2], [\"-\", 13, 2], [\"+\", 14, 2], [\"-\", 13, 2], [\"+\", 18, 2], [\"+\", 14, 1], [\"+\", 133, 1], [\"-\", 62, 1], [\"+\", 133, 1]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.029827594757080078", "solution_depth": "14", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[14, 119, 62, 18, 133, 13], [218, 272, 314]]", "is_correct_args": "[[14, 119, 62, 18, 133, 13], [218, 272, 314]]", "A*_args": "[\"[14, 119, 62, 18, 133, 13]\", \"[218, 272, 314]\"]"}
{"diff_sorted_id": "11", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[59, 76, 55], [54, '_', 85], [50, 95, 53]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[54, 50, 95, 53, 85, 54, 53, 95, 50, 53, 95, 85, 54, 55, 76, 95, 85, 50, 53, 59, 95, 85, 55, 54]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.10947823524475098", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[59, 76, 55], [54, \"_\", 85], [50, 95, 53]]]", "is_correct_args": "[[[59, 76, 55], [54, \"_\", 85], [50, 95, 53]]]", "A*_args": "[\"[[59, 76, 55], [54, '_', 85], [50, 95, 53]]\"]"}
{"diff_sorted_id": "11", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: bud, codo, waup, yelp   The initial board: [['o', 'b', 'e', 'd'], ['c', 'o', 'd', 'u'], ['w', 'a', '_', 'p'], ['y', 'u', 'l', 'p']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.2195606231689453", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"o\", \"b\", \"e\", \"d\"], [\"c\", \"o\", \"d\", \"u\"], [\"w\", \"a\", \"_\", \"p\"], [\"y\", \"u\", \"l\", \"p\"]]]", "is_correct_args": "[[[\"o\", \"b\", \"e\", \"d\"], [\"c\", \"o\", \"d\", \"u\"], [\"w\", \"a\", \"_\", \"p\"], [\"y\", \"u\", \"l\", \"p\"]], [\"bud\", \"codo\", \"waup\", \"yelp\"]]", "A*_args": "[\"[['o', 'b', 'e', 'd'], ['c', 'o', 'd', 'u'], ['w', 'a', '_', 'p'], ['y', 'u', 'l', 'p']]\", \"['bud', 'codo', 'waup', 'yelp']\"]"}
{"diff_sorted_id": "11", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'Q'. Our task is to visit city T and city E excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from E and T, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  Q T A X M Y Z B S E \nQ 0 0 0 0 0 0 1 0 0 0 \nT 1 0 1 1 0 0 0 0 0 0 \nA 0 0 0 0 1 0 0 0 0 0 \nX 0 0 0 0 1 0 1 1 1 0 \nM 1 0 0 0 0 0 0 1 0 1 \nY 0 1 1 1 0 0 0 0 0 0 \nZ 0 0 0 0 1 1 0 1 0 0 \nB 1 1 1 0 0 0 0 0 0 0 \nS 0 1 0 0 0 1 0 0 0 1 \nE 0 0 1 1 1 0 0 1 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[\"Q\", \"Z\", \"Y\", \"T\", \"A\", \"M\", \"E\", \"S\", \"E\", \"B\", \"T\"]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.028751611709594727", "solution_depth": "11", "max_successor_states": "10", "num_vars_per_state": "13", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 1, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 0, 0, 1, 1, 0]], [\"Q\", \"T\", \"A\", \"X\", \"M\", \"Y\", \"Z\", \"B\", \"S\", \"E\"], \"T\", \"E\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 1, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 0, 0, 1, 1, 0]], [\"Q\", \"T\", \"A\", \"X\", \"M\", \"Y\", \"Z\", \"B\", \"S\", \"E\"], \"Q\", \"T\", \"E\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 1, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 0, 0, 1, 1, 0]]\", \"['Q', 'T', 'A', 'X', 'M', 'Y', 'Z', 'B', 'S', 'E']\", \"['Q']\", \"['T', 'E']\"]"}
{"diff_sorted_id": "11", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [21, 20, 21, 11, 23, 16, 16, 16, 3, 20, 2, 19, 16, 21, 18, 7, 20, 3, 16, 18, 7, 22, 3, 22, 7, 21, 12, 22, 5, 6, 17, 16, 8, 8, 14, 4, 18, 9, 4, 20, 2], such that the sum of the chosen coins adds up to 228. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {6: 1, 7: 3, 9: 1, 18: 1, 2: 1, 11: 7, 5: 3, 12: 2, 3: 3, 22: 6, 14: 3, 20: 15, 4: 3, 17: 4, 16: 8, 23: 18, 21: 16, 19: 2, 8: 6}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "25", "opt_solution": "[18, 6, 9, 19, 18, 14, 12, 2, 7, 7, 17, 23, 22, 18, 16, 2, 7, 11]", "opt_solution_cost": "66", "opt_solution_compute_t": "0.04258108139038086", "solution_depth": "18", "max_successor_states": "41", "num_vars_per_state": "41", "is_feasible_args": "[[21, 20, 21, 11, 23, 16, 16, 16, 3, 20, 2, 19, 16, 21, 18, 7, 20, 3, 16, 18, 7, 22, 3, 22, 7, 21, 12, 22, 5, 6, 17, 16, 8, 8, 14, 4, 18, 9, 4, 20, 2]]", "is_correct_args": "[[21, 20, 21, 11, 23, 16, 16, 16, 3, 20, 2, 19, 16, 21, 18, 7, 20, 3, 16, 18, 7, 22, 3, 22, 7, 21, 12, 22, 5, 6, 17, 16, 8, 8, 14, 4, 18, 9, 4, 20, 2], {\"6\": 1, \"7\": 3, \"9\": 1, \"18\": 1, \"2\": 1, \"11\": 7, \"5\": 3, \"12\": 2, \"3\": 3, \"22\": 6, \"14\": 3, \"20\": 15, \"4\": 3, \"17\": 4, \"16\": 8, \"23\": 18, \"21\": 16, \"19\": 2, \"8\": 6}, 228]", "A*_args": "[\"[21, 20, 21, 11, 23, 16, 16, 16, 3, 20, 2, 19, 16, 21, 18, 7, 20, 3, 16, 18, 7, 22, 3, 22, 7, 21, 12, 22, 5, 6, 17, 16, 8, 8, 14, 4, 18, 9, 4, 20, 2]\", \"{6: 1, 7: 3, 9: 1, 18: 1, 2: 1, 11: 7, 5: 3, 12: 2, 3: 3, 22: 6, 14: 3, 20: 15, 4: 3, 17: 4, 16: 8, 23: 18, 21: 16, 19: 2, 8: 6}\", \"228\"]"}
{"diff_sorted_id": "11", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Red', 'Red', 'Green'], ['Blue', 'Red', 'Green', 'Blue'], ['Green', 'Blue', 'Blue', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[0, 2], [0, 1], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [1, 2], [1, 2], [1, 0], [1, 2], [1, 2], [0, 1], [0, 1], [0, 1], [2, 0]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.6104025840759277", "solution_depth": "16", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Red\", \"Red\", \"Green\"], [\"Blue\", \"Red\", \"Green\", \"Blue\"], [\"Green\", \"Blue\", \"Blue\", \"Red\"]], 6]", "is_correct_args": "[[[\"Green\", \"Red\", \"Red\", \"Green\"], [\"Blue\", \"Red\", \"Green\", \"Blue\"], [\"Green\", \"Blue\", \"Blue\", \"Red\"]], 6]", "A*_args": "[\"[['Green', 'Red', 'Red', 'Green'], ['Blue', 'Red', 'Green', 'Blue'], ['Green', 'Blue', 'Blue', 'Red']]\", \"6\"]"}
{"diff_sorted_id": "11", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 33 to 71 (33 included in the range but 71 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' '55']\n ['50' 'x' '56']\n ['40' '43' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 51], [0, 1, 53], [1, 1, 52], [2, 2, 57]]", "opt_solution_cost": "487", "opt_solution_compute_t": "0.27827906608581543", "solution_depth": "4", "max_successor_states": "38", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', '55'], ['50', '', '56'], ['40', '43', '']]\", 33, 71]", "is_correct_args": "[\"[['', '', '55'], ['50', '', '56'], ['40', '43', '']]\", 33, 71]", "A*_args": "[\"[['', '', '55'], ['50', '', '56'], ['40', '43', '']]\", \"33\", \"71\"]"}
{"diff_sorted_id": "11", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 35 to 59. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 127, and sum of row 1 must be 144. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 141. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' '48']\n ['x' 'x' 'x']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 0, 35], [0, 1, 36], [1, 0, 40], [1, 1, 54], [1, 2, 50], [2, 0, 39], [2, 1, 37], [2, 2, 38]]", "opt_solution_cost": "377", "opt_solution_compute_t": "1.0946576595306396", "solution_depth": "8", "max_successor_states": "24", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', '48'], ['', '', ''], ['', '', '']]\", 3, 35, 59]", "is_correct_args": "[\"[['', '', '48'], ['', '', ''], ['', '', '']]\", 35, 59, [1, 2], [1, 2], [127], [144], 141]", "A*_args": "[\"[['', '', '48'], ['', '', ''], ['', '', '']]\", \"35\", \"59\", \"[None, 127, None]\", \"[None, 144, None]\", \"141\"]"}
{"diff_sorted_id": "11", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 3, 1: 5, 2: 1, 3: 6, 4: 7, 5: 4}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Blue', 'Blue', 'Green', 'Red'], [], ['Green', 'Red', 'Yellow', 'Yellow'], [], ['Green', 'Red', 'Blue', 'Yellow']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[1, 0], [1, 0], [1, 2], [3, 2], [3, 1], [5, 2], [5, 1], [5, 0], [3, 5], [3, 5]]", "opt_solution_cost": "30", "opt_solution_compute_t": "0.07445669174194336", "solution_depth": "10", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[], [\"Blue\", \"Blue\", \"Green\", \"Red\"], [], [\"Green\", \"Red\", \"Yellow\", \"Yellow\"], [], [\"Green\", \"Red\", \"Blue\", \"Yellow\"]], 4, {\"0\": 3, \"1\": 5, \"2\": 1, \"3\": 6, \"4\": 7, \"5\": 4}]", "is_correct_args": "[[[], [\"Blue\", \"Blue\", \"Green\", \"Red\"], [], [\"Green\", \"Red\", \"Yellow\", \"Yellow\"], [], [\"Green\", \"Red\", \"Blue\", \"Yellow\"]], 4, {\"0\": 3, \"1\": 5, \"2\": 1, \"3\": 6, \"4\": 7, \"5\": 4}, 3]", "A*_args": "[\"[[], ['Blue', 'Blue', 'Green', 'Red'], [], ['Green', 'Red', 'Yellow', 'Yellow'], [], ['Green', 'Red', 'Blue', 'Yellow']]\", \"{0: 3, 1: 5, 2: 1, 3: 6, 4: 7, 5: 4}\", \"4\", \"3\"]"}
{"diff_sorted_id": "11", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 0) to his destination workshop at index (4, 8), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 4, and district 3 covering rows 5 to 8. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 15 x 18 8 6 11 x 7]\n[9 10 18 9 2 16 9 8 x]\n[14 x x 10 18 x 13 12 14]\n[11 18 4 11 14 2 20 x 15]\n[12 x x 8 10 x x 10 11]\n[5 19 20 15 11 x 14 x 18]\n[x 5 x x x x x 9 x]\n[x x 18 x x 4 x 17 13]\n[x 7 17 x x x x 7 19]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "1", "opt_solution": "[[3, 0], [3, 1], [3, 2], [3, 3], [3, 4], [3, 5], [3, 6], [2, 6], [2, 7], [2, 8], [3, 8], [4, 8], [5, 8], [4, 8]]", "opt_solution_cost": "163", "opt_solution_compute_t": "0.0204925537109375", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"15\", \"x\", \"18\", \"8\", \"6\", \"11\", \"x\", \"7\"], [\"9\", \"10\", \"18\", \"9\", \"2\", \"16\", \"9\", \"8\", \"x\"], [\"14\", \"x\", \"x\", \"10\", \"18\", \"x\", \"13\", \"12\", \"14\"], [\"11\", \"18\", \"4\", \"11\", \"14\", \"2\", \"20\", \"x\", \"15\"], [\"12\", \"x\", \"x\", \"8\", \"10\", \"x\", \"x\", \"10\", \"11\"], [\"5\", \"19\", \"20\", \"15\", \"11\", \"x\", \"14\", \"x\", \"18\"], [\"x\", \"5\", \"x\", \"x\", \"x\", \"x\", \"x\", \"9\", \"x\"], [\"x\", \"x\", \"18\", \"x\", \"x\", \"4\", \"x\", \"17\", \"13\"], [\"x\", \"7\", \"17\", \"x\", \"x\", \"x\", \"x\", \"7\", \"19\"]]]", "is_correct_args": "[[[\"x\", \"15\", \"x\", \"18\", \"8\", \"6\", \"11\", \"x\", \"7\"], [\"9\", \"10\", \"18\", \"9\", \"2\", \"16\", \"9\", \"8\", \"x\"], [\"14\", \"x\", \"x\", \"10\", \"18\", \"x\", \"13\", \"12\", \"14\"], [\"11\", \"18\", \"4\", \"11\", \"14\", \"2\", \"20\", \"x\", \"15\"], [\"12\", \"x\", \"x\", \"8\", \"10\", \"x\", \"x\", \"10\", \"11\"], [\"5\", \"19\", \"20\", \"15\", \"11\", \"x\", \"14\", \"x\", \"18\"], [\"x\", \"5\", \"x\", \"x\", \"x\", \"x\", \"x\", \"9\", \"x\"], [\"x\", \"x\", \"18\", \"x\", \"x\", \"4\", \"x\", \"17\", \"13\"], [\"x\", \"7\", \"17\", \"x\", \"x\", \"x\", \"x\", \"7\", \"19\"]], [3, 0], [4, 8], 2, 4]", "A*_args": "[\"[['x', '15', 'x', '18', '8', '6', '11', 'x', '7'], ['9', '10', '18', '9', '2', '16', '9', '8', 'x'], ['14', 'x', 'x', '10', '18', 'x', '13', '12', '14'], ['11', '18', '4', '11', '14', '2', '20', 'x', '15'], ['12', 'x', 'x', '8', '10', 'x', 'x', '10', '11'], ['5', '19', '20', '15', '11', 'x', '14', 'x', '18'], ['x', '5', 'x', 'x', 'x', 'x', 'x', '9', 'x'], ['x', 'x', '18', 'x', 'x', '4', 'x', '17', '13'], ['x', '7', '17', 'x', 'x', 'x', 'x', '7', '19']]\", \"(3, 0)\", \"(4, 8)\", \"2\", \"4\"]"}
{"diff_sorted_id": "11", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 9x9. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (8, 7) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (0, 3). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 0 0 0 0 1 1\n0 1 1 0 0 0 0 0 0\n1 1 1 1 0 1 0 0 1\n0 0 0 1 0 0 0 0 0\n0 0 1 1 0 1 1 0 1\n1 1 1 1 1 0 0 0 0\n0 1 1 1 0 1 1 0 0\n1 1 1 0 0 0 0 0 0\n1 1 1 0 0 0 1 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "9", "opt_solution": "[[8, 7], [7, 7], [6, 7], [5, 6], [5, 5], [4, 4], [3, 4], [2, 4], [1, 3], [0, 3]]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.03075408935546875", "solution_depth": "10", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 0, 0, 0, 0, 1, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 1, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 1, 1, 0, 1], [1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1, 1, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 1, 0, 0]]\", 3]", "is_correct_args": "[\"[[1, 1, 1, 0, 0, 0, 0, 1, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 1, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 1, 1, 0, 1], [1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1, 1, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 1, 0, 0]]\", [8, 7], [0, 3], 3]", "A*_args": "[\"[[1, 1, 1, 0, 0, 0, 0, 1, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 1, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 1, 1, 0, 1], [1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1, 1, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 1, 0, 0]]\", \"(8, 7)\", \"(0, 3)\", \"3\"]"}
{"diff_sorted_id": "11", "problem_statement": "Given 5 labeled water jugs with capacities 140, 58, 129, 130, 125 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 391, 401, 431 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 140, 3], [\"+\", 140, 3], [\"+\", 140, 3], [\"-\", 129, 3], [\"+\", 140, 3], [\"+\", 125, 2], [\"+\", 125, 2], [\"+\", 140, 2], [\"-\", 129, 2], [\"+\", 140, 2], [\"+\", 125, 1], [\"+\", 125, 1], [\"+\", 130, 1], [\"-\", 129, 1], [\"+\", 140, 1]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.04181361198425293", "solution_depth": "15", "max_successor_states": "30", "num_vars_per_state": "3", "is_feasible_args": "[[140, 58, 129, 130, 125], [391, 401, 431]]", "is_correct_args": "[[140, 58, 129, 130, 125], [391, 401, 431]]", "A*_args": "[\"[140, 58, 129, 130, 125]\", \"[391, 401, 431]\"]"}
{"diff_sorted_id": "12", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[66, 35, 51], [76, '_', 73], [90, 54, 22]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[35, 51, 73, 22, 54, 35, 51, 66, 76, 90, 35, 54, 22, 51, 66, 76, 90, 66, 54, 22]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.061293601989746094", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[66, 35, 51], [76, \"_\", 73], [90, 54, 22]]]", "is_correct_args": "[[[66, 35, 51], [76, \"_\", 73], [90, 54, 22]]]", "A*_args": "[\"[[66, 35, 51], [76, '_', 73], [90, 54, 22]]\"]"}
{"diff_sorted_id": "12", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: hat, skag, alit, mand   The initial board: [['k', 'h', 'a', 't'], ['s', 'a', 'a', 'a'], ['i', 'l', '_', 't'], ['m', 'g', 'n', 'd']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.185685396194458", "solution_depth": "10", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"k\", \"h\", \"a\", \"t\"], [\"s\", \"a\", \"a\", \"a\"], [\"i\", \"l\", \"_\", \"t\"], [\"m\", \"g\", \"n\", \"d\"]]]", "is_correct_args": "[[[\"k\", \"h\", \"a\", \"t\"], [\"s\", \"a\", \"a\", \"a\"], [\"i\", \"l\", \"_\", \"t\"], [\"m\", \"g\", \"n\", \"d\"]], [\"hat\", \"skag\", \"alit\", \"mand\"]]", "A*_args": "[\"[['k', 'h', 'a', 't'], ['s', 'a', 'a', 'a'], ['i', 'l', '_', 't'], ['m', 'g', 'n', 'd']]\", \"['hat', 'skag', 'alit', 'mand']\"]"}
{"diff_sorted_id": "12", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'B'. Our task is to visit city V and city L excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from L and V, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  S T R A L B V I P N \nS 0 1 0 0 0 1 0 0 1 0 \nT 0 0 0 0 0 0 1 0 0 0 \nR 1 1 0 0 0 0 0 0 1 1 \nA 1 0 1 0 0 0 1 0 0 1 \nL 0 0 0 1 0 0 1 1 0 1 \nB 1 0 0 0 0 0 0 1 0 0 \nV 1 1 1 1 0 1 0 0 1 1 \nI 0 0 0 0 1 0 0 0 0 0 \nP 0 0 0 0 0 0 0 1 0 0 \nN 0 0 0 0 1 1 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[\"B\", \"I\", \"L\", \"V\", \"N\", \"L\", \"V\"]", "opt_solution_cost": "7", "opt_solution_compute_t": "0.027237892150878906", "solution_depth": "7", "max_successor_states": "10", "num_vars_per_state": "13", "is_feasible_args": "[[[0, 1, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 1, 1, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]], [\"S\", \"T\", \"R\", \"A\", \"L\", \"B\", \"V\", \"I\", \"P\", \"N\"], \"V\", \"L\"]", "is_correct_args": "[[[0, 1, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 1, 1, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]], [\"S\", \"T\", \"R\", \"A\", \"L\", \"B\", \"V\", \"I\", \"P\", \"N\"], \"B\", \"V\", \"L\"]", "A*_args": "[\"[[0, 1, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 1, 1, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]]\", \"['S', 'T', 'R', 'A', 'L', 'B', 'V', 'I', 'P', 'N']\", \"['B']\", \"['V', 'L']\"]"}
{"diff_sorted_id": "12", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [9, 2, 23, 20, 13, 4, 15, 16, 12, 21, 13, 9, 2, 14, 13, 14, 4, 19, 12, 6, 21, 23, 4, 18, 2, 23, 23, 6, 18, 23, 3, 16, 7, 2, 22, 16, 8, 10, 23, 17, 3, 18, 8], such that the sum of the chosen coins adds up to 230. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {9: 1, 17: 6, 2: 2, 22: 9, 13: 13, 16: 8, 12: 4, 4: 1, 21: 14, 14: 10, 19: 9, 10: 7, 7: 6, 8: 7, 6: 2, 23: 16, 18: 3, 20: 2, 3: 1, 15: 2}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "26", "opt_solution": "[20, 18, 4, 9, 4, 15, 12, 6, 19, 18, 12, 6, 4, 9, 17, 23, 18, 16]", "opt_solution_cost": "69", "opt_solution_compute_t": "0.04821968078613281", "solution_depth": "18", "max_successor_states": "43", "num_vars_per_state": "43", "is_feasible_args": "[[9, 2, 23, 20, 13, 4, 15, 16, 12, 21, 13, 9, 2, 14, 13, 14, 4, 19, 12, 6, 21, 23, 4, 18, 2, 23, 23, 6, 18, 23, 3, 16, 7, 2, 22, 16, 8, 10, 23, 17, 3, 18, 8]]", "is_correct_args": "[[9, 2, 23, 20, 13, 4, 15, 16, 12, 21, 13, 9, 2, 14, 13, 14, 4, 19, 12, 6, 21, 23, 4, 18, 2, 23, 23, 6, 18, 23, 3, 16, 7, 2, 22, 16, 8, 10, 23, 17, 3, 18, 8], {\"9\": 1, \"17\": 6, \"2\": 2, \"22\": 9, \"13\": 13, \"16\": 8, \"12\": 4, \"4\": 1, \"21\": 14, \"14\": 10, \"19\": 9, \"10\": 7, \"7\": 6, \"8\": 7, \"6\": 2, \"23\": 16, \"18\": 3, \"20\": 2, \"3\": 1, \"15\": 2}, 230]", "A*_args": "[\"[9, 2, 23, 20, 13, 4, 15, 16, 12, 21, 13, 9, 2, 14, 13, 14, 4, 19, 12, 6, 21, 23, 4, 18, 2, 23, 23, 6, 18, 23, 3, 16, 7, 2, 22, 16, 8, 10, 23, 17, 3, 18, 8]\", \"{9: 1, 17: 6, 2: 2, 22: 9, 13: 13, 16: 8, 12: 4, 4: 1, 21: 14, 14: 10, 19: 9, 10: 7, 7: 6, 8: 7, 6: 2, 23: 16, 18: 3, 20: 2, 3: 1, 15: 2}\", \"230\"]"}
{"diff_sorted_id": "12", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Blue', 'Red', 'Blue'], ['Red', 'Green', 'Green', 'Green'], ['Red', 'Red', 'Blue', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[0, 2], [0, 2], [0, 1], [2, 0], [2, 0], [2, 0], [2, 1], [2, 0], [2, 0], [1, 2], [1, 2], [1, 2], [0, 1], [0, 1], [0, 2], [1, 0]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.49949169158935547", "solution_depth": "16", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Blue\", \"Blue\", \"Red\", \"Blue\"], [\"Red\", \"Green\", \"Green\", \"Green\"], [\"Red\", \"Red\", \"Blue\", \"Green\"]], 6]", "is_correct_args": "[[[\"Blue\", \"Blue\", \"Red\", \"Blue\"], [\"Red\", \"Green\", \"Green\", \"Green\"], [\"Red\", \"Red\", \"Blue\", \"Green\"]], 6]", "A*_args": "[\"[['Blue', 'Blue', 'Red', 'Blue'], ['Red', 'Green', 'Green', 'Green'], ['Red', 'Red', 'Blue', 'Green']]\", \"6\"]"}
{"diff_sorted_id": "12", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 35 to 73 (35 included in the range but 73 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['57' 'x' 'x']\n ['x' '50' '63']\n ['x' '69' '71']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 1, 36], [0, 2, 35], [1, 0, 38], [2, 0, 37]]", "opt_solution_cost": "475", "opt_solution_compute_t": "0.1643369197845459", "solution_depth": "4", "max_successor_states": "38", "num_vars_per_state": "9", "is_feasible_args": "[\"[['57', '', ''], ['', '50', '63'], ['', '69', '71']]\", 35, 73]", "is_correct_args": "[\"[['57', '', ''], ['', '50', '63'], ['', '69', '71']]\", 35, 73]", "A*_args": "[\"[['57', '', ''], ['', '50', '63'], ['', '69', '71']]\", \"35\", \"73\"]"}
{"diff_sorted_id": "12", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 28 to 57. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 126, and sum of row 1 must be 124. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 136. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '46' 'x']\n ['39' 'x' 'x']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 0, 29], [0, 2, 31], [1, 1, 52], [1, 2, 33], [2, 0, 53], [2, 1, 28], [2, 2, 30]]", "opt_solution_cost": "341", "opt_solution_compute_t": "1.8470244407653809", "solution_depth": "7", "max_successor_states": "24", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '46', ''], ['39', '', ''], ['', '', '']]\", 3, 28, 57]", "is_correct_args": "[\"[['', '46', ''], ['39', '', ''], ['', '', '']]\", 28, 57, [1, 2], [1, 2], [126], [124], 136]", "A*_args": "[\"[['', '46', ''], ['39', '', ''], ['', '', '']]\", \"28\", \"57\", \"[None, 126, None]\", \"[None, 124, None]\", \"136\"]"}
{"diff_sorted_id": "12", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 2, 1: 2, 2: 3, 3: 7, 4: 1, 5: 7}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Green', 'Yellow', 'Yellow', 'Green'], ['Red', 'Red', 'Blue', 'Yellow'], [], [], ['Blue', 'Red', 'Blue', 'Green'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[1, 3], [1, 3], [4, 2], [4, 3], [1, 2], [4, 2], [0, 4], [0, 1], [0, 1], [0, 4]]", "opt_solution_cost": "36", "opt_solution_compute_t": "0.08908510208129883", "solution_depth": "10", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Yellow\", \"Yellow\", \"Green\"], [\"Red\", \"Red\", \"Blue\", \"Yellow\"], [], [], [\"Blue\", \"Red\", \"Blue\", \"Green\"], []], 4, {\"0\": 2, \"1\": 2, \"2\": 3, \"3\": 7, \"4\": 1, \"5\": 7}]", "is_correct_args": "[[[\"Green\", \"Yellow\", \"Yellow\", \"Green\"], [\"Red\", \"Red\", \"Blue\", \"Yellow\"], [], [], [\"Blue\", \"Red\", \"Blue\", \"Green\"], []], 4, {\"0\": 2, \"1\": 2, \"2\": 3, \"3\": 7, \"4\": 1, \"5\": 7}, 3]", "A*_args": "[\"[['Green', 'Yellow', 'Yellow', 'Green'], ['Red', 'Red', 'Blue', 'Yellow'], [], [], ['Blue', 'Red', 'Blue', 'Green'], []]\", \"{0: 2, 1: 2, 2: 3, 3: 7, 4: 1, 5: 7}\", \"4\", \"3\"]"}
{"diff_sorted_id": "12", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 1) to his destination workshop at index (5, 8), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 4, and district 3 covering rows 5 to 8. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[19 x 17 14 3 x 10 5 2]\n[x x 1 x x x 19 7 1]\n[16 12 x 3 19 2 14 1 14]\n[x 1 16 x 12 3 13 x 3]\n[x x 7 19 10 x 5 x 19]\n[5 x x 6 14 x x 10 12]\n[x x x x 18 x x 15 12]\n[x x 16 8 x 3 4 x x]\n[x x x 16 x x 8 14 7]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "1", "opt_solution": "[[3, 1], [3, 2], [4, 2], [4, 3], [4, 4], [3, 4], [3, 5], [2, 5], [2, 6], [2, 7], [2, 8], [3, 8], [4, 8], [5, 8]]", "opt_solution_cost": "132", "opt_solution_compute_t": "0.020636796951293945", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"19\", \"x\", \"17\", \"14\", \"3\", \"x\", \"10\", \"5\", \"2\"], [\"x\", \"x\", \"1\", \"x\", \"x\", \"x\", \"19\", \"7\", \"1\"], [\"16\", \"12\", \"x\", \"3\", \"19\", \"2\", \"14\", \"1\", \"14\"], [\"x\", \"1\", \"16\", \"x\", \"12\", \"3\", \"13\", \"x\", \"3\"], [\"x\", \"x\", \"7\", \"19\", \"10\", \"x\", \"5\", \"x\", \"19\"], [\"5\", \"x\", \"x\", \"6\", \"14\", \"x\", \"x\", \"10\", \"12\"], [\"x\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\", \"15\", \"12\"], [\"x\", \"x\", \"16\", \"8\", \"x\", \"3\", \"4\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"16\", \"x\", \"x\", \"8\", \"14\", \"7\"]]]", "is_correct_args": "[[[\"19\", \"x\", \"17\", \"14\", \"3\", \"x\", \"10\", \"5\", \"2\"], [\"x\", \"x\", \"1\", \"x\", \"x\", \"x\", \"19\", \"7\", \"1\"], [\"16\", \"12\", \"x\", \"3\", \"19\", \"2\", \"14\", \"1\", \"14\"], [\"x\", \"1\", \"16\", \"x\", \"12\", \"3\", \"13\", \"x\", \"3\"], [\"x\", \"x\", \"7\", \"19\", \"10\", \"x\", \"5\", \"x\", \"19\"], [\"5\", \"x\", \"x\", \"6\", \"14\", \"x\", \"x\", \"10\", \"12\"], [\"x\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\", \"15\", \"12\"], [\"x\", \"x\", \"16\", \"8\", \"x\", \"3\", \"4\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"16\", \"x\", \"x\", \"8\", \"14\", \"7\"]], [3, 1], [5, 8], 3, 4]", "A*_args": "[\"[['19', 'x', '17', '14', '3', 'x', '10', '5', '2'], ['x', 'x', '1', 'x', 'x', 'x', '19', '7', '1'], ['16', '12', 'x', '3', '19', '2', '14', '1', '14'], ['x', '1', '16', 'x', '12', '3', '13', 'x', '3'], ['x', 'x', '7', '19', '10', 'x', '5', 'x', '19'], ['5', 'x', 'x', '6', '14', 'x', 'x', '10', '12'], ['x', 'x', 'x', 'x', '18', 'x', 'x', '15', '12'], ['x', 'x', '16', '8', 'x', '3', '4', 'x', 'x'], ['x', 'x', 'x', '16', 'x', 'x', '8', '14', '7']]\", \"(3, 1)\", \"(5, 8)\", \"3\", \"4\"]"}
{"diff_sorted_id": "12", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 9x9. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (3, 7) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (8, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 1 0 0 0 0 1\n0 0 1 1 1 0 1 1 1\n1 1 1 0 1 0 1 1 1\n1 0 0 0 0 1 1 0 1\n1 0 0 0 1 1 0 0 1\n0 0 1 1 0 0 0 0 0\n0 0 0 0 1 0 0 1 0\n0 0 0 1 0 1 1 1 1\n0 0 0 0 0 0 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "9", "opt_solution": "[[3, 7], [4, 6], [5, 5], [5, 4], [6, 3], [6, 2], [6, 1], [7, 1], [7, 0], [8, 0]]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.029245376586914062", "solution_depth": "10", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 0, 1, 0, 1, 1, 1], [1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 1, 1, 0, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1]]\", 3]", "is_correct_args": "[\"[[1, 1, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 0, 1, 0, 1, 1, 1], [1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 1, 1, 0, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1]]\", [3, 7], [8, 0], 3]", "A*_args": "[\"[[1, 1, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 0, 1, 0, 1, 1, 1], [1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 1, 1, 0, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1]]\", \"(3, 7)\", \"(8, 0)\", \"3\"]"}
{"diff_sorted_id": "12", "problem_statement": "Given 5 labeled water jugs with capacities 46, 99, 145, 131, 78, 100 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 247, 340, 368 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 78, 3], [\"+\", 145, 3], [\"+\", 145, 3], [\"+\", 78, 2], [\"+\", 131, 2], [\"+\", 131, 2], [\"+\", 131, 1], [\"-\", 46, 1], [\"+\", 131, 1], [\"-\", 100, 1], [\"+\", 131, 1]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.027457475662231445", "solution_depth": "11", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[46, 99, 145, 131, 78, 100], [247, 340, 368]]", "is_correct_args": "[[46, 99, 145, 131, 78, 100], [247, 340, 368]]", "A*_args": "[\"[46, 99, 145, 131, 78, 100]\", \"[247, 340, 368]\"]"}
{"diff_sorted_id": "13", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[41, 36, 82], [29, 97, 43], ['_', 51, 61]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[29, 97, 36, 41, 97, 36, 51, 29, 36, 51, 43, 61, 29, 43, 41, 82, 61, 41, 43, 29]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.04056262969970703", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[41, 36, 82], [29, 97, 43], [\"_\", 51, 61]]]", "is_correct_args": "[[[41, 36, 82], [29, 97, 43], [\"_\", 51, 61]]]", "A*_args": "[\"[[41, 36, 82], [29, 97, 43], ['_', 51, 61]]\"]"}
{"diff_sorted_id": "13", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: lag, abas, numa, sham   The initial board: [['b', 'l', '_', 'g'], ['a', 'n', 'a', 's'], ['m', 'u', 'a', 'a'], ['s', 'h', 'a', 'm']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.17847561836242676", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"b\", \"l\", \"_\", \"g\"], [\"a\", \"n\", \"a\", \"s\"], [\"m\", \"u\", \"a\", \"a\"], [\"s\", \"h\", \"a\", \"m\"]]]", "is_correct_args": "[[[\"b\", \"l\", \"_\", \"g\"], [\"a\", \"n\", \"a\", \"s\"], [\"m\", \"u\", \"a\", \"a\"], [\"s\", \"h\", \"a\", \"m\"]], [\"lag\", \"abas\", \"numa\", \"sham\"]]", "A*_args": "[\"[['b', 'l', '_', 'g'], ['a', 'n', 'a', 's'], ['m', 'u', 'a', 'a'], ['s', 'h', 'a', 'm']]\", \"['lag', 'abas', 'numa', 'sham']\"]"}
{"diff_sorted_id": "13", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'H'. Our task is to visit city E and city X excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from X and E, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  G X R L Y E V T B H \nG 0 1 0 0 0 0 0 1 0 0 \nX 0 0 0 1 1 0 0 0 1 0 \nR 0 0 0 0 1 1 0 0 1 0 \nL 0 0 0 0 0 1 0 0 0 0 \nY 0 1 0 0 0 0 0 0 0 0 \nE 0 0 0 0 1 0 0 1 1 0 \nV 0 0 1 0 1 1 0 0 1 1 \nT 1 1 1 1 0 1 0 0 0 0 \nB 0 0 0 0 1 0 0 1 0 1 \nH 0 0 0 0 1 0 1 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[\"H\", \"V\", \"E\", \"T\", \"X\", \"Y\", \"X\", \"L\", \"E\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.02870488166809082", "solution_depth": "9", "max_successor_states": "10", "num_vars_per_state": "13", "is_feasible_args": "[[[0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [0, 0, 1, 0, 1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0]], [\"G\", \"X\", \"R\", \"L\", \"Y\", \"E\", \"V\", \"T\", \"B\", \"H\"], \"E\", \"X\"]", "is_correct_args": "[[[0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [0, 0, 1, 0, 1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0]], [\"G\", \"X\", \"R\", \"L\", \"Y\", \"E\", \"V\", \"T\", \"B\", \"H\"], \"H\", \"E\", \"X\"]", "A*_args": "[\"[[0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [0, 0, 1, 0, 1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0]]\", \"['G', 'X', 'R', 'L', 'Y', 'E', 'V', 'T', 'B', 'H']\", \"['H']\", \"['E', 'X']\"]"}
{"diff_sorted_id": "13", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [20, 19, 2, 12, 23, 18, 15, 13, 10, 6, 9, 4, 9, 16, 5, 8, 19, 6, 7, 2, 6, 15, 10, 9, 4, 6, 19, 10, 10, 16, 21, 17, 21, 16, 13, 6, 16, 8, 7, 11, 13, 7, 21, 15, 15, 6, 11, 19, 7], such that the sum of the chosen coins adds up to 216. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {6: 6, 8: 6, 16: 4, 15: 11, 12: 3, 10: 5, 20: 14, 9: 3, 17: 8, 7: 5, 5: 5, 2: 1, 11: 4, 23: 18, 19: 3, 13: 13, 18: 6, 4: 3, 21: 20}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "27", "opt_solution": "[16, 2, 9, 19, 19, 19, 16, 19, 16, 12, 2, 9, 9, 11, 11, 10, 17]", "opt_solution_cost": "59", "opt_solution_compute_t": "0.04360342025756836", "solution_depth": "17", "max_successor_states": "49", "num_vars_per_state": "49", "is_feasible_args": "[[20, 19, 2, 12, 23, 18, 15, 13, 10, 6, 9, 4, 9, 16, 5, 8, 19, 6, 7, 2, 6, 15, 10, 9, 4, 6, 19, 10, 10, 16, 21, 17, 21, 16, 13, 6, 16, 8, 7, 11, 13, 7, 21, 15, 15, 6, 11, 19, 7]]", "is_correct_args": "[[20, 19, 2, 12, 23, 18, 15, 13, 10, 6, 9, 4, 9, 16, 5, 8, 19, 6, 7, 2, 6, 15, 10, 9, 4, 6, 19, 10, 10, 16, 21, 17, 21, 16, 13, 6, 16, 8, 7, 11, 13, 7, 21, 15, 15, 6, 11, 19, 7], {\"6\": 6, \"8\": 6, \"16\": 4, \"15\": 11, \"12\": 3, \"10\": 5, \"20\": 14, \"9\": 3, \"17\": 8, \"7\": 5, \"5\": 5, \"2\": 1, \"11\": 4, \"23\": 18, \"19\": 3, \"13\": 13, \"18\": 6, \"4\": 3, \"21\": 20}, 216]", "A*_args": "[\"[20, 19, 2, 12, 23, 18, 15, 13, 10, 6, 9, 4, 9, 16, 5, 8, 19, 6, 7, 2, 6, 15, 10, 9, 4, 6, 19, 10, 10, 16, 21, 17, 21, 16, 13, 6, 16, 8, 7, 11, 13, 7, 21, 15, 15, 6, 11, 19, 7]\", \"{6: 6, 8: 6, 16: 4, 15: 11, 12: 3, 10: 5, 20: 14, 9: 3, 17: 8, 7: 5, 5: 5, 2: 1, 11: 4, 23: 18, 19: 3, 13: 13, 18: 6, 4: 3, 21: 20}\", \"216\"]"}
{"diff_sorted_id": "13", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Blue', 'Blue', 'Green'], ['Red', 'Green', 'Red', 'Blue'], ['Red', 'Green', 'Blue', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[1, 0], [2, 0], [2, 1], [2, 1], [0, 2], [0, 2], [0, 1], [0, 2], [0, 2], [1, 0], [1, 2], [1, 0], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [0, 2]]", "opt_solution_cost": "18", "opt_solution_compute_t": "1.4882152080535889", "solution_depth": "18", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Blue\", \"Blue\", \"Green\"], [\"Red\", \"Green\", \"Red\", \"Blue\"], [\"Red\", \"Green\", \"Blue\", \"Red\"]], 6]", "is_correct_args": "[[[\"Green\", \"Blue\", \"Blue\", \"Green\"], [\"Red\", \"Green\", \"Red\", \"Blue\"], [\"Red\", \"Green\", \"Blue\", \"Red\"]], 6]", "A*_args": "[\"[['Green', 'Blue', 'Blue', 'Green'], ['Red', 'Green', 'Red', 'Blue'], ['Red', 'Green', 'Blue', 'Red']]\", \"6\"]"}
{"diff_sorted_id": "13", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 21 to 59 (21 included in the range but 59 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['29' '45' 'x']\n ['x' 'x' 'x']\n ['x' '43' '34']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 2, 46], [1, 0, 47], [1, 1, 44], [1, 2, 35], [2, 0, 48]]", "opt_solution_cost": "342", "opt_solution_compute_t": "0.32321739196777344", "solution_depth": "5", "max_successor_states": "38", "num_vars_per_state": "9", "is_feasible_args": "[\"[['29', '45', ''], ['', '', ''], ['', '43', '34']]\", 21, 59]", "is_correct_args": "[\"[['29', '45', ''], ['', '', ''], ['', '43', '34']]\", 21, 59]", "A*_args": "[\"[['29', '45', ''], ['', '', ''], ['', '43', '34']]\", \"21\", \"59\"]"}
{"diff_sorted_id": "13", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 28 to 57. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 129, and sum of row 1 must be 133. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 136. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['41' 'x' 'x']\n ['34' 'x' 'x']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 1, 29], [0, 2, 30], [1, 1, 56], [1, 2, 43], [2, 0, 50], [2, 1, 44], [2, 2, 28]]", "opt_solution_cost": "355", "opt_solution_compute_t": "2.4692792892456055", "solution_depth": "7", "max_successor_states": "24", "num_vars_per_state": "9", "is_feasible_args": "[\"[['41', '', ''], ['34', '', ''], ['', '', '']]\", 3, 28, 57]", "is_correct_args": "[\"[['41', '', ''], ['34', '', ''], ['', '', '']]\", 28, 57, [1, 2], [1, 2], [129], [133], 136]", "A*_args": "[\"[['41', '', ''], ['34', '', ''], ['', '', '']]\", \"28\", \"57\", \"[None, 129, None]\", \"[None, 133, None]\", \"136\"]"}
{"diff_sorted_id": "13", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 4, 1: 2, 2: 2, 3: 7, 4: 4, 5: 5}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Green', 'Red', 'Blue', 'Blue'], [], ['Yellow', 'Red', 'Green', 'Green'], [], [], ['Red', 'Yellow', 'Blue', 'Yellow']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[2, 1], [2, 4], [0, 2], [0, 4], [5, 4], [5, 1], [5, 0], [5, 1]]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.023777484893798828", "solution_depth": "8", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Red\", \"Blue\", \"Blue\"], [], [\"Yellow\", \"Red\", \"Green\", \"Green\"], [], [], [\"Red\", \"Yellow\", \"Blue\", \"Yellow\"]], 4, {\"0\": 4, \"1\": 2, \"2\": 2, \"3\": 7, \"4\": 4, \"5\": 5}]", "is_correct_args": "[[[\"Green\", \"Red\", \"Blue\", \"Blue\"], [], [\"Yellow\", \"Red\", \"Green\", \"Green\"], [], [], [\"Red\", \"Yellow\", \"Blue\", \"Yellow\"]], 4, {\"0\": 4, \"1\": 2, \"2\": 2, \"3\": 7, \"4\": 4, \"5\": 5}, 3]", "A*_args": "[\"[['Green', 'Red', 'Blue', 'Blue'], [], ['Yellow', 'Red', 'Green', 'Green'], [], [], ['Red', 'Yellow', 'Blue', 'Yellow']]\", \"{0: 4, 1: 2, 2: 2, 3: 7, 4: 4, 5: 5}\", \"4\", \"3\"]"}
{"diff_sorted_id": "13", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 7) to his destination workshop at index (5, 0), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 4, and district 3 covering rows 5 to 8. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x x x 9 x 20 3 9]\n[17 11 17 x 9 2 7 x 15]\n[x 4 2 19 12 6 x 4 17]\n[15 x x 15 11 19 x 9 5]\n[3 9 19 15 2 x x 18 x]\n[19 5 9 11 9 x x 3 x]\n[x x 2 8 8 x x x 19]\n[x x 14 x x x 18 x 18]\n[x 14 18 7 8 x 10 15 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "1", "opt_solution": "[[3, 7], [2, 7], [2, 8], [1, 8], [0, 8], [0, 7], [0, 6], [1, 6], [1, 5], [2, 5], [2, 4], [3, 4], [4, 4], [5, 4], [5, 3], [5, 2], [5, 1], [5, 0]]", "opt_solution_cost": "161", "opt_solution_compute_t": "0.020489215850830078", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"x\", \"x\", \"9\", \"x\", \"20\", \"3\", \"9\"], [\"17\", \"11\", \"17\", \"x\", \"9\", \"2\", \"7\", \"x\", \"15\"], [\"x\", \"4\", \"2\", \"19\", \"12\", \"6\", \"x\", \"4\", \"17\"], [\"15\", \"x\", \"x\", \"15\", \"11\", \"19\", \"x\", \"9\", \"5\"], [\"3\", \"9\", \"19\", \"15\", \"2\", \"x\", \"x\", \"18\", \"x\"], [\"19\", \"5\", \"9\", \"11\", \"9\", \"x\", \"x\", \"3\", \"x\"], [\"x\", \"x\", \"2\", \"8\", \"8\", \"x\", \"x\", \"x\", \"19\"], [\"x\", \"x\", \"14\", \"x\", \"x\", \"x\", \"18\", \"x\", \"18\"], [\"x\", \"14\", \"18\", \"7\", \"8\", \"x\", \"10\", \"15\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"x\", \"x\", \"9\", \"x\", \"20\", \"3\", \"9\"], [\"17\", \"11\", \"17\", \"x\", \"9\", \"2\", \"7\", \"x\", \"15\"], [\"x\", \"4\", \"2\", \"19\", \"12\", \"6\", \"x\", \"4\", \"17\"], [\"15\", \"x\", \"x\", \"15\", \"11\", \"19\", \"x\", \"9\", \"5\"], [\"3\", \"9\", \"19\", \"15\", \"2\", \"x\", \"x\", \"18\", \"x\"], [\"19\", \"5\", \"9\", \"11\", \"9\", \"x\", \"x\", \"3\", \"x\"], [\"x\", \"x\", \"2\", \"8\", \"8\", \"x\", \"x\", \"x\", \"19\"], [\"x\", \"x\", \"14\", \"x\", \"x\", \"x\", \"18\", \"x\", \"18\"], [\"x\", \"14\", \"18\", \"7\", \"8\", \"x\", \"10\", \"15\", \"x\"]], [3, 7], [5, 0], 3, 4]", "A*_args": "[\"[['x', 'x', 'x', 'x', '9', 'x', '20', '3', '9'], ['17', '11', '17', 'x', '9', '2', '7', 'x', '15'], ['x', '4', '2', '19', '12', '6', 'x', '4', '17'], ['15', 'x', 'x', '15', '11', '19', 'x', '9', '5'], ['3', '9', '19', '15', '2', 'x', 'x', '18', 'x'], ['19', '5', '9', '11', '9', 'x', 'x', '3', 'x'], ['x', 'x', '2', '8', '8', 'x', 'x', 'x', '19'], ['x', 'x', '14', 'x', 'x', 'x', '18', 'x', '18'], ['x', '14', '18', '7', '8', 'x', '10', '15', 'x']]\", \"(3, 7)\", \"(5, 0)\", \"3\", \"4\"]"}
{"diff_sorted_id": "13", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 9x9. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (5, 8). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 1 0 1 1 0 0 0\n0 0 0 1 1 1 0 1 1\n0 1 0 0 0 0 1 0 1\n0 1 1 1 0 0 1 1 0\n0 1 1 1 1 0 0 1 1\n1 0 1 1 0 1 0 0 0\n0 1 1 1 1 0 0 0 0\n1 1 0 1 1 0 1 0 0\n0 1 1 1 1 1 0 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "9", "opt_solution": "[[1, 0], [1, 1], [1, 2], [2, 3], [2, 4], [2, 5], [3, 5], [4, 6], [5, 7], [5, 8]]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.029414653778076172", "solution_depth": "10", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 1, 1], [0, 1, 0, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 0, 0, 1, 1, 0], [0, 1, 1, 1, 1, 0, 0, 1, 1], [1, 0, 1, 1, 0, 1, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0]]\", 3]", "is_correct_args": "[\"[[0, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 1, 1], [0, 1, 0, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 0, 0, 1, 1, 0], [0, 1, 1, 1, 1, 0, 0, 1, 1], [1, 0, 1, 1, 0, 1, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0]]\", [1, 0], [5, 8], 3]", "A*_args": "[\"[[0, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 1, 1], [0, 1, 0, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 0, 0, 1, 1, 0], [0, 1, 1, 1, 1, 0, 0, 1, 1], [1, 0, 1, 1, 0, 1, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0]]\", \"(1, 0)\", \"(5, 8)\", \"3\"]"}
{"diff_sorted_id": "13", "problem_statement": "Given 5 labeled water jugs with capacities 57, 84, 47, 76, 85, 69 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 203, 217, 334 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 47, 3], [\"+\", 76, 3], [\"+\", 85, 3], [\"+\", 57, 3], [\"+\", 69, 3], [\"+\", 85, 2], [\"+\", 85, 2], [\"+\", 47, 2], [\"+\", 47, 1], [\"+\", 57, 1], [\"+\", 84, 1], [\"-\", 69, 1], [\"+\", 84, 1]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.028015613555908203", "solution_depth": "13", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[57, 84, 47, 76, 85, 69], [203, 217, 334]]", "is_correct_args": "[[57, 84, 47, 76, 85, 69], [203, 217, 334]]", "A*_args": "[\"[57, 84, 47, 76, 85, 69]\", \"[203, 217, 334]\"]"}
{"diff_sorted_id": "14", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[28, 51, 19], [89, '_', 21], [43, 39, 45]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[21, 45, 39, 21, 45, 19, 51, 28, 89, 43, 21, 39, 19, 45, 28, 51, 45, 28, 39, 19]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.045632362365722656", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[28, 51, 19], [89, \"_\", 21], [43, 39, 45]]]", "is_correct_args": "[[[28, 51, 19], [89, \"_\", 21], [43, 39, 45]]]", "A*_args": "[\"[[28, 51, 19], [89, '_', 21], [43, 39, 45]]\"]"}
{"diff_sorted_id": "14", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: ann, birk, trey, bali   The initial board: [['_', 'a', 't', 'n'], ['b', 'i', 'r', 'n'], ['k', 'r', 'e', 'y'], ['b', 'a', 'l', 'i']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"down-right\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.1393892765045166", "solution_depth": "12", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"_\", \"a\", \"t\", \"n\"], [\"b\", \"i\", \"r\", \"n\"], [\"k\", \"r\", \"e\", \"y\"], [\"b\", \"a\", \"l\", \"i\"]]]", "is_correct_args": "[[[\"_\", \"a\", \"t\", \"n\"], [\"b\", \"i\", \"r\", \"n\"], [\"k\", \"r\", \"e\", \"y\"], [\"b\", \"a\", \"l\", \"i\"]], [\"ann\", \"birk\", \"trey\", \"bali\"]]", "A*_args": "[\"[['_', 'a', 't', 'n'], ['b', 'i', 'r', 'n'], ['k', 'r', 'e', 'y'], ['b', 'a', 'l', 'i']]\", \"['ann', 'birk', 'trey', 'bali']\"]"}
{"diff_sorted_id": "14", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'N'. Our task is to visit city H and city M excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from M and H, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  M U B F V Z P N E H \nM 0 0 0 0 0 1 0 0 0 0 \nU 1 0 0 1 0 0 1 0 0 0 \nB 1 1 0 0 1 0 0 0 1 0 \nF 0 0 1 0 0 0 0 0 0 1 \nV 0 0 0 1 0 0 1 0 0 0 \nZ 0 1 1 0 1 0 0 0 0 1 \nP 1 0 0 0 1 1 0 0 0 0 \nN 0 1 1 0 0 1 0 0 1 0 \nE 1 0 0 0 0 1 0 0 0 0 \nH 1 0 1 0 1 1 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[\"N\", \"U\", \"F\", \"H\", \"M\", \"Z\", \"H\", \"M\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.027659177780151367", "solution_depth": "8", "max_successor_states": "10", "num_vars_per_state": "13", "is_feasible_args": "[[[0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 0, 0, 0, 0]], [\"M\", \"U\", \"B\", \"F\", \"V\", \"Z\", \"P\", \"N\", \"E\", \"H\"], \"H\", \"M\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 0, 0, 0, 0]], [\"M\", \"U\", \"B\", \"F\", \"V\", \"Z\", \"P\", \"N\", \"E\", \"H\"], \"N\", \"H\", \"M\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 0, 0, 0, 0]]\", \"['M', 'U', 'B', 'F', 'V', 'Z', 'P', 'N', 'E', 'H']\", \"['N']\", \"['H', 'M']\"]"}
{"diff_sorted_id": "14", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [9, 18, 7, 20, 4, 12, 5, 5, 18, 5, 2, 11, 5, 16, 19, 8, 10, 9, 12, 14, 17, 6, 14, 16, 20, 10, 10, 13, 4, 13, 7, 14, 14, 10, 2, 7, 14, 11, 16, 10, 10, 5, 14, 20, 4, 17], such that the sum of the chosen coins adds up to 206. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {17: 16, 8: 8, 6: 6, 16: 12, 5: 4, 14: 12, 18: 9, 12: 1, 19: 12, 4: 2, 7: 3, 10: 7, 11: 7, 13: 6, 2: 1, 9: 1, 20: 10}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "28", "opt_solution": "[12, 2, 9, 9, 4, 7, 13, 13, 12, 4, 7, 4, 7, 19, 18, 10, 11, 10, 2, 5, 11, 17]", "opt_solution_cost": "102", "opt_solution_compute_t": "0.040293216705322266", "solution_depth": "22", "max_successor_states": "46", "num_vars_per_state": "46", "is_feasible_args": "[[9, 18, 7, 20, 4, 12, 5, 5, 18, 5, 2, 11, 5, 16, 19, 8, 10, 9, 12, 14, 17, 6, 14, 16, 20, 10, 10, 13, 4, 13, 7, 14, 14, 10, 2, 7, 14, 11, 16, 10, 10, 5, 14, 20, 4, 17]]", "is_correct_args": "[[9, 18, 7, 20, 4, 12, 5, 5, 18, 5, 2, 11, 5, 16, 19, 8, 10, 9, 12, 14, 17, 6, 14, 16, 20, 10, 10, 13, 4, 13, 7, 14, 14, 10, 2, 7, 14, 11, 16, 10, 10, 5, 14, 20, 4, 17], {\"17\": 16, \"8\": 8, \"6\": 6, \"16\": 12, \"5\": 4, \"14\": 12, \"18\": 9, \"12\": 1, \"19\": 12, \"4\": 2, \"7\": 3, \"10\": 7, \"11\": 7, \"13\": 6, \"2\": 1, \"9\": 1, \"20\": 10}, 206]", "A*_args": "[\"[9, 18, 7, 20, 4, 12, 5, 5, 18, 5, 2, 11, 5, 16, 19, 8, 10, 9, 12, 14, 17, 6, 14, 16, 20, 10, 10, 13, 4, 13, 7, 14, 14, 10, 2, 7, 14, 11, 16, 10, 10, 5, 14, 20, 4, 17]\", \"{17: 16, 8: 8, 6: 6, 16: 12, 5: 4, 14: 12, 18: 9, 12: 1, 19: 12, 4: 2, 7: 3, 10: 7, 11: 7, 13: 6, 2: 1, 9: 1, 20: 10}\", \"206\"]"}
{"diff_sorted_id": "14", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Blue', 'Green', 'Blue'], ['Red', 'Green', 'Red', 'Red'], ['Green', 'Blue', 'Red', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[0, 2], [0, 1], [0, 2], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [1, 2], [1, 2], [0, 1], [0, 2], [1, 2], [1, 2], [1, 0], [2, 1], [2, 1]]", "opt_solution_cost": "18", "opt_solution_compute_t": "1.1862623691558838", "solution_depth": "18", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Blue\", \"Green\", \"Blue\"], [\"Red\", \"Green\", \"Red\", \"Red\"], [\"Green\", \"Blue\", \"Red\", \"Blue\"]], 6]", "is_correct_args": "[[[\"Green\", \"Blue\", \"Green\", \"Blue\"], [\"Red\", \"Green\", \"Red\", \"Red\"], [\"Green\", \"Blue\", \"Red\", \"Blue\"]], 6]", "A*_args": "[\"[['Green', 'Blue', 'Green', 'Blue'], ['Red', 'Green', 'Red', 'Red'], ['Green', 'Blue', 'Red', 'Blue']]\", \"6\"]"}
{"diff_sorted_id": "14", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 11 to 49 (11 included in the range but 49 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['41' 'x' '21']\n ['x' 'x' 'x']\n ['12' 'x' '42']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 1, 22], [1, 0, 13], [1, 1, 15], [1, 2, 23], [2, 1, 14]]", "opt_solution_cost": "268", "opt_solution_compute_t": "0.8595123291015625", "solution_depth": "5", "max_successor_states": "38", "num_vars_per_state": "9", "is_feasible_args": "[\"[['41', '', '21'], ['', '', ''], ['12', '', '42']]\", 11, 49]", "is_correct_args": "[\"[['41', '', '21'], ['', '', ''], ['12', '', '42']]\", 11, 49]", "A*_args": "[\"[['41', '', '21'], ['', '', ''], ['12', '', '42']]\", \"11\", \"49\"]"}
{"diff_sorted_id": "14", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 28 to 57. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 143, and sum of row 1 must be 134. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 131. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '32' 'x']\n ['38' 'x' 'x']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 28], [0, 2, 30], [1, 1, 56], [1, 2, 40], [2, 0, 45], [2, 1, 55], [2, 2, 29]]", "opt_solution_cost": "353", "opt_solution_compute_t": "3.0488429069519043", "solution_depth": "7", "max_successor_states": "24", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '32', ''], ['38', '', ''], ['', '', '']]\", 3, 28, 57]", "is_correct_args": "[\"[['', '32', ''], ['38', '', ''], ['', '', '']]\", 28, 57, [1, 2], [1, 2], [143], [134], 131]", "A*_args": "[\"[['', '32', ''], ['38', '', ''], ['', '', '']]\", \"28\", \"57\", \"[None, 143, None]\", \"[None, 134, None]\", \"131\"]"}
{"diff_sorted_id": "14", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 3, 1: 6, 2: 5, 3: 5, 4: 3, 5: 1}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Green', 'Yellow', 'Red', 'Yellow'], [], ['Blue', 'Blue', 'Blue', 'Red'], [], ['Green', 'Green', 'Red', 'Yellow'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[0, 1], [4, 1], [4, 1], [2, 3], [2, 3], [2, 3], [4, 5], [0, 4], [0, 5], [0, 4], [2, 5]]", "opt_solution_cost": "42", "opt_solution_compute_t": "0.16206979751586914", "solution_depth": "11", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Yellow\", \"Red\", \"Yellow\"], [], [\"Blue\", \"Blue\", \"Blue\", \"Red\"], [], [\"Green\", \"Green\", \"Red\", \"Yellow\"], []], 4, {\"0\": 3, \"1\": 6, \"2\": 5, \"3\": 5, \"4\": 3, \"5\": 1}]", "is_correct_args": "[[[\"Green\", \"Yellow\", \"Red\", \"Yellow\"], [], [\"Blue\", \"Blue\", \"Blue\", \"Red\"], [], [\"Green\", \"Green\", \"Red\", \"Yellow\"], []], 4, {\"0\": 3, \"1\": 6, \"2\": 5, \"3\": 5, \"4\": 3, \"5\": 1}, 3]", "A*_args": "[\"[['Green', 'Yellow', 'Red', 'Yellow'], [], ['Blue', 'Blue', 'Blue', 'Red'], [], ['Green', 'Green', 'Red', 'Yellow'], []]\", \"{0: 3, 1: 6, 2: 5, 3: 5, 4: 3, 5: 1}\", \"4\", \"3\"]"}
{"diff_sorted_id": "14", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 1) to his destination workshop at index (7, 8), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 6, and district 3 covering rows 7 to 8. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 3 13 18 x x 3 x x]\n[x 3 x x 18 1 13 x x]\n[x x x 6 x 13 x 11 1]\n[4 3 x x x x 6 6 11]\n[14 16 x x x x x 18 11]\n[14 x 11 x x 4 x 1 x]\n[18 7 1 x 8 x x x x]\n[4 9 6 12 13 19 x 14 4]\n[x x 17 12 7 7 9 3 1]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "1", "opt_solution": "[[3, 1], [3, 0], [4, 0], [5, 0], [6, 0], [6, 1], [6, 2], [7, 2], [7, 3], [8, 3], [8, 4], [8, 5], [8, 6], [8, 7], [8, 8], [7, 8]]", "opt_solution_cost": "119", "opt_solution_compute_t": "0.02022695541381836", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"3\", \"13\", \"18\", \"x\", \"x\", \"3\", \"x\", \"x\"], [\"x\", \"3\", \"x\", \"x\", \"18\", \"1\", \"13\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"6\", \"x\", \"13\", \"x\", \"11\", \"1\"], [\"4\", \"3\", \"x\", \"x\", \"x\", \"x\", \"6\", \"6\", \"11\"], [\"14\", \"16\", \"x\", \"x\", \"x\", \"x\", \"x\", \"18\", \"11\"], [\"14\", \"x\", \"11\", \"x\", \"x\", \"4\", \"x\", \"1\", \"x\"], [\"18\", \"7\", \"1\", \"x\", \"8\", \"x\", \"x\", \"x\", \"x\"], [\"4\", \"9\", \"6\", \"12\", \"13\", \"19\", \"x\", \"14\", \"4\"], [\"x\", \"x\", \"17\", \"12\", \"7\", \"7\", \"9\", \"3\", \"1\"]]]", "is_correct_args": "[[[\"x\", \"3\", \"13\", \"18\", \"x\", \"x\", \"3\", \"x\", \"x\"], [\"x\", \"3\", \"x\", \"x\", \"18\", \"1\", \"13\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"6\", \"x\", \"13\", \"x\", \"11\", \"1\"], [\"4\", \"3\", \"x\", \"x\", \"x\", \"x\", \"6\", \"6\", \"11\"], [\"14\", \"16\", \"x\", \"x\", \"x\", \"x\", \"x\", \"18\", \"11\"], [\"14\", \"x\", \"11\", \"x\", \"x\", \"4\", \"x\", \"1\", \"x\"], [\"18\", \"7\", \"1\", \"x\", \"8\", \"x\", \"x\", \"x\", \"x\"], [\"4\", \"9\", \"6\", \"12\", \"13\", \"19\", \"x\", \"14\", \"4\"], [\"x\", \"x\", \"17\", \"12\", \"7\", \"7\", \"9\", \"3\", \"1\"]], [3, 1], [7, 8], 3, 6]", "A*_args": "[\"[['x', '3', '13', '18', 'x', 'x', '3', 'x', 'x'], ['x', '3', 'x', 'x', '18', '1', '13', 'x', 'x'], ['x', 'x', 'x', '6', 'x', '13', 'x', '11', '1'], ['4', '3', 'x', 'x', 'x', 'x', '6', '6', '11'], ['14', '16', 'x', 'x', 'x', 'x', 'x', '18', '11'], ['14', 'x', '11', 'x', 'x', '4', 'x', '1', 'x'], ['18', '7', '1', 'x', '8', 'x', 'x', 'x', 'x'], ['4', '9', '6', '12', '13', '19', 'x', '14', '4'], ['x', 'x', '17', '12', '7', '7', '9', '3', '1']]\", \"(3, 1)\", \"(7, 8)\", \"3\", \"6\"]"}
{"diff_sorted_id": "14", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 9x9. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 7) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (7, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 0 0 0 1 1 0 0\n1 0 0 1 0 1 1 0 0\n0 0 1 0 1 0 0 0 1\n1 0 0 1 1 0 0 0 0\n0 0 0 0 1 1 1 0 1\n0 0 0 1 1 0 1 1 0\n0 1 1 0 1 1 0 1 0\n0 1 0 0 1 0 0 0 0\n0 0 0 0 1 0 1 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "9", "opt_solution": "[[0, 7], [1, 7], [2, 7], [2, 6], [2, 5], [1, 4], [2, 3], [3, 2], [4, 2], [5, 2], [5, 1], [5, 0], [6, 0], [7, 0]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.03127884864807129", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 0, 1, 0, 1, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 1], [1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 1], [0, 0, 0, 1, 1, 0, 1, 1, 0], [0, 1, 1, 0, 1, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0]]\", 3]", "is_correct_args": "[\"[[1, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 0, 1, 0, 1, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 1], [1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 1], [0, 0, 0, 1, 1, 0, 1, 1, 0], [0, 1, 1, 0, 1, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0]]\", [0, 7], [7, 0], 3]", "A*_args": "[\"[[1, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 0, 1, 0, 1, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 1], [1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 1], [0, 0, 0, 1, 1, 0, 1, 1, 0], [0, 1, 1, 0, 1, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0]]\", \"(0, 7)\", \"(7, 0)\", \"3\"]"}
{"diff_sorted_id": "14", "problem_statement": "Given 5 labeled water jugs with capacities 144, 37, 73, 79, 75, 74 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 236, 333, 386 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 74, 3], [\"+\", 75, 3], [\"+\", 79, 3], [\"+\", 79, 3], [\"+\", 79, 3], [\"+\", 73, 2], [\"+\", 79, 2], [\"+\", 144, 2], [\"+\", 37, 2], [\"+\", 73, 1], [\"+\", 79, 1], [\"+\", 79, 1], [\"-\", 74, 1], [\"+\", 79, 1]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.03917884826660156", "solution_depth": "14", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[144, 37, 73, 79, 75, 74], [236, 333, 386]]", "is_correct_args": "[[144, 37, 73, 79, 75, 74], [236, 333, 386]]", "A*_args": "[\"[144, 37, 73, 79, 75, 74]\", \"[236, 333, 386]\"]"}
{"diff_sorted_id": "15", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[80, 62, 76], [47, 67, 82], [24, 73, '_']]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[73, 67, 82, 73, 67, 24, 47, 82, 62, 80, 82, 47, 24, 62, 73, 67, 62, 24, 47, 73, 67, 62]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.08130145072937012", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[80, 62, 76], [47, 67, 82], [24, 73, \"_\"]]]", "is_correct_args": "[[[80, 62, 76], [47, 67, 82], [24, 73, \"_\"]]]", "A*_args": "[\"[[80, 62, 76], [47, 67, 82], [24, 73, '_']]\"]"}
{"diff_sorted_id": "15", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: ric, have, sgad, batz   The initial board: [['a', 'r', '_', 'c'], ['h', 'a', 'v', 'e'], ['a', 'g', 's', 'd'], ['b', 'i', 't', 'z']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.1922132968902588", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"a\", \"r\", \"_\", \"c\"], [\"h\", \"a\", \"v\", \"e\"], [\"a\", \"g\", \"s\", \"d\"], [\"b\", \"i\", \"t\", \"z\"]]]", "is_correct_args": "[[[\"a\", \"r\", \"_\", \"c\"], [\"h\", \"a\", \"v\", \"e\"], [\"a\", \"g\", \"s\", \"d\"], [\"b\", \"i\", \"t\", \"z\"]], [\"ric\", \"have\", \"sgad\", \"batz\"]]", "A*_args": "[\"[['a', 'r', '_', 'c'], ['h', 'a', 'v', 'e'], ['a', 'g', 's', 'd'], ['b', 'i', 't', 'z']]\", \"['ric', 'have', 'sgad', 'batz']\"]"}
{"diff_sorted_id": "15", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'E'. Our task is to visit city W and city X excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from X and W, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  U W A J K H E X R T \nU 0 0 0 0 1 0 0 0 0 1 \nW 1 0 0 1 0 0 0 0 0 0 \nA 0 0 0 0 0 0 0 1 1 0 \nJ 1 0 1 0 0 0 1 0 0 0 \nK 0 1 0 1 0 0 0 0 0 1 \nH 0 1 0 0 0 0 1 0 0 0 \nE 0 0 0 0 0 0 0 0 1 0 \nX 0 1 0 0 0 1 0 0 0 0 \nR 1 0 0 0 1 1 1 0 0 1 \nT 1 1 1 0 0 1 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[\"E\", \"R\", \"T\", \"X\", \"W\", \"J\", \"A\", \"X\", \"W\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.02704644203186035", "solution_depth": "9", "max_successor_states": "10", "num_vars_per_state": "13", "is_feasible_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], [1, 1, 1, 0, 0, 1, 0, 1, 0, 0]], [\"U\", \"W\", \"A\", \"J\", \"K\", \"H\", \"E\", \"X\", \"R\", \"T\"], \"W\", \"X\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], [1, 1, 1, 0, 0, 1, 0, 1, 0, 0]], [\"U\", \"W\", \"A\", \"J\", \"K\", \"H\", \"E\", \"X\", \"R\", \"T\"], \"E\", \"W\", \"X\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 1, 1, 0, 0, 1], [1, 1, 1, 0, 0, 1, 0, 1, 0, 0]]\", \"['U', 'W', 'A', 'J', 'K', 'H', 'E', 'X', 'R', 'T']\", \"['E']\", \"['W', 'X']\"]"}
{"diff_sorted_id": "15", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [1, 2, 17, 12, 7, 17, 2, 20, 4, 4, 17, 19, 15, 16, 18, 21, 18, 10, 3, 9, 12, 13, 8, 16, 9, 14, 13, 5, 13, 6, 20, 6, 13, 12, 8, 14, 15, 7, 10, 3, 16, 16, 9, 3, 2, 6, 9, 14, 16, 20, 11, 4, 17], such that the sum of the chosen coins adds up to 213. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {8: 5, 5: 2, 19: 2, 4: 4, 9: 2, 3: 1, 2: 2, 12: 1, 13: 6, 6: 5, 11: 1, 17: 14, 7: 4, 16: 13, 21: 10, 14: 13, 1: 1, 18: 12, 10: 10, 15: 11, 20: 20}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "29", "opt_solution": "[3, 3, 11, 19, 12, 2, 9, 9, 9, 9, 13, 12, 13, 13, 13, 21, 12, 15, 15]", "opt_solution_cost": "74", "opt_solution_compute_t": "0.046939849853515625", "solution_depth": "19", "max_successor_states": "53", "num_vars_per_state": "53", "is_feasible_args": "[[1, 2, 17, 12, 7, 17, 2, 20, 4, 4, 17, 19, 15, 16, 18, 21, 18, 10, 3, 9, 12, 13, 8, 16, 9, 14, 13, 5, 13, 6, 20, 6, 13, 12, 8, 14, 15, 7, 10, 3, 16, 16, 9, 3, 2, 6, 9, 14, 16, 20, 11, 4, 17]]", "is_correct_args": "[[1, 2, 17, 12, 7, 17, 2, 20, 4, 4, 17, 19, 15, 16, 18, 21, 18, 10, 3, 9, 12, 13, 8, 16, 9, 14, 13, 5, 13, 6, 20, 6, 13, 12, 8, 14, 15, 7, 10, 3, 16, 16, 9, 3, 2, 6, 9, 14, 16, 20, 11, 4, 17], {\"8\": 5, \"5\": 2, \"19\": 2, \"4\": 4, \"9\": 2, \"3\": 1, \"2\": 2, \"12\": 1, \"13\": 6, \"6\": 5, \"11\": 1, \"17\": 14, \"7\": 4, \"16\": 13, \"21\": 10, \"14\": 13, \"1\": 1, \"18\": 12, \"10\": 10, \"15\": 11, \"20\": 20}, 213]", "A*_args": "[\"[1, 2, 17, 12, 7, 17, 2, 20, 4, 4, 17, 19, 15, 16, 18, 21, 18, 10, 3, 9, 12, 13, 8, 16, 9, 14, 13, 5, 13, 6, 20, 6, 13, 12, 8, 14, 15, 7, 10, 3, 16, 16, 9, 3, 2, 6, 9, 14, 16, 20, 11, 4, 17]\", \"{8: 5, 5: 2, 19: 2, 4: 4, 9: 2, 3: 1, 2: 2, 12: 1, 13: 6, 6: 5, 11: 1, 17: 14, 7: 4, 16: 13, 21: 10, 14: 13, 1: 1, 18: 12, 10: 10, 15: 11, 20: 20}\", \"213\"]"}
{"diff_sorted_id": "15", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Red', 'Red', 'Blue'], ['Green', 'Green', 'Red', 'Red'], ['Green', 'Green', 'Blue', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [2, 0], [2, 1], [2, 1], [0, 2]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.14858675003051758", "solution_depth": "14", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Blue\", \"Red\", \"Red\", \"Blue\"], [\"Green\", \"Green\", \"Red\", \"Red\"], [\"Green\", \"Green\", \"Blue\", \"Blue\"]], 6]", "is_correct_args": "[[[\"Blue\", \"Red\", \"Red\", \"Blue\"], [\"Green\", \"Green\", \"Red\", \"Red\"], [\"Green\", \"Green\", \"Blue\", \"Blue\"]], 6]", "A*_args": "[\"[['Blue', 'Red', 'Red', 'Blue'], ['Green', 'Green', 'Red', 'Red'], ['Green', 'Green', 'Blue', 'Blue']]\", \"6\"]"}
{"diff_sorted_id": "15", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 18 to 56 (18 included in the range but 56 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' '23']\n ['31' 'x' 'x']\n ['x' '42' '51']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 18], [0, 1, 19], [1, 1, 25], [1, 2, 24], [2, 0, 32]]", "opt_solution_cost": "252", "opt_solution_compute_t": "0.17498183250427246", "solution_depth": "5", "max_successor_states": "38", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', '23'], ['31', '', ''], ['', '42', '51']]\", 18, 56]", "is_correct_args": "[\"[['', '', '23'], ['31', '', ''], ['', '42', '51']]\", 18, 56]", "A*_args": "[\"[['', '', '23'], ['31', '', ''], ['', '42', '51']]\", \"18\", \"56\"]"}
{"diff_sorted_id": "15", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 48 to 77. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 190, and sum of row 1 must be 167. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 172. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x']\n ['x' 'x' '55']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 49], [0, 1, 51], [0, 2, 52], [1, 0, 48], [1, 1, 64], [2, 0, 56], [2, 1, 75], [2, 2, 50]]", "opt_solution_cost": "500", "opt_solution_compute_t": "37.735610485076904", "solution_depth": "8", "max_successor_states": "24", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '', '55'], ['', '', '']]\", 3, 48, 77]", "is_correct_args": "[\"[['', '', ''], ['', '', '55'], ['', '', '']]\", 48, 77, [1, 2], [1, 2], [190], [167], 172]", "A*_args": "[\"[['', '', ''], ['', '', '55'], ['', '', '']]\", \"48\", \"77\", \"[None, 190, None]\", \"[None, 167, None]\", \"172\"]"}
{"diff_sorted_id": "15", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 4, 1: 5, 2: 5, 3: 2, 4: 5, 5: 2}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], [], ['Red', 'Green', 'Green', 'Red'], ['Yellow', 'Blue', 'Yellow', 'Blue'], ['Yellow', 'Green', 'Red', 'Blue']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[4, 0], [5, 0], [3, 1], [5, 2], [5, 1], [3, 2], [3, 2], [4, 5], [4, 0], [1, 3], [1, 3], [4, 5]]", "opt_solution_cost": "45", "opt_solution_compute_t": "0.027285099029541016", "solution_depth": "12", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[], [], [], [\"Red\", \"Green\", \"Green\", \"Red\"], [\"Yellow\", \"Blue\", \"Yellow\", \"Blue\"], [\"Yellow\", \"Green\", \"Red\", \"Blue\"]], 4, {\"0\": 4, \"1\": 5, \"2\": 5, \"3\": 2, \"4\": 5, \"5\": 2}]", "is_correct_args": "[[[], [], [], [\"Red\", \"Green\", \"Green\", \"Red\"], [\"Yellow\", \"Blue\", \"Yellow\", \"Blue\"], [\"Yellow\", \"Green\", \"Red\", \"Blue\"]], 4, {\"0\": 4, \"1\": 5, \"2\": 5, \"3\": 2, \"4\": 5, \"5\": 2}, 3]", "A*_args": "[\"[[], [], [], ['Red', 'Green', 'Green', 'Red'], ['Yellow', 'Blue', 'Yellow', 'Blue'], ['Yellow', 'Green', 'Red', 'Blue']]\", \"{0: 4, 1: 5, 2: 5, 3: 2, 4: 5, 5: 2}\", \"4\", \"3\"]"}
{"diff_sorted_id": "15", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 1) to his destination workshop at index (5, 8), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 4, and district 3 covering rows 5 to 8. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[4 13 x 9 x x x x x]\n[1 11 x 16 5 7 12 16 x]\n[12 11 x 14 x x 12 x 3]\n[9 11 x 9 10 x 8 x x]\n[20 2 x 1 16 12 18 17 10]\n[10 13 4 15 13 2 20 3 15]\n[x 6 13 1 8 20 14 11 3]\n[14 x 9 x x 13 19 10 x]\n[12 x 18 1 x x 9 x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "1", "opt_solution": "[[3, 1], [2, 1], [3, 1], [4, 1], [5, 1], [5, 2], [5, 3], [5, 4], [5, 5], [5, 6], [5, 7], [5, 8]]", "opt_solution_cost": "109", "opt_solution_compute_t": "0.020708322525024414", "solution_depth": "12", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"4\", \"13\", \"x\", \"9\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"1\", \"11\", \"x\", \"16\", \"5\", \"7\", \"12\", \"16\", \"x\"], [\"12\", \"11\", \"x\", \"14\", \"x\", \"x\", \"12\", \"x\", \"3\"], [\"9\", \"11\", \"x\", \"9\", \"10\", \"x\", \"8\", \"x\", \"x\"], [\"20\", \"2\", \"x\", \"1\", \"16\", \"12\", \"18\", \"17\", \"10\"], [\"10\", \"13\", \"4\", \"15\", \"13\", \"2\", \"20\", \"3\", \"15\"], [\"x\", \"6\", \"13\", \"1\", \"8\", \"20\", \"14\", \"11\", \"3\"], [\"14\", \"x\", \"9\", \"x\", \"x\", \"13\", \"19\", \"10\", \"x\"], [\"12\", \"x\", \"18\", \"1\", \"x\", \"x\", \"9\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"4\", \"13\", \"x\", \"9\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"1\", \"11\", \"x\", \"16\", \"5\", \"7\", \"12\", \"16\", \"x\"], [\"12\", \"11\", \"x\", \"14\", \"x\", \"x\", \"12\", \"x\", \"3\"], [\"9\", \"11\", \"x\", \"9\", \"10\", \"x\", \"8\", \"x\", \"x\"], [\"20\", \"2\", \"x\", \"1\", \"16\", \"12\", \"18\", \"17\", \"10\"], [\"10\", \"13\", \"4\", \"15\", \"13\", \"2\", \"20\", \"3\", \"15\"], [\"x\", \"6\", \"13\", \"1\", \"8\", \"20\", \"14\", \"11\", \"3\"], [\"14\", \"x\", \"9\", \"x\", \"x\", \"13\", \"19\", \"10\", \"x\"], [\"12\", \"x\", \"18\", \"1\", \"x\", \"x\", \"9\", \"x\", \"x\"]], [3, 1], [5, 8], 2, 4]", "A*_args": "[\"[['4', '13', 'x', '9', 'x', 'x', 'x', 'x', 'x'], ['1', '11', 'x', '16', '5', '7', '12', '16', 'x'], ['12', '11', 'x', '14', 'x', 'x', '12', 'x', '3'], ['9', '11', 'x', '9', '10', 'x', '8', 'x', 'x'], ['20', '2', 'x', '1', '16', '12', '18', '17', '10'], ['10', '13', '4', '15', '13', '2', '20', '3', '15'], ['x', '6', '13', '1', '8', '20', '14', '11', '3'], ['14', 'x', '9', 'x', 'x', '13', '19', '10', 'x'], ['12', 'x', '18', '1', 'x', 'x', '9', 'x', 'x']]\", \"(3, 1)\", \"(5, 8)\", \"2\", \"4\"]"}
{"diff_sorted_id": "15", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 9x9. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 7) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (7, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 1 0 0 0 0 0 0\n1 1 0 0 1 0 0 1 1\n0 0 0 0 0 0 0 1 1\n0 0 1 0 0 0 1 1 0\n1 0 0 0 1 1 0 0 1\n0 0 0 0 1 0 0 0 0\n1 0 0 0 1 0 0 0 1\n0 0 1 1 1 1 1 1 0\n1 1 0 1 0 0 1 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "9", "opt_solution": "[[0, 7], [0, 6], [1, 6], [2, 6], [2, 5], [3, 5], [3, 4], [4, 3], [5, 3], [6, 2], [7, 1]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.029547452926635742", "solution_depth": "11", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 1, 0, 0, 0, 1, 1, 0], [1, 0, 0, 0, 1, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 1, 0], [1, 1, 0, 1, 0, 0, 1, 0, 0]]\", 3]", "is_correct_args": "[\"[[1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 1, 0, 0, 0, 1, 1, 0], [1, 0, 0, 0, 1, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 1, 0], [1, 1, 0, 1, 0, 0, 1, 0, 0]]\", [0, 7], [7, 1], 3]", "A*_args": "[\"[[1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 1, 0, 0, 0, 1, 1, 0], [1, 0, 0, 0, 1, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 1, 0], [1, 1, 0, 1, 0, 0, 1, 0, 0]]\", \"(0, 7)\", \"(7, 1)\", \"3\"]"}
{"diff_sorted_id": "15", "problem_statement": "Given 5 labeled water jugs with capacities 19, 50, 12, 63, 143, 13 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 160, 170, 330 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 63, 3], [\"+\", 143, 3], [\"-\", 19, 3], [\"+\", 143, 3], [\"+\", 63, 2], [\"+\", 63, 2], [\"-\", 19, 2], [\"+\", 63, 2], [\"+\", 143, 1], [\"-\", 63, 1], [\"-\", 63, 1], [\"+\", 143, 1]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.03795623779296875", "solution_depth": "12", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[19, 50, 12, 63, 143, 13], [160, 170, 330]]", "is_correct_args": "[[19, 50, 12, 63, 143, 13], [160, 170, 330]]", "A*_args": "[\"[19, 50, 12, 63, 143, 13]\", \"[160, 170, 330]\"]"}
{"diff_sorted_id": "16", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[77, 81, 74], [93, 85, 98], [59, 53, '_']]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[53, 59, 93, 77, 81, 85, 98, 74, 85, 98, 77, 93, 59, 77, 93, 81, 98, 93, 77, 53]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.028780221939086914", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[77, 81, 74], [93, 85, 98], [59, 53, \"_\"]]]", "is_correct_args": "[[[77, 81, 74], [93, 85, 98], [59, 53, \"_\"]]]", "A*_args": "[\"[[77, 81, 74], [93, 85, 98], [59, 53, '_']]\"]"}
{"diff_sorted_id": "16", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: goa, yodh, wall, acle   The initial board: [['o', 'g', 'h', 'a'], ['y', 'c', 'd', 'l'], ['o', 'a', '_', 'l'], ['a', 'w', 'l', 'e']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.13991522789001465", "solution_depth": "8", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"o\", \"g\", \"h\", \"a\"], [\"y\", \"c\", \"d\", \"l\"], [\"o\", \"a\", \"_\", \"l\"], [\"a\", \"w\", \"l\", \"e\"]]]", "is_correct_args": "[[[\"o\", \"g\", \"h\", \"a\"], [\"y\", \"c\", \"d\", \"l\"], [\"o\", \"a\", \"_\", \"l\"], [\"a\", \"w\", \"l\", \"e\"]], [\"goa\", \"yodh\", \"wall\", \"acle\"]]", "A*_args": "[\"[['o', 'g', 'h', 'a'], ['y', 'c', 'd', 'l'], ['o', 'a', '_', 'l'], ['a', 'w', 'l', 'e']]\", \"['goa', 'yodh', 'wall', 'acle']\"]"}
{"diff_sorted_id": "16", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'S'. Our task is to visit city P and city G excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from G and P, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  C V A G Y P Z S J I \nC 0 0 0 1 0 1 1 1 0 0 \nV 0 0 0 0 0 1 0 0 0 0 \nA 0 1 0 0 0 0 1 0 1 0 \nG 0 1 0 0 1 0 0 0 0 0 \nY 0 0 0 1 0 0 1 0 0 0 \nP 0 1 0 0 1 0 1 0 0 1 \nZ 0 0 0 0 1 1 0 1 1 0 \nS 0 0 1 0 0 0 0 0 0 0 \nJ 0 0 0 0 0 1 0 1 0 0 \nI 1 0 0 0 1 1 1 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[\"S\", \"A\", \"J\", \"P\", \"I\", \"C\", \"G\", \"V\", \"P\", \"Y\", \"G\"]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.030188560485839844", "solution_depth": "11", "max_successor_states": "10", "num_vars_per_state": "13", "is_feasible_args": "[[[0, 0, 0, 1, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 1, 0, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 0, 0, 1, 1, 1, 0, 0, 0]], [\"C\", \"V\", \"A\", \"G\", \"Y\", \"P\", \"Z\", \"S\", \"J\", \"I\"], \"P\", \"G\"]", "is_correct_args": "[[[0, 0, 0, 1, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 1, 0, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 0, 0, 1, 1, 1, 0, 0, 0]], [\"C\", \"V\", \"A\", \"G\", \"Y\", \"P\", \"Z\", \"S\", \"J\", \"I\"], \"S\", \"P\", \"G\"]", "A*_args": "[\"[[0, 0, 0, 1, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 1, 0, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 0, 0, 1, 1, 1, 0, 0, 0]]\", \"['C', 'V', 'A', 'G', 'Y', 'P', 'Z', 'S', 'J', 'I']\", \"['S']\", \"['P', 'G']\"]"}
{"diff_sorted_id": "16", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [11, 13, 22, 11, 16, 20, 10, 10, 17, 21, 6, 6, 15, 15, 21, 6, 4, 16, 9, 11, 3, 13, 2, 9, 11, 1, 7, 2, 2, 12, 5, 2, 11, 16, 20, 9, 2, 4, 10, 17, 11, 22, 11, 2, 18, 23, 15, 22, 11, 15, 20, 9], such that the sum of the chosen coins adds up to 223. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {6: 2, 11: 9, 3: 3, 15: 2, 9: 1, 18: 13, 22: 13, 16: 5, 21: 2, 5: 2, 12: 4, 7: 5, 4: 3, 13: 2, 1: 1, 20: 14, 2: 1, 10: 4, 23: 15, 17: 9}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "30", "opt_solution": "[9, 9, 9, 21, 2, 13, 13, 15, 15, 15, 15, 21, 16, 12, 6, 9, 6, 17]", "opt_solution_cost": "43", "opt_solution_compute_t": "0.04377126693725586", "solution_depth": "18", "max_successor_states": "52", "num_vars_per_state": "52", "is_feasible_args": "[[11, 13, 22, 11, 16, 20, 10, 10, 17, 21, 6, 6, 15, 15, 21, 6, 4, 16, 9, 11, 3, 13, 2, 9, 11, 1, 7, 2, 2, 12, 5, 2, 11, 16, 20, 9, 2, 4, 10, 17, 11, 22, 11, 2, 18, 23, 15, 22, 11, 15, 20, 9]]", "is_correct_args": "[[11, 13, 22, 11, 16, 20, 10, 10, 17, 21, 6, 6, 15, 15, 21, 6, 4, 16, 9, 11, 3, 13, 2, 9, 11, 1, 7, 2, 2, 12, 5, 2, 11, 16, 20, 9, 2, 4, 10, 17, 11, 22, 11, 2, 18, 23, 15, 22, 11, 15, 20, 9], {\"6\": 2, \"11\": 9, \"3\": 3, \"15\": 2, \"9\": 1, \"18\": 13, \"22\": 13, \"16\": 5, \"21\": 2, \"5\": 2, \"12\": 4, \"7\": 5, \"4\": 3, \"13\": 2, \"1\": 1, \"20\": 14, \"2\": 1, \"10\": 4, \"23\": 15, \"17\": 9}, 223]", "A*_args": "[\"[11, 13, 22, 11, 16, 20, 10, 10, 17, 21, 6, 6, 15, 15, 21, 6, 4, 16, 9, 11, 3, 13, 2, 9, 11, 1, 7, 2, 2, 12, 5, 2, 11, 16, 20, 9, 2, 4, 10, 17, 11, 22, 11, 2, 18, 23, 15, 22, 11, 15, 20, 9]\", \"{6: 2, 11: 9, 3: 3, 15: 2, 9: 1, 18: 13, 22: 13, 16: 5, 21: 2, 5: 2, 12: 4, 7: 5, 4: 3, 13: 2, 1: 1, 20: 14, 2: 1, 10: 4, 23: 15, 17: 9}\", \"223\"]"}
{"diff_sorted_id": "16", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Green', 'Blue'], ['Red', 'Green', 'Red', 'Blue'], ['Blue', 'Red', 'Green', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[0, 2], [1, 2], [0, 1], [0, 1], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [1, 0], [2, 1], [2, 0], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [0, 1], [0, 1], [0, 2], [0, 1], [2, 0], [2, 0]]", "opt_solution_cost": "23", "opt_solution_compute_t": "8.691032648086548", "solution_depth": "23", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Green\", \"Green\", \"Blue\"], [\"Red\", \"Green\", \"Red\", \"Blue\"], [\"Blue\", \"Red\", \"Green\", \"Blue\"]], 6]", "is_correct_args": "[[[\"Red\", \"Green\", \"Green\", \"Blue\"], [\"Red\", \"Green\", \"Red\", \"Blue\"], [\"Blue\", \"Red\", \"Green\", \"Blue\"]], 6]", "A*_args": "[\"[['Red', 'Green', 'Green', 'Blue'], ['Red', 'Green', 'Red', 'Blue'], ['Blue', 'Red', 'Green', 'Blue']]\", \"6\"]"}
{"diff_sorted_id": "16", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 28 to 66 (28 included in the range but 66 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['37' 'x' 'x']\n ['x' 'x' 'x']\n ['44' 'x' '61']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 1, 29], [0, 2, 28], [1, 0, 38], [1, 1, 31], [1, 2, 30], [2, 1, 45]]", "opt_solution_cost": "342", "opt_solution_compute_t": "0.1785869598388672", "solution_depth": "6", "max_successor_states": "38", "num_vars_per_state": "9", "is_feasible_args": "[\"[['37', '', ''], ['', '', ''], ['44', '', '61']]\", 28, 66]", "is_correct_args": "[\"[['37', '', ''], ['', '', ''], ['44', '', '61']]\", 28, 66]", "A*_args": "[\"[['37', '', ''], ['', '', ''], ['44', '', '61']]\", \"28\", \"66\"]"}
{"diff_sorted_id": "16", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 48 to 77. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 200, and sum of row 1 must be 191. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 201. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x']\n ['x' 'x' '66']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 48], [0, 1, 51], [0, 2, 53], [1, 0, 49], [1, 1, 76], [2, 0, 72], [2, 1, 73], [2, 2, 50]]", "opt_solution_cost": "538", "opt_solution_compute_t": "89.56194949150085", "solution_depth": "8", "max_successor_states": "24", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '', '66'], ['', '', '']]\", 3, 48, 77]", "is_correct_args": "[\"[['', '', ''], ['', '', '66'], ['', '', '']]\", 48, 77, [1, 2], [1, 2], [200], [191], 201]", "A*_args": "[\"[['', '', ''], ['', '', '66'], ['', '', '']]\", \"48\", \"77\", \"[None, 200, None]\", \"[None, 191, None]\", \"201\"]"}
{"diff_sorted_id": "16", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 6, 1: 5, 2: 2, 3: 3, 4: 3, 5: 6}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Green', 'Green', 'Blue', 'Green'], [], ['Yellow', 'Red', 'Red', 'Blue'], [], [], ['Yellow', 'Yellow', 'Blue', 'Red']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[2, 3], [5, 3], [5, 3], [5, 4], [2, 1], [2, 1], [5, 1], [2, 4], [0, 2], [0, 2], [0, 4], [0, 2]]", "opt_solution_cost": "39", "opt_solution_compute_t": "0.09036970138549805", "solution_depth": "12", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Green\", \"Blue\", \"Green\"], [], [\"Yellow\", \"Red\", \"Red\", \"Blue\"], [], [], [\"Yellow\", \"Yellow\", \"Blue\", \"Red\"]], 4, {\"0\": 6, \"1\": 5, \"2\": 2, \"3\": 3, \"4\": 3, \"5\": 6}]", "is_correct_args": "[[[\"Green\", \"Green\", \"Blue\", \"Green\"], [], [\"Yellow\", \"Red\", \"Red\", \"Blue\"], [], [], [\"Yellow\", \"Yellow\", \"Blue\", \"Red\"]], 4, {\"0\": 6, \"1\": 5, \"2\": 2, \"3\": 3, \"4\": 3, \"5\": 6}, 3]", "A*_args": "[\"[['Green', 'Green', 'Blue', 'Green'], [], ['Yellow', 'Red', 'Red', 'Blue'], [], [], ['Yellow', 'Yellow', 'Blue', 'Red']]\", \"{0: 6, 1: 5, 2: 2, 3: 3, 4: 3, 5: 6}\", \"4\", \"3\"]"}
{"diff_sorted_id": "16", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (5, 1) to his destination workshop at index (3, 9), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 5, and district 3 covering rows 6 to 9. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x x 16 1 13 17 7 14 x]\n[x 10 x 12 x 13 x 8 19 4]\n[9 13 x 13 x x 15 x x 16]\n[3 8 x 16 12 x x x x 13]\n[13 x 1 15 18 8 x 10 x x]\n[8 1 2 14 x 8 x 4 x 11]\n[14 13 15 x 16 x 13 2 x 19]\n[x 4 10 x x 16 x 11 x x]\n[x 14 x x x x x 18 6 18]\n[x 3 2 6 7 x x 9 8 5]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "2", "opt_solution": "[[5, 1], [6, 1], [5, 1], [5, 2], [4, 2], [4, 3], [3, 3], [2, 3], [1, 3], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [1, 7], [1, 8], [1, 9], [2, 9], [3, 9]]", "opt_solution_cost": "187", "opt_solution_compute_t": "0.020601749420166016", "solution_depth": "19", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"x\", \"16\", \"1\", \"13\", \"17\", \"7\", \"14\", \"x\"], [\"x\", \"10\", \"x\", \"12\", \"x\", \"13\", \"x\", \"8\", \"19\", \"4\"], [\"9\", \"13\", \"x\", \"13\", \"x\", \"x\", \"15\", \"x\", \"x\", \"16\"], [\"3\", \"8\", \"x\", \"16\", \"12\", \"x\", \"x\", \"x\", \"x\", \"13\"], [\"13\", \"x\", \"1\", \"15\", \"18\", \"8\", \"x\", \"10\", \"x\", \"x\"], [\"8\", \"1\", \"2\", \"14\", \"x\", \"8\", \"x\", \"4\", \"x\", \"11\"], [\"14\", \"13\", \"15\", \"x\", \"16\", \"x\", \"13\", \"2\", \"x\", \"19\"], [\"x\", \"4\", \"10\", \"x\", \"x\", \"16\", \"x\", \"11\", \"x\", \"x\"], [\"x\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"18\", \"6\", \"18\"], [\"x\", \"3\", \"2\", \"6\", \"7\", \"x\", \"x\", \"9\", \"8\", \"5\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"x\", \"16\", \"1\", \"13\", \"17\", \"7\", \"14\", \"x\"], [\"x\", \"10\", \"x\", \"12\", \"x\", \"13\", \"x\", \"8\", \"19\", \"4\"], [\"9\", \"13\", \"x\", \"13\", \"x\", \"x\", \"15\", \"x\", \"x\", \"16\"], [\"3\", \"8\", \"x\", \"16\", \"12\", \"x\", \"x\", \"x\", \"x\", \"13\"], [\"13\", \"x\", \"1\", \"15\", \"18\", \"8\", \"x\", \"10\", \"x\", \"x\"], [\"8\", \"1\", \"2\", \"14\", \"x\", \"8\", \"x\", \"4\", \"x\", \"11\"], [\"14\", \"13\", \"15\", \"x\", \"16\", \"x\", \"13\", \"2\", \"x\", \"19\"], [\"x\", \"4\", \"10\", \"x\", \"x\", \"16\", \"x\", \"11\", \"x\", \"x\"], [\"x\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"18\", \"6\", \"18\"], [\"x\", \"3\", \"2\", \"6\", \"7\", \"x\", \"x\", \"9\", \"8\", \"5\"]], [5, 1], [3, 9], 3, 5]", "A*_args": "[\"[['x', 'x', 'x', '16', '1', '13', '17', '7', '14', 'x'], ['x', '10', 'x', '12', 'x', '13', 'x', '8', '19', '4'], ['9', '13', 'x', '13', 'x', 'x', '15', 'x', 'x', '16'], ['3', '8', 'x', '16', '12', 'x', 'x', 'x', 'x', '13'], ['13', 'x', '1', '15', '18', '8', 'x', '10', 'x', 'x'], ['8', '1', '2', '14', 'x', '8', 'x', '4', 'x', '11'], ['14', '13', '15', 'x', '16', 'x', '13', '2', 'x', '19'], ['x', '4', '10', 'x', 'x', '16', 'x', '11', 'x', 'x'], ['x', '14', 'x', 'x', 'x', 'x', 'x', '18', '6', '18'], ['x', '3', '2', '6', '7', 'x', 'x', '9', '8', '5']]\", \"(5, 1)\", \"(3, 9)\", \"3\", \"5\"]"}
{"diff_sorted_id": "16", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 10x10. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 1) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (6, 9). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 0 0 1 1 1 1 0 0\n1 1 1 0 0 1 0 1 0 1\n1 0 0 0 1 0 0 0 0 0\n1 1 1 1 0 1 0 0 0 0\n1 0 1 0 0 1 1 0 0 0\n1 1 1 1 1 1 0 0 0 0\n0 1 1 1 1 0 1 1 1 0\n1 0 1 1 0 0 1 1 0 0\n1 1 1 0 1 1 0 1 0 1\n1 1 1 0 0 1 1 0 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[[0, 1], [0, 2], [0, 3], [1, 3], [1, 4], [2, 5], [2, 6], [3, 6], [3, 7], [4, 7], [5, 8], [6, 9]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.03220367431640625", "solution_depth": "12", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 0, 0, 1, 1, 1, 1, 0, 0], [1, 1, 1, 0, 0, 1, 0, 1, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 0, 0], [1, 1, 1, 0, 1, 1, 0, 1, 0, 1], [1, 1, 1, 0, 0, 1, 1, 0, 0, 1]]\", 3]", "is_correct_args": "[\"[[1, 0, 0, 0, 1, 1, 1, 1, 0, 0], [1, 1, 1, 0, 0, 1, 0, 1, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 0, 0], [1, 1, 1, 0, 1, 1, 0, 1, 0, 1], [1, 1, 1, 0, 0, 1, 1, 0, 0, 1]]\", [0, 1], [6, 9], 3]", "A*_args": "[\"[[1, 0, 0, 0, 1, 1, 1, 1, 0, 0], [1, 1, 1, 0, 0, 1, 0, 1, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 0, 0], [1, 1, 1, 0, 1, 1, 0, 1, 0, 1], [1, 1, 1, 0, 0, 1, 1, 0, 0, 1]]\", \"(0, 1)\", \"(6, 9)\", \"3\"]"}
{"diff_sorted_id": "16", "problem_statement": "Given 5 labeled water jugs with capacities 102, 130, 82, 131, 133, 116 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 265, 368, 378 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 116, 3], [\"+\", 131, 3], [\"+\", 131, 3], [\"+\", 102, 2], [\"+\", 133, 2], [\"+\", 133, 2], [\"+\", 130, 1], [\"+\", 133, 1], [\"-\", 131, 1], [\"+\", 133, 1]]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.033504486083984375", "solution_depth": "10", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[102, 130, 82, 131, 133, 116], [265, 368, 378]]", "is_correct_args": "[[102, 130, 82, 131, 133, 116], [265, 368, 378]]", "A*_args": "[\"[102, 130, 82, 131, 133, 116]\", \"[265, 368, 378]\"]"}
{"diff_sorted_id": "17", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[27, 18, 79], [22, 99, 9], [49, 53, '_']]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[53, 49, 22, 99, 18, 27, 99, 18, 49, 22, 18, 49, 9, 53, 22, 9, 27, 79, 53, 22]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.027205705642700195", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[27, 18, 79], [22, 99, 9], [49, 53, \"_\"]]]", "is_correct_args": "[[[27, 18, 79], [22, 99, 9], [49, 53, \"_\"]]]", "A*_args": "[\"[[27, 18, 79], [22, 99, 9], [49, 53, '_']]\"]"}
{"diff_sorted_id": "17", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: hay, werf, rudd, frib   The initial board: [['e', 'h', 'r', 'y'], ['w', 'f', 'r', 'r'], ['_', 'u', 'd', 'd'], ['f', 'a', 'i', 'b']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.18766021728515625", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"e\", \"h\", \"r\", \"y\"], [\"w\", \"f\", \"r\", \"r\"], [\"_\", \"u\", \"d\", \"d\"], [\"f\", \"a\", \"i\", \"b\"]]]", "is_correct_args": "[[[\"e\", \"h\", \"r\", \"y\"], [\"w\", \"f\", \"r\", \"r\"], [\"_\", \"u\", \"d\", \"d\"], [\"f\", \"a\", \"i\", \"b\"]], [\"hay\", \"werf\", \"rudd\", \"frib\"]]", "A*_args": "[\"[['e', 'h', 'r', 'y'], ['w', 'f', 'r', 'r'], ['_', 'u', 'd', 'd'], ['f', 'a', 'i', 'b']]\", \"['hay', 'werf', 'rudd', 'frib']\"]"}
{"diff_sorted_id": "17", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'V'. Our task is to visit city Y and city I excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from I and Y, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  I V F E Y A Z T H Q \nI 0 0 0 1 0 0 1 0 0 1 \nV 0 0 0 0 0 0 0 0 1 0 \nF 1 0 0 1 0 1 0 0 0 0 \nE 1 0 0 0 1 0 0 0 0 0 \nY 1 0 1 0 0 0 1 0 0 1 \nA 1 1 0 0 0 0 0 0 0 0 \nZ 1 0 1 1 0 0 0 0 0 1 \nT 0 1 1 1 1 1 1 0 0 0 \nH 1 0 0 0 0 0 0 1 0 0 \nQ 0 0 0 0 0 0 1 1 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[\"V\", \"H\", \"T\", \"Y\", \"I\", \"E\", \"Y\", \"I\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.026442289352416992", "solution_depth": "8", "max_successor_states": "10", "num_vars_per_state": "13", "is_feasible_args": "[[[0, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 1, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 1, 1, 1, 1, 1, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 0]], [\"I\", \"V\", \"F\", \"E\", \"Y\", \"A\", \"Z\", \"T\", \"H\", \"Q\"], \"Y\", \"I\"]", "is_correct_args": "[[[0, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 1, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 1, 1, 1, 1, 1, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 0]], [\"I\", \"V\", \"F\", \"E\", \"Y\", \"A\", \"Z\", \"T\", \"H\", \"Q\"], \"V\", \"Y\", \"I\"]", "A*_args": "[\"[[0, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 1, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 1, 1, 1, 1, 1, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 0]]\", \"['I', 'V', 'F', 'E', 'Y', 'A', 'Z', 'T', 'H', 'Q']\", \"['V']\", \"['Y', 'I']\"]"}
{"diff_sorted_id": "17", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [4, 2, 18, 5, 18, 13, 22, 15, 5, 14, 15, 21, 23, 13, 19, 22, 6, 12, 19, 8, 15, 8, 12, 15, 11, 17, 7, 19, 23, 9, 3, 4, 12, 10, 11, 2, 22, 19, 19, 11, 18, 6, 10, 23, 20, 1, 6, 23, 8, 6], such that the sum of the chosen coins adds up to 233. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {21: 18, 1: 1, 13: 3, 20: 2, 19: 7, 5: 4, 18: 4, 4: 1, 15: 5, 12: 7, 17: 5, 22: 10, 8: 3, 7: 5, 23: 11, 9: 7, 10: 8, 3: 2, 14: 4, 6: 1, 2: 2, 11: 10}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "31", "opt_solution": "[20, 18, 6, 4, 13, 6, 4, 13, 6, 19, 18, 19, 18, 8, 15, 14, 15, 17]", "opt_solution_cost": "61", "opt_solution_compute_t": "0.06324076652526855", "solution_depth": "18", "max_successor_states": "50", "num_vars_per_state": "50", "is_feasible_args": "[[4, 2, 18, 5, 18, 13, 22, 15, 5, 14, 15, 21, 23, 13, 19, 22, 6, 12, 19, 8, 15, 8, 12, 15, 11, 17, 7, 19, 23, 9, 3, 4, 12, 10, 11, 2, 22, 19, 19, 11, 18, 6, 10, 23, 20, 1, 6, 23, 8, 6]]", "is_correct_args": "[[4, 2, 18, 5, 18, 13, 22, 15, 5, 14, 15, 21, 23, 13, 19, 22, 6, 12, 19, 8, 15, 8, 12, 15, 11, 17, 7, 19, 23, 9, 3, 4, 12, 10, 11, 2, 22, 19, 19, 11, 18, 6, 10, 23, 20, 1, 6, 23, 8, 6], {\"21\": 18, \"1\": 1, \"13\": 3, \"20\": 2, \"19\": 7, \"5\": 4, \"18\": 4, \"4\": 1, \"15\": 5, \"12\": 7, \"17\": 5, \"22\": 10, \"8\": 3, \"7\": 5, \"23\": 11, \"9\": 7, \"10\": 8, \"3\": 2, \"14\": 4, \"6\": 1, \"2\": 2, \"11\": 10}, 233]", "A*_args": "[\"[4, 2, 18, 5, 18, 13, 22, 15, 5, 14, 15, 21, 23, 13, 19, 22, 6, 12, 19, 8, 15, 8, 12, 15, 11, 17, 7, 19, 23, 9, 3, 4, 12, 10, 11, 2, 22, 19, 19, 11, 18, 6, 10, 23, 20, 1, 6, 23, 8, 6]\", \"{21: 18, 1: 1, 13: 3, 20: 2, 19: 7, 5: 4, 18: 4, 4: 1, 15: 5, 12: 7, 17: 5, 22: 10, 8: 3, 7: 5, 23: 11, 9: 7, 10: 8, 3: 2, 14: 4, 6: 1, 2: 2, 11: 10}\", \"233\"]"}
{"diff_sorted_id": "17", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Red', 'Blue', 'Red'], ['Green', 'Red', 'Green', 'Green'], ['Blue', 'Green', 'Blue', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[0, 2], [0, 1], [0, 2], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [1, 2], [1, 2], [1, 0], [1, 2], [0, 1], [0, 2], [0, 1], [2, 0]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.8329384326934814", "solution_depth": "17", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Blue\", \"Red\", \"Blue\", \"Red\"], [\"Green\", \"Red\", \"Green\", \"Green\"], [\"Blue\", \"Green\", \"Blue\", \"Red\"]], 6]", "is_correct_args": "[[[\"Blue\", \"Red\", \"Blue\", \"Red\"], [\"Green\", \"Red\", \"Green\", \"Green\"], [\"Blue\", \"Green\", \"Blue\", \"Red\"]], 6]", "A*_args": "[\"[['Blue', 'Red', 'Blue', 'Red'], ['Green', 'Red', 'Green', 'Green'], ['Blue', 'Green', 'Blue', 'Red']]\", \"6\"]"}
{"diff_sorted_id": "17", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 38 to 76 (38 included in the range but 76 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '42' '38']\n ['x' 'x' 'x']\n ['x' '63' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 0, 43], [1, 0, 45], [1, 1, 44], [1, 2, 39], [2, 0, 64], [2, 2, 40]]", "opt_solution_cost": "367", "opt_solution_compute_t": "0.9439022541046143", "solution_depth": "6", "max_successor_states": "38", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '42', '38'], ['', '', ''], ['', '63', '']]\", 38, 76]", "is_correct_args": "[\"[['', '42', '38'], ['', '', ''], ['', '63', '']]\", 38, 76]", "A*_args": "[\"[['', '42', '38'], ['', '', ''], ['', '63', '']]\", \"38\", \"76\"]"}
{"diff_sorted_id": "17", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 48 to 77. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 166, and sum of row 1 must be 192. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 184. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '52' 'x']\n ['x' 'x' 'x']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 0, 49], [0, 2, 51], [1, 0, 53], [1, 1, 66], [1, 2, 73], [2, 0, 67], [2, 1, 48], [2, 2, 50]]", "opt_solution_cost": "509", "opt_solution_compute_t": "26.031718254089355", "solution_depth": "8", "max_successor_states": "29", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '52', ''], ['', '', ''], ['', '', '']]\", 3, 48, 77]", "is_correct_args": "[\"[['', '52', ''], ['', '', ''], ['', '', '']]\", 48, 77, [1, 2], [1, 2], [166], [192], 184]", "A*_args": "[\"[['', '52', ''], ['', '', ''], ['', '', '']]\", \"48\", \"77\", \"[None, 166, None]\", \"[None, 192, None]\", \"184\"]"}
{"diff_sorted_id": "17", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 2, 1: 3, 2: 3, 3: 6, 4: 1, 5: 6}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Blue', 'Red', 'Green', 'Yellow'], [], ['Red', 'Yellow', 'Yellow', 'Green'], [], ['Blue', 'Blue', 'Green', 'Red'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[0, 1], [0, 3], [0, 5], [2, 3], [4, 1], [4, 1], [2, 0], [2, 0], [4, 2], [5, 2], [3, 4], [3, 4]]", "opt_solution_cost": "39", "opt_solution_compute_t": "0.03980541229248047", "solution_depth": "12", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Blue\", \"Red\", \"Green\", \"Yellow\"], [], [\"Red\", \"Yellow\", \"Yellow\", \"Green\"], [], [\"Blue\", \"Blue\", \"Green\", \"Red\"], []], 4, {\"0\": 2, \"1\": 3, \"2\": 3, \"3\": 6, \"4\": 1, \"5\": 6}]", "is_correct_args": "[[[\"Blue\", \"Red\", \"Green\", \"Yellow\"], [], [\"Red\", \"Yellow\", \"Yellow\", \"Green\"], [], [\"Blue\", \"Blue\", \"Green\", \"Red\"], []], 4, {\"0\": 2, \"1\": 3, \"2\": 3, \"3\": 6, \"4\": 1, \"5\": 6}, 3]", "A*_args": "[\"[['Blue', 'Red', 'Green', 'Yellow'], [], ['Red', 'Yellow', 'Yellow', 'Green'], [], ['Blue', 'Blue', 'Green', 'Red'], []]\", \"{0: 2, 1: 3, 2: 3, 3: 6, 4: 1, 5: 6}\", \"4\", \"3\"]"}
{"diff_sorted_id": "17", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (7, 9) to his destination workshop at index (3, 2), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 6, and district 3 covering rows 7 to 9. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[16 2 16 x 4 x x 1 16 x]\n[x x 19 x 3 x 5 x x x]\n[x x x 3 x x 2 x 10 x]\n[11 5 20 x 1 3 1 x 9 x]\n[x x 8 19 x 16 9 x 16 15]\n[x 3 5 10 x x x 4 1 x]\n[9 18 10 17 5 6 x x x 5]\n[x x 14 5 18 x x 1 15 1]\n[13 x 13 13 14 2 19 12 x 1]\n[9 6 x 4 12 1 13 8 2 13]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "2", "opt_solution": "[[7, 9], [8, 9], [9, 9], [9, 8], [9, 7], [9, 6], [9, 5], [8, 5], [8, 4], [8, 3], [7, 3], [7, 2], [6, 2], [5, 2], [4, 2], [3, 2]]", "opt_solution_cost": "129", "opt_solution_compute_t": "0.028354406356811523", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"16\", \"2\", \"16\", \"x\", \"4\", \"x\", \"x\", \"1\", \"16\", \"x\"], [\"x\", \"x\", \"19\", \"x\", \"3\", \"x\", \"5\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"3\", \"x\", \"x\", \"2\", \"x\", \"10\", \"x\"], [\"11\", \"5\", \"20\", \"x\", \"1\", \"3\", \"1\", \"x\", \"9\", \"x\"], [\"x\", \"x\", \"8\", \"19\", \"x\", \"16\", \"9\", \"x\", \"16\", \"15\"], [\"x\", \"3\", \"5\", \"10\", \"x\", \"x\", \"x\", \"4\", \"1\", \"x\"], [\"9\", \"18\", \"10\", \"17\", \"5\", \"6\", \"x\", \"x\", \"x\", \"5\"], [\"x\", \"x\", \"14\", \"5\", \"18\", \"x\", \"x\", \"1\", \"15\", \"1\"], [\"13\", \"x\", \"13\", \"13\", \"14\", \"2\", \"19\", \"12\", \"x\", \"1\"], [\"9\", \"6\", \"x\", \"4\", \"12\", \"1\", \"13\", \"8\", \"2\", \"13\"]]]", "is_correct_args": "[[[\"16\", \"2\", \"16\", \"x\", \"4\", \"x\", \"x\", \"1\", \"16\", \"x\"], [\"x\", \"x\", \"19\", \"x\", \"3\", \"x\", \"5\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"3\", \"x\", \"x\", \"2\", \"x\", \"10\", \"x\"], [\"11\", \"5\", \"20\", \"x\", \"1\", \"3\", \"1\", \"x\", \"9\", \"x\"], [\"x\", \"x\", \"8\", \"19\", \"x\", \"16\", \"9\", \"x\", \"16\", \"15\"], [\"x\", \"3\", \"5\", \"10\", \"x\", \"x\", \"x\", \"4\", \"1\", \"x\"], [\"9\", \"18\", \"10\", \"17\", \"5\", \"6\", \"x\", \"x\", \"x\", \"5\"], [\"x\", \"x\", \"14\", \"5\", \"18\", \"x\", \"x\", \"1\", \"15\", \"1\"], [\"13\", \"x\", \"13\", \"13\", \"14\", \"2\", \"19\", \"12\", \"x\", \"1\"], [\"9\", \"6\", \"x\", \"4\", \"12\", \"1\", \"13\", \"8\", \"2\", \"13\"]], [7, 9], [3, 2], 3, 6]", "A*_args": "[\"[['16', '2', '16', 'x', '4', 'x', 'x', '1', '16', 'x'], ['x', 'x', '19', 'x', '3', 'x', '5', 'x', 'x', 'x'], ['x', 'x', 'x', '3', 'x', 'x', '2', 'x', '10', 'x'], ['11', '5', '20', 'x', '1', '3', '1', 'x', '9', 'x'], ['x', 'x', '8', '19', 'x', '16', '9', 'x', '16', '15'], ['x', '3', '5', '10', 'x', 'x', 'x', '4', '1', 'x'], ['9', '18', '10', '17', '5', '6', 'x', 'x', 'x', '5'], ['x', 'x', '14', '5', '18', 'x', 'x', '1', '15', '1'], ['13', 'x', '13', '13', '14', '2', '19', '12', 'x', '1'], ['9', '6', 'x', '4', '12', '1', '13', '8', '2', '13']]\", \"(7, 9)\", \"(3, 2)\", \"3\", \"6\"]"}
{"diff_sorted_id": "17", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 10x10. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 4) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (9, 8). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 1 1 0 0 1 0 0 1\n1 0 0 0 0 0 0 0 1 1\n1 1 0 0 0 0 0 0 1 1\n0 1 0 1 1 1 1 0 1 1\n0 0 1 0 1 1 1 0 0 0\n1 1 0 1 1 0 1 0 0 0\n1 0 1 0 0 0 1 0 0 0\n0 0 0 0 0 1 1 0 0 0\n0 1 0 0 1 1 1 1 0 0\n1 0 0 0 1 1 1 1 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[[0, 4], [1, 4], [2, 5], [2, 6], [3, 7], [4, 7], [5, 7], [6, 7], [7, 7], [8, 8], [9, 8]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.0298614501953125", "solution_depth": "11", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 1, 1, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 0, 0, 0, 1, 1], [0, 1, 0, 1, 1, 1, 1, 0, 1, 1], [0, 0, 1, 0, 1, 1, 1, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 1, 1, 1, 0, 0]]\", 3]", "is_correct_args": "[\"[[0, 1, 1, 1, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 0, 0, 0, 1, 1], [0, 1, 0, 1, 1, 1, 1, 0, 1, 1], [0, 0, 1, 0, 1, 1, 1, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 1, 1, 1, 0, 0]]\", [0, 4], [9, 8], 3]", "A*_args": "[\"[[0, 1, 1, 1, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 0, 0, 0, 1, 1], [0, 1, 0, 1, 1, 1, 1, 0, 1, 1], [0, 0, 1, 0, 1, 1, 1, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 1, 1, 1, 0, 0]]\", \"(0, 4)\", \"(9, 8)\", \"3\"]"}
{"diff_sorted_id": "17", "problem_statement": "Given 5 labeled water jugs with capacities 143, 117, 116, 103, 84, 87 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 398, 440, 440 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 103, 3], [\"+\", 117, 3], [\"+\", 117, 3], [\"+\", 103, 3], [\"+\", 103, 2], [\"+\", 117, 2], [\"+\", 117, 2], [\"+\", 103, 2], [\"+\", 84, 1], [\"+\", 87, 1], [\"+\", 143, 1], [\"+\", 84, 1]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.03967571258544922", "solution_depth": "12", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[143, 117, 116, 103, 84, 87], [398, 440, 440]]", "is_correct_args": "[[143, 117, 116, 103, 84, 87], [398, 440, 440]]", "A*_args": "[\"[143, 117, 116, 103, 84, 87]\", \"[398, 440, 440]\"]"}
{"diff_sorted_id": "18", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[88, 52, 85], [98, 96, 83], [50, 80, '_']]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[83, 96, 52, 88, 98, 52, 96, 85, 88, 96, 85, 83, 80, 50, 52, 85, 83, 80]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.027386188507080078", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[88, 52, 85], [98, 96, 83], [50, 80, \"_\"]]]", "is_correct_args": "[[[88, 52, 85], [98, 96, 83], [50, 80, \"_\"]]]", "A*_args": "[\"[[88, 52, 85], [98, 96, 83], [50, 80, '_']]\"]"}
{"diff_sorted_id": "18", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: moi, good, boyd, peck   The initial board: [['o', 'm', 'y', 'i'], ['g', 'd', 'o', 'e'], ['_', 'o', 'b', 'd'], ['p', 'o', 'c', 'k']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "1", "opt_solution": "[\"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.20071721076965332", "solution_depth": "12", "max_successor_states": "4", "num_vars_per_state": "16", "is_feasible_args": "[[[\"o\", \"m\", \"y\", \"i\"], [\"g\", \"d\", \"o\", \"e\"], [\"_\", \"o\", \"b\", \"d\"], [\"p\", \"o\", \"c\", \"k\"]]]", "is_correct_args": "[[[\"o\", \"m\", \"y\", \"i\"], [\"g\", \"d\", \"o\", \"e\"], [\"_\", \"o\", \"b\", \"d\"], [\"p\", \"o\", \"c\", \"k\"]], [\"moi\", \"good\", \"boyd\", \"peck\"]]", "A*_args": "[\"[['o', 'm', 'y', 'i'], ['g', 'd', 'o', 'e'], ['_', 'o', 'b', 'd'], ['p', 'o', 'c', 'k']]\", \"['moi', 'good', 'boyd', 'peck']\"]"}
{"diff_sorted_id": "18", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'Q'. Our task is to visit city K and city Y excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from Y and K, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  G J Y Q C D R F K H N \nG 0 0 0 0 0 0 1 0 0 1 0 \nJ 1 0 1 1 0 0 0 0 1 0 0 \nY 1 0 0 0 0 0 1 1 0 0 1 \nQ 0 0 0 0 0 0 0 1 0 1 0 \nC 1 1 0 0 0 0 0 0 1 0 0 \nD 1 0 1 1 0 0 0 1 0 0 0 \nR 0 1 1 1 0 1 0 0 0 1 0 \nF 0 0 0 0 0 1 1 0 0 0 0 \nK 1 0 0 0 0 0 1 1 0 1 1 \nH 0 1 1 1 1 0 0 0 0 0 0 \nN 0 1 1 0 1 1 0 1 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[\"Q\", \"F\", \"D\", \"Y\", \"N\", \"C\", \"K\", \"H\", \"Y\", \"R\", \"J\", \"K\"]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.049555063247680664", "solution_depth": "12", "max_successor_states": "11", "num_vars_per_state": "14", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0]], [\"G\", \"J\", \"Y\", \"Q\", \"C\", \"D\", \"R\", \"F\", \"K\", \"H\", \"N\"], \"K\", \"Y\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0]], [\"G\", \"J\", \"Y\", \"Q\", \"C\", \"D\", \"R\", \"F\", \"K\", \"H\", \"N\"], \"Q\", \"K\", \"Y\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0]]\", \"['G', 'J', 'Y', 'Q', 'C', 'D', 'R', 'F', 'K', 'H', 'N']\", \"['Q']\", \"['K', 'Y']\"]"}
{"diff_sorted_id": "18", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [10, 5, 6, 2, 16, 19, 18, 5, 11, 12, 11, 7, 13, 19, 11, 12, 8, 17, 5, 18, 3, 12, 10, 14, 20, 18, 10, 11, 20, 13, 8, 8, 2, 7, 17, 10, 7, 21, 9, 20, 17, 1, 8, 19, 17, 16, 17, 10, 20, 8, 16, 14, 9], such that the sum of the chosen coins adds up to 211. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {7: 2, 3: 2, 18: 1, 13: 3, 2: 2, 19: 17, 16: 6, 10: 1, 9: 9, 12: 7, 8: 7, 6: 3, 21: 18, 11: 10, 14: 13, 1: 1, 5: 5, 20: 18, 17: 14}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "32", "opt_solution": "[18, 10, 13, 10, 13, 10, 6, 7, 7, 7, 19, 18, 16, 10, 19, 18, 10]", "opt_solution_cost": "63", "opt_solution_compute_t": "0.049751996994018555", "solution_depth": "17", "max_successor_states": "53", "num_vars_per_state": "53", "is_feasible_args": "[[10, 5, 6, 2, 16, 19, 18, 5, 11, 12, 11, 7, 13, 19, 11, 12, 8, 17, 5, 18, 3, 12, 10, 14, 20, 18, 10, 11, 20, 13, 8, 8, 2, 7, 17, 10, 7, 21, 9, 20, 17, 1, 8, 19, 17, 16, 17, 10, 20, 8, 16, 14, 9]]", "is_correct_args": "[[10, 5, 6, 2, 16, 19, 18, 5, 11, 12, 11, 7, 13, 19, 11, 12, 8, 17, 5, 18, 3, 12, 10, 14, 20, 18, 10, 11, 20, 13, 8, 8, 2, 7, 17, 10, 7, 21, 9, 20, 17, 1, 8, 19, 17, 16, 17, 10, 20, 8, 16, 14, 9], {\"7\": 2, \"3\": 2, \"18\": 1, \"13\": 3, \"2\": 2, \"19\": 17, \"16\": 6, \"10\": 1, \"9\": 9, \"12\": 7, \"8\": 7, \"6\": 3, \"21\": 18, \"11\": 10, \"14\": 13, \"1\": 1, \"5\": 5, \"20\": 18, \"17\": 14}, 211]", "A*_args": "[\"[10, 5, 6, 2, 16, 19, 18, 5, 11, 12, 11, 7, 13, 19, 11, 12, 8, 17, 5, 18, 3, 12, 10, 14, 20, 18, 10, 11, 20, 13, 8, 8, 2, 7, 17, 10, 7, 21, 9, 20, 17, 1, 8, 19, 17, 16, 17, 10, 20, 8, 16, 14, 9]\", \"{7: 2, 3: 2, 18: 1, 13: 3, 2: 2, 19: 17, 16: 6, 10: 1, 9: 9, 12: 7, 8: 7, 6: 3, 21: 18, 11: 10, 14: 13, 1: 1, 5: 5, 20: 18, 17: 14}\", \"211\"]"}
{"diff_sorted_id": "18", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Green', 'Red', 'Blue'], ['Red', 'Red', 'Blue', 'Green'], ['Red', 'Green', 'Blue', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[2, 1], [0, 2], [0, 2], [0, 1], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [2, 0], [2, 1], [2, 1], [2, 1], [0, 2], [0, 2]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.4702601432800293", "solution_depth": "16", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Green\", \"Red\", \"Blue\"], [\"Red\", \"Red\", \"Blue\", \"Green\"], [\"Red\", \"Green\", \"Blue\", \"Blue\"]], 6]", "is_correct_args": "[[[\"Green\", \"Green\", \"Red\", \"Blue\"], [\"Red\", \"Red\", \"Blue\", \"Green\"], [\"Red\", \"Green\", \"Blue\", \"Blue\"]], 6]", "A*_args": "[\"[['Green', 'Green', 'Red', 'Blue'], ['Red', 'Red', 'Blue', 'Green'], ['Red', 'Green', 'Blue', 'Blue']]\", \"6\"]"}
{"diff_sorted_id": "18", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 16 to 54 (16 included in the range but 54 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['16' '17' 'x']\n ['x' 'x' 'x']\n ['x' '44' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 2, 18], [1, 0, 22], [1, 1, 21], [1, 2, 19], [2, 0, 45], [2, 2, 20]]", "opt_solution_cost": "165", "opt_solution_compute_t": "1.0585572719573975", "solution_depth": "6", "max_successor_states": "38", "num_vars_per_state": "9", "is_feasible_args": "[\"[['16', '17', ''], ['', '', ''], ['', '44', '']]\", 16, 54]", "is_correct_args": "[\"[['16', '17', ''], ['', '', ''], ['', '44', '']]\", 16, 54]", "A*_args": "[\"[['16', '17', ''], ['', '', ''], ['', '44', '']]\", \"16\", \"54\"]"}
{"diff_sorted_id": "18", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 48 to 77. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 191, and sum of row 1 must be 194. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 186. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x']\n ['x' 'x' 'x']\n ['x' '70' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 0, 49], [0, 1, 48], [0, 2, 51], [1, 0, 52], [1, 1, 73], [1, 2, 69], [2, 0, 62], [2, 2, 50]]", "opt_solution_cost": "524", "opt_solution_compute_t": "7.050852060317993", "solution_depth": "8", "max_successor_states": "29", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '', ''], ['', '70', '']]\", 3, 48, 77]", "is_correct_args": "[\"[['', '', ''], ['', '', ''], ['', '70', '']]\", 48, 77, [1, 2], [1, 2], [191], [194], 186]", "A*_args": "[\"[['', '', ''], ['', '', ''], ['', '70', '']]\", \"48\", \"77\", \"[None, 191, None]\", \"[None, 194, None]\", \"186\"]"}
{"diff_sorted_id": "18", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 7, 1: 6, 2: 2, 3: 7, 4: 7, 5: 4}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], ['Blue', 'Green', 'Yellow', 'Green'], ['Red', 'Yellow', 'Yellow', 'Green'], [], ['Red', 'Blue', 'Red', 'Blue']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[2, 1], [3, 0], [5, 0], [3, 4], [3, 4], [2, 3], [2, 4], [5, 1], [5, 0], [1, 5], [1, 5], [3, 2], [3, 2]]", "opt_solution_cost": "73", "opt_solution_compute_t": "0.037363290786743164", "solution_depth": "13", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[], [], [\"Blue\", \"Green\", \"Yellow\", \"Green\"], [\"Red\", \"Yellow\", \"Yellow\", \"Green\"], [], [\"Red\", \"Blue\", \"Red\", \"Blue\"]], 4, {\"0\": 7, \"1\": 6, \"2\": 2, \"3\": 7, \"4\": 7, \"5\": 4}]", "is_correct_args": "[[[], [], [\"Blue\", \"Green\", \"Yellow\", \"Green\"], [\"Red\", \"Yellow\", \"Yellow\", \"Green\"], [], [\"Red\", \"Blue\", \"Red\", \"Blue\"]], 4, {\"0\": 7, \"1\": 6, \"2\": 2, \"3\": 7, \"4\": 7, \"5\": 4}, 3]", "A*_args": "[\"[[], [], ['Blue', 'Green', 'Yellow', 'Green'], ['Red', 'Yellow', 'Yellow', 'Green'], [], ['Red', 'Blue', 'Red', 'Blue']]\", \"{0: 7, 1: 6, 2: 2, 3: 7, 4: 7, 5: 4}\", \"4\", \"3\"]"}
{"diff_sorted_id": "18", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (1, 8) to his destination workshop at index (4, 1), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 4, and district 3 covering rows 5 to 9. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[13 x x x x x 8 x x 6]\n[x x x 8 10 x 17 x 15 14]\n[x 6 x x x 16 12 7 8 11]\n[x 15 x 1 11 19 9 17 x x]\n[18 20 16 19 12 1 x x x 5]\n[11 x 18 14 x 2 x 9 8 1]\n[x 2 5 16 3 9 2 18 x x]\n[x 8 15 17 16 6 x 3 x 10]\n[3 x x x 8 9 10 x 6 x]\n[6 x 9 16 1 3 16 18 x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "2", "opt_solution": "[[1, 8], [2, 8], [2, 7], [2, 6], [3, 6], [3, 5], [4, 5], [5, 5], [4, 5], [4, 4], [4, 3], [4, 2], [4, 1]]", "opt_solution_cost": "126", "opt_solution_compute_t": "0.026239633560180664", "solution_depth": "13", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"8\", \"x\", \"x\", \"6\"], [\"x\", \"x\", \"x\", \"8\", \"10\", \"x\", \"17\", \"x\", \"15\", \"14\"], [\"x\", \"6\", \"x\", \"x\", \"x\", \"16\", \"12\", \"7\", \"8\", \"11\"], [\"x\", \"15\", \"x\", \"1\", \"11\", \"19\", \"9\", \"17\", \"x\", \"x\"], [\"18\", \"20\", \"16\", \"19\", \"12\", \"1\", \"x\", \"x\", \"x\", \"5\"], [\"11\", \"x\", \"18\", \"14\", \"x\", \"2\", \"x\", \"9\", \"8\", \"1\"], [\"x\", \"2\", \"5\", \"16\", \"3\", \"9\", \"2\", \"18\", \"x\", \"x\"], [\"x\", \"8\", \"15\", \"17\", \"16\", \"6\", \"x\", \"3\", \"x\", \"10\"], [\"3\", \"x\", \"x\", \"x\", \"8\", \"9\", \"10\", \"x\", \"6\", \"x\"], [\"6\", \"x\", \"9\", \"16\", \"1\", \"3\", \"16\", \"18\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"8\", \"x\", \"x\", \"6\"], [\"x\", \"x\", \"x\", \"8\", \"10\", \"x\", \"17\", \"x\", \"15\", \"14\"], [\"x\", \"6\", \"x\", \"x\", \"x\", \"16\", \"12\", \"7\", \"8\", \"11\"], [\"x\", \"15\", \"x\", \"1\", \"11\", \"19\", \"9\", \"17\", \"x\", \"x\"], [\"18\", \"20\", \"16\", \"19\", \"12\", \"1\", \"x\", \"x\", \"x\", \"5\"], [\"11\", \"x\", \"18\", \"14\", \"x\", \"2\", \"x\", \"9\", \"8\", \"1\"], [\"x\", \"2\", \"5\", \"16\", \"3\", \"9\", \"2\", \"18\", \"x\", \"x\"], [\"x\", \"8\", \"15\", \"17\", \"16\", \"6\", \"x\", \"3\", \"x\", \"10\"], [\"3\", \"x\", \"x\", \"x\", \"8\", \"9\", \"10\", \"x\", \"6\", \"x\"], [\"6\", \"x\", \"9\", \"16\", \"1\", \"3\", \"16\", \"18\", \"x\", \"x\"]], [1, 8], [4, 1], 1, 4]", "A*_args": "[\"[['13', 'x', 'x', 'x', 'x', 'x', '8', 'x', 'x', '6'], ['x', 'x', 'x', '8', '10', 'x', '17', 'x', '15', '14'], ['x', '6', 'x', 'x', 'x', '16', '12', '7', '8', '11'], ['x', '15', 'x', '1', '11', '19', '9', '17', 'x', 'x'], ['18', '20', '16', '19', '12', '1', 'x', 'x', 'x', '5'], ['11', 'x', '18', '14', 'x', '2', 'x', '9', '8', '1'], ['x', '2', '5', '16', '3', '9', '2', '18', 'x', 'x'], ['x', '8', '15', '17', '16', '6', 'x', '3', 'x', '10'], ['3', 'x', 'x', 'x', '8', '9', '10', 'x', '6', 'x'], ['6', 'x', '9', '16', '1', '3', '16', '18', 'x', 'x']]\", \"(1, 8)\", \"(4, 1)\", \"1\", \"4\"]"}
{"diff_sorted_id": "18", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 10x10. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (8, 2) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (1, 8). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 1 0 0 1 1 0 0 0\n0 0 1 1 0 0 1 1 0 0\n0 0 1 0 0 1 1 1 1 0\n0 0 1 0 0 0 0 0 0 0\n1 0 0 1 1 0 1 1 0 0\n1 0 1 0 0 1 0 1 0 0\n0 1 0 1 0 0 1 0 0 0\n0 1 1 0 0 0 0 0 0 0\n1 1 0 0 0 0 0 1 1 0\n1 1 1 1 1 1 1 1 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[[8, 2], [7, 3], [6, 4], [5, 4], [4, 5], [3, 5], [3, 6], [3, 7], [3, 8], [3, 9], [2, 9], [1, 9], [1, 8]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.031194448471069336", "solution_depth": "13", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0, 1, 1, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1, 1, 0, 1]]\", 3]", "is_correct_args": "[\"[[0, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0, 1, 1, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1, 1, 0, 1]]\", [8, 2], [1, 8], 3]", "A*_args": "[\"[[0, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0, 1, 1, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1, 1, 0, 1]]\", \"(8, 2)\", \"(1, 8)\", \"3\"]"}
{"diff_sorted_id": "18", "problem_statement": "Given 5 labeled water jugs with capacities 71, 124, 95, 42, 56, 41 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 291, 292, 326 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "4", "opt_solution": "[[\"+\", 95, 3], [\"+\", 95, 3], [\"+\", 95, 3], [\"+\", 41, 3], [\"+\", 56, 2], [\"+\", 71, 2], [\"+\", 124, 2], [\"+\", 41, 2], [\"+\", 42, 1], [\"+\", 95, 1], [\"+\", 124, 1], [\"-\", 41, 1], [\"+\", 71, 1]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.03421187400817871", "solution_depth": "13", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[71, 124, 95, 42, 56, 41], [291, 292, 326]]", "is_correct_args": "[[71, 124, 95, 42, 56, 41], [291, 292, 326]]", "A*_args": "[\"[71, 124, 95, 42, 56, 41]\", \"[291, 292, 326]\"]"}
{"diff_sorted_id": "19", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[89, 69, 35], [16, 14, 64], ['_', 23, 32]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[16, 89, 69, 35, 64, 32, 23, 14, 35, 69, 89, 35, 32, 23]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.030463218688964844", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[89, 69, 35], [16, 14, 64], [\"_\", 23, 32]]]", "is_correct_args": "[[[89, 69, 35], [16, 14, 64], [\"_\", 23, 32]]]", "A*_args": "[\"[[89, 69, 35], [16, 14, 64], ['_', 23, 32]]\"]"}
{"diff_sorted_id": "19", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: aeon, plier, gazon, ileum   The initial board: [['l', 'a', 'e', 'o', 'n'], ['p', 'z', 'i', 'n', 'r'], ['l', 'a', 'g', 'o', '_'], ['i', 'e', 'e', 'u', 'm']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"up-left\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.19801783561706543", "solution_depth": "12", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"l\", \"a\", \"e\", \"o\", \"n\"], [\"p\", \"z\", \"i\", \"n\", \"r\"], [\"l\", \"a\", \"g\", \"o\", \"_\"], [\"i\", \"e\", \"e\", \"u\", \"m\"]]]", "is_correct_args": "[[[\"l\", \"a\", \"e\", \"o\", \"n\"], [\"p\", \"z\", \"i\", \"n\", \"r\"], [\"l\", \"a\", \"g\", \"o\", \"_\"], [\"i\", \"e\", \"e\", \"u\", \"m\"]], [\"aeon\", \"plier\", \"gazon\", \"ileum\"]]", "A*_args": "[\"[['l', 'a', 'e', 'o', 'n'], ['p', 'z', 'i', 'n', 'r'], ['l', 'a', 'g', 'o', '_'], ['i', 'e', 'e', 'u', 'm']]\", \"['aeon', 'plier', 'gazon', 'ileum']\"]"}
{"diff_sorted_id": "19", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'E'. Our task is to visit city Y and city T excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from T and Y, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  J X U I R T Y B M D E \nJ 0 0 0 1 1 0 0 0 1 1 0 \nX 0 0 0 0 1 1 0 0 0 0 0 \nU 1 1 0 0 0 1 0 1 0 0 1 \nI 0 0 1 0 0 0 0 0 0 0 0 \nR 0 0 0 1 0 0 1 0 1 0 0 \nT 1 0 0 1 0 0 0 1 0 0 0 \nY 0 0 0 1 0 1 0 0 0 1 0 \nB 0 1 0 0 1 0 0 0 0 0 1 \nM 0 0 0 1 0 0 1 0 0 0 0 \nD 0 1 0 0 1 0 0 0 0 0 1 \nE 1 1 0 1 0 0 0 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[\"E\", \"M\", \"Y\", \"T\", \"B\", \"R\", \"Y\", \"T\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.022693395614624023", "solution_depth": "8", "max_successor_states": "11", "num_vars_per_state": "14", "is_feasible_args": "[[[0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [\"J\", \"X\", \"U\", \"I\", \"R\", \"T\", \"Y\", \"B\", \"M\", \"D\", \"E\"], \"Y\", \"T\"]", "is_correct_args": "[[[0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [\"J\", \"X\", \"U\", \"I\", \"R\", \"T\", \"Y\", \"B\", \"M\", \"D\", \"E\"], \"E\", \"Y\", \"T\"]", "A*_args": "[\"[[0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]]\", \"['J', 'X', 'U', 'I', 'R', 'T', 'Y', 'B', 'M', 'D', 'E']\", \"['E']\", \"['Y', 'T']\"]"}
{"diff_sorted_id": "19", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [9, 20, 4, 23, 10, 11, 8, 6, 20, 8, 20, 12, 15, 20, 18, 16, 19, 21, 5, 6, 4, 5, 14, 5, 4, 18, 22, 7, 8, 15, 5, 15, 8, 19, 14, 12, 2, 5, 5, 15, 2, 6, 10, 18, 14, 13, 8, 10, 21, 14, 5, 18, 16, 6, 11], such that the sum of the chosen coins adds up to 243. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {20: 3, 9: 2, 23: 1, 10: 3, 5: 4, 21: 14, 22: 5, 18: 7, 16: 4, 13: 5, 2: 1, 8: 2, 19: 16, 7: 3, 6: 6, 11: 3, 14: 8, 4: 2, 12: 7, 15: 14}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "33", "opt_solution": "[20, 23, 22, 20, 16, 8, 11, 10, 8, 11, 10, 8, 13, 10, 8, 4, 2, 9, 8, 4, 2, 7, 4, 5]", "opt_solution_cost": "63", "opt_solution_compute_t": "0.05074810981750488", "solution_depth": "24", "max_successor_states": "55", "num_vars_per_state": "55", "is_feasible_args": "[[9, 20, 4, 23, 10, 11, 8, 6, 20, 8, 20, 12, 15, 20, 18, 16, 19, 21, 5, 6, 4, 5, 14, 5, 4, 18, 22, 7, 8, 15, 5, 15, 8, 19, 14, 12, 2, 5, 5, 15, 2, 6, 10, 18, 14, 13, 8, 10, 21, 14, 5, 18, 16, 6, 11]]", "is_correct_args": "[[9, 20, 4, 23, 10, 11, 8, 6, 20, 8, 20, 12, 15, 20, 18, 16, 19, 21, 5, 6, 4, 5, 14, 5, 4, 18, 22, 7, 8, 15, 5, 15, 8, 19, 14, 12, 2, 5, 5, 15, 2, 6, 10, 18, 14, 13, 8, 10, 21, 14, 5, 18, 16, 6, 11], {\"20\": 3, \"9\": 2, \"23\": 1, \"10\": 3, \"5\": 4, \"21\": 14, \"22\": 5, \"18\": 7, \"16\": 4, \"13\": 5, \"2\": 1, \"8\": 2, \"19\": 16, \"7\": 3, \"6\": 6, \"11\": 3, \"14\": 8, \"4\": 2, \"12\": 7, \"15\": 14}, 243]", "A*_args": "[\"[9, 20, 4, 23, 10, 11, 8, 6, 20, 8, 20, 12, 15, 20, 18, 16, 19, 21, 5, 6, 4, 5, 14, 5, 4, 18, 22, 7, 8, 15, 5, 15, 8, 19, 14, 12, 2, 5, 5, 15, 2, 6, 10, 18, 14, 13, 8, 10, 21, 14, 5, 18, 16, 6, 11]\", \"{20: 3, 9: 2, 23: 1, 10: 3, 5: 4, 21: 14, 22: 5, 18: 7, 16: 4, 13: 5, 2: 1, 8: 2, 19: 16, 7: 3, 6: 6, 11: 3, 14: 8, 4: 2, 12: 7, 15: 14}\", \"243\"]"}
{"diff_sorted_id": "19", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Green', 'Red'], ['Red', 'Blue', 'Green', 'Red'], ['Blue', 'Red', 'Green', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[0, 1], [0, 2], [0, 2], [0, 1], [2, 0], [2, 0], [1, 0], [2, 1], [2, 0], [2, 0], [1, 2], [1, 2], [1, 0], [1, 2], [1, 2], [0, 1], [0, 2], [0, 1], [0, 1], [2, 0], [2, 0]]", "opt_solution_cost": "21", "opt_solution_compute_t": "4.620145320892334", "solution_depth": "21", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Green\", \"Red\"], [\"Red\", \"Blue\", \"Green\", \"Red\"], [\"Blue\", \"Red\", \"Green\", \"Blue\"]], 6]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Green\", \"Red\"], [\"Red\", \"Blue\", \"Green\", \"Red\"], [\"Blue\", \"Red\", \"Green\", \"Blue\"]], 6]", "A*_args": "[\"[['Blue', 'Green', 'Green', 'Red'], ['Red', 'Blue', 'Green', 'Red'], ['Blue', 'Red', 'Green', 'Blue']]\", \"6\"]"}
{"diff_sorted_id": "19", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 48 to 91 (48 included in the range but 91 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' '85']\n ['58' 'x' '84']\n ['x' '74' '59']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 48], [0, 1, 49], [1, 1, 60], [2, 0, 75]]", "opt_solution_cost": "577", "opt_solution_compute_t": "0.17565202713012695", "solution_depth": "4", "max_successor_states": "43", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', '85'], ['58', '', '84'], ['', '74', '59']]\", 48, 91]", "is_correct_args": "[\"[['', '', '85'], ['58', '', '84'], ['', '74', '59']]\", 48, 91]", "A*_args": "[\"[['', '', '85'], ['58', '', '84'], ['', '74', '59']]\", \"48\", \"91\"]"}
{"diff_sorted_id": "19", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 50 to 84. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 234, and sum of row 1 must be 201. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 213. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['64' '78' 'x']\n ['x' 'x' 'x']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 2, 51], [1, 0, 52], [1, 1, 83], [1, 2, 66], [2, 0, 79], [2, 1, 73], [2, 2, 50]]", "opt_solution_cost": "596", "opt_solution_compute_t": "7.28009295463562", "solution_depth": "7", "max_successor_states": "29", "num_vars_per_state": "9", "is_feasible_args": "[\"[['64', '78', ''], ['', '', ''], ['', '', '']]\", 3, 50, 84]", "is_correct_args": "[\"[['64', '78', ''], ['', '', ''], ['', '', '']]\", 50, 84, [1, 2], [1, 2], [234], [201], 213]", "A*_args": "[\"[['64', '78', ''], ['', '', ''], ['', '', '']]\", \"50\", \"84\", \"[None, 234, None]\", \"[None, 201, None]\", \"213\"]"}
{"diff_sorted_id": "19", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 2, 1: 4, 2: 6, 3: 6, 4: 6, 5: 7}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], ['Green', 'Blue', 'Green', 'Yellow'], [], ['Red', 'Red', 'Yellow', 'Blue'], ['Green', 'Red', 'Blue', 'Yellow']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[5, 0], [2, 0], [2, 1], [2, 0], [5, 3], [5, 1], [4, 3], [4, 3], [4, 2], [5, 2], [4, 1]]", "opt_solution_cost": "48", "opt_solution_compute_t": "0.03397560119628906", "solution_depth": "11", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[], [], [\"Green\", \"Blue\", \"Green\", \"Yellow\"], [], [\"Red\", \"Red\", \"Yellow\", \"Blue\"], [\"Green\", \"Red\", \"Blue\", \"Yellow\"]], 4, {\"0\": 2, \"1\": 4, \"2\": 6, \"3\": 6, \"4\": 6, \"5\": 7}]", "is_correct_args": "[[[], [], [\"Green\", \"Blue\", \"Green\", \"Yellow\"], [], [\"Red\", \"Red\", \"Yellow\", \"Blue\"], [\"Green\", \"Red\", \"Blue\", \"Yellow\"]], 4, {\"0\": 2, \"1\": 4, \"2\": 6, \"3\": 6, \"4\": 6, \"5\": 7}, 3]", "A*_args": "[\"[[], [], ['Green', 'Blue', 'Green', 'Yellow'], [], ['Red', 'Red', 'Yellow', 'Blue'], ['Green', 'Red', 'Blue', 'Yellow']]\", \"{0: 2, 1: 4, 2: 6, 3: 6, 4: 6, 5: 7}\", \"4\", \"3\"]"}
{"diff_sorted_id": "19", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (5, 0) to his destination workshop at index (3, 9), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 5, and district 3 covering rows 6 to 9. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 16 15 14 2 12 3 x 7 7]\n[11 x x x 4 10 5 x x x]\n[12 x 3 x x 19 x 13 x x]\n[16 15 13 x 12 x x 1 x 7]\n[2 6 x 5 x 14 7 x 8 18]\n[19 17 2 11 8 17 12 8 9 14]\n[11 1 10 11 x x 19 6 2 18]\n[7 x 10 15 x x x x 18 17]\n[x 6 x x x 5 x 7 12 20]\n[x x 2 15 x 17 x x 10 11]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "2", "opt_solution": "[[5, 0], [6, 0], [6, 1], [6, 2], [5, 2], [5, 3], [5, 4], [5, 5], [5, 6], [5, 7], [5, 8], [4, 8], [4, 9], [3, 9]]", "opt_solution_cost": "122", "opt_solution_compute_t": "0.027219295501708984", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"16\", \"15\", \"14\", \"2\", \"12\", \"3\", \"x\", \"7\", \"7\"], [\"11\", \"x\", \"x\", \"x\", \"4\", \"10\", \"5\", \"x\", \"x\", \"x\"], [\"12\", \"x\", \"3\", \"x\", \"x\", \"19\", \"x\", \"13\", \"x\", \"x\"], [\"16\", \"15\", \"13\", \"x\", \"12\", \"x\", \"x\", \"1\", \"x\", \"7\"], [\"2\", \"6\", \"x\", \"5\", \"x\", \"14\", \"7\", \"x\", \"8\", \"18\"], [\"19\", \"17\", \"2\", \"11\", \"8\", \"17\", \"12\", \"8\", \"9\", \"14\"], [\"11\", \"1\", \"10\", \"11\", \"x\", \"x\", \"19\", \"6\", \"2\", \"18\"], [\"7\", \"x\", \"10\", \"15\", \"x\", \"x\", \"x\", \"x\", \"18\", \"17\"], [\"x\", \"6\", \"x\", \"x\", \"x\", \"5\", \"x\", \"7\", \"12\", \"20\"], [\"x\", \"x\", \"2\", \"15\", \"x\", \"17\", \"x\", \"x\", \"10\", \"11\"]]]", "is_correct_args": "[[[\"x\", \"16\", \"15\", \"14\", \"2\", \"12\", \"3\", \"x\", \"7\", \"7\"], [\"11\", \"x\", \"x\", \"x\", \"4\", \"10\", \"5\", \"x\", \"x\", \"x\"], [\"12\", \"x\", \"3\", \"x\", \"x\", \"19\", \"x\", \"13\", \"x\", \"x\"], [\"16\", \"15\", \"13\", \"x\", \"12\", \"x\", \"x\", \"1\", \"x\", \"7\"], [\"2\", \"6\", \"x\", \"5\", \"x\", \"14\", \"7\", \"x\", \"8\", \"18\"], [\"19\", \"17\", \"2\", \"11\", \"8\", \"17\", \"12\", \"8\", \"9\", \"14\"], [\"11\", \"1\", \"10\", \"11\", \"x\", \"x\", \"19\", \"6\", \"2\", \"18\"], [\"7\", \"x\", \"10\", \"15\", \"x\", \"x\", \"x\", \"x\", \"18\", \"17\"], [\"x\", \"6\", \"x\", \"x\", \"x\", \"5\", \"x\", \"7\", \"12\", \"20\"], [\"x\", \"x\", \"2\", \"15\", \"x\", \"17\", \"x\", \"x\", \"10\", \"11\"]], [5, 0], [3, 9], 3, 5]", "A*_args": "[\"[['x', '16', '15', '14', '2', '12', '3', 'x', '7', '7'], ['11', 'x', 'x', 'x', '4', '10', '5', 'x', 'x', 'x'], ['12', 'x', '3', 'x', 'x', '19', 'x', '13', 'x', 'x'], ['16', '15', '13', 'x', '12', 'x', 'x', '1', 'x', '7'], ['2', '6', 'x', '5', 'x', '14', '7', 'x', '8', '18'], ['19', '17', '2', '11', '8', '17', '12', '8', '9', '14'], ['11', '1', '10', '11', 'x', 'x', '19', '6', '2', '18'], ['7', 'x', '10', '15', 'x', 'x', 'x', 'x', '18', '17'], ['x', '6', 'x', 'x', 'x', '5', 'x', '7', '12', '20'], ['x', 'x', '2', '15', 'x', '17', 'x', 'x', '10', '11']]\", \"(5, 0)\", \"(3, 9)\", \"3\", \"5\"]"}
{"diff_sorted_id": "19", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 10x10. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 9) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (7, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 1 1 0 0 0 0 0 1\n0 0 0 0 0 1 0 0 0 0\n0 1 1 0 0 1 0 0 0 1\n0 0 1 0 1 1 0 0 1 1\n1 0 1 1 1 0 1 0 1 1\n1 0 1 1 1 1 1 1 1 1\n0 0 0 1 1 0 0 1 1 1\n1 0 1 1 1 0 1 1 1 0\n1 1 1 1 1 1 0 1 1 0\n1 1 1 0 1 0 1 0 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[[1, 9], [1, 8], [1, 7], [1, 6], [0, 5], [0, 4], [1, 4], [1, 3], [1, 2], [1, 1], [2, 0], [3, 0], [4, 1], [5, 1], [6, 1], [7, 1]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.029511690139770508", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 1, 1, 0, 0, 1, 1], [1, 0, 1, 1, 1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 1, 1, 0, 0, 1, 1, 1], [1, 0, 1, 1, 1, 0, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1, 0, 1, 1, 0], [1, 1, 1, 0, 1, 0, 1, 0, 1, 1]]\", 3]", "is_correct_args": "[\"[[1, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 1, 1, 0, 0, 1, 1], [1, 0, 1, 1, 1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 1, 1, 0, 0, 1, 1, 1], [1, 0, 1, 1, 1, 0, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1, 0, 1, 1, 0], [1, 1, 1, 0, 1, 0, 1, 0, 1, 1]]\", [1, 9], [7, 1], 3]", "A*_args": "[\"[[1, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 1, 1, 0, 0, 1, 1], [1, 0, 1, 1, 1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 1, 1, 0, 0, 1, 1, 1], [1, 0, 1, 1, 1, 0, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1, 0, 1, 1, 0], [1, 1, 1, 0, 1, 0, 1, 0, 1, 1]]\", \"(1, 9)\", \"(7, 1)\", \"3\"]"}
{"diff_sorted_id": "19", "problem_statement": "Given 7 labeled water jugs with capacities 21, 62, 98, 143, 61, 110, 140, 40 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 280, 338, 353 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 110, 3], [\"+\", 140, 3], [\"-\", 40, 3], [\"+\", 143, 3], [\"+\", 140, 2], [\"+\", 140, 2], [\"-\", 40, 2], [\"+\", 98, 2], [\"+\", 140, 1], [\"+\", 140, 1]]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.0442960262298584", "solution_depth": "10", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[21, 62, 98, 143, 61, 110, 140, 40], [280, 338, 353]]", "is_correct_args": "[[21, 62, 98, 143, 61, 110, 140, 40], [280, 338, 353]]", "A*_args": "[\"[21, 62, 98, 143, 61, 110, 140, 40]\", \"[280, 338, 353]\"]"}
{"diff_sorted_id": "20", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[46, 50, 97], [92, 49, 99], [91, 25, '_']]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[99, 49, 92, 91, 25, 99, 49, 92, 91, 46, 50, 91, 99, 25, 46, 50, 91, 99, 50, 91, 99, 97, 92, 49]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.10476183891296387", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[46, 50, 97], [92, 49, 99], [91, 25, \"_\"]]]", "is_correct_args": "[[[46, 50, 97], [92, 49, 99], [91, 25, \"_\"]]]", "A*_args": "[\"[[46, 50, 97], [92, 49, 99], [91, 25, '_']]\"]"}
{"diff_sorted_id": "20", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: snog, trema, mosur, awiwi   The initial board: [['r', 's', 'w', 'o', 'g'], ['t', 'n', 'e', 'm', 'a'], ['m', 'o', '_', 'u', 's'], ['a', 'w', 'i', 'r', 'i']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.2547872066497803", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"r\", \"s\", \"w\", \"o\", \"g\"], [\"t\", \"n\", \"e\", \"m\", \"a\"], [\"m\", \"o\", \"_\", \"u\", \"s\"], [\"a\", \"w\", \"i\", \"r\", \"i\"]]]", "is_correct_args": "[[[\"r\", \"s\", \"w\", \"o\", \"g\"], [\"t\", \"n\", \"e\", \"m\", \"a\"], [\"m\", \"o\", \"_\", \"u\", \"s\"], [\"a\", \"w\", \"i\", \"r\", \"i\"]], [\"snog\", \"trema\", \"mosur\", \"awiwi\"]]", "A*_args": "[\"[['r', 's', 'w', 'o', 'g'], ['t', 'n', 'e', 'm', 'a'], ['m', 'o', '_', 'u', 's'], ['a', 'w', 'i', 'r', 'i']]\", \"['snog', 'trema', 'mosur', 'awiwi']\"]"}
{"diff_sorted_id": "20", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'F'. Our task is to visit city N and city I excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from I and N, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  F I Y R X Q M S C D N \nF 0 0 0 0 0 0 0 0 0 1 0 \nI 0 0 0 1 0 0 0 0 0 0 0 \nY 0 0 0 0 0 0 0 0 0 0 1 \nR 1 0 0 0 0 0 1 0 0 1 0 \nX 0 0 0 1 0 1 0 0 0 0 0 \nQ 0 1 0 0 0 0 1 0 0 0 0 \nM 1 0 0 1 1 0 0 0 0 0 1 \nS 1 1 0 0 1 1 0 0 0 0 0 \nC 0 1 1 1 0 0 0 1 0 0 0 \nD 0 0 1 0 1 0 1 0 0 0 0 \nN 0 0 0 0 1 0 0 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[\"F\", \"D\", \"Y\", \"N\", \"C\", \"I\", \"R\", \"M\", \"N\", \"X\", \"Q\", \"I\"]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.029342174530029297", "solution_depth": "12", "max_successor_states": "11", "num_vars_per_state": "14", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]], [\"F\", \"I\", \"Y\", \"R\", \"X\", \"Q\", \"M\", \"S\", \"C\", \"D\", \"N\"], \"N\", \"I\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]], [\"F\", \"I\", \"Y\", \"R\", \"X\", \"Q\", \"M\", \"S\", \"C\", \"D\", \"N\"], \"F\", \"N\", \"I\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0]]\", \"['F', 'I', 'Y', 'R', 'X', 'Q', 'M', 'S', 'C', 'D', 'N']\", \"['F']\", \"['N', 'I']\"]"}
{"diff_sorted_id": "20", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [12, 15, 3, 24, 10, 18, 10, 20, 21, 17, 9, 8, 2, 11, 5, 5, 3, 8, 6, 12, 20, 22, 4, 5, 17, 5, 14, 10, 15, 8, 9, 22, 4, 7, 15, 16, 4, 2, 5, 9, 24, 23, 3, 7, 20, 9, 12, 10, 4, 4, 8, 24, 11, 20, 2, 15], such that the sum of the chosen coins adds up to 246. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {20: 14, 15: 15, 6: 1, 14: 1, 7: 2, 18: 5, 2: 1, 16: 5, 21: 9, 3: 3, 12: 3, 17: 10, 22: 4, 10: 9, 4: 3, 11: 1, 5: 1, 23: 13, 24: 4, 9: 9, 8: 4}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "34", "opt_solution": "[24, 22, 2, 5, 11, 2, 5, 11, 2, 5, 5, 5, 7, 6, 21, 16, 14, 12, 23, 22, 18, 8]", "opt_solution_cost": "65", "opt_solution_compute_t": "0.05625104904174805", "solution_depth": "22", "max_successor_states": "56", "num_vars_per_state": "56", "is_feasible_args": "[[12, 15, 3, 24, 10, 18, 10, 20, 21, 17, 9, 8, 2, 11, 5, 5, 3, 8, 6, 12, 20, 22, 4, 5, 17, 5, 14, 10, 15, 8, 9, 22, 4, 7, 15, 16, 4, 2, 5, 9, 24, 23, 3, 7, 20, 9, 12, 10, 4, 4, 8, 24, 11, 20, 2, 15]]", "is_correct_args": "[[12, 15, 3, 24, 10, 18, 10, 20, 21, 17, 9, 8, 2, 11, 5, 5, 3, 8, 6, 12, 20, 22, 4, 5, 17, 5, 14, 10, 15, 8, 9, 22, 4, 7, 15, 16, 4, 2, 5, 9, 24, 23, 3, 7, 20, 9, 12, 10, 4, 4, 8, 24, 11, 20, 2, 15], {\"20\": 14, \"15\": 15, \"6\": 1, \"14\": 1, \"7\": 2, \"18\": 5, \"2\": 1, \"16\": 5, \"21\": 9, \"3\": 3, \"12\": 3, \"17\": 10, \"22\": 4, \"10\": 9, \"4\": 3, \"11\": 1, \"5\": 1, \"23\": 13, \"24\": 4, \"9\": 9, \"8\": 4}, 246]", "A*_args": "[\"[12, 15, 3, 24, 10, 18, 10, 20, 21, 17, 9, 8, 2, 11, 5, 5, 3, 8, 6, 12, 20, 22, 4, 5, 17, 5, 14, 10, 15, 8, 9, 22, 4, 7, 15, 16, 4, 2, 5, 9, 24, 23, 3, 7, 20, 9, 12, 10, 4, 4, 8, 24, 11, 20, 2, 15]\", \"{20: 14, 15: 15, 6: 1, 14: 1, 7: 2, 18: 5, 2: 1, 16: 5, 21: 9, 3: 3, 12: 3, 17: 10, 22: 4, 10: 9, 4: 3, 11: 1, 5: 1, 23: 13, 24: 4, 9: 9, 8: 4}\", \"246\"]"}
{"diff_sorted_id": "20", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Red', 'Green', 'Blue'], ['Green', 'Green', 'Red', 'Green'], ['Blue', 'Blue', 'Red', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[1, 2], [1, 2], [1, 0], [2, 1], [2, 1], [2, 1], [2, 1], [2, 0], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [2, 1]]", "opt_solution_cost": "18", "opt_solution_compute_t": "1.1464557647705078", "solution_depth": "18", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Red\", \"Green\", \"Blue\"], [\"Green\", \"Green\", \"Red\", \"Green\"], [\"Blue\", \"Blue\", \"Red\", \"Blue\"]], 6]", "is_correct_args": "[[[\"Red\", \"Red\", \"Green\", \"Blue\"], [\"Green\", \"Green\", \"Red\", \"Green\"], [\"Blue\", \"Blue\", \"Red\", \"Blue\"]], 6]", "A*_args": "[\"[['Red', 'Red', 'Green', 'Blue'], ['Green', 'Green', 'Red', 'Green'], ['Blue', 'Blue', 'Red', 'Blue']]\", \"6\"]"}
{"diff_sorted_id": "20", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 48 to 91 (48 included in the range but 91 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['80' 'x' 'x']\n ['56' 'x' '64']\n ['51' 'x' '76']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 1, 49], [0, 2, 48], [1, 1, 57], [2, 1, 58]]", "opt_solution_cost": "578", "opt_solution_compute_t": "0.17241978645324707", "solution_depth": "4", "max_successor_states": "43", "num_vars_per_state": "9", "is_feasible_args": "[\"[['80', '', ''], ['56', '', '64'], ['51', '', '76']]\", 48, 91]", "is_correct_args": "[\"[['80', '', ''], ['56', '', '64'], ['51', '', '76']]\", 48, 91]", "A*_args": "[\"[['80', '', ''], ['56', '', '64'], ['51', '', '76']]\", \"48\", \"91\"]"}
{"diff_sorted_id": "20", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 50 to 84. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 233, and sum of row 1 must be 207. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 185. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['62' '82' 'x']\n ['x' 'x' 'x']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 2, 50], [1, 0, 53], [1, 1, 83], [1, 2, 71], [2, 0, 52], [2, 1, 68], [2, 2, 51]]", "opt_solution_cost": "572", "opt_solution_compute_t": "3.969967842102051", "solution_depth": "7", "max_successor_states": "29", "num_vars_per_state": "9", "is_feasible_args": "[\"[['62', '82', ''], ['', '', ''], ['', '', '']]\", 3, 50, 84]", "is_correct_args": "[\"[['62', '82', ''], ['', '', ''], ['', '', '']]\", 50, 84, [1, 2], [1, 2], [233], [207], 185]", "A*_args": "[\"[['62', '82', ''], ['', '', ''], ['', '', '']]\", \"50\", \"84\", \"[None, 233, None]\", \"[None, 207, None]\", \"185\"]"}
{"diff_sorted_id": "20", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 4, 1: 2, 2: 5, 3: 2, 4: 4, 5: 1}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Green', 'Red', 'Yellow', 'Blue'], [], ['Red', 'Blue', 'Yellow', 'Green'], ['Red', 'Yellow', 'Blue', 'Green'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[1, 2], [1, 0], [3, 0], [4, 0], [1, 5], [3, 1], [4, 5], [4, 1], [3, 5], [2, 3], [4, 3]]", "opt_solution_cost": "28", "opt_solution_compute_t": "0.036955833435058594", "solution_depth": "11", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[], [\"Green\", \"Red\", \"Yellow\", \"Blue\"], [], [\"Red\", \"Blue\", \"Yellow\", \"Green\"], [\"Red\", \"Yellow\", \"Blue\", \"Green\"], []], 4, {\"0\": 4, \"1\": 2, \"2\": 5, \"3\": 2, \"4\": 4, \"5\": 1}]", "is_correct_args": "[[[], [\"Green\", \"Red\", \"Yellow\", \"Blue\"], [], [\"Red\", \"Blue\", \"Yellow\", \"Green\"], [\"Red\", \"Yellow\", \"Blue\", \"Green\"], []], 4, {\"0\": 4, \"1\": 2, \"2\": 5, \"3\": 2, \"4\": 4, \"5\": 1}, 3]", "A*_args": "[\"[[], ['Green', 'Red', 'Yellow', 'Blue'], [], ['Red', 'Blue', 'Yellow', 'Green'], ['Red', 'Yellow', 'Blue', 'Green'], []]\", \"{0: 4, 1: 2, 2: 5, 3: 2, 4: 4, 5: 1}\", \"4\", \"3\"]"}
{"diff_sorted_id": "20", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (6, 0) to his destination workshop at index (4, 9), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 5, and district 3 covering rows 6 to 9. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[19 x 7 x 12 x 15 5 19 14]\n[17 x 3 5 7 x x x 17 20]\n[x 11 15 8 x 16 4 x 1 1]\n[x 8 19 4 3 3 3 17 8 15]\n[13 10 17 17 6 1 x 8 13 20]\n[20 x x x x 4 18 4 17 x]\n[5 x x 10 x x 14 2 5 x]\n[7 x 4 x x x 15 x x x]\n[18 x 18 x 4 x x x 17 x]\n[x x x x x x x 13 x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "2", "opt_solution": "[[6, 0], [5, 0], [4, 0], [4, 1], [3, 1], [3, 2], [3, 3], [3, 4], [3, 5], [3, 6], [3, 7], [3, 8], [4, 8], [4, 9]]", "opt_solution_cost": "141", "opt_solution_compute_t": "0.029550790786743164", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"19\", \"x\", \"7\", \"x\", \"12\", \"x\", \"15\", \"5\", \"19\", \"14\"], [\"17\", \"x\", \"3\", \"5\", \"7\", \"x\", \"x\", \"x\", \"17\", \"20\"], [\"x\", \"11\", \"15\", \"8\", \"x\", \"16\", \"4\", \"x\", \"1\", \"1\"], [\"x\", \"8\", \"19\", \"4\", \"3\", \"3\", \"3\", \"17\", \"8\", \"15\"], [\"13\", \"10\", \"17\", \"17\", \"6\", \"1\", \"x\", \"8\", \"13\", \"20\"], [\"20\", \"x\", \"x\", \"x\", \"x\", \"4\", \"18\", \"4\", \"17\", \"x\"], [\"5\", \"x\", \"x\", \"10\", \"x\", \"x\", \"14\", \"2\", \"5\", \"x\"], [\"7\", \"x\", \"4\", \"x\", \"x\", \"x\", \"15\", \"x\", \"x\", \"x\"], [\"18\", \"x\", \"18\", \"x\", \"4\", \"x\", \"x\", \"x\", \"17\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"13\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"19\", \"x\", \"7\", \"x\", \"12\", \"x\", \"15\", \"5\", \"19\", \"14\"], [\"17\", \"x\", \"3\", \"5\", \"7\", \"x\", \"x\", \"x\", \"17\", \"20\"], [\"x\", \"11\", \"15\", \"8\", \"x\", \"16\", \"4\", \"x\", \"1\", \"1\"], [\"x\", \"8\", \"19\", \"4\", \"3\", \"3\", \"3\", \"17\", \"8\", \"15\"], [\"13\", \"10\", \"17\", \"17\", \"6\", \"1\", \"x\", \"8\", \"13\", \"20\"], [\"20\", \"x\", \"x\", \"x\", \"x\", \"4\", \"18\", \"4\", \"17\", \"x\"], [\"5\", \"x\", \"x\", \"10\", \"x\", \"x\", \"14\", \"2\", \"5\", \"x\"], [\"7\", \"x\", \"4\", \"x\", \"x\", \"x\", \"15\", \"x\", \"x\", \"x\"], [\"18\", \"x\", \"18\", \"x\", \"4\", \"x\", \"x\", \"x\", \"17\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"13\", \"x\", \"x\"]], [6, 0], [4, 9], 3, 5]", "A*_args": "[\"[['19', 'x', '7', 'x', '12', 'x', '15', '5', '19', '14'], ['17', 'x', '3', '5', '7', 'x', 'x', 'x', '17', '20'], ['x', '11', '15', '8', 'x', '16', '4', 'x', '1', '1'], ['x', '8', '19', '4', '3', '3', '3', '17', '8', '15'], ['13', '10', '17', '17', '6', '1', 'x', '8', '13', '20'], ['20', 'x', 'x', 'x', 'x', '4', '18', '4', '17', 'x'], ['5', 'x', 'x', '10', 'x', 'x', '14', '2', '5', 'x'], ['7', 'x', '4', 'x', 'x', 'x', '15', 'x', 'x', 'x'], ['18', 'x', '18', 'x', '4', 'x', 'x', 'x', '17', 'x'], ['x', 'x', 'x', 'x', 'x', 'x', 'x', '13', 'x', 'x']]\", \"(6, 0)\", \"(4, 9)\", \"3\", \"5\"]"}
{"diff_sorted_id": "20", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 10x10. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (7, 6). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 1 1 1 1 0 1 1 0\n1 0 1 1 1 1 0 1 0 0\n0 0 0 1 1 0 0 1 1 1\n1 0 1 1 1 0 0 0 1 1\n0 0 1 1 1 1 0 0 1 1\n0 0 0 1 1 0 0 0 1 1\n0 0 0 0 1 0 0 0 1 1\n0 0 0 0 0 0 0 0 1 1\n1 0 1 0 0 0 0 1 0 0\n0 0 1 0 1 1 1 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[[0, 0], [0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 2], [6, 3], [7, 4], [7, 5], [7, 6]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.03641462326049805", "solution_depth": "11", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 1, 1, 1, 1, 0, 1, 1, 0], [1, 0, 1, 1, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 1, 1], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1], [0, 0, 1, 1, 1, 1, 0, 0, 1, 1], [0, 0, 0, 1, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 1, 1, 1, 1, 1]]\", 3]", "is_correct_args": "[\"[[0, 0, 1, 1, 1, 1, 0, 1, 1, 0], [1, 0, 1, 1, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 1, 1], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1], [0, 0, 1, 1, 1, 1, 0, 0, 1, 1], [0, 0, 0, 1, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 1, 1, 1, 1, 1]]\", [0, 0], [7, 6], 3]", "A*_args": "[\"[[0, 0, 1, 1, 1, 1, 0, 1, 1, 0], [1, 0, 1, 1, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 1, 1], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1], [0, 0, 1, 1, 1, 1, 0, 0, 1, 1], [0, 0, 0, 1, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 1, 1, 1, 1, 1]]\", \"(0, 0)\", \"(7, 6)\", \"3\"]"}
{"diff_sorted_id": "20", "problem_statement": "Given 7 labeled water jugs with capacities 76, 48, 35, 94, 93, 115, 16, 53 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 247, 261, 273 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 48, 3], [\"+\", 94, 3], [\"+\", 16, 3], [\"+\", 115, 3], [\"+\", 93, 2], [\"+\", 115, 2], [\"+\", 53, 2], [\"+\", 76, 1], [\"+\", 93, 1], [\"-\", 16, 1], [\"+\", 94, 1]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.03790163993835449", "solution_depth": "11", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[76, 48, 35, 94, 93, 115, 16, 53], [247, 261, 273]]", "is_correct_args": "[[76, 48, 35, 94, 93, 115, 16, 53], [247, 261, 273]]", "A*_args": "[\"[76, 48, 35, 94, 93, 115, 16, 53]\", \"[247, 261, 273]\"]"}
{"diff_sorted_id": "21", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[25, 71, 58], [61, 94, 53], [50, 18, '_']]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[53, 94, 61, 25, 71, 58, 94, 61, 18, 50, 25, 71, 58, 94, 61, 53, 50, 18, 71, 58, 94, 71, 53, 50]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.061148881912231445", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[25, 71, 58], [61, 94, 53], [50, 18, \"_\"]]]", "is_correct_args": "[[[25, 71, 58], [61, 94, 53], [50, 18, \"_\"]]]", "A*_args": "[\"[[25, 71, 58], [61, 94, 53], [50, 18, '_']]\"]"}
{"diff_sorted_id": "21", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: poss, smoke, casel, hiram   The initial board: [['m', 'p', 'l', 's', 's'], ['s', 'a', 'o', 's', 'e'], ['c', 'a', '_', 'e', 'k'], ['h', 'i', 'r', 'o', 'm']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.25868940353393555", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"m\", \"p\", \"l\", \"s\", \"s\"], [\"s\", \"a\", \"o\", \"s\", \"e\"], [\"c\", \"a\", \"_\", \"e\", \"k\"], [\"h\", \"i\", \"r\", \"o\", \"m\"]]]", "is_correct_args": "[[[\"m\", \"p\", \"l\", \"s\", \"s\"], [\"s\", \"a\", \"o\", \"s\", \"e\"], [\"c\", \"a\", \"_\", \"e\", \"k\"], [\"h\", \"i\", \"r\", \"o\", \"m\"]], [\"poss\", \"smoke\", \"casel\", \"hiram\"]]", "A*_args": "[\"[['m', 'p', 'l', 's', 's'], ['s', 'a', 'o', 's', 'e'], ['c', 'a', '_', 'e', 'k'], ['h', 'i', 'r', 'o', 'm']]\", \"['poss', 'smoke', 'casel', 'hiram']\"]"}
{"diff_sorted_id": "21", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'Y'. Our task is to visit city I and city Q excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from Q and I, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  I K D M Y H C R V W Q \nI 0 0 0 1 0 1 1 0 1 0 0 \nK 0 0 0 1 0 0 0 0 0 0 0 \nD 0 0 0 0 0 0 0 1 0 1 0 \nM 1 0 0 0 0 0 0 0 0 0 0 \nY 0 1 1 0 0 0 0 0 0 0 0 \nH 0 1 1 1 0 0 1 0 1 0 1 \nC 0 1 0 1 1 1 0 0 1 0 0 \nR 0 0 0 1 0 0 0 0 1 0 1 \nV 0 0 0 0 1 0 0 1 0 0 0 \nW 1 0 0 1 1 0 0 0 0 0 0 \nQ 0 1 1 0 1 0 1 1 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[\"Y\", \"K\", \"M\", \"I\", \"H\", \"Q\", \"R\", \"Q\", \"W\", \"I\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.020466327667236328", "solution_depth": "10", "max_successor_states": "11", "num_vars_per_state": "14", "is_feasible_args": "[[[0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0]], [\"I\", \"K\", \"D\", \"M\", \"Y\", \"H\", \"C\", \"R\", \"V\", \"W\", \"Q\"], \"I\", \"Q\"]", "is_correct_args": "[[[0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0]], [\"I\", \"K\", \"D\", \"M\", \"Y\", \"H\", \"C\", \"R\", \"V\", \"W\", \"Q\"], \"Y\", \"I\", \"Q\"]", "A*_args": "[\"[[0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0]]\", \"['I', 'K', 'D', 'M', 'Y', 'H', 'C', 'R', 'V', 'W', 'Q']\", \"['Y']\", \"['I', 'Q']\"]"}
{"diff_sorted_id": "21", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [17, 19, 5, 17, 13, 2, 12, 4, 4, 15, 19, 7, 18, 15, 4, 6, 9, 2, 4, 11, 21, 17, 20, 4, 8, 2, 19, 16, 2, 12, 8, 16, 18, 3, 18, 13, 3, 15, 7, 18, 4, 14, 3, 5, 8, 7, 19, 9, 17, 5, 17, 6, 3, 5, 15], such that the sum of the chosen coins adds up to 210. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {9: 9, 6: 1, 13: 4, 2: 1, 16: 3, 14: 4, 19: 16, 20: 2, 15: 3, 7: 3, 18: 14, 17: 15, 4: 2, 5: 5, 8: 8, 21: 10, 12: 11, 11: 7, 3: 2}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "35", "opt_solution": "[20, 16, 6, 15, 15, 15, 15, 14, 6, 4, 13, 13, 4, 21, 16, 4, 2, 7, 4]", "opt_solution_cost": "56", "opt_solution_compute_t": "0.052184104919433594", "solution_depth": "19", "max_successor_states": "55", "num_vars_per_state": "55", "is_feasible_args": "[[17, 19, 5, 17, 13, 2, 12, 4, 4, 15, 19, 7, 18, 15, 4, 6, 9, 2, 4, 11, 21, 17, 20, 4, 8, 2, 19, 16, 2, 12, 8, 16, 18, 3, 18, 13, 3, 15, 7, 18, 4, 14, 3, 5, 8, 7, 19, 9, 17, 5, 17, 6, 3, 5, 15]]", "is_correct_args": "[[17, 19, 5, 17, 13, 2, 12, 4, 4, 15, 19, 7, 18, 15, 4, 6, 9, 2, 4, 11, 21, 17, 20, 4, 8, 2, 19, 16, 2, 12, 8, 16, 18, 3, 18, 13, 3, 15, 7, 18, 4, 14, 3, 5, 8, 7, 19, 9, 17, 5, 17, 6, 3, 5, 15], {\"9\": 9, \"6\": 1, \"13\": 4, \"2\": 1, \"16\": 3, \"14\": 4, \"19\": 16, \"20\": 2, \"15\": 3, \"7\": 3, \"18\": 14, \"17\": 15, \"4\": 2, \"5\": 5, \"8\": 8, \"21\": 10, \"12\": 11, \"11\": 7, \"3\": 2}, 210]", "A*_args": "[\"[17, 19, 5, 17, 13, 2, 12, 4, 4, 15, 19, 7, 18, 15, 4, 6, 9, 2, 4, 11, 21, 17, 20, 4, 8, 2, 19, 16, 2, 12, 8, 16, 18, 3, 18, 13, 3, 15, 7, 18, 4, 14, 3, 5, 8, 7, 19, 9, 17, 5, 17, 6, 3, 5, 15]\", \"{9: 9, 6: 1, 13: 4, 2: 1, 16: 3, 14: 4, 19: 16, 20: 2, 15: 3, 7: 3, 18: 14, 17: 15, 4: 2, 5: 5, 8: 8, 21: 10, 12: 11, 11: 7, 3: 2}\", \"210\"]"}
{"diff_sorted_id": "21", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Red', 'Blue', 'Green'], ['Red', 'Blue', 'Red', 'Blue'], ['Red', 'Blue', 'Green', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[1, 2], [0, 1], [0, 2], [0, 1], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [1, 2], [1, 0], [1, 2], [1, 0], [1, 2], [0, 1], [0, 1], [0, 1], [2, 0]]", "opt_solution_cost": "18", "opt_solution_compute_t": "1.3162987232208252", "solution_depth": "18", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Red\", \"Blue\", \"Green\"], [\"Red\", \"Blue\", \"Red\", \"Blue\"], [\"Red\", \"Blue\", \"Green\", \"Green\"]], 6]", "is_correct_args": "[[[\"Green\", \"Red\", \"Blue\", \"Green\"], [\"Red\", \"Blue\", \"Red\", \"Blue\"], [\"Red\", \"Blue\", \"Green\", \"Green\"]], 6]", "A*_args": "[\"[['Green', 'Red', 'Blue', 'Green'], ['Red', 'Blue', 'Red', 'Blue'], ['Red', 'Blue', 'Green', 'Green']]\", \"6\"]"}
{"diff_sorted_id": "21", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 15 to 58 (15 included in the range but 58 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['30' 'x' 'x']\n ['28' '33' '43']\n ['x' 'x' '51']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 1, 16], [0, 2, 15], [2, 0, 17], [2, 1, 34]]", "opt_solution_cost": "284", "opt_solution_compute_t": "0.16371726989746094", "solution_depth": "4", "max_successor_states": "43", "num_vars_per_state": "9", "is_feasible_args": "[\"[['30', '', ''], ['28', '33', '43'], ['', '', '51']]\", 15, 58]", "is_correct_args": "[\"[['30', '', ''], ['28', '33', '43'], ['', '', '51']]\", 15, 58]", "A*_args": "[\"[['30', '', ''], ['28', '33', '43'], ['', '', '51']]\", \"15\", \"58\"]"}
{"diff_sorted_id": "21", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 50 to 84. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 212, and sum of row 1 must be 193. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 217. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' '62']\n ['x' 'x' 'x']\n ['x' 'x' '56']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 50], [0, 1, 51], [1, 0, 52], [1, 1, 83], [1, 2, 58], [2, 0, 72], [2, 1, 78]]", "opt_solution_cost": "562", "opt_solution_compute_t": "155.01593708992004", "solution_depth": "7", "max_successor_states": "29", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', '62'], ['', '', ''], ['', '', '56']]\", 3, 50, 84]", "is_correct_args": "[\"[['', '', '62'], ['', '', ''], ['', '', '56']]\", 50, 84, [1, 2], [1, 2], [212], [193], 217]", "A*_args": "[\"[['', '', '62'], ['', '', ''], ['', '', '56']]\", \"50\", \"84\", \"[None, 212, None]\", \"[None, 193, None]\", \"217\"]"}
{"diff_sorted_id": "21", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 4, 1: 5, 2: 3, 3: 3, 4: 3, 5: 5}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Red', 'Yellow', 'Blue', 'Yellow'], [], [], ['Green', 'Blue', 'Green', 'Red'], [], ['Yellow', 'Red', 'Green', 'Blue']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[0, 2], [5, 4], [5, 2], [5, 1], [0, 4], [0, 5], [3, 1], [3, 5], [3, 1], [0, 4], [3, 2]]", "opt_solution_cost": "43", "opt_solution_compute_t": "0.025786161422729492", "solution_depth": "11", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Yellow\", \"Blue\", \"Yellow\"], [], [], [\"Green\", \"Blue\", \"Green\", \"Red\"], [], [\"Yellow\", \"Red\", \"Green\", \"Blue\"]], 4, {\"0\": 4, \"1\": 5, \"2\": 3, \"3\": 3, \"4\": 3, \"5\": 5}]", "is_correct_args": "[[[\"Red\", \"Yellow\", \"Blue\", \"Yellow\"], [], [], [\"Green\", \"Blue\", \"Green\", \"Red\"], [], [\"Yellow\", \"Red\", \"Green\", \"Blue\"]], 4, {\"0\": 4, \"1\": 5, \"2\": 3, \"3\": 3, \"4\": 3, \"5\": 5}, 3]", "A*_args": "[\"[['Red', 'Yellow', 'Blue', 'Yellow'], [], [], ['Green', 'Blue', 'Green', 'Red'], [], ['Yellow', 'Red', 'Green', 'Blue']]\", \"{0: 4, 1: 5, 2: 3, 3: 3, 4: 3, 5: 5}\", \"4\", \"3\"]"}
{"diff_sorted_id": "21", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (1, 9) to his destination workshop at index (6, 3), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 6, and district 3 covering rows 7 to 9. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[15 4 9 10 19 x 12 4 x 15]\n[12 19 11 x x x x 7 6 3]\n[4 x 8 x x 19 x 11 1 6]\n[x x 5 x x x 12 6 6 x]\n[x 14 x x 14 11 2 9 6 14]\n[8 8 5 17 7 x 1 2 x 6]\n[18 x x 15 x 15 4 x x 7]\n[19 x 10 18 14 x 14 9 8 6]\n[19 x 14 x 10 8 15 x 15 x]\n[12 1 x 5 3 3 x x x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "2", "opt_solution": "[[1, 9], [1, 8], [2, 8], [3, 8], [3, 7], [4, 7], [4, 6], [5, 6], [6, 6], [7, 6], [6, 6], [5, 6], [4, 6], [4, 5], [4, 4], [5, 4], [5, 3], [6, 3]]", "opt_solution_cost": "120", "opt_solution_compute_t": "0.022410869598388672", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"15\", \"4\", \"9\", \"10\", \"19\", \"x\", \"12\", \"4\", \"x\", \"15\"], [\"12\", \"19\", \"11\", \"x\", \"x\", \"x\", \"x\", \"7\", \"6\", \"3\"], [\"4\", \"x\", \"8\", \"x\", \"x\", \"19\", \"x\", \"11\", \"1\", \"6\"], [\"x\", \"x\", \"5\", \"x\", \"x\", \"x\", \"12\", \"6\", \"6\", \"x\"], [\"x\", \"14\", \"x\", \"x\", \"14\", \"11\", \"2\", \"9\", \"6\", \"14\"], [\"8\", \"8\", \"5\", \"17\", \"7\", \"x\", \"1\", \"2\", \"x\", \"6\"], [\"18\", \"x\", \"x\", \"15\", \"x\", \"15\", \"4\", \"x\", \"x\", \"7\"], [\"19\", \"x\", \"10\", \"18\", \"14\", \"x\", \"14\", \"9\", \"8\", \"6\"], [\"19\", \"x\", \"14\", \"x\", \"10\", \"8\", \"15\", \"x\", \"15\", \"x\"], [\"12\", \"1\", \"x\", \"5\", \"3\", \"3\", \"x\", \"x\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"15\", \"4\", \"9\", \"10\", \"19\", \"x\", \"12\", \"4\", \"x\", \"15\"], [\"12\", \"19\", \"11\", \"x\", \"x\", \"x\", \"x\", \"7\", \"6\", \"3\"], [\"4\", \"x\", \"8\", \"x\", \"x\", \"19\", \"x\", \"11\", \"1\", \"6\"], [\"x\", \"x\", \"5\", \"x\", \"x\", \"x\", \"12\", \"6\", \"6\", \"x\"], [\"x\", \"14\", \"x\", \"x\", \"14\", \"11\", \"2\", \"9\", \"6\", \"14\"], [\"8\", \"8\", \"5\", \"17\", \"7\", \"x\", \"1\", \"2\", \"x\", \"6\"], [\"18\", \"x\", \"x\", \"15\", \"x\", \"15\", \"4\", \"x\", \"x\", \"7\"], [\"19\", \"x\", \"10\", \"18\", \"14\", \"x\", \"14\", \"9\", \"8\", \"6\"], [\"19\", \"x\", \"14\", \"x\", \"10\", \"8\", \"15\", \"x\", \"15\", \"x\"], [\"12\", \"1\", \"x\", \"5\", \"3\", \"3\", \"x\", \"x\", \"x\", \"x\"]], [1, 9], [6, 3], 1, 6]", "A*_args": "[\"[['15', '4', '9', '10', '19', 'x', '12', '4', 'x', '15'], ['12', '19', '11', 'x', 'x', 'x', 'x', '7', '6', '3'], ['4', 'x', '8', 'x', 'x', '19', 'x', '11', '1', '6'], ['x', 'x', '5', 'x', 'x', 'x', '12', '6', '6', 'x'], ['x', '14', 'x', 'x', '14', '11', '2', '9', '6', '14'], ['8', '8', '5', '17', '7', 'x', '1', '2', 'x', '6'], ['18', 'x', 'x', '15', 'x', '15', '4', 'x', 'x', '7'], ['19', 'x', '10', '18', '14', 'x', '14', '9', '8', '6'], ['19', 'x', '14', 'x', '10', '8', '15', 'x', '15', 'x'], ['12', '1', 'x', '5', '3', '3', 'x', 'x', 'x', 'x']]\", \"(1, 9)\", \"(6, 3)\", \"1\", \"6\"]"}
{"diff_sorted_id": "21", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 10x10. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 9) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (5, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 0 0 0 1 1 0 1 0\n0 0 0 1 0 1 1 0 0 0\n1 1 1 0 0 1 1 0 0 1\n1 0 0 0 0 0 0 0 0 1\n1 1 1 0 0 0 0 0 0 1\n0 0 0 0 1 0 0 1 1 1\n0 0 1 1 0 1 1 1 1 0\n0 0 1 1 1 1 0 0 1 0\n1 0 1 1 1 1 1 0 1 1\n1 1 1 0 0 1 1 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[[1, 9], [1, 8], [2, 7], [3, 6], [3, 5], [3, 4], [3, 3], [4, 3], [5, 2], [5, 1], [5, 0]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.029159069061279297", "solution_depth": "11", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 1, 0, 1, 1, 0, 0, 0], [1, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 1, 1], [0, 0, 1, 1, 0, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 0, 0, 1, 0], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1], [1, 1, 1, 0, 0, 1, 1, 1, 1, 1]]\", 3]", "is_correct_args": "[\"[[0, 1, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 1, 0, 1, 1, 0, 0, 0], [1, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 1, 1], [0, 0, 1, 1, 0, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 0, 0, 1, 0], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1], [1, 1, 1, 0, 0, 1, 1, 1, 1, 1]]\", [1, 9], [5, 0], 3]", "A*_args": "[\"[[0, 1, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 1, 0, 1, 1, 0, 0, 0], [1, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 1, 1], [0, 0, 1, 1, 0, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 0, 0, 1, 0], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1], [1, 1, 1, 0, 0, 1, 1, 1, 1, 1]]\", \"(1, 9)\", \"(5, 0)\", \"3\"]"}
{"diff_sorted_id": "21", "problem_statement": "Given 7 labeled water jugs with capacities 52, 131, 82, 132, 117, 65 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 357, 384, 522 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 117, 3], [\"+\", 117, 3], [\"+\", 52, 3], [\"+\", 52, 3], [\"+\", 52, 3], [\"+\", 132, 3], [\"+\", 82, 2], [\"+\", 131, 2], [\"+\", 52, 2], [\"+\", 52, 2], [\"-\", 65, 2], [\"+\", 132, 2], [\"+\", 65, 1], [\"+\", 131, 1], [\"+\", 131, 1], [\"-\", 52, 1], [\"+\", 82, 1]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.047934532165527344", "solution_depth": "17", "max_successor_states": "36", "num_vars_per_state": "3", "is_feasible_args": "[[52, 131, 82, 132, 117, 65], [357, 384, 522]]", "is_correct_args": "[[52, 131, 82, 132, 117, 65], [357, 384, 522]]", "A*_args": "[\"[52, 131, 82, 132, 117, 65]\", \"[357, 384, 522]\"]"}
{"diff_sorted_id": "22", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[81, 25, '_'], [19, 56, 14], [61, 41, 39]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[25, 56, 41, 61, 19, 41, 61, 39, 14, 25, 56, 61, 39, 14]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.019939899444580078", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[81, 25, \"_\"], [19, 56, 14], [61, 41, 39]]]", "is_correct_args": "[[[81, 25, \"_\"], [19, 56, 14], [61, 41, 39]]]", "A*_args": "[\"[[81, 25, '_'], [19, 56, 14], [61, 41, 39]]\"]"}
{"diff_sorted_id": "22", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: jehu, wormy, linty, ilial   The initial board: [['o', 'j', '_', 'h', 'u'], ['w', 'l', 'r', 'e', 'y'], ['n', 'i', 'l', 't', 'a'], ['i', 'y', 'i', 'm', 'l']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.13087821006774902", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"o\", \"j\", \"_\", \"h\", \"u\"], [\"w\", \"l\", \"r\", \"e\", \"y\"], [\"n\", \"i\", \"l\", \"t\", \"a\"], [\"i\", \"y\", \"i\", \"m\", \"l\"]]]", "is_correct_args": "[[[\"o\", \"j\", \"_\", \"h\", \"u\"], [\"w\", \"l\", \"r\", \"e\", \"y\"], [\"n\", \"i\", \"l\", \"t\", \"a\"], [\"i\", \"y\", \"i\", \"m\", \"l\"]], [\"jehu\", \"wormy\", \"linty\", \"ilial\"]]", "A*_args": "[\"[['o', 'j', '_', 'h', 'u'], ['w', 'l', 'r', 'e', 'y'], ['n', 'i', 'l', 't', 'a'], ['i', 'y', 'i', 'm', 'l']]\", \"['jehu', 'wormy', 'linty', 'ilial']\"]"}
{"diff_sorted_id": "22", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'X'. Our task is to visit city E and city T excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from T and E, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  X M U N T V Z S F E J \nX 0 0 1 1 0 0 1 1 0 0 0 \nM 0 0 1 1 1 0 0 1 0 0 0 \nU 0 0 0 1 0 0 0 1 0 0 0 \nN 1 0 0 0 0 0 0 1 1 0 0 \nT 1 0 1 1 0 0 0 0 0 1 0 \nV 1 1 1 1 1 0 1 1 0 1 0 \nZ 0 1 0 0 0 1 0 0 1 0 0 \nS 0 0 0 0 0 0 0 0 1 1 0 \nF 0 0 0 0 0 0 0 0 0 1 0 \nE 0 0 1 0 0 0 1 1 1 0 1 \nJ 0 1 1 0 0 0 0 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[\"X\", \"Z\", \"V\", \"T\", \"E\", \"J\", \"M\", \"T\", \"E\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.029807567596435547", "solution_depth": "9", "max_successor_states": "11", "num_vars_per_state": "14", "is_feasible_args": "[[[0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0], [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0], [0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]], [\"X\", \"M\", \"U\", \"N\", \"T\", \"V\", \"Z\", \"S\", \"F\", \"E\", \"J\"], \"E\", \"T\"]", "is_correct_args": "[[[0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0], [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0], [0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]], [\"X\", \"M\", \"U\", \"N\", \"T\", \"V\", \"Z\", \"S\", \"F\", \"E\", \"J\"], \"X\", \"E\", \"T\"]", "A*_args": "[\"[[0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0], [1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0], [0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]]\", \"['X', 'M', 'U', 'N', 'T', 'V', 'Z', 'S', 'F', 'E', 'J']\", \"['X']\", \"['E', 'T']\"]"}
{"diff_sorted_id": "22", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [10, 2, 5, 22, 15, 3, 4, 66, 3, 11, 21, 16, 69, 2, 19, 20, 9, 24, 24, 20, 12, 13, 21, 7, 7, 23, 25, 10], such that the sum of the chosen coins adds up to 268. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {66: 17, 9: 3, 15: 10, 7: 6, 3: 3, 13: 7, 11: 10, 25: 14, 22: 18, 24: 17, 12: 6, 23: 18, 2: 2, 10: 5, 19: 10, 20: 19, 5: 4, 16: 1, 21: 20, 69: 14, 4: 4}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "15", "opt_solution": "[9, 13, 10, 69, 66, 16, 10, 19, 25, 12, 15, 4]", "opt_solution_cost": "96", "opt_solution_compute_t": "0.04047846794128418", "solution_depth": "12", "max_successor_states": "28", "num_vars_per_state": "28", "is_feasible_args": "[[10, 2, 5, 22, 15, 3, 4, 66, 3, 11, 21, 16, 69, 2, 19, 20, 9, 24, 24, 20, 12, 13, 21, 7, 7, 23, 25, 10]]", "is_correct_args": "[[10, 2, 5, 22, 15, 3, 4, 66, 3, 11, 21, 16, 69, 2, 19, 20, 9, 24, 24, 20, 12, 13, 21, 7, 7, 23, 25, 10], {\"66\": 17, \"9\": 3, \"15\": 10, \"7\": 6, \"3\": 3, \"13\": 7, \"11\": 10, \"25\": 14, \"22\": 18, \"24\": 17, \"12\": 6, \"23\": 18, \"2\": 2, \"10\": 5, \"19\": 10, \"20\": 19, \"5\": 4, \"16\": 1, \"21\": 20, \"69\": 14, \"4\": 4}, 268]", "A*_args": "[\"[10, 2, 5, 22, 15, 3, 4, 66, 3, 11, 21, 16, 69, 2, 19, 20, 9, 24, 24, 20, 12, 13, 21, 7, 7, 23, 25, 10]\", \"{66: 17, 9: 3, 15: 10, 7: 6, 3: 3, 13: 7, 11: 10, 25: 14, 22: 18, 24: 17, 12: 6, 23: 18, 2: 2, 10: 5, 19: 10, 20: 19, 5: 4, 16: 1, 21: 20, 69: 14, 4: 4}\", \"268\"]"}
{"diff_sorted_id": "22", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Red', 'Blue', 'Green'], ['Red', 'Blue', 'Green', 'Red'], ['Blue', 'Green', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[0, 2], [1, 0], [1, 2], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [0, 2], [0, 1], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [2, 1]]", "opt_solution_cost": "19", "opt_solution_compute_t": "2.2448041439056396", "solution_depth": "19", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Blue\", \"Red\", \"Blue\", \"Green\"], [\"Red\", \"Blue\", \"Green\", \"Red\"], [\"Blue\", \"Green\", \"Green\", \"Red\"]], 6]", "is_correct_args": "[[[\"Blue\", \"Red\", \"Blue\", \"Green\"], [\"Red\", \"Blue\", \"Green\", \"Red\"], [\"Blue\", \"Green\", \"Green\", \"Red\"]], 6]", "A*_args": "[\"[['Blue', 'Red', 'Blue', 'Green'], ['Red', 'Blue', 'Green', 'Red'], ['Blue', 'Green', 'Green', 'Red']]\", \"6\"]"}
{"diff_sorted_id": "22", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 13 to 56 (13 included in the range but 56 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['16' 'x' 'x']\n ['28' '34' 'x']\n ['x' '46' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 1, 14], [0, 2, 13], [1, 2, 35], [2, 0, 47], [2, 2, 36]]", "opt_solution_cost": "213", "opt_solution_compute_t": "7.270275831222534", "solution_depth": "5", "max_successor_states": "43", "num_vars_per_state": "9", "is_feasible_args": "[\"[['16', '', ''], ['28', '34', ''], ['', '46', '']]\", 13, 56]", "is_correct_args": "[\"[['16', '', ''], ['28', '34', ''], ['', '46', '']]\", 13, 56]", "A*_args": "[\"[['16', '', ''], ['28', '34', ''], ['', '46', '']]\", \"13\", \"56\"]"}
{"diff_sorted_id": "22", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 12 to 46. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 120, and sum of row 1 must be 105. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 99. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x']\n ['x' 'x' 'x']\n ['x' '43' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 12], [0, 1, 32], [0, 2, 14], [1, 0, 16], [1, 1, 45], [1, 2, 44], [2, 0, 40], [2, 2, 13]]", "opt_solution_cost": "259", "opt_solution_compute_t": "92.43742489814758", "solution_depth": "8", "max_successor_states": "29", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '', ''], ['', '43', '']]\", 3, 12, 46]", "is_correct_args": "[\"[['', '', ''], ['', '', ''], ['', '43', '']]\", 12, 46, [1, 2], [1, 2], [120], [105], 99]", "A*_args": "[\"[['', '', ''], ['', '', ''], ['', '43', '']]\", \"12\", \"46\", \"[None, 120, None]\", \"[None, 105, None]\", \"99\"]"}
{"diff_sorted_id": "22", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 1, 1: 4, 2: 2, 3: 7, 4: 6, 5: 6}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Blue', 'Yellow', 'Blue', 'Yellow'], [], [], ['Red', 'Blue', 'Yellow', 'Green'], ['Green', 'Green', 'Red', 'Red']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[5, 3], [5, 3], [4, 5], [1, 2], [4, 2], [1, 0], [1, 2], [4, 1], [0, 1], [3, 0], [3, 0], [4, 0]]", "opt_solution_cost": "38", "opt_solution_compute_t": "0.09250640869140625", "solution_depth": "12", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[], [\"Blue\", \"Yellow\", \"Blue\", \"Yellow\"], [], [], [\"Red\", \"Blue\", \"Yellow\", \"Green\"], [\"Green\", \"Green\", \"Red\", \"Red\"]], 4, {\"0\": 1, \"1\": 4, \"2\": 2, \"3\": 7, \"4\": 6, \"5\": 6}]", "is_correct_args": "[[[], [\"Blue\", \"Yellow\", \"Blue\", \"Yellow\"], [], [], [\"Red\", \"Blue\", \"Yellow\", \"Green\"], [\"Green\", \"Green\", \"Red\", \"Red\"]], 4, {\"0\": 1, \"1\": 4, \"2\": 2, \"3\": 7, \"4\": 6, \"5\": 6}, 3]", "A*_args": "[\"[[], ['Blue', 'Yellow', 'Blue', 'Yellow'], [], [], ['Red', 'Blue', 'Yellow', 'Green'], ['Green', 'Green', 'Red', 'Red']]\", \"{0: 1, 1: 4, 2: 2, 3: 7, 4: 6, 5: 6}\", \"4\", \"3\"]"}
{"diff_sorted_id": "22", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (1, 0) to his destination workshop at index (5, 7), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 4, and district 3 covering rows 5 to 9. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[2 2 3 x 2 10 x 8 6 x]\n[6 11 x x x x x 16 x 7]\n[17 17 7 12 13 15 5 6 10 13]\n[1 15 13 3 x x x 14 x 9]\n[14 x x 6 15 2 12 18 x 18]\n[11 19 1 19 10 8 x 14 x x]\n[11 x x x 3 x x 7 x 2]\n[16 12 x x x 5 x x 10 x]\n[x 11 x 2 12 x 8 x 8 x]\n[x x 16 x x x 16 x 16 12]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "2", "opt_solution": "[[1, 0], [2, 0], [3, 0], [3, 1], [3, 2], [3, 3], [4, 3], [4, 4], [4, 5], [4, 6], [4, 7], [5, 7]]", "opt_solution_cost": "116", "opt_solution_compute_t": "0.020702600479125977", "solution_depth": "12", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"2\", \"2\", \"3\", \"x\", \"2\", \"10\", \"x\", \"8\", \"6\", \"x\"], [\"6\", \"11\", \"x\", \"x\", \"x\", \"x\", \"x\", \"16\", \"x\", \"7\"], [\"17\", \"17\", \"7\", \"12\", \"13\", \"15\", \"5\", \"6\", \"10\", \"13\"], [\"1\", \"15\", \"13\", \"3\", \"x\", \"x\", \"x\", \"14\", \"x\", \"9\"], [\"14\", \"x\", \"x\", \"6\", \"15\", \"2\", \"12\", \"18\", \"x\", \"18\"], [\"11\", \"19\", \"1\", \"19\", \"10\", \"8\", \"x\", \"14\", \"x\", \"x\"], [\"11\", \"x\", \"x\", \"x\", \"3\", \"x\", \"x\", \"7\", \"x\", \"2\"], [\"16\", \"12\", \"x\", \"x\", \"x\", \"5\", \"x\", \"x\", \"10\", \"x\"], [\"x\", \"11\", \"x\", \"2\", \"12\", \"x\", \"8\", \"x\", \"8\", \"x\"], [\"x\", \"x\", \"16\", \"x\", \"x\", \"x\", \"16\", \"x\", \"16\", \"12\"]]]", "is_correct_args": "[[[\"2\", \"2\", \"3\", \"x\", \"2\", \"10\", \"x\", \"8\", \"6\", \"x\"], [\"6\", \"11\", \"x\", \"x\", \"x\", \"x\", \"x\", \"16\", \"x\", \"7\"], [\"17\", \"17\", \"7\", \"12\", \"13\", \"15\", \"5\", \"6\", \"10\", \"13\"], [\"1\", \"15\", \"13\", \"3\", \"x\", \"x\", \"x\", \"14\", \"x\", \"9\"], [\"14\", \"x\", \"x\", \"6\", \"15\", \"2\", \"12\", \"18\", \"x\", \"18\"], [\"11\", \"19\", \"1\", \"19\", \"10\", \"8\", \"x\", \"14\", \"x\", \"x\"], [\"11\", \"x\", \"x\", \"x\", \"3\", \"x\", \"x\", \"7\", \"x\", \"2\"], [\"16\", \"12\", \"x\", \"x\", \"x\", \"5\", \"x\", \"x\", \"10\", \"x\"], [\"x\", \"11\", \"x\", \"2\", \"12\", \"x\", \"8\", \"x\", \"8\", \"x\"], [\"x\", \"x\", \"16\", \"x\", \"x\", \"x\", \"16\", \"x\", \"16\", \"12\"]], [1, 0], [5, 7], 1, 4]", "A*_args": "[\"[['2', '2', '3', 'x', '2', '10', 'x', '8', '6', 'x'], ['6', '11', 'x', 'x', 'x', 'x', 'x', '16', 'x', '7'], ['17', '17', '7', '12', '13', '15', '5', '6', '10', '13'], ['1', '15', '13', '3', 'x', 'x', 'x', '14', 'x', '9'], ['14', 'x', 'x', '6', '15', '2', '12', '18', 'x', '18'], ['11', '19', '1', '19', '10', '8', 'x', '14', 'x', 'x'], ['11', 'x', 'x', 'x', '3', 'x', 'x', '7', 'x', '2'], ['16', '12', 'x', 'x', 'x', '5', 'x', 'x', '10', 'x'], ['x', '11', 'x', '2', '12', 'x', '8', 'x', '8', 'x'], ['x', 'x', '16', 'x', 'x', 'x', '16', 'x', '16', '12']]\", \"(1, 0)\", \"(5, 7)\", \"1\", \"4\"]"}
{"diff_sorted_id": "22", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 10x10. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (8, 1) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (1, 9). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 0 1 0 0 0 1 0 0\n1 0 1 0 0 1 0 1 1 0\n1 1 1 0 1 1 1 0 1 0\n1 1 1 0 0 1 0 0 1 0\n0 1 1 0 0 1 0 1 0 0\n1 1 1 0 1 0 0 0 1 0\n0 1 0 1 0 1 0 0 0 0\n0 1 1 1 0 1 0 0 0 0\n0 0 1 0 0 1 0 0 1 0\n1 1 0 0 0 0 0 1 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[[8, 1], [9, 2], [9, 3], [8, 3], [8, 4], [7, 4], [6, 4], [5, 5], [5, 6], [5, 7], [4, 8], [4, 9], [3, 9], [2, 9], [1, 9]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.02926492691040039", "solution_depth": "15", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 0, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 1, 0], [1, 1, 1, 0, 1, 1, 1, 0, 1, 0], [1, 1, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 1, 0, 0, 1, 0, 1, 0, 0], [1, 1, 1, 0, 1, 0, 0, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 1, 1, 0]]\", 3]", "is_correct_args": "[\"[[1, 0, 0, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 1, 0], [1, 1, 1, 0, 1, 1, 1, 0, 1, 0], [1, 1, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 1, 0, 0, 1, 0, 1, 0, 0], [1, 1, 1, 0, 1, 0, 0, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 1, 1, 0]]\", [8, 1], [1, 9], 3]", "A*_args": "[\"[[1, 0, 0, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 1, 0], [1, 1, 1, 0, 1, 1, 1, 0, 1, 0], [1, 1, 1, 0, 0, 1, 0, 0, 1, 0], [0, 1, 1, 0, 0, 1, 0, 1, 0, 0], [1, 1, 1, 0, 1, 0, 0, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 1, 1, 0]]\", \"(8, 1)\", \"(1, 9)\", \"3\"]"}
{"diff_sorted_id": "22", "problem_statement": "Given 7 labeled water jugs with capacities 16, 124, 57, 40, 99, 45, 72, 98 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 263, 341, 360 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 98, 3], [\"+\", 124, 3], [\"+\", 40, 3], [\"+\", 98, 3], [\"+\", 45, 2], [\"+\", 98, 2], [\"+\", 99, 2], [\"+\", 99, 2], [\"+\", 40, 1], [\"+\", 99, 1], [\"+\", 124, 1]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.04340982437133789", "solution_depth": "11", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[16, 124, 57, 40, 99, 45, 72, 98], [263, 341, 360]]", "is_correct_args": "[[16, 124, 57, 40, 99, 45, 72, 98], [263, 341, 360]]", "A*_args": "[\"[16, 124, 57, 40, 99, 45, 72, 98]\", \"[263, 341, 360]\"]"}
{"diff_sorted_id": "23", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[62, 43, 28], [59, 34, 53], [29, 76, '_']]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[53, 28, 43, 34, 59, 29, 76, 53, 28, 43, 34, 59, 29, 76, 53, 29, 43, 34, 59, 62, 76, 53, 29, 28]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.11378741264343262", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[62, 43, 28], [59, 34, 53], [29, 76, \"_\"]]]", "is_correct_args": "[[[62, 43, 28], [59, 34, 53], [29, 76, \"_\"]]]", "A*_args": "[\"[[62, 43, 28], [59, 34, 53], [29, 76, '_']]\"]"}
{"diff_sorted_id": "23", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: song, amish, hiper, agley   The initial board: [['m', 's', '_', 'n', 'g'], ['a', 'o', 'i', 'e', 'h'], ['h', 'i', 'p', 'e', 's'], ['a', 'g', 'l', 'r', 'y']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"down-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.1897449493408203", "solution_depth": "8", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"m\", \"s\", \"_\", \"n\", \"g\"], [\"a\", \"o\", \"i\", \"e\", \"h\"], [\"h\", \"i\", \"p\", \"e\", \"s\"], [\"a\", \"g\", \"l\", \"r\", \"y\"]]]", "is_correct_args": "[[[\"m\", \"s\", \"_\", \"n\", \"g\"], [\"a\", \"o\", \"i\", \"e\", \"h\"], [\"h\", \"i\", \"p\", \"e\", \"s\"], [\"a\", \"g\", \"l\", \"r\", \"y\"]], [\"song\", \"amish\", \"hiper\", \"agley\"]]", "A*_args": "[\"[['m', 's', '_', 'n', 'g'], ['a', 'o', 'i', 'e', 'h'], ['h', 'i', 'p', 'e', 's'], ['a', 'g', 'l', 'r', 'y']]\", \"['song', 'amish', 'hiper', 'agley']\"]"}
{"diff_sorted_id": "23", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'K'. Our task is to visit city P and city N excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from N and P, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  N W X P J E L M I K Q \nN 0 0 1 0 0 1 0 1 0 0 0 \nW 1 0 0 1 1 0 0 0 0 0 0 \nX 0 1 0 1 0 1 0 0 0 1 1 \nP 1 1 0 0 1 0 0 0 0 0 1 \nJ 0 0 1 0 0 1 0 0 0 0 0 \nE 1 1 0 0 0 0 0 0 0 0 0 \nL 1 0 0 0 0 0 0 0 0 0 1 \nM 1 1 0 0 0 1 0 0 0 0 0 \nI 0 0 1 0 1 0 1 1 0 0 0 \nK 0 0 0 0 0 1 0 0 1 0 0 \nQ 1 1 0 0 0 0 1 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[\"K\", \"E\", \"N\", \"X\", \"P\", \"W\", \"P\", \"N\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.02664780616760254", "solution_depth": "8", "max_successor_states": "11", "num_vars_per_state": "14", "is_feasible_args": "[[[0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0], [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0]], [\"N\", \"W\", \"X\", \"P\", \"J\", \"E\", \"L\", \"M\", \"I\", \"K\", \"Q\"], \"P\", \"N\"]", "is_correct_args": "[[[0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0], [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0]], [\"N\", \"W\", \"X\", \"P\", \"J\", \"E\", \"L\", \"M\", \"I\", \"K\", \"Q\"], \"K\", \"P\", \"N\"]", "A*_args": "[\"[[0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0], [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1], [1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0]]\", \"['N', 'W', 'X', 'P', 'J', 'E', 'L', 'M', 'I', 'K', 'Q']\", \"['K']\", \"['P', 'N']\"]"}
{"diff_sorted_id": "23", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [84, 2, 8, 16, 21, 10, 15, 4, 17, 16, 4, 85, 30, 13, 28, 2, 2, 11, 18, 9, 25, 5, 24, 14, 20, 30, 6], such that the sum of the chosen coins adds up to 309. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {15: 2, 18: 9, 28: 4, 84: 10, 2: 1, 24: 19, 30: 12, 5: 2, 9: 9, 21: 9, 11: 10, 16: 14, 4: 2, 17: 2, 85: 18, 6: 5, 8: 6, 13: 2, 10: 4, 25: 11, 20: 19, 14: 2}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "16", "opt_solution": "[84, 28, 10, 13, 17, 4, 5, 15, 85, 30, 14, 4]", "opt_solution_cost": "62", "opt_solution_compute_t": "0.03924393653869629", "solution_depth": "12", "max_successor_states": "27", "num_vars_per_state": "27", "is_feasible_args": "[[84, 2, 8, 16, 21, 10, 15, 4, 17, 16, 4, 85, 30, 13, 28, 2, 2, 11, 18, 9, 25, 5, 24, 14, 20, 30, 6]]", "is_correct_args": "[[84, 2, 8, 16, 21, 10, 15, 4, 17, 16, 4, 85, 30, 13, 28, 2, 2, 11, 18, 9, 25, 5, 24, 14, 20, 30, 6], {\"15\": 2, \"18\": 9, \"28\": 4, \"84\": 10, \"2\": 1, \"24\": 19, \"30\": 12, \"5\": 2, \"9\": 9, \"21\": 9, \"11\": 10, \"16\": 14, \"4\": 2, \"17\": 2, \"85\": 18, \"6\": 5, \"8\": 6, \"13\": 2, \"10\": 4, \"25\": 11, \"20\": 19, \"14\": 2}, 309]", "A*_args": "[\"[84, 2, 8, 16, 21, 10, 15, 4, 17, 16, 4, 85, 30, 13, 28, 2, 2, 11, 18, 9, 25, 5, 24, 14, 20, 30, 6]\", \"{15: 2, 18: 9, 28: 4, 84: 10, 2: 1, 24: 19, 30: 12, 5: 2, 9: 9, 21: 9, 11: 10, 16: 14, 4: 2, 17: 2, 85: 18, 6: 5, 8: 6, 13: 2, 10: 4, 25: 11, 20: 19, 14: 2}\", \"309\"]"}
{"diff_sorted_id": "23", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Red', 'Blue', 'Green'], ['Blue', 'Green', 'Blue', 'Blue'], ['Red', 'Green', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[2, 0], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0], [1, 2], [1, 0], [2, 1], [2, 1]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.13763999938964844", "solution_depth": "13", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Red\", \"Blue\", \"Green\"], [\"Blue\", \"Green\", \"Blue\", \"Blue\"], [\"Red\", \"Green\", \"Green\", \"Red\"]], 6]", "is_correct_args": "[[[\"Red\", \"Red\", \"Blue\", \"Green\"], [\"Blue\", \"Green\", \"Blue\", \"Blue\"], [\"Red\", \"Green\", \"Green\", \"Red\"]], 6]", "A*_args": "[\"[['Red', 'Red', 'Blue', 'Green'], ['Blue', 'Green', 'Blue', 'Blue'], ['Red', 'Green', 'Green', 'Red']]\", \"6\"]"}
{"diff_sorted_id": "23", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 23 to 66 (23 included in the range but 66 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' '57']\n ['x' 'x' 'x']\n ['33' '43' '47']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 23], [0, 1, 24], [1, 0, 25], [1, 1, 26], [1, 2, 48]]", "opt_solution_cost": "352", "opt_solution_compute_t": "1.0622022151947021", "solution_depth": "5", "max_successor_states": "43", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', '57'], ['', '', ''], ['33', '43', '47']]\", 23, 66]", "is_correct_args": "[\"[['', '', '57'], ['', '', ''], ['33', '43', '47']]\", 23, 66]", "A*_args": "[\"[['', '', '57'], ['', '', ''], ['33', '43', '47']]\", \"23\", \"66\"]"}
{"diff_sorted_id": "23", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 12 to 46. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 71, and sum of row 1 must be 82. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 70. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x']\n ['x' 'x' 'x']\n ['x' 'x' '19']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 13], [0, 1, 14], [0, 2, 12], [1, 0, 17], [1, 1, 42], [1, 2, 23], [2, 0, 16], [2, 1, 15]]", "opt_solution_cost": "171", "opt_solution_compute_t": "8.869033575057983", "solution_depth": "8", "max_successor_states": "29", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '', ''], ['', '', '19']]\", 3, 12, 46]", "is_correct_args": "[\"[['', '', ''], ['', '', ''], ['', '', '19']]\", 12, 46, [1, 2], [1, 2], [71], [82], 70]", "A*_args": "[\"[['', '', ''], ['', '', ''], ['', '', '19']]\", \"12\", \"46\", \"[None, 71, None]\", \"[None, 82, None]\", \"70\"]"}
{"diff_sorted_id": "23", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 2, 1: 7, 2: 4, 3: 7, 4: 6, 5: 3}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Green', 'Green', 'Blue', 'Red'], ['Blue', 'Red', 'Yellow', 'Blue'], [], ['Green', 'Yellow', 'Red', 'Yellow'], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[3, 2], [0, 2], [0, 2], [0, 5], [1, 5], [1, 0], [1, 4], [3, 4], [3, 0], [3, 4], [1, 5]]", "opt_solution_cost": "43", "opt_solution_compute_t": "0.04391932487487793", "solution_depth": "11", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Green\", \"Blue\", \"Red\"], [\"Blue\", \"Red\", \"Yellow\", \"Blue\"], [], [\"Green\", \"Yellow\", \"Red\", \"Yellow\"], [], []], 4, {\"0\": 2, \"1\": 7, \"2\": 4, \"3\": 7, \"4\": 6, \"5\": 3}]", "is_correct_args": "[[[\"Green\", \"Green\", \"Blue\", \"Red\"], [\"Blue\", \"Red\", \"Yellow\", \"Blue\"], [], [\"Green\", \"Yellow\", \"Red\", \"Yellow\"], [], []], 4, {\"0\": 2, \"1\": 7, \"2\": 4, \"3\": 7, \"4\": 6, \"5\": 3}, 3]", "A*_args": "[\"[['Green', 'Green', 'Blue', 'Red'], ['Blue', 'Red', 'Yellow', 'Blue'], [], ['Green', 'Yellow', 'Red', 'Yellow'], [], []]\", \"{0: 2, 1: 7, 2: 4, 3: 7, 4: 6, 5: 3}\", \"4\", \"3\"]"}
{"diff_sorted_id": "23", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (5, 8) to his destination workshop at index (3, 0), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 4, and district 3 covering rows 5 to 9. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x x x x 8 x 15 18 10]\n[4 5 10 6 20 2 12 x x x]\n[19 6 19 7 6 2 x 15 x 14]\n[16 17 x 2 3 7 4 x 18 6]\n[x 2 1 19 7 10 18 5 3 19]\n[8 5 x 1 x 10 17 x 13 5]\n[18 1 3 4 x x 8 x 5 x]\n[15 x x 13 x 11 x 2 x x]\n[4 x x 4 1 x x x x x]\n[x 10 8 x x 7 19 x x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "2", "opt_solution": "[[5, 8], [4, 8], [4, 7], [4, 6], [3, 6], [3, 5], [2, 5], [2, 4], [3, 4], [3, 3], [4, 3], [4, 2], [4, 1], [3, 1], [3, 0]]", "opt_solution_cost": "105", "opt_solution_compute_t": "0.02059459686279297", "solution_depth": "15", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"x\", \"x\", \"x\", \"8\", \"x\", \"15\", \"18\", \"10\"], [\"4\", \"5\", \"10\", \"6\", \"20\", \"2\", \"12\", \"x\", \"x\", \"x\"], [\"19\", \"6\", \"19\", \"7\", \"6\", \"2\", \"x\", \"15\", \"x\", \"14\"], [\"16\", \"17\", \"x\", \"2\", \"3\", \"7\", \"4\", \"x\", \"18\", \"6\"], [\"x\", \"2\", \"1\", \"19\", \"7\", \"10\", \"18\", \"5\", \"3\", \"19\"], [\"8\", \"5\", \"x\", \"1\", \"x\", \"10\", \"17\", \"x\", \"13\", \"5\"], [\"18\", \"1\", \"3\", \"4\", \"x\", \"x\", \"8\", \"x\", \"5\", \"x\"], [\"15\", \"x\", \"x\", \"13\", \"x\", \"11\", \"x\", \"2\", \"x\", \"x\"], [\"4\", \"x\", \"x\", \"4\", \"1\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"10\", \"8\", \"x\", \"x\", \"7\", \"19\", \"x\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"x\", \"x\", \"x\", \"8\", \"x\", \"15\", \"18\", \"10\"], [\"4\", \"5\", \"10\", \"6\", \"20\", \"2\", \"12\", \"x\", \"x\", \"x\"], [\"19\", \"6\", \"19\", \"7\", \"6\", \"2\", \"x\", \"15\", \"x\", \"14\"], [\"16\", \"17\", \"x\", \"2\", \"3\", \"7\", \"4\", \"x\", \"18\", \"6\"], [\"x\", \"2\", \"1\", \"19\", \"7\", \"10\", \"18\", \"5\", \"3\", \"19\"], [\"8\", \"5\", \"x\", \"1\", \"x\", \"10\", \"17\", \"x\", \"13\", \"5\"], [\"18\", \"1\", \"3\", \"4\", \"x\", \"x\", \"8\", \"x\", \"5\", \"x\"], [\"15\", \"x\", \"x\", \"13\", \"x\", \"11\", \"x\", \"2\", \"x\", \"x\"], [\"4\", \"x\", \"x\", \"4\", \"1\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"10\", \"8\", \"x\", \"x\", \"7\", \"19\", \"x\", \"x\", \"x\"]], [5, 8], [3, 0], 2, 4]", "A*_args": "[\"[['x', 'x', 'x', 'x', 'x', '8', 'x', '15', '18', '10'], ['4', '5', '10', '6', '20', '2', '12', 'x', 'x', 'x'], ['19', '6', '19', '7', '6', '2', 'x', '15', 'x', '14'], ['16', '17', 'x', '2', '3', '7', '4', 'x', '18', '6'], ['x', '2', '1', '19', '7', '10', '18', '5', '3', '19'], ['8', '5', 'x', '1', 'x', '10', '17', 'x', '13', '5'], ['18', '1', '3', '4', 'x', 'x', '8', 'x', '5', 'x'], ['15', 'x', 'x', '13', 'x', '11', 'x', '2', 'x', 'x'], ['4', 'x', 'x', '4', '1', 'x', 'x', 'x', 'x', 'x'], ['x', '10', '8', 'x', 'x', '7', '19', 'x', 'x', 'x']]\", \"(5, 8)\", \"(3, 0)\", \"2\", \"4\"]"}
{"diff_sorted_id": "23", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 10x10. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 9) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (8, 3). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 0 1 0 1 1 0 1 1\n0 0 1 0 0 1 1 1 1 0\n1 0 0 0 1 1 0 0 0 0\n1 1 0 0 1 1 1 1 0 0\n0 0 1 1 1 0 1 0 0 0\n1 0 1 0 0 0 0 0 0 1\n1 0 1 0 0 0 0 1 1 1\n1 0 1 0 1 0 1 0 1 1\n1 0 1 0 0 1 1 1 1 1\n1 1 1 0 1 1 0 0 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[[1, 9], [2, 8], [3, 8], [4, 7], [5, 6], [5, 5], [6, 5], [6, 4], [6, 3], [7, 3], [8, 3]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.028395891189575195", "solution_depth": "11", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 0, 1, 0, 1, 1, 0, 1, 1], [0, 0, 1, 0, 0, 1, 1, 1, 1, 0], [1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1, 1, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 1], [1, 0, 1, 0, 0, 1, 1, 1, 1, 1], [1, 1, 1, 0, 1, 1, 0, 0, 1, 0]]\", 3]", "is_correct_args": "[\"[[1, 0, 0, 1, 0, 1, 1, 0, 1, 1], [0, 0, 1, 0, 0, 1, 1, 1, 1, 0], [1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1, 1, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 1], [1, 0, 1, 0, 0, 1, 1, 1, 1, 1], [1, 1, 1, 0, 1, 1, 0, 0, 1, 0]]\", [1, 9], [8, 3], 3]", "A*_args": "[\"[[1, 0, 0, 1, 0, 1, 1, 0, 1, 1], [0, 0, 1, 0, 0, 1, 1, 1, 1, 0], [1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1, 1, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 1], [1, 0, 1, 0, 0, 1, 1, 1, 1, 1], [1, 1, 1, 0, 1, 1, 0, 0, 1, 0]]\", \"(1, 9)\", \"(8, 3)\", \"3\"]"}
{"diff_sorted_id": "23", "problem_statement": "Given 7 labeled water jugs with capacities 118, 15, 88, 145, 84, 14, 107, 31 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 226, 258, 296 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 31, 3], [\"+\", 118, 3], [\"+\", 15, 3], [\"+\", 118, 3], [\"+\", 14, 3], [\"+\", 15, 2], [\"+\", 84, 2], [\"+\", 145, 2], [\"+\", 14, 2], [\"+\", 88, 1], [\"+\", 107, 1], [\"+\", 31, 1]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.05219745635986328", "solution_depth": "12", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[118, 15, 88, 145, 84, 14, 107, 31], [226, 258, 296]]", "is_correct_args": "[[118, 15, 88, 145, 84, 14, 107, 31], [226, 258, 296]]", "A*_args": "[\"[118, 15, 88, 145, 84, 14, 107, 31]\", \"[226, 258, 296]\"]"}
{"diff_sorted_id": "24", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[35, 92, '_'], [32, 44, 94], [97, 75, 58]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[92, 35, 32, 97, 75, 44, 97, 32, 35, 97, 94, 58, 44, 75, 32, 35, 97, 94, 75, 32, 35, 75, 58, 44]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.1467905044555664", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[35, 92, \"_\"], [32, 44, 94], [97, 75, 58]]]", "is_correct_args": "[[[35, 92, \"_\"], [32, 44, 94], [97, 75, 58]]]", "A*_args": "[\"[[35, 92, '_'], [32, 44, 94], [97, 75, 58]]\"]"}
{"diff_sorted_id": "24", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: pimp, sadhe, aurir, unzen   The initial board: [['_', 'p', 'h', 'm', 'p'], ['s', 'a', 'd', 'r', 'e'], ['i', 'u', 'n', 'i', 'r'], ['u', 'a', 'z', 'e', 'n']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-right\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.184800386428833", "solution_depth": "8", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"_\", \"p\", \"h\", \"m\", \"p\"], [\"s\", \"a\", \"d\", \"r\", \"e\"], [\"i\", \"u\", \"n\", \"i\", \"r\"], [\"u\", \"a\", \"z\", \"e\", \"n\"]]]", "is_correct_args": "[[[\"_\", \"p\", \"h\", \"m\", \"p\"], [\"s\", \"a\", \"d\", \"r\", \"e\"], [\"i\", \"u\", \"n\", \"i\", \"r\"], [\"u\", \"a\", \"z\", \"e\", \"n\"]], [\"pimp\", \"sadhe\", \"aurir\", \"unzen\"]]", "A*_args": "[\"[['_', 'p', 'h', 'm', 'p'], ['s', 'a', 'd', 'r', 'e'], ['i', 'u', 'n', 'i', 'r'], ['u', 'a', 'z', 'e', 'n']]\", \"['pimp', 'sadhe', 'aurir', 'unzen']\"]"}
{"diff_sorted_id": "24", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'D'. Our task is to visit city B and city L excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from L and B, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  L H D O A M I J W Y B \nL 0 1 0 1 0 0 0 1 0 1 0 \nH 0 0 0 0 1 0 1 0 1 1 0 \nD 0 1 0 0 0 0 0 0 0 0 0 \nO 0 1 1 0 1 0 0 0 0 0 1 \nA 0 0 1 0 0 0 0 0 0 0 1 \nM 1 1 0 0 0 0 0 0 0 0 0 \nI 0 0 0 0 0 0 0 1 0 1 0 \nJ 1 0 0 1 0 1 0 0 1 0 0 \nW 1 0 0 1 0 1 1 0 0 0 1 \nY 0 1 1 0 0 0 0 0 0 0 1 \nB 0 0 0 0 0 0 1 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[\"D\", \"H\", \"A\", \"B\", \"W\", \"L\", \"J\", \"L\", \"O\", \"B\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.0295867919921875", "solution_depth": "10", "max_successor_states": "11", "num_vars_per_state": "14", "is_feasible_args": "[[[0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0]], [\"L\", \"H\", \"D\", \"O\", \"A\", \"M\", \"I\", \"J\", \"W\", \"Y\", \"B\"], \"B\", \"L\"]", "is_correct_args": "[[[0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0]], [\"L\", \"H\", \"D\", \"O\", \"A\", \"M\", \"I\", \"J\", \"W\", \"Y\", \"B\"], \"D\", \"B\", \"L\"]", "A*_args": "[\"[[0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0]]\", \"['L', 'H', 'D', 'O', 'A', 'M', 'I', 'J', 'W', 'Y', 'B']\", \"['D']\", \"['B', 'L']\"]"}
{"diff_sorted_id": "24", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [25, 29, 8, 11, 8, 25, 20, 16, 6, 4, 98, 7, 28, 24, 27, 16, 23, 26, 26, 99, 2, 7, 22, 7, 5, 24, 2], such that the sum of the chosen coins adds up to 305. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {24: 5, 26: 16, 28: 20, 2: 1, 22: 16, 25: 11, 27: 7, 11: 4, 6: 3, 99: 17, 8: 5, 7: 5, 5: 3, 23: 5, 4: 4, 98: 16, 16: 3, 29: 5, 20: 19}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "17", "opt_solution": "[98, 16, 29, 24, 16, 23, 99]", "opt_solution_cost": "54", "opt_solution_compute_t": "0.034387826919555664", "solution_depth": "7", "max_successor_states": "27", "num_vars_per_state": "27", "is_feasible_args": "[[25, 29, 8, 11, 8, 25, 20, 16, 6, 4, 98, 7, 28, 24, 27, 16, 23, 26, 26, 99, 2, 7, 22, 7, 5, 24, 2]]", "is_correct_args": "[[25, 29, 8, 11, 8, 25, 20, 16, 6, 4, 98, 7, 28, 24, 27, 16, 23, 26, 26, 99, 2, 7, 22, 7, 5, 24, 2], {\"24\": 5, \"26\": 16, \"28\": 20, \"2\": 1, \"22\": 16, \"25\": 11, \"27\": 7, \"11\": 4, \"6\": 3, \"99\": 17, \"8\": 5, \"7\": 5, \"5\": 3, \"23\": 5, \"4\": 4, \"98\": 16, \"16\": 3, \"29\": 5, \"20\": 19}, 305]", "A*_args": "[\"[25, 29, 8, 11, 8, 25, 20, 16, 6, 4, 98, 7, 28, 24, 27, 16, 23, 26, 26, 99, 2, 7, 22, 7, 5, 24, 2]\", \"{24: 5, 26: 16, 28: 20, 2: 1, 22: 16, 25: 11, 27: 7, 11: 4, 6: 3, 99: 17, 8: 5, 7: 5, 5: 3, 23: 5, 4: 4, 98: 16, 16: 3, 29: 5, 20: 19}\", \"305\"]"}
{"diff_sorted_id": "24", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Blue', 'Green', 'Blue'], ['Red', 'Red', 'Red', 'Green'], ['Blue', 'Green', 'Blue', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[0, 1], [0, 2], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [1, 2], [0, 1], [0, 2], [1, 0], [1, 0], [1, 2], [1, 2], [1, 2], [1, 0], [2, 1], [2, 1], [2, 1], [0, 2], [0, 1]]", "opt_solution_cost": "21", "opt_solution_compute_t": "3.7056467533111572", "solution_depth": "21", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Blue\", \"Green\", \"Blue\"], [\"Red\", \"Red\", \"Red\", \"Green\"], [\"Blue\", \"Green\", \"Blue\", \"Green\"]], 6]", "is_correct_args": "[[[\"Red\", \"Blue\", \"Green\", \"Blue\"], [\"Red\", \"Red\", \"Red\", \"Green\"], [\"Blue\", \"Green\", \"Blue\", \"Green\"]], 6]", "A*_args": "[\"[['Red', 'Blue', 'Green', 'Blue'], ['Red', 'Red', 'Red', 'Green'], ['Blue', 'Green', 'Blue', 'Green']]\", \"6\"]"}
{"diff_sorted_id": "24", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 50 to 93 (50 included in the range but 93 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['66' 'x' 'x']\n ['65' '68' 'x']\n ['x' 'x' '79']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 1, 51], [0, 2, 50], [1, 2, 69], [2, 0, 52], [2, 1, 70]]", "opt_solution_cost": "578", "opt_solution_compute_t": "0.18818449974060059", "solution_depth": "5", "max_successor_states": "43", "num_vars_per_state": "9", "is_feasible_args": "[\"[['66', '', ''], ['65', '68', ''], ['', '', '79']]\", 50, 93]", "is_correct_args": "[\"[['66', '', ''], ['65', '68', ''], ['', '', '79']]\", 50, 93]", "A*_args": "[\"[['66', '', ''], ['65', '68', ''], ['', '', '79']]\", \"50\", \"93\"]"}
{"diff_sorted_id": "24", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 9 to 48. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 115, and sum of row 1 must be 95. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 133. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x']\n ['x' 'x' 'x']\n ['42' '45' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 9], [0, 1, 23], [0, 2, 44], [1, 0, 11], [1, 1, 47], [1, 2, 37], [2, 2, 10]]", "opt_solution_cost": "268", "opt_solution_compute_t": "97.89336490631104", "solution_depth": "7", "max_successor_states": "29", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '', ''], ['42', '45', '']]\", 3, 9, 48]", "is_correct_args": "[\"[['', '', ''], ['', '', ''], ['42', '45', '']]\", 9, 48, [1, 2], [1, 2], [115], [95], 133]", "A*_args": "[\"[['', '', ''], ['', '', ''], ['42', '45', '']]\", \"9\", \"48\", \"[None, 115, None]\", \"[None, 95, None]\", \"133\"]"}
{"diff_sorted_id": "24", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 5, 1: 1, 2: 6, 3: 7, 4: 7, 5: 7}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], ['Green', 'Yellow', 'Green', 'Red'], ['Green', 'Red', 'Blue', 'Yellow'], [], ['Blue', 'Red', 'Yellow', 'Blue']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[3, 4], [2, 4], [2, 0], [2, 4], [3, 2], [5, 1], [5, 2], [5, 0], [3, 1], [3, 0], [5, 1]]", "opt_solution_cost": "51", "opt_solution_compute_t": "0.07999825477600098", "solution_depth": "11", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[], [], [\"Green\", \"Yellow\", \"Green\", \"Red\"], [\"Green\", \"Red\", \"Blue\", \"Yellow\"], [], [\"Blue\", \"Red\", \"Yellow\", \"Blue\"]], 4, {\"0\": 5, \"1\": 1, \"2\": 6, \"3\": 7, \"4\": 7, \"5\": 7}]", "is_correct_args": "[[[], [], [\"Green\", \"Yellow\", \"Green\", \"Red\"], [\"Green\", \"Red\", \"Blue\", \"Yellow\"], [], [\"Blue\", \"Red\", \"Yellow\", \"Blue\"]], 4, {\"0\": 5, \"1\": 1, \"2\": 6, \"3\": 7, \"4\": 7, \"5\": 7}, 3]", "A*_args": "[\"[[], [], ['Green', 'Yellow', 'Green', 'Red'], ['Green', 'Red', 'Blue', 'Yellow'], [], ['Blue', 'Red', 'Yellow', 'Blue']]\", \"{0: 5, 1: 1, 2: 6, 3: 7, 4: 7, 5: 7}\", \"4\", \"3\"]"}
{"diff_sorted_id": "24", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (5, 1) to his destination workshop at index (3, 9), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 4, and district 3 covering rows 5 to 9. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[18 19 9 x x x 3 x 8 x]\n[13 2 3 15 3 x 8 9 x x]\n[x 6 18 1 20 7 16 8 1 19]\n[x x x 20 14 x 19 11 9 6]\n[2 x x 6 5 6 7 1 x 8]\n[17 9 5 3 3 x 16 18 x 8]\n[10 x 14 16 x 8 x 9 6 x]\n[x 17 8 11 12 x 4 8 x 13]\n[x x 6 x x x x 13 x 7]\n[9 x x x 3 10 x 3 10 1]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "2", "opt_solution": "[[5, 1], [5, 2], [5, 3], [5, 4], [4, 4], [4, 5], [4, 6], [4, 7], [3, 7], [3, 8], [3, 9]]", "opt_solution_cost": "56", "opt_solution_compute_t": "0.020661354064941406", "solution_depth": "11", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"18\", \"19\", \"9\", \"x\", \"x\", \"x\", \"3\", \"x\", \"8\", \"x\"], [\"13\", \"2\", \"3\", \"15\", \"3\", \"x\", \"8\", \"9\", \"x\", \"x\"], [\"x\", \"6\", \"18\", \"1\", \"20\", \"7\", \"16\", \"8\", \"1\", \"19\"], [\"x\", \"x\", \"x\", \"20\", \"14\", \"x\", \"19\", \"11\", \"9\", \"6\"], [\"2\", \"x\", \"x\", \"6\", \"5\", \"6\", \"7\", \"1\", \"x\", \"8\"], [\"17\", \"9\", \"5\", \"3\", \"3\", \"x\", \"16\", \"18\", \"x\", \"8\"], [\"10\", \"x\", \"14\", \"16\", \"x\", \"8\", \"x\", \"9\", \"6\", \"x\"], [\"x\", \"17\", \"8\", \"11\", \"12\", \"x\", \"4\", \"8\", \"x\", \"13\"], [\"x\", \"x\", \"6\", \"x\", \"x\", \"x\", \"x\", \"13\", \"x\", \"7\"], [\"9\", \"x\", \"x\", \"x\", \"3\", \"10\", \"x\", \"3\", \"10\", \"1\"]]]", "is_correct_args": "[[[\"18\", \"19\", \"9\", \"x\", \"x\", \"x\", \"3\", \"x\", \"8\", \"x\"], [\"13\", \"2\", \"3\", \"15\", \"3\", \"x\", \"8\", \"9\", \"x\", \"x\"], [\"x\", \"6\", \"18\", \"1\", \"20\", \"7\", \"16\", \"8\", \"1\", \"19\"], [\"x\", \"x\", \"x\", \"20\", \"14\", \"x\", \"19\", \"11\", \"9\", \"6\"], [\"2\", \"x\", \"x\", \"6\", \"5\", \"6\", \"7\", \"1\", \"x\", \"8\"], [\"17\", \"9\", \"5\", \"3\", \"3\", \"x\", \"16\", \"18\", \"x\", \"8\"], [\"10\", \"x\", \"14\", \"16\", \"x\", \"8\", \"x\", \"9\", \"6\", \"x\"], [\"x\", \"17\", \"8\", \"11\", \"12\", \"x\", \"4\", \"8\", \"x\", \"13\"], [\"x\", \"x\", \"6\", \"x\", \"x\", \"x\", \"x\", \"13\", \"x\", \"7\"], [\"9\", \"x\", \"x\", \"x\", \"3\", \"10\", \"x\", \"3\", \"10\", \"1\"]], [5, 1], [3, 9], 3, 4]", "A*_args": "[\"[['18', '19', '9', 'x', 'x', 'x', '3', 'x', '8', 'x'], ['13', '2', '3', '15', '3', 'x', '8', '9', 'x', 'x'], ['x', '6', '18', '1', '20', '7', '16', '8', '1', '19'], ['x', 'x', 'x', '20', '14', 'x', '19', '11', '9', '6'], ['2', 'x', 'x', '6', '5', '6', '7', '1', 'x', '8'], ['17', '9', '5', '3', '3', 'x', '16', '18', 'x', '8'], ['10', 'x', '14', '16', 'x', '8', 'x', '9', '6', 'x'], ['x', '17', '8', '11', '12', 'x', '4', '8', 'x', '13'], ['x', 'x', '6', 'x', 'x', 'x', 'x', '13', 'x', '7'], ['9', 'x', 'x', 'x', '3', '10', 'x', '3', '10', '1']]\", \"(5, 1)\", \"(3, 9)\", \"3\", \"4\"]"}
{"diff_sorted_id": "24", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 10x10. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (9, 9) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (4, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 1 0 1 0 0 0 0\n1 1 0 0 0 0 0 0 0 1\n1 0 1 0 1 1 0 1 1 1\n1 0 1 0 1 1 0 1 1 1\n1 0 1 1 0 1 1 1 0 1\n1 0 1 1 1 0 1 1 1 1\n1 0 0 1 1 1 1 0 0 0\n0 0 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 0 1 0\n0 1 1 0 0 1 1 1 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[[9, 9], [9, 8], [8, 7], [7, 6], [7, 5], [7, 4], [7, 3], [6, 2], [6, 1], [5, 1], [4, 1]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.030521631240844727", "solution_depth": "11", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 1, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 0, 1, 1, 1], [1, 0, 1, 1, 0, 1, 1, 1, 0, 1], [1, 0, 1, 1, 1, 0, 1, 1, 1, 1], [1, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 1, 0, 0, 1, 1, 1, 0, 0]]\", 3]", "is_correct_args": "[\"[[1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 1, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 0, 1, 1, 1], [1, 0, 1, 1, 0, 1, 1, 1, 0, 1], [1, 0, 1, 1, 1, 0, 1, 1, 1, 1], [1, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 1, 0, 0, 1, 1, 1, 0, 0]]\", [9, 9], [4, 1], 3]", "A*_args": "[\"[[1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 1, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 0, 1, 1, 1], [1, 0, 1, 1, 0, 1, 1, 1, 0, 1], [1, 0, 1, 1, 1, 0, 1, 1, 1, 1], [1, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 1, 0, 0, 1, 1, 1, 0, 0]]\", \"(9, 9)\", \"(4, 1)\", \"3\"]"}
{"diff_sorted_id": "24", "problem_statement": "Given 7 labeled water jugs with capacities 33, 56, 108, 53, 65, 54, 52, 59 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 168, 239, 307 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 59, 3], [\"+\", 108, 3], [\"+\", 108, 3], [\"-\", 33, 3], [\"+\", 65, 3], [\"+\", 108, 2], [\"+\", 108, 2], [\"-\", 33, 2], [\"+\", 56, 2], [\"+\", 53, 1], [\"+\", 56, 1], [\"+\", 59, 1]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.04154396057128906", "solution_depth": "12", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[33, 56, 108, 53, 65, 54, 52, 59], [168, 239, 307]]", "is_correct_args": "[[33, 56, 108, 53, 65, 54, 52, 59], [168, 239, 307]]", "A*_args": "[\"[33, 56, 108, 53, 65, 54, 52, 59]\", \"[168, 239, 307]\"]"}
{"diff_sorted_id": "25", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[45, 13, '_'], [66, 41, 76], [85, 21, 74]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[76, 41, 13, 76, 41, 13, 66, 85, 21, 74, 13, 41, 76, 45, 85, 66, 74, 13, 41, 74, 45, 76, 74, 41]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.10150957107543945", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[45, 13, \"_\"], [66, 41, 76], [85, 21, 74]]]", "is_correct_args": "[[[45, 13, \"_\"], [66, 41, 76], [85, 21, 74]]]", "A*_args": "[\"[[45, 13, '_'], [66, 41, 76], [85, 21, 74]]\"]"}
{"diff_sorted_id": "25", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: guha, nisus, uncap, jough   The initial board: [['i', 'g', 'u', 'h', 'a'], ['n', 'o', 's', 'u', 's'], ['c', 'n', 'g', 'a', '_'], ['j', 'u', 'u', 'p', 'h']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"up-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-left\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.21672630310058594", "solution_depth": "8", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"i\", \"g\", \"u\", \"h\", \"a\"], [\"n\", \"o\", \"s\", \"u\", \"s\"], [\"c\", \"n\", \"g\", \"a\", \"_\"], [\"j\", \"u\", \"u\", \"p\", \"h\"]]]", "is_correct_args": "[[[\"i\", \"g\", \"u\", \"h\", \"a\"], [\"n\", \"o\", \"s\", \"u\", \"s\"], [\"c\", \"n\", \"g\", \"a\", \"_\"], [\"j\", \"u\", \"u\", \"p\", \"h\"]], [\"guha\", \"nisus\", \"uncap\", \"jough\"]]", "A*_args": "[\"[['i', 'g', 'u', 'h', 'a'], ['n', 'o', 's', 'u', 's'], ['c', 'n', 'g', 'a', '_'], ['j', 'u', 'u', 'p', 'h']]\", \"['guha', 'nisus', 'uncap', 'jough']\"]"}
{"diff_sorted_id": "25", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'M'. Our task is to visit city Y and city X excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from X and Y, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  O M Y J Z V K F X L R \nO 0 0 0 0 1 0 0 0 0 1 1 \nM 0 0 0 0 0 1 0 0 0 0 0 \nY 1 1 0 0 0 1 0 0 0 0 1 \nJ 0 0 0 0 1 0 0 1 1 1 0 \nZ 0 0 0 0 0 0 1 0 0 0 0 \nV 0 0 0 0 0 0 0 1 0 0 0 \nK 0 1 1 0 1 1 0 0 0 0 0 \nF 1 0 1 0 0 0 0 0 0 0 0 \nX 0 0 0 1 1 1 1 0 0 0 0 \nL 1 1 0 0 0 0 1 0 1 0 0 \nR 0 0 0 1 0 1 0 1 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[\"M\", \"V\", \"F\", \"Y\", \"O\", \"L\", \"X\", \"J\", \"X\", \"K\", \"Y\"]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.02562737464904785", "solution_depth": "11", "max_successor_states": "11", "num_vars_per_state": "14", "is_feasible_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0]], [\"O\", \"M\", \"Y\", \"J\", \"Z\", \"V\", \"K\", \"F\", \"X\", \"L\", \"R\"], \"Y\", \"X\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0]], [\"O\", \"M\", \"Y\", \"J\", \"Z\", \"V\", \"K\", \"F\", \"X\", \"L\", \"R\"], \"M\", \"Y\", \"X\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0]]\", \"['O', 'M', 'Y', 'J', 'Z', 'V', 'K', 'F', 'X', 'L', 'R']\", \"['M']\", \"['Y', 'X']\"]"}
{"diff_sorted_id": "25", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [28, 5, 25, 22, 26, 13, 20, 20, 18, 28, 7, 20, 18, 19, 18, 5, 15, 23, 28, 27, 22, 10, 8, 17, 3, 8, 5, 11, 21, 17, 65, 23, 11, 3, 12], such that the sum of the chosen coins adds up to 284. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {20: 12, 21: 3, 5: 2, 3: 2, 7: 1, 15: 8, 8: 7, 27: 6, 17: 8, 18: 14, 28: 5, 13: 1, 23: 4, 65: 8, 26: 8, 22: 5, 25: 3, 11: 11, 12: 8, 19: 19, 10: 7}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "18", "opt_solution": "[7, 13, 21, 23, 25, 65, 28, 22, 23, 22, 27, 8]", "opt_solution_cost": "52", "opt_solution_compute_t": "0.03629875183105469", "solution_depth": "12", "max_successor_states": "35", "num_vars_per_state": "35", "is_feasible_args": "[[28, 5, 25, 22, 26, 13, 20, 20, 18, 28, 7, 20, 18, 19, 18, 5, 15, 23, 28, 27, 22, 10, 8, 17, 3, 8, 5, 11, 21, 17, 65, 23, 11, 3, 12]]", "is_correct_args": "[[28, 5, 25, 22, 26, 13, 20, 20, 18, 28, 7, 20, 18, 19, 18, 5, 15, 23, 28, 27, 22, 10, 8, 17, 3, 8, 5, 11, 21, 17, 65, 23, 11, 3, 12], {\"20\": 12, \"21\": 3, \"5\": 2, \"3\": 2, \"7\": 1, \"15\": 8, \"8\": 7, \"27\": 6, \"17\": 8, \"18\": 14, \"28\": 5, \"13\": 1, \"23\": 4, \"65\": 8, \"26\": 8, \"22\": 5, \"25\": 3, \"11\": 11, \"12\": 8, \"19\": 19, \"10\": 7}, 284]", "A*_args": "[\"[28, 5, 25, 22, 26, 13, 20, 20, 18, 28, 7, 20, 18, 19, 18, 5, 15, 23, 28, 27, 22, 10, 8, 17, 3, 8, 5, 11, 21, 17, 65, 23, 11, 3, 12]\", \"{20: 12, 21: 3, 5: 2, 3: 2, 7: 1, 15: 8, 8: 7, 27: 6, 17: 8, 18: 14, 28: 5, 13: 1, 23: 4, 65: 8, 26: 8, 22: 5, 25: 3, 11: 11, 12: 8, 19: 19, 10: 7}\", \"284\"]"}
{"diff_sorted_id": "25", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 6 balls. It is not allowed to place a ball in a tube that already has 6 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Green', 'Red', 'Red'], ['Blue', 'Blue', 'Blue', 'Blue'], ['Green', 'Red', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "7", "opt_solution": "[[2, 0], [2, 1], [2, 0], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0]]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.04879570007324219", "solution_depth": "10", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Green\", \"Red\", \"Red\"], [\"Blue\", \"Blue\", \"Blue\", \"Blue\"], [\"Green\", \"Red\", \"Green\", \"Red\"]], 6]", "is_correct_args": "[[[\"Green\", \"Green\", \"Red\", \"Red\"], [\"Blue\", \"Blue\", \"Blue\", \"Blue\"], [\"Green\", \"Red\", \"Green\", \"Red\"]], 6]", "A*_args": "[\"[['Green', 'Green', 'Red', 'Red'], ['Blue', 'Blue', 'Blue', 'Blue'], ['Green', 'Red', 'Green', 'Red']]\", \"6\"]"}
{"diff_sorted_id": "25", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 29 to 72 (29 included in the range but 72 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' 'x']\n ['39' 'x' '52']\n ['60' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 0, 29], [0, 1, 31], [0, 2, 53], [1, 1, 40], [2, 1, 41], [2, 2, 30]]", "opt_solution_cost": "347", "opt_solution_compute_t": "36.68832039833069", "solution_depth": "6", "max_successor_states": "43", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['39', '', '52'], ['60', '', '']]\", 29, 72]", "is_correct_args": "[\"[['', '', ''], ['39', '', '52'], ['60', '', '']]\", 29, 72]", "A*_args": "[\"[['', '', ''], ['39', '', '52'], ['60', '', '']]\", \"29\", \"72\"]"}
{"diff_sorted_id": "25", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 9 to 48. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 67, and sum of row 1 must be 60. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 89. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '16' 'x']\n ['x' 'x' 'x']\n ['45' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 0, 9], [0, 2, 10], [1, 0, 12], [1, 1, 34], [1, 2, 14], [2, 1, 17], [2, 2, 11]]", "opt_solution_cost": "168", "opt_solution_compute_t": "0.5386793613433838", "solution_depth": "7", "max_successor_states": "34", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '16', ''], ['', '', ''], ['45', '', '']]\", 3, 9, 48]", "is_correct_args": "[\"[['', '16', ''], ['', '', ''], ['45', '', '']]\", 9, 48, [1, 2], [1, 2], [67], [60], 89]", "A*_args": "[\"[['', '16', ''], ['', '', ''], ['45', '', '']]\", \"9\", \"48\", \"[None, 67, None]\", \"[None, 60, None]\", \"89\"]"}
{"diff_sorted_id": "25", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 4, 1: 3, 2: 2, 3: 4, 4: 2, 5: 5}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Green', 'Blue', 'Yellow', 'Green'], ['Yellow', 'Red', 'Red', 'Blue'], [], ['Blue', 'Green', 'Yellow', 'Red'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[2, 0], [4, 3], [4, 5], [4, 0], [2, 4], [2, 4], [2, 3], [1, 2], [1, 3], [1, 0], [1, 2], [5, 2]]", "opt_solution_cost": "39", "opt_solution_compute_t": "0.023729562759399414", "solution_depth": "12", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[], [\"Green\", \"Blue\", \"Yellow\", \"Green\"], [\"Yellow\", \"Red\", \"Red\", \"Blue\"], [], [\"Blue\", \"Green\", \"Yellow\", \"Red\"], []], 4, {\"0\": 4, \"1\": 3, \"2\": 2, \"3\": 4, \"4\": 2, \"5\": 5}]", "is_correct_args": "[[[], [\"Green\", \"Blue\", \"Yellow\", \"Green\"], [\"Yellow\", \"Red\", \"Red\", \"Blue\"], [], [\"Blue\", \"Green\", \"Yellow\", \"Red\"], []], 4, {\"0\": 4, \"1\": 3, \"2\": 2, \"3\": 4, \"4\": 2, \"5\": 5}, 3]", "A*_args": "[\"[[], ['Green', 'Blue', 'Yellow', 'Green'], ['Yellow', 'Red', 'Red', 'Blue'], [], ['Blue', 'Green', 'Yellow', 'Red'], []]\", \"{0: 4, 1: 3, 2: 2, 3: 4, 4: 2, 5: 5}\", \"4\", \"3\"]"}
{"diff_sorted_id": "25", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (2, 9) to his destination workshop at index (5, 2), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 4, and district 3 covering rows 5 to 9. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x 6 x x x x 15 x x]\n[x 17 13 13 x 12 x 3 10 2]\n[x 5 13 15 4 x x 20 6 2]\n[x 9 x 6 2 16 18 9 13 x]\n[x x 15 17 x 10 11 x x x]\n[3 x 3 17 8 x 1 x 16 x]\n[x x 13 15 x x 11 x x 4]\n[x x 12 1 x x x 14 11 x]\n[x 14 x x 19 13 4 x x x]\n[1 x x 14 11 19 2 17 2 5]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "2", "opt_solution": "[[2, 9], [2, 8], [3, 8], [3, 7], [3, 6], [3, 5], [3, 4], [3, 3], [4, 3], [4, 2], [5, 2]]", "opt_solution_cost": "105", "opt_solution_compute_t": "0.022072553634643555", "solution_depth": "11", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"6\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\", \"x\"], [\"x\", \"17\", \"13\", \"13\", \"x\", \"12\", \"x\", \"3\", \"10\", \"2\"], [\"x\", \"5\", \"13\", \"15\", \"4\", \"x\", \"x\", \"20\", \"6\", \"2\"], [\"x\", \"9\", \"x\", \"6\", \"2\", \"16\", \"18\", \"9\", \"13\", \"x\"], [\"x\", \"x\", \"15\", \"17\", \"x\", \"10\", \"11\", \"x\", \"x\", \"x\"], [\"3\", \"x\", \"3\", \"17\", \"8\", \"x\", \"1\", \"x\", \"16\", \"x\"], [\"x\", \"x\", \"13\", \"15\", \"x\", \"x\", \"11\", \"x\", \"x\", \"4\"], [\"x\", \"x\", \"12\", \"1\", \"x\", \"x\", \"x\", \"14\", \"11\", \"x\"], [\"x\", \"14\", \"x\", \"x\", \"19\", \"13\", \"4\", \"x\", \"x\", \"x\"], [\"1\", \"x\", \"x\", \"14\", \"11\", \"19\", \"2\", \"17\", \"2\", \"5\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"6\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\", \"x\"], [\"x\", \"17\", \"13\", \"13\", \"x\", \"12\", \"x\", \"3\", \"10\", \"2\"], [\"x\", \"5\", \"13\", \"15\", \"4\", \"x\", \"x\", \"20\", \"6\", \"2\"], [\"x\", \"9\", \"x\", \"6\", \"2\", \"16\", \"18\", \"9\", \"13\", \"x\"], [\"x\", \"x\", \"15\", \"17\", \"x\", \"10\", \"11\", \"x\", \"x\", \"x\"], [\"3\", \"x\", \"3\", \"17\", \"8\", \"x\", \"1\", \"x\", \"16\", \"x\"], [\"x\", \"x\", \"13\", \"15\", \"x\", \"x\", \"11\", \"x\", \"x\", \"4\"], [\"x\", \"x\", \"12\", \"1\", \"x\", \"x\", \"x\", \"14\", \"11\", \"x\"], [\"x\", \"14\", \"x\", \"x\", \"19\", \"13\", \"4\", \"x\", \"x\", \"x\"], [\"1\", \"x\", \"x\", \"14\", \"11\", \"19\", \"2\", \"17\", \"2\", \"5\"]], [2, 9], [5, 2], 2, 4]", "A*_args": "[\"[['x', 'x', '6', 'x', 'x', 'x', 'x', '15', 'x', 'x'], ['x', '17', '13', '13', 'x', '12', 'x', '3', '10', '2'], ['x', '5', '13', '15', '4', 'x', 'x', '20', '6', '2'], ['x', '9', 'x', '6', '2', '16', '18', '9', '13', 'x'], ['x', 'x', '15', '17', 'x', '10', '11', 'x', 'x', 'x'], ['3', 'x', '3', '17', '8', 'x', '1', 'x', '16', 'x'], ['x', 'x', '13', '15', 'x', 'x', '11', 'x', 'x', '4'], ['x', 'x', '12', '1', 'x', 'x', 'x', '14', '11', 'x'], ['x', '14', 'x', 'x', '19', '13', '4', 'x', 'x', 'x'], ['1', 'x', 'x', '14', '11', '19', '2', '17', '2', '5']]\", \"(2, 9)\", \"(5, 2)\", \"2\", \"4\"]"}
{"diff_sorted_id": "25", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 10x10. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (7, 6). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 0 1 1 1 0 1 0 0\n0 0 0 1 1 0 1 1 0 1\n1 0 1 1 1 1 0 0 1 1\n0 1 0 1 0 0 1 1 1 1\n0 0 0 0 0 0 1 1 1 1\n1 1 1 0 0 0 1 1 1 0\n1 0 1 1 0 0 1 1 1 1\n1 0 1 1 1 0 0 0 0 0\n1 1 0 1 0 1 1 1 0 0\n0 1 1 1 0 1 1 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[[0, 0], [1, 0], [1, 1], [2, 1], [3, 2], [4, 2], [4, 3], [4, 4], [5, 4], [6, 5], [7, 6]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.031239748001098633", "solution_depth": "11", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 0, 1, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 1, 1, 0, 1], [1, 0, 1, 1, 1, 1, 0, 0, 1, 1], [0, 1, 0, 1, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 1, 1], [1, 0, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 1, 1, 1, 0, 0], [0, 1, 1, 1, 0, 1, 1, 1, 1, 1]]\", 3]", "is_correct_args": "[\"[[0, 0, 0, 1, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 1, 1, 0, 1], [1, 0, 1, 1, 1, 1, 0, 0, 1, 1], [0, 1, 0, 1, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 1, 1], [1, 0, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 1, 1, 1, 0, 0], [0, 1, 1, 1, 0, 1, 1, 1, 1, 1]]\", [0, 0], [7, 6], 3]", "A*_args": "[\"[[0, 0, 0, 1, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 1, 1, 0, 1], [1, 0, 1, 1, 1, 1, 0, 0, 1, 1], [0, 1, 0, 1, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 1, 1], [1, 0, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 1, 1, 1, 0, 0], [0, 1, 1, 1, 0, 1, 1, 1, 1, 1]]\", \"(0, 0)\", \"(7, 6)\", \"3\"]"}
{"diff_sorted_id": "25", "problem_statement": "Given 7 labeled water jugs with capacities 75, 20, 64, 106, 88, 13, 107, 131 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 287, 394, 455 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 75, 3], [\"+\", 131, 3], [\"+\", 131, 3], [\"-\", 13, 3], [\"+\", 131, 3], [\"+\", 106, 2], [\"+\", 106, 2], [\"+\", 75, 2], [\"+\", 107, 2], [\"+\", 75, 1], [\"+\", 106, 1], [\"+\", 106, 1]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.05149412155151367", "solution_depth": "12", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[75, 20, 64, 106, 88, 13, 107, 131], [287, 394, 455]]", "is_correct_args": "[[75, 20, 64, 106, 88, 13, 107, 131], [287, 394, 455]]", "A*_args": "[\"[75, 20, 64, 106, 88, 13, 107, 131]\", \"[287, 394, 455]\"]"}
{"diff_sorted_id": "26", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[56, 79, '_'], [43, 89, 94], [36, 52, 25]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[79, 89, 94, 79, 89, 94, 43, 56, 94, 89, 79, 43, 52, 25]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.0211181640625", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[56, 79, \"_\"], [43, 89, 94], [36, 52, 25]]]", "is_correct_args": "[[[56, 79, \"_\"], [43, 89, 94], [36, 52, 25]]]", "A*_args": "[\"[[56, 79, '_'], [43, 89, 94], [36, 52, 25]]\"]"}
{"diff_sorted_id": "26", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: wolf, stunt, lammy, faded   The initial board: [['t', 'w', 'y', 'l', '_'], ['s', 'a', 'u', 'f', 't'], ['o', 'a', 'e', 'm', 'n'], ['f', 'l', 'd', 'm', 'd']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.2016615867614746", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"t\", \"w\", \"y\", \"l\", \"_\"], [\"s\", \"a\", \"u\", \"f\", \"t\"], [\"o\", \"a\", \"e\", \"m\", \"n\"], [\"f\", \"l\", \"d\", \"m\", \"d\"]]]", "is_correct_args": "[[[\"t\", \"w\", \"y\", \"l\", \"_\"], [\"s\", \"a\", \"u\", \"f\", \"t\"], [\"o\", \"a\", \"e\", \"m\", \"n\"], [\"f\", \"l\", \"d\", \"m\", \"d\"]], [\"wolf\", \"stunt\", \"lammy\", \"faded\"]]", "A*_args": "[\"[['t', 'w', 'y', 'l', '_'], ['s', 'a', 'u', 'f', 't'], ['o', 'a', 'e', 'm', 'n'], ['f', 'l', 'd', 'm', 'd']]\", \"['wolf', 'stunt', 'lammy', 'faded']\"]"}
{"diff_sorted_id": "26", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'I'. Our task is to visit city W and city L excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from L and W, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  L T W P Z H I X R C K \nL 0 0 0 0 1 0 0 0 1 0 1 \nT 1 0 0 1 0 0 1 1 0 0 0 \nW 0 0 0 0 0 0 0 0 1 1 0 \nP 1 0 0 0 0 0 0 0 0 0 1 \nZ 1 1 0 1 0 0 0 0 1 0 0 \nH 1 1 1 0 0 0 0 0 0 0 1 \nI 0 1 0 0 1 0 0 0 0 1 0 \nX 0 0 1 0 0 1 0 0 0 0 0 \nR 0 1 1 1 1 0 1 1 0 0 0 \nC 1 1 0 1 0 0 0 0 1 0 0 \nK 0 0 0 0 0 1 0 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[\"I\", \"T\", \"L\", \"K\", \"H\", \"W\", \"R\", \"W\", \"C\", \"L\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.03812885284423828", "solution_depth": "10", "max_successor_states": "11", "num_vars_per_state": "14", "is_feasible_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]], [\"L\", \"T\", \"W\", \"P\", \"Z\", \"H\", \"I\", \"X\", \"R\", \"C\", \"K\"], \"W\", \"L\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]], [\"L\", \"T\", \"W\", \"P\", \"Z\", \"H\", \"I\", \"X\", \"R\", \"C\", \"K\"], \"I\", \"W\", \"L\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0]]\", \"['L', 'T', 'W', 'P', 'Z', 'H', 'I', 'X', 'R', 'C', 'K']\", \"['I']\", \"['W', 'L']\"]"}
{"diff_sorted_id": "26", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [29, 29, 22, 23, 23, 3, 26, 9, 15, 8, 21, 15, 29, 25, 71, 27, 23, 6, 7, 9, 15, 21, 6, 8, 19, 17, 18, 6, 26, 24, 24, 3, 25, 2], such that the sum of the chosen coins adds up to 307. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {24: 14, 2: 1, 25: 2, 26: 14, 18: 12, 27: 15, 29: 19, 19: 3, 15: 7, 9: 1, 8: 1, 21: 18, 6: 1, 71: 3, 23: 4, 17: 7, 7: 2, 22: 11, 3: 1}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "19", "opt_solution": "[6, 9, 25, 25, 71, 6, 19, 8, 23, 23, 23, 6, 7, 9, 15, 15, 17]", "opt_solution_cost": "51", "opt_solution_compute_t": "0.04102158546447754", "solution_depth": "17", "max_successor_states": "34", "num_vars_per_state": "34", "is_feasible_args": "[[29, 29, 22, 23, 23, 3, 26, 9, 15, 8, 21, 15, 29, 25, 71, 27, 23, 6, 7, 9, 15, 21, 6, 8, 19, 17, 18, 6, 26, 24, 24, 3, 25, 2]]", "is_correct_args": "[[29, 29, 22, 23, 23, 3, 26, 9, 15, 8, 21, 15, 29, 25, 71, 27, 23, 6, 7, 9, 15, 21, 6, 8, 19, 17, 18, 6, 26, 24, 24, 3, 25, 2], {\"24\": 14, \"2\": 1, \"25\": 2, \"26\": 14, \"18\": 12, \"27\": 15, \"29\": 19, \"19\": 3, \"15\": 7, \"9\": 1, \"8\": 1, \"21\": 18, \"6\": 1, \"71\": 3, \"23\": 4, \"17\": 7, \"7\": 2, \"22\": 11, \"3\": 1}, 307]", "A*_args": "[\"[29, 29, 22, 23, 23, 3, 26, 9, 15, 8, 21, 15, 29, 25, 71, 27, 23, 6, 7, 9, 15, 21, 6, 8, 19, 17, 18, 6, 26, 24, 24, 3, 25, 2]\", \"{24: 14, 2: 1, 25: 2, 26: 14, 18: 12, 27: 15, 29: 19, 19: 3, 15: 7, 9: 1, 8: 1, 21: 18, 6: 1, 71: 3, 23: 4, 17: 7, 7: 2, 22: 11, 3: 1}\", \"307\"]"}
{"diff_sorted_id": "26", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Blue', 'Blue', 'Red'], ['Green', 'Green', 'Blue', 'Blue'], ['Green', 'Green', 'Red', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[0, 2], [1, 2], [1, 2], [0, 1], [0, 1], [0, 1], [2, 0], [2, 0], [2, 1], [2, 0], [2, 0], [1, 2], [1, 2]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.2634403705596924", "solution_depth": "13", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Red\"], [\"Green\", \"Green\", \"Blue\", \"Blue\"], [\"Green\", \"Green\", \"Red\", \"Red\"]], 7]", "is_correct_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Red\"], [\"Green\", \"Green\", \"Blue\", \"Blue\"], [\"Green\", \"Green\", \"Red\", \"Red\"]], 7]", "A*_args": "[\"[['Red', 'Blue', 'Blue', 'Red'], ['Green', 'Green', 'Blue', 'Blue'], ['Green', 'Green', 'Red', 'Red']]\", \"7\"]"}
{"diff_sorted_id": "26", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 17 to 60 (17 included in the range but 60 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['29' 'x' 'x']\n ['x' 'x' 'x']\n ['36' '55' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 1, 18], [0, 2, 17], [1, 0, 30], [1, 1, 20], [1, 2, 19], [2, 2, 56]]", "opt_solution_cost": "261", "opt_solution_compute_t": "27.528469800949097", "solution_depth": "6", "max_successor_states": "43", "num_vars_per_state": "9", "is_feasible_args": "[\"[['29', '', ''], ['', '', ''], ['36', '55', '']]\", 17, 60]", "is_correct_args": "[\"[['29', '', ''], ['', '', ''], ['36', '55', '']]\", 17, 60]", "A*_args": "[\"[['29', '', ''], ['', '', ''], ['36', '55', '']]\", \"17\", \"60\"]"}
{"diff_sorted_id": "26", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 26 to 65. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 150, and sum of row 1 must be 135. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 119. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x']\n ['x' 'x' 'x']\n ['x' '32' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 0, 26], [0, 1, 54], [0, 2, 27], [1, 0, 30], [1, 1, 64], [1, 2, 41], [2, 0, 28], [2, 2, 29]]", "opt_solution_cost": "331", "opt_solution_compute_t": "25.04846739768982", "solution_depth": "8", "max_successor_states": "34", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '', ''], ['', '32', '']]\", 3, 26, 65]", "is_correct_args": "[\"[['', '', ''], ['', '', ''], ['', '32', '']]\", 26, 65, [1, 2], [1, 2], [150], [135], 119]", "A*_args": "[\"[['', '', ''], ['', '', ''], ['', '32', '']]\", \"26\", \"65\", \"[None, 150, None]\", \"[None, 135, None]\", \"119\"]"}
{"diff_sorted_id": "26", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 4, 1: 4, 2: 7, 3: 7, 4: 5, 5: 6}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Blue', 'Yellow', 'Red', 'Yellow'], ['Green', 'Red', 'Green', 'Red'], ['Blue', 'Green', 'Blue', 'Yellow'], [], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[0, 4], [1, 5], [2, 4], [2, 5], [2, 3], [0, 2], [3, 4], [0, 3], [0, 2], [1, 0], [1, 5], [0, 1], [3, 1]]", "opt_solution_cost": "73", "opt_solution_compute_t": "0.024808883666992188", "solution_depth": "13", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Blue\", \"Yellow\", \"Red\", \"Yellow\"], [\"Green\", \"Red\", \"Green\", \"Red\"], [\"Blue\", \"Green\", \"Blue\", \"Yellow\"], [], [], []], 4, {\"0\": 4, \"1\": 4, \"2\": 7, \"3\": 7, \"4\": 5, \"5\": 6}]", "is_correct_args": "[[[\"Blue\", \"Yellow\", \"Red\", \"Yellow\"], [\"Green\", \"Red\", \"Green\", \"Red\"], [\"Blue\", \"Green\", \"Blue\", \"Yellow\"], [], [], []], 4, {\"0\": 4, \"1\": 4, \"2\": 7, \"3\": 7, \"4\": 5, \"5\": 6}, 3]", "A*_args": "[\"[['Blue', 'Yellow', 'Red', 'Yellow'], ['Green', 'Red', 'Green', 'Red'], ['Blue', 'Green', 'Blue', 'Yellow'], [], [], []]\", \"{0: 4, 1: 4, 2: 7, 3: 7, 4: 5, 5: 6}\", \"4\", \"3\"]"}
{"diff_sorted_id": "26", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (5, 9) to his destination workshop at index (3, 1), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 4, and district 3 covering rows 5 to 9. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[7 x 19 11 6 x 4 15 9 3]\n[x x 13 x 8 17 x x 12 16]\n[x x 2 x 15 8 x 13 4 x]\n[13 11 3 3 3 x x x x x]\n[1 16 14 6 14 17 4 9 1 x]\n[x 4 9 x 17 17 x 13 2 9]\n[x x x x 5 14 17 12 7 14]\n[x 15 1 6 x x 5 x x 1]\n[x x 19 x x x x x 13 8]\n[x 6 9 12 8 8 x 18 x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "2", "opt_solution": "[[5, 9], [5, 8], [4, 8], [4, 7], [4, 6], [4, 5], [4, 4], [3, 4], [3, 3], [3, 2], [3, 1]]", "opt_solution_cost": "67", "opt_solution_compute_t": "0.02885293960571289", "solution_depth": "11", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"7\", \"x\", \"19\", \"11\", \"6\", \"x\", \"4\", \"15\", \"9\", \"3\"], [\"x\", \"x\", \"13\", \"x\", \"8\", \"17\", \"x\", \"x\", \"12\", \"16\"], [\"x\", \"x\", \"2\", \"x\", \"15\", \"8\", \"x\", \"13\", \"4\", \"x\"], [\"13\", \"11\", \"3\", \"3\", \"3\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"1\", \"16\", \"14\", \"6\", \"14\", \"17\", \"4\", \"9\", \"1\", \"x\"], [\"x\", \"4\", \"9\", \"x\", \"17\", \"17\", \"x\", \"13\", \"2\", \"9\"], [\"x\", \"x\", \"x\", \"x\", \"5\", \"14\", \"17\", \"12\", \"7\", \"14\"], [\"x\", \"15\", \"1\", \"6\", \"x\", \"x\", \"5\", \"x\", \"x\", \"1\"], [\"x\", \"x\", \"19\", \"x\", \"x\", \"x\", \"x\", \"x\", \"13\", \"8\"], [\"x\", \"6\", \"9\", \"12\", \"8\", \"8\", \"x\", \"18\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"7\", \"x\", \"19\", \"11\", \"6\", \"x\", \"4\", \"15\", \"9\", \"3\"], [\"x\", \"x\", \"13\", \"x\", \"8\", \"17\", \"x\", \"x\", \"12\", \"16\"], [\"x\", \"x\", \"2\", \"x\", \"15\", \"8\", \"x\", \"13\", \"4\", \"x\"], [\"13\", \"11\", \"3\", \"3\", \"3\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"1\", \"16\", \"14\", \"6\", \"14\", \"17\", \"4\", \"9\", \"1\", \"x\"], [\"x\", \"4\", \"9\", \"x\", \"17\", \"17\", \"x\", \"13\", \"2\", \"9\"], [\"x\", \"x\", \"x\", \"x\", \"5\", \"14\", \"17\", \"12\", \"7\", \"14\"], [\"x\", \"15\", \"1\", \"6\", \"x\", \"x\", \"5\", \"x\", \"x\", \"1\"], [\"x\", \"x\", \"19\", \"x\", \"x\", \"x\", \"x\", \"x\", \"13\", \"8\"], [\"x\", \"6\", \"9\", \"12\", \"8\", \"8\", \"x\", \"18\", \"x\", \"x\"]], [5, 9], [3, 1], 3, 4]", "A*_args": "[\"[['7', 'x', '19', '11', '6', 'x', '4', '15', '9', '3'], ['x', 'x', '13', 'x', '8', '17', 'x', 'x', '12', '16'], ['x', 'x', '2', 'x', '15', '8', 'x', '13', '4', 'x'], ['13', '11', '3', '3', '3', 'x', 'x', 'x', 'x', 'x'], ['1', '16', '14', '6', '14', '17', '4', '9', '1', 'x'], ['x', '4', '9', 'x', '17', '17', 'x', '13', '2', '9'], ['x', 'x', 'x', 'x', '5', '14', '17', '12', '7', '14'], ['x', '15', '1', '6', 'x', 'x', '5', 'x', 'x', '1'], ['x', 'x', '19', 'x', 'x', 'x', 'x', 'x', '13', '8'], ['x', '6', '9', '12', '8', '8', 'x', '18', 'x', 'x']]\", \"(5, 9)\", \"(3, 1)\", \"3\", \"4\"]"}
{"diff_sorted_id": "26", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 10x10. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (8, 6) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (0, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 0 1 1 0 0 1 1 0\n1 0 0 0 1 0 1 1 0 1\n0 0 0 1 0 0 1 1 1 1\n0 1 1 0 1 1 1 1 0 1\n0 1 1 0 1 1 1 1 0 0\n0 1 1 0 0 0 1 1 1 0\n0 1 0 0 1 1 0 0 1 1\n0 0 0 0 0 0 0 1 1 1\n1 1 0 1 1 0 0 0 0 0\n0 0 1 0 0 0 0 0 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[[8, 6], [7, 5], [7, 4], [6, 3], [5, 3], [4, 3], [3, 3], [2, 2], [1, 2], [0, 2], [0, 1]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.030196428298950195", "solution_depth": "11", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 0, 1, 1, 0, 0, 1, 1, 0], [1, 0, 0, 0, 1, 0, 1, 1, 0, 1], [0, 0, 0, 1, 0, 0, 1, 1, 1, 1], [0, 1, 1, 0, 1, 1, 1, 1, 0, 1], [0, 1, 1, 0, 1, 1, 1, 1, 0, 0], [0, 1, 1, 0, 0, 0, 1, 1, 1, 0], [0, 1, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [1, 1, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]]\", 3]", "is_correct_args": "[\"[[1, 0, 0, 1, 1, 0, 0, 1, 1, 0], [1, 0, 0, 0, 1, 0, 1, 1, 0, 1], [0, 0, 0, 1, 0, 0, 1, 1, 1, 1], [0, 1, 1, 0, 1, 1, 1, 1, 0, 1], [0, 1, 1, 0, 1, 1, 1, 1, 0, 0], [0, 1, 1, 0, 0, 0, 1, 1, 1, 0], [0, 1, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [1, 1, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]]\", [8, 6], [0, 1], 3]", "A*_args": "[\"[[1, 0, 0, 1, 1, 0, 0, 1, 1, 0], [1, 0, 0, 0, 1, 0, 1, 1, 0, 1], [0, 0, 0, 1, 0, 0, 1, 1, 1, 1], [0, 1, 1, 0, 1, 1, 1, 1, 0, 1], [0, 1, 1, 0, 1, 1, 1, 1, 0, 0], [0, 1, 1, 0, 0, 0, 1, 1, 1, 0], [0, 1, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [1, 1, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 1, 0]]\", \"(8, 6)\", \"(0, 1)\", \"3\"]"}
{"diff_sorted_id": "26", "problem_statement": "Given 7 labeled water jugs with capacities 24, 132, 149, 62, 120, 61, 42 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 298, 430, 468 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 42, 3], [\"+\", 132, 3], [\"+\", 132, 3], [\"+\", 42, 3], [\"+\", 120, 3], [\"+\", 132, 2], [\"+\", 149, 2], [\"+\", 149, 2], [\"+\", 149, 1], [\"+\", 149, 1]]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.0418705940246582", "solution_depth": "10", "max_successor_states": "42", "num_vars_per_state": "3", "is_feasible_args": "[[24, 132, 149, 62, 120, 61, 42], [298, 430, 468]]", "is_correct_args": "[[24, 132, 149, 62, 120, 61, 42], [298, 430, 468]]", "A*_args": "[\"[24, 132, 149, 62, 120, 61, 42]\", \"[298, 430, 468]\"]"}
{"diff_sorted_id": "27", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[85, 73, 14], [79, 23, 50], ['_', 99, 63]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[99, 23, 50, 14, 73, 50, 79, 99, 23, 63, 14, 73, 50, 79, 73, 50, 79, 85, 99, 73, 63, 14]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.036279916763305664", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[85, 73, 14], [79, 23, 50], [\"_\", 99, 63]]]", "is_correct_args": "[[[85, 73, 14], [79, 23, 50], [\"_\", 99, 63]]]", "A*_args": "[\"[[85, 73, 14], [79, 23, 50], ['_', 99, 63]]\"]"}
{"diff_sorted_id": "27", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: bois, duroc, linen, spent   The initial board: [['_', 'b', 'p', 'i', 's'], ['d', 'u', 'r', 'n', 'c'], ['l', 'i', 'o', 'e', 'n'], ['s', 'n', 'e', 'o', 't']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-right\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.26288700103759766", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"_\", \"b\", \"p\", \"i\", \"s\"], [\"d\", \"u\", \"r\", \"n\", \"c\"], [\"l\", \"i\", \"o\", \"e\", \"n\"], [\"s\", \"n\", \"e\", \"o\", \"t\"]]]", "is_correct_args": "[[[\"_\", \"b\", \"p\", \"i\", \"s\"], [\"d\", \"u\", \"r\", \"n\", \"c\"], [\"l\", \"i\", \"o\", \"e\", \"n\"], [\"s\", \"n\", \"e\", \"o\", \"t\"]], [\"bois\", \"duroc\", \"linen\", \"spent\"]]", "A*_args": "[\"[['_', 'b', 'p', 'i', 's'], ['d', 'u', 'r', 'n', 'c'], ['l', 'i', 'o', 'e', 'n'], ['s', 'n', 'e', 'o', 't']]\", \"['bois', 'duroc', 'linen', 'spent']\"]"}
{"diff_sorted_id": "27", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'D'. Our task is to visit city H and city Z excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from Z and H, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  J H K W X I B U D Z G \nJ 0 0 0 0 1 0 0 0 0 0 0 \nH 0 0 1 0 0 0 1 1 0 0 0 \nK 0 0 0 0 0 1 0 0 0 0 0 \nW 0 1 1 0 1 0 0 0 0 0 0 \nX 0 1 0 0 0 1 0 0 0 0 0 \nI 0 0 1 0 0 0 1 1 0 1 0 \nB 0 0 0 1 0 0 0 0 0 1 1 \nU 0 0 1 1 1 0 0 0 0 0 0 \nD 0 0 0 1 0 1 0 1 0 0 0 \nZ 1 0 1 1 0 0 0 1 0 0 0 \nG 1 0 0 0 1 0 0 0 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[\"D\", \"I\", \"Z\", \"J\", \"X\", \"H\", \"B\", \"Z\", \"W\", \"H\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.03222942352294922", "solution_depth": "10", "max_successor_states": "11", "num_vars_per_state": "14", "is_feasible_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0]], [\"J\", \"H\", \"K\", \"W\", \"X\", \"I\", \"B\", \"U\", \"D\", \"Z\", \"G\"], \"H\", \"Z\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0]], [\"J\", \"H\", \"K\", \"W\", \"X\", \"I\", \"B\", \"U\", \"D\", \"Z\", \"G\"], \"D\", \"H\", \"Z\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0]]\", \"['J', 'H', 'K', 'W', 'X', 'I', 'B', 'U', 'D', 'Z', 'G']\", \"['D']\", \"['H', 'Z']\"]"}
{"diff_sorted_id": "27", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [22, 4, 12, 26, 4, 9, 4, 28, 28, 8, 28, 19, 15, 20, 9, 161, 11, 28, 17, 10, 25, 15, 7, 28, 21, 24, 10, 13, 22, 4, 10, 14], such that the sum of the chosen coins adds up to 301. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {15: 2, 17: 10, 10: 3, 12: 10, 21: 12, 4: 2, 22: 1, 11: 6, 26: 9, 14: 7, 24: 12, 161: 16, 20: 15, 9: 8, 8: 1, 13: 10, 28: 6, 7: 6, 25: 6, 19: 15}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "20", "opt_solution": "[22, 10, 15, 10, 8, 15, 161, 28, 22, 10]", "opt_solution_cost": "38", "opt_solution_compute_t": "0.0371396541595459", "solution_depth": "10", "max_successor_states": "32", "num_vars_per_state": "32", "is_feasible_args": "[[22, 4, 12, 26, 4, 9, 4, 28, 28, 8, 28, 19, 15, 20, 9, 161, 11, 28, 17, 10, 25, 15, 7, 28, 21, 24, 10, 13, 22, 4, 10, 14]]", "is_correct_args": "[[22, 4, 12, 26, 4, 9, 4, 28, 28, 8, 28, 19, 15, 20, 9, 161, 11, 28, 17, 10, 25, 15, 7, 28, 21, 24, 10, 13, 22, 4, 10, 14], {\"15\": 2, \"17\": 10, \"10\": 3, \"12\": 10, \"21\": 12, \"4\": 2, \"22\": 1, \"11\": 6, \"26\": 9, \"14\": 7, \"24\": 12, \"161\": 16, \"20\": 15, \"9\": 8, \"8\": 1, \"13\": 10, \"28\": 6, \"7\": 6, \"25\": 6, \"19\": 15}, 301]", "A*_args": "[\"[22, 4, 12, 26, 4, 9, 4, 28, 28, 8, 28, 19, 15, 20, 9, 161, 11, 28, 17, 10, 25, 15, 7, 28, 21, 24, 10, 13, 22, 4, 10, 14]\", \"{15: 2, 17: 10, 10: 3, 12: 10, 21: 12, 4: 2, 22: 1, 11: 6, 26: 9, 14: 7, 24: 12, 161: 16, 20: 15, 9: 8, 8: 1, 13: 10, 28: 6, 7: 6, 25: 6, 19: 15}\", \"301\"]"}
{"diff_sorted_id": "27", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Red', 'Red', 'Blue'], ['Green', 'Red', 'Red', 'Green'], ['Blue', 'Blue', 'Green', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[0, 2], [0, 1], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [1, 2], [1, 2], [1, 0], [1, 2], [1, 2], [0, 1], [0, 1], [0, 1]]", "opt_solution_cost": "16", "opt_solution_compute_t": "1.1768579483032227", "solution_depth": "16", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Blue\", \"Red\", \"Red\", \"Blue\"], [\"Green\", \"Red\", \"Red\", \"Green\"], [\"Blue\", \"Blue\", \"Green\", \"Green\"]], 7]", "is_correct_args": "[[[\"Blue\", \"Red\", \"Red\", \"Blue\"], [\"Green\", \"Red\", \"Red\", \"Green\"], [\"Blue\", \"Blue\", \"Green\", \"Green\"]], 7]", "A*_args": "[\"[['Blue', 'Red', 'Red', 'Blue'], ['Green', 'Red', 'Red', 'Green'], ['Blue', 'Blue', 'Green', 'Green']]\", \"7\"]"}
{"diff_sorted_id": "27", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 46 to 89 (46 included in the range but 89 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['52' 'x' 'x']\n ['50' 'x' 'x']\n ['x' 'x' '69']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 1, 47], [0, 2, 46], [1, 1, 51], [1, 2, 53], [2, 0, 48], [2, 1, 54]]", "opt_solution_cost": "485", "opt_solution_compute_t": "0.19235539436340332", "solution_depth": "6", "max_successor_states": "43", "num_vars_per_state": "9", "is_feasible_args": "[\"[['52', '', ''], ['50', '', ''], ['', '', '69']]\", 46, 89]", "is_correct_args": "[\"[['52', '', ''], ['50', '', ''], ['', '', '69']]\", 46, 89]", "A*_args": "[\"[['52', '', ''], ['50', '', ''], ['', '', '69']]\", \"46\", \"89\"]"}
{"diff_sorted_id": "27", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 26 to 65. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 93, and sum of row 1 must be 135. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 106. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['47' 'x' 'x']\n ['x' 'x' 'x']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 1, 26], [0, 2, 29], [1, 0, 31], [1, 1, 40], [1, 2, 64], [2, 0, 37], [2, 1, 27], [2, 2, 28]]", "opt_solution_cost": "329", "opt_solution_compute_t": "29.752150774002075", "solution_depth": "8", "max_successor_states": "34", "num_vars_per_state": "9", "is_feasible_args": "[\"[['47', '', ''], ['', '', ''], ['', '', '']]\", 3, 26, 65]", "is_correct_args": "[\"[['47', '', ''], ['', '', ''], ['', '', '']]\", 26, 65, [1, 2], [1, 2], [93], [135], 106]", "A*_args": "[\"[['47', '', ''], ['', '', ''], ['', '', '']]\", \"26\", \"65\", \"[None, 93, None]\", \"[None, 135, None]\", \"106\"]"}
{"diff_sorted_id": "27", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 3, 1: 6, 2: 2, 3: 4, 4: 6, 5: 5}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Red', 'Blue', 'Green', 'Yellow'], ['Blue', 'Blue', 'Green', 'Red'], [], [], [], ['Green', 'Red', 'Yellow', 'Yellow']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[0, 2], [5, 3], [5, 2], [0, 4], [0, 3], [0, 5], [1, 0], [1, 0], [1, 3], [4, 0], [1, 2]]", "opt_solution_cost": "38", "opt_solution_compute_t": "0.03287506103515625", "solution_depth": "11", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Blue\", \"Green\", \"Yellow\"], [\"Blue\", \"Blue\", \"Green\", \"Red\"], [], [], [], [\"Green\", \"Red\", \"Yellow\", \"Yellow\"]], 4, {\"0\": 3, \"1\": 6, \"2\": 2, \"3\": 4, \"4\": 6, \"5\": 5}]", "is_correct_args": "[[[\"Red\", \"Blue\", \"Green\", \"Yellow\"], [\"Blue\", \"Blue\", \"Green\", \"Red\"], [], [], [], [\"Green\", \"Red\", \"Yellow\", \"Yellow\"]], 4, {\"0\": 3, \"1\": 6, \"2\": 2, \"3\": 4, \"4\": 6, \"5\": 5}, 3]", "A*_args": "[\"[['Red', 'Blue', 'Green', 'Yellow'], ['Blue', 'Blue', 'Green', 'Red'], [], [], [], ['Green', 'Red', 'Yellow', 'Yellow']]\", \"{0: 3, 1: 6, 2: 2, 3: 4, 4: 6, 5: 5}\", \"4\", \"3\"]"}
{"diff_sorted_id": "27", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 8) to his destination workshop at index (6, 0), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 5, and district 3 covering rows 6 to 9. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[19 x 3 x x x 13 x 12 x]\n[x x 8 x 15 18 11 12 x 7]\n[x 8 x x 15 20 17 12 2 8]\n[x x 4 13 2 14 19 13 15 19]\n[13 2 x 8 x 17 13 x x 12]\n[2 20 20 14 x x 15 x 2 19]\n[15 16 18 x 2 x x x x x]\n[2 x 17 x x 12 x x 3 x]\n[2 x 10 x 6 x x 9 8 19]\n[17 x 6 13 x 18 x 3 x 18]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "2", "opt_solution": "[[3, 8], [2, 8], [2, 7], [3, 7], [3, 6], [3, 5], [3, 4], [3, 3], [4, 3], [5, 3], [5, 2], [5, 1], [5, 0], [6, 0]]", "opt_solution_cost": "154", "opt_solution_compute_t": "0.028217792510986328", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"19\", \"x\", \"3\", \"x\", \"x\", \"x\", \"13\", \"x\", \"12\", \"x\"], [\"x\", \"x\", \"8\", \"x\", \"15\", \"18\", \"11\", \"12\", \"x\", \"7\"], [\"x\", \"8\", \"x\", \"x\", \"15\", \"20\", \"17\", \"12\", \"2\", \"8\"], [\"x\", \"x\", \"4\", \"13\", \"2\", \"14\", \"19\", \"13\", \"15\", \"19\"], [\"13\", \"2\", \"x\", \"8\", \"x\", \"17\", \"13\", \"x\", \"x\", \"12\"], [\"2\", \"20\", \"20\", \"14\", \"x\", \"x\", \"15\", \"x\", \"2\", \"19\"], [\"15\", \"16\", \"18\", \"x\", \"2\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"2\", \"x\", \"17\", \"x\", \"x\", \"12\", \"x\", \"x\", \"3\", \"x\"], [\"2\", \"x\", \"10\", \"x\", \"6\", \"x\", \"x\", \"9\", \"8\", \"19\"], [\"17\", \"x\", \"6\", \"13\", \"x\", \"18\", \"x\", \"3\", \"x\", \"18\"]]]", "is_correct_args": "[[[\"19\", \"x\", \"3\", \"x\", \"x\", \"x\", \"13\", \"x\", \"12\", \"x\"], [\"x\", \"x\", \"8\", \"x\", \"15\", \"18\", \"11\", \"12\", \"x\", \"7\"], [\"x\", \"8\", \"x\", \"x\", \"15\", \"20\", \"17\", \"12\", \"2\", \"8\"], [\"x\", \"x\", \"4\", \"13\", \"2\", \"14\", \"19\", \"13\", \"15\", \"19\"], [\"13\", \"2\", \"x\", \"8\", \"x\", \"17\", \"13\", \"x\", \"x\", \"12\"], [\"2\", \"20\", \"20\", \"14\", \"x\", \"x\", \"15\", \"x\", \"2\", \"19\"], [\"15\", \"16\", \"18\", \"x\", \"2\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"2\", \"x\", \"17\", \"x\", \"x\", \"12\", \"x\", \"x\", \"3\", \"x\"], [\"2\", \"x\", \"10\", \"x\", \"6\", \"x\", \"x\", \"9\", \"8\", \"19\"], [\"17\", \"x\", \"6\", \"13\", \"x\", \"18\", \"x\", \"3\", \"x\", \"18\"]], [3, 8], [6, 0], 2, 5]", "A*_args": "[\"[['19', 'x', '3', 'x', 'x', 'x', '13', 'x', '12', 'x'], ['x', 'x', '8', 'x', '15', '18', '11', '12', 'x', '7'], ['x', '8', 'x', 'x', '15', '20', '17', '12', '2', '8'], ['x', 'x', '4', '13', '2', '14', '19', '13', '15', '19'], ['13', '2', 'x', '8', 'x', '17', '13', 'x', 'x', '12'], ['2', '20', '20', '14', 'x', 'x', '15', 'x', '2', '19'], ['15', '16', '18', 'x', '2', 'x', 'x', 'x', 'x', 'x'], ['2', 'x', '17', 'x', 'x', '12', 'x', 'x', '3', 'x'], ['2', 'x', '10', 'x', '6', 'x', 'x', '9', '8', '19'], ['17', 'x', '6', '13', 'x', '18', 'x', '3', 'x', '18']]\", \"(3, 8)\", \"(6, 0)\", \"2\", \"5\"]"}
{"diff_sorted_id": "27", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 10x10. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (7, 9) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (3, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 0 1 1 1 1 1 1\n0 1 0 0 1 1 0 1 0 0\n1 1 1 0 1 1 1 0 0 0\n0 1 0 1 0 0 1 1 1 1\n0 0 1 1 0 1 1 1 0 0\n0 0 0 0 1 1 1 1 1 1\n0 0 0 0 1 1 0 0 0 1\n0 1 0 0 0 0 0 0 0 0\n0 0 0 0 0 0 0 1 0 0\n1 0 0 0 0 1 0 0 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[[7, 9], [7, 8], [7, 7], [7, 6], [7, 5], [7, 4], [6, 3], [5, 2], [4, 1], [4, 0], [3, 0]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.030271291732788086", "solution_depth": "11", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 1, 0, 1, 0, 0], [1, 1, 1, 0, 1, 1, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 1, 1, 1, 1], [0, 0, 1, 1, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 0]]\", 3]", "is_correct_args": "[\"[[1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 1, 0, 1, 0, 0], [1, 1, 1, 0, 1, 1, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 1, 1, 1, 1], [0, 0, 1, 1, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 0]]\", [7, 9], [3, 0], 3]", "A*_args": "[\"[[1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 1, 0, 1, 0, 0], [1, 1, 1, 0, 1, 1, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 1, 1, 1, 1], [0, 0, 1, 1, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 0]]\", \"(7, 9)\", \"(3, 0)\", \"3\"]"}
{"diff_sorted_id": "27", "problem_statement": "Given 7 labeled water jugs with capacities 80, 76, 132, 60, 83, 28, 75, 26 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 337, 378, 398 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 28, 3], [\"+\", 80, 3], [\"+\", 132, 3], [\"+\", 75, 3], [\"+\", 83, 3], [\"+\", 80, 2], [\"+\", 83, 2], [\"+\", 83, 2], [\"+\", 132, 2], [\"+\", 28, 1], [\"+\", 83, 1], [\"+\", 83, 1], [\"+\", 83, 1], [\"+\", 60, 1]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.05565452575683594", "solution_depth": "14", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[80, 76, 132, 60, 83, 28, 75, 26], [337, 378, 398]]", "is_correct_args": "[[80, 76, 132, 60, 83, 28, 75, 26], [337, 378, 398]]", "A*_args": "[\"[80, 76, 132, 60, 83, 28, 75, 26]\", \"[337, 378, 398]\"]"}
{"diff_sorted_id": "28", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[10, 81, 46], [87, 74, 72], [36, 45, '_']]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[45, 36, 87, 10, 81, 74, 10, 87, 36, 10, 72, 46, 74, 81, 87, 72, 46, 45]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.023023605346679688", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[10, 81, 46], [87, 74, 72], [36, 45, \"_\"]]]", "is_correct_args": "[[[10, 81, 46], [87, 74, 72], [36, 45, \"_\"]]]", "A*_args": "[\"[[10, 81, 46], [87, 74, 72], [36, 45, '_']]\"]"}
{"diff_sorted_id": "28", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: akey, haikh, trone, manto   The initial board: [['a', 'a', 'e', 'e', 'y'], ['h', 'a', 'i', 't', 'h'], ['_', 'r', 'k', 'n', 't'], ['m', 'k', 'n', 'o', 'o']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"up-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.22631430625915527", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"a\", \"a\", \"e\", \"e\", \"y\"], [\"h\", \"a\", \"i\", \"t\", \"h\"], [\"_\", \"r\", \"k\", \"n\", \"t\"], [\"m\", \"k\", \"n\", \"o\", \"o\"]]]", "is_correct_args": "[[[\"a\", \"a\", \"e\", \"e\", \"y\"], [\"h\", \"a\", \"i\", \"t\", \"h\"], [\"_\", \"r\", \"k\", \"n\", \"t\"], [\"m\", \"k\", \"n\", \"o\", \"o\"]], [\"akey\", \"haikh\", \"trone\", \"manto\"]]", "A*_args": "[\"[['a', 'a', 'e', 'e', 'y'], ['h', 'a', 'i', 't', 'h'], ['_', 'r', 'k', 'n', 't'], ['m', 'k', 'n', 'o', 'o']]\", \"['akey', 'haikh', 'trone', 'manto']\"]"}
{"diff_sorted_id": "28", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'B'. Our task is to visit city E and city N excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from N and E, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  A N B M Z O E Q G L P \nA 0 0 0 1 0 1 1 0 1 0 1 \nN 0 0 0 0 0 0 0 1 0 0 1 \nB 0 0 0 0 1 0 0 1 1 0 0 \nM 0 1 0 0 0 0 1 0 0 0 0 \nZ 0 0 0 0 0 1 0 1 0 0 0 \nO 0 0 0 1 0 0 1 1 0 1 0 \nE 1 0 1 1 1 0 0 0 1 0 1 \nQ 0 0 0 1 0 0 0 0 0 0 0 \nG 0 1 0 1 0 0 0 1 0 0 0 \nL 0 1 0 0 0 0 0 1 1 0 1 \nP 0 0 0 0 0 0 1 0 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[\"B\", \"G\", \"N\", \"P\", \"E\", \"A\", \"E\", \"M\", \"N\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.029226064682006836", "solution_depth": "9", "max_successor_states": "11", "num_vars_per_state": "14", "is_feasible_args": "[[[0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0]], [\"A\", \"N\", \"B\", \"M\", \"Z\", \"O\", \"E\", \"Q\", \"G\", \"L\", \"P\"], \"E\", \"N\"]", "is_correct_args": "[[[0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0]], [\"A\", \"N\", \"B\", \"M\", \"Z\", \"O\", \"E\", \"Q\", \"G\", \"L\", \"P\"], \"B\", \"E\", \"N\"]", "A*_args": "[\"[[0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0]]\", \"['A', 'N', 'B', 'M', 'Z', 'O', 'E', 'Q', 'G', 'L', 'P']\", \"['B']\", \"['E', 'N']\"]"}
{"diff_sorted_id": "28", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [26, 19, 7, 24, 27, 15, 9, 9, 9, 26, 15, 23, 6, 6, 24, 8, 21, 6, 6, 7, 25, 22, 8, 2, 7, 5, 8, 18, 14, 15, 24, 10, 4, 23, 21, 8, 18, 12, 16], such that the sum of the chosen coins adds up to 267. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {24: 14, 27: 10, 22: 14, 16: 7, 14: 12, 6: 3, 8: 7, 23: 6, 18: 18, 5: 3, 25: 8, 7: 6, 12: 3, 15: 8, 9: 2, 19: 15, 2: 1, 4: 1, 26: 15, 10: 8, 21: 19}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "21", "opt_solution": "[9, 9, 9, 23, 12, 23, 6, 25, 6, 27, 26, 16, 6, 15, 15, 6, 4, 5, 15, 10]", "opt_solution_cost": "109", "opt_solution_compute_t": "0.044671058654785156", "solution_depth": "20", "max_successor_states": "39", "num_vars_per_state": "39", "is_feasible_args": "[[26, 19, 7, 24, 27, 15, 9, 9, 9, 26, 15, 23, 6, 6, 24, 8, 21, 6, 6, 7, 25, 22, 8, 2, 7, 5, 8, 18, 14, 15, 24, 10, 4, 23, 21, 8, 18, 12, 16]]", "is_correct_args": "[[26, 19, 7, 24, 27, 15, 9, 9, 9, 26, 15, 23, 6, 6, 24, 8, 21, 6, 6, 7, 25, 22, 8, 2, 7, 5, 8, 18, 14, 15, 24, 10, 4, 23, 21, 8, 18, 12, 16], {\"24\": 14, \"27\": 10, \"22\": 14, \"16\": 7, \"14\": 12, \"6\": 3, \"8\": 7, \"23\": 6, \"18\": 18, \"5\": 3, \"25\": 8, \"7\": 6, \"12\": 3, \"15\": 8, \"9\": 2, \"19\": 15, \"2\": 1, \"4\": 1, \"26\": 15, \"10\": 8, \"21\": 19}, 267]", "A*_args": "[\"[26, 19, 7, 24, 27, 15, 9, 9, 9, 26, 15, 23, 6, 6, 24, 8, 21, 6, 6, 7, 25, 22, 8, 2, 7, 5, 8, 18, 14, 15, 24, 10, 4, 23, 21, 8, 18, 12, 16]\", \"{24: 14, 27: 10, 22: 14, 16: 7, 14: 12, 6: 3, 8: 7, 23: 6, 18: 18, 5: 3, 25: 8, 7: 6, 12: 3, 15: 8, 9: 2, 19: 15, 2: 1, 4: 1, 26: 15, 10: 8, 21: 19}\", \"267\"]"}
{"diff_sorted_id": "28", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Green', 'Blue'], ['Blue', 'Red', 'Red', 'Red'], ['Blue', 'Green', 'Green', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[0, 1], [0, 2], [0, 2], [0, 1], [2, 0], [2, 0], [2, 1], [2, 0], [2, 0], [1, 2], [1, 2], [1, 0], [1, 2], [0, 1]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.5192186832427979", "solution_depth": "14", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Green\", \"Green\", \"Blue\"], [\"Blue\", \"Red\", \"Red\", \"Red\"], [\"Blue\", \"Green\", \"Green\", \"Blue\"]], 7]", "is_correct_args": "[[[\"Red\", \"Green\", \"Green\", \"Blue\"], [\"Blue\", \"Red\", \"Red\", \"Red\"], [\"Blue\", \"Green\", \"Green\", \"Blue\"]], 7]", "A*_args": "[\"[['Red', 'Green', 'Green', 'Blue'], ['Blue', 'Red', 'Red', 'Red'], ['Blue', 'Green', 'Green', 'Blue']]\", \"7\"]"}
{"diff_sorted_id": "28", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 12 to 60 (12 included in the range but 60 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['12' 'x' 'x']\n ['18' 'x' '52']\n ['22' 'x' '31']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 1, 13], [0, 2, 53], [1, 1, 19], [2, 1, 23]]", "opt_solution_cost": "276", "opt_solution_compute_t": "0.17951035499572754", "solution_depth": "4", "max_successor_states": "48", "num_vars_per_state": "9", "is_feasible_args": "[\"[['12', '', ''], ['18', '', '52'], ['22', '', '31']]\", 12, 60]", "is_correct_args": "[\"[['12', '', ''], ['18', '', '52'], ['22', '', '31']]\", 12, 60]", "A*_args": "[\"[['12', '', ''], ['18', '', '52'], ['22', '', '31']]\", \"12\", \"60\"]"}
{"diff_sorted_id": "28", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 26 to 65. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 107, and sum of row 1 must be 124. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 108. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['51' 'x' 'x']\n ['x' 'x' 'x']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 1, 27], [0, 2, 26], [1, 0, 31], [1, 1, 52], [1, 2, 41], [2, 0, 30], [2, 1, 28], [2, 2, 29]]", "opt_solution_cost": "315", "opt_solution_compute_t": "4.654482126235962", "solution_depth": "8", "max_successor_states": "34", "num_vars_per_state": "9", "is_feasible_args": "[\"[['51', '', ''], ['', '', ''], ['', '', '']]\", 3, 26, 65]", "is_correct_args": "[\"[['51', '', ''], ['', '', ''], ['', '', '']]\", 26, 65, [1, 2], [1, 2], [107], [124], 108]", "A*_args": "[\"[['51', '', ''], ['', '', ''], ['', '', '']]\", \"26\", \"65\", \"[None, 107, None]\", \"[None, 124, None]\", \"108\"]"}
{"diff_sorted_id": "28", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 3, 1: 7, 2: 7, 3: 7, 4: 2, 5: 4}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Green', 'Yellow', 'Red', 'Red'], [], ['Yellow', 'Green', 'Blue', 'Yellow'], [], [], ['Red', 'Blue', 'Green', 'Blue']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[0, 4], [0, 1], [5, 0], [2, 1], [2, 4], [2, 3], [5, 3], [5, 4], [2, 1], [3, 5], [3, 5]]", "opt_solution_cost": "52", "opt_solution_compute_t": "0.031346797943115234", "solution_depth": "11", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Yellow\", \"Red\", \"Red\"], [], [\"Yellow\", \"Green\", \"Blue\", \"Yellow\"], [], [], [\"Red\", \"Blue\", \"Green\", \"Blue\"]], 4, {\"0\": 3, \"1\": 7, \"2\": 7, \"3\": 7, \"4\": 2, \"5\": 4}]", "is_correct_args": "[[[\"Green\", \"Yellow\", \"Red\", \"Red\"], [], [\"Yellow\", \"Green\", \"Blue\", \"Yellow\"], [], [], [\"Red\", \"Blue\", \"Green\", \"Blue\"]], 4, {\"0\": 3, \"1\": 7, \"2\": 7, \"3\": 7, \"4\": 2, \"5\": 4}, 3]", "A*_args": "[\"[['Green', 'Yellow', 'Red', 'Red'], [], ['Yellow', 'Green', 'Blue', 'Yellow'], [], [], ['Red', 'Blue', 'Green', 'Blue']]\", \"{0: 3, 1: 7, 2: 7, 3: 7, 4: 2, 5: 4}\", \"4\", \"3\"]"}
{"diff_sorted_id": "28", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (5, 0) to his destination workshop at index (3, 8), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 4, and district 3 covering rows 5 to 9. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[15 x 8 x 6 9 x x x x]\n[14 x 8 x 14 x 5 11 x 9]\n[x 17 8 x 17 15 12 x x 13]\n[x 13 x x 2 x 17 17 1 x]\n[6 x 1 5 17 x 2 18 11 7]\n[12 8 17 10 x x x 15 x 16]\n[12 12 x 4 x 13 x 10 x 16]\n[x x 10 x 6 x x x 8 5]\n[x 2 11 18 15 x 11 x x 12]\n[x x 14 x x 7 14 15 18 9]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "2", "opt_solution": "[[5, 0], [5, 1], [5, 2], [4, 2], [4, 3], [4, 4], [3, 4], [2, 4], [2, 5], [2, 6], [3, 6], [3, 7], [3, 8]]", "opt_solution_cost": "129", "opt_solution_compute_t": "0.028196334838867188", "solution_depth": "13", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"15\", \"x\", \"8\", \"x\", \"6\", \"9\", \"x\", \"x\", \"x\", \"x\"], [\"14\", \"x\", \"8\", \"x\", \"14\", \"x\", \"5\", \"11\", \"x\", \"9\"], [\"x\", \"17\", \"8\", \"x\", \"17\", \"15\", \"12\", \"x\", \"x\", \"13\"], [\"x\", \"13\", \"x\", \"x\", \"2\", \"x\", \"17\", \"17\", \"1\", \"x\"], [\"6\", \"x\", \"1\", \"5\", \"17\", \"x\", \"2\", \"18\", \"11\", \"7\"], [\"12\", \"8\", \"17\", \"10\", \"x\", \"x\", \"x\", \"15\", \"x\", \"16\"], [\"12\", \"12\", \"x\", \"4\", \"x\", \"13\", \"x\", \"10\", \"x\", \"16\"], [\"x\", \"x\", \"10\", \"x\", \"6\", \"x\", \"x\", \"x\", \"8\", \"5\"], [\"x\", \"2\", \"11\", \"18\", \"15\", \"x\", \"11\", \"x\", \"x\", \"12\"], [\"x\", \"x\", \"14\", \"x\", \"x\", \"7\", \"14\", \"15\", \"18\", \"9\"]]]", "is_correct_args": "[[[\"15\", \"x\", \"8\", \"x\", \"6\", \"9\", \"x\", \"x\", \"x\", \"x\"], [\"14\", \"x\", \"8\", \"x\", \"14\", \"x\", \"5\", \"11\", \"x\", \"9\"], [\"x\", \"17\", \"8\", \"x\", \"17\", \"15\", \"12\", \"x\", \"x\", \"13\"], [\"x\", \"13\", \"x\", \"x\", \"2\", \"x\", \"17\", \"17\", \"1\", \"x\"], [\"6\", \"x\", \"1\", \"5\", \"17\", \"x\", \"2\", \"18\", \"11\", \"7\"], [\"12\", \"8\", \"17\", \"10\", \"x\", \"x\", \"x\", \"15\", \"x\", \"16\"], [\"12\", \"12\", \"x\", \"4\", \"x\", \"13\", \"x\", \"10\", \"x\", \"16\"], [\"x\", \"x\", \"10\", \"x\", \"6\", \"x\", \"x\", \"x\", \"8\", \"5\"], [\"x\", \"2\", \"11\", \"18\", \"15\", \"x\", \"11\", \"x\", \"x\", \"12\"], [\"x\", \"x\", \"14\", \"x\", \"x\", \"7\", \"14\", \"15\", \"18\", \"9\"]], [5, 0], [3, 8], 3, 4]", "A*_args": "[\"[['15', 'x', '8', 'x', '6', '9', 'x', 'x', 'x', 'x'], ['14', 'x', '8', 'x', '14', 'x', '5', '11', 'x', '9'], ['x', '17', '8', 'x', '17', '15', '12', 'x', 'x', '13'], ['x', '13', 'x', 'x', '2', 'x', '17', '17', '1', 'x'], ['6', 'x', '1', '5', '17', 'x', '2', '18', '11', '7'], ['12', '8', '17', '10', 'x', 'x', 'x', '15', 'x', '16'], ['12', '12', 'x', '4', 'x', '13', 'x', '10', 'x', '16'], ['x', 'x', '10', 'x', '6', 'x', 'x', 'x', '8', '5'], ['x', '2', '11', '18', '15', 'x', '11', 'x', 'x', '12'], ['x', 'x', '14', 'x', 'x', '7', '14', '15', '18', '9']]\", \"(5, 0)\", \"(3, 8)\", \"3\", \"4\"]"}
{"diff_sorted_id": "28", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 10x10. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (8, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (0, 6). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 0 1 1 1 0 1 1 0\n1 0 0 0 0 0 0 1 1 1\n0 1 0 1 0 0 0 0 1 0\n0 0 0 0 1 1 0 0 1 1\n0 1 1 0 0 1 1 1 1 0\n0 1 0 1 1 1 1 0 1 0\n0 1 0 0 1 1 0 0 1 0\n0 1 1 1 1 1 0 1 1 1\n0 0 1 0 1 1 0 0 0 1\n0 0 1 0 1 0 1 1 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[[8, 0], [7, 0], [6, 0], [5, 0], [4, 0], [3, 0], [3, 1], [3, 2], [3, 3], [2, 4], [1, 5], [0, 6]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.031847238540649414", "solution_depth": "12", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 0, 1, 1, 1, 0, 1, 1, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [0, 1, 1, 0, 0, 1, 1, 1, 1, 0], [0, 1, 0, 1, 1, 1, 1, 0, 1, 0], [0, 1, 0, 0, 1, 1, 0, 0, 1, 0], [0, 1, 1, 1, 1, 1, 0, 1, 1, 1], [0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [0, 0, 1, 0, 1, 0, 1, 1, 0, 1]]\", 3]", "is_correct_args": "[\"[[1, 0, 0, 1, 1, 1, 0, 1, 1, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [0, 1, 1, 0, 0, 1, 1, 1, 1, 0], [0, 1, 0, 1, 1, 1, 1, 0, 1, 0], [0, 1, 0, 0, 1, 1, 0, 0, 1, 0], [0, 1, 1, 1, 1, 1, 0, 1, 1, 1], [0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [0, 0, 1, 0, 1, 0, 1, 1, 0, 1]]\", [8, 0], [0, 6], 3]", "A*_args": "[\"[[1, 0, 0, 1, 1, 1, 0, 1, 1, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [0, 1, 1, 0, 0, 1, 1, 1, 1, 0], [0, 1, 0, 1, 1, 1, 1, 0, 1, 0], [0, 1, 0, 0, 1, 1, 0, 0, 1, 0], [0, 1, 1, 1, 1, 1, 0, 1, 1, 1], [0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [0, 0, 1, 0, 1, 0, 1, 1, 0, 1]]\", \"(8, 0)\", \"(0, 6)\", \"3\"]"}
{"diff_sorted_id": "28", "problem_statement": "Given 7 labeled water jugs with capacities 149, 128, 67, 43, 55, 38, 129 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 385, 387, 491 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 128, 3], [\"+\", 129, 3], [\"+\", 67, 3], [\"+\", 129, 3], [\"+\", 38, 3], [\"+\", 129, 2], [\"+\", 129, 2], [\"+\", 129, 2], [\"+\", 128, 1], [\"+\", 128, 1], [\"+\", 129, 1]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.039963722229003906", "solution_depth": "11", "max_successor_states": "42", "num_vars_per_state": "3", "is_feasible_args": "[[149, 128, 67, 43, 55, 38, 129], [385, 387, 491]]", "is_correct_args": "[[149, 128, 67, 43, 55, 38, 129], [385, 387, 491]]", "A*_args": "[\"[149, 128, 67, 43, 55, 38, 129]\", \"[385, 387, 491]\"]"}
{"diff_sorted_id": "29", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[30, 12, 67], [21, '_', 28], [80, 16, 37]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[12, 30, 21, 80, 16, 12, 30, 21, 80, 30, 28, 37, 12, 28, 21, 67, 37, 21, 28, 12]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.03293919563293457", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[30, 12, 67], [21, \"_\", 28], [80, 16, 37]]]", "is_correct_args": "[[[30, 12, 67], [21, \"_\", 28], [80, 16, 37]]]", "A*_args": "[\"[[30, 12, 67], [21, '_', 28], [80, 16, 37]]\"]"}
{"diff_sorted_id": "29", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: tala, udasi, glair, wench   The initial board: [['d', 't', 's', 'l', 'a'], ['u', 'a', 'a', 'e', 'i'], ['_', 'l', 'g', 'i', 'a'], ['w', 'r', 'n', 'c', 'h']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.3418314456939697", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"d\", \"t\", \"s\", \"l\", \"a\"], [\"u\", \"a\", \"a\", \"e\", \"i\"], [\"_\", \"l\", \"g\", \"i\", \"a\"], [\"w\", \"r\", \"n\", \"c\", \"h\"]]]", "is_correct_args": "[[[\"d\", \"t\", \"s\", \"l\", \"a\"], [\"u\", \"a\", \"a\", \"e\", \"i\"], [\"_\", \"l\", \"g\", \"i\", \"a\"], [\"w\", \"r\", \"n\", \"c\", \"h\"]], [\"tala\", \"udasi\", \"glair\", \"wench\"]]", "A*_args": "[\"[['d', 't', 's', 'l', 'a'], ['u', 'a', 'a', 'e', 'i'], ['_', 'l', 'g', 'i', 'a'], ['w', 'r', 'n', 'c', 'h']]\", \"['tala', 'udasi', 'glair', 'wench']\"]"}
{"diff_sorted_id": "29", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'G'. Our task is to visit city S and city E excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from E and S, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  R S W B P G Q E N D J \nR 0 0 0 0 0 0 0 1 0 1 1 \nS 0 0 1 0 0 1 0 0 1 0 1 \nW 1 0 0 0 0 0 0 0 0 0 0 \nB 0 0 0 0 1 0 0 0 0 0 1 \nP 0 1 0 0 0 0 0 0 0 1 0 \nG 0 0 0 1 0 0 0 0 0 0 0 \nQ 0 0 1 1 1 0 0 0 1 1 0 \nE 1 1 0 0 1 1 1 0 0 0 0 \nN 0 0 0 0 1 1 0 0 0 1 0 \nD 0 0 1 0 0 0 0 1 0 0 0 \nJ 0 1 0 0 1 0 1 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[\"G\", \"B\", \"J\", \"S\", \"N\", \"D\", \"E\", \"R\", \"E\", \"S\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.029485225677490234", "solution_depth": "10", "max_successor_states": "11", "num_vars_per_state": "14", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0], [1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0]], [\"R\", \"S\", \"W\", \"B\", \"P\", \"G\", \"Q\", \"E\", \"N\", \"D\", \"J\"], \"S\", \"E\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0], [1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0]], [\"R\", \"S\", \"W\", \"B\", \"P\", \"G\", \"Q\", \"E\", \"N\", \"D\", \"J\"], \"G\", \"S\", \"E\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0], [1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0]]\", \"['R', 'S', 'W', 'B', 'P', 'G', 'Q', 'E', 'N', 'D', 'J']\", \"['G']\", \"['S', 'E']\"]"}
{"diff_sorted_id": "29", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [5, 21, 4, 18, 17, 13, 27, 10, 27, 21, 25, 22, 27, 29, 28, 15, 16, 12, 7, 19, 8, 19, 9, 21, 29, 15, 15, 23, 8, 13, 20, 9, 13, 16, 3, 14, 11, 15, 2, 23, 18, 4], such that the sum of the chosen coins adds up to 295. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {14: 2, 12: 11, 20: 5, 4: 2, 23: 12, 28: 1, 25: 8, 27: 3, 19: 1, 21: 6, 16: 2, 29: 7, 13: 5, 17: 2, 22: 15, 10: 1, 15: 1, 3: 2, 8: 5, 5: 4, 9: 1, 7: 2, 2: 2, 18: 17, 11: 1}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "22", "opt_solution": "[28, 14, 15, 19, 10, 15, 15, 15, 27, 16, 19, 27, 27, 4, 11, 17, 16]", "opt_solution_cost": "28", "opt_solution_compute_t": "0.045546770095825195", "solution_depth": "17", "max_successor_states": "42", "num_vars_per_state": "42", "is_feasible_args": "[[5, 21, 4, 18, 17, 13, 27, 10, 27, 21, 25, 22, 27, 29, 28, 15, 16, 12, 7, 19, 8, 19, 9, 21, 29, 15, 15, 23, 8, 13, 20, 9, 13, 16, 3, 14, 11, 15, 2, 23, 18, 4]]", "is_correct_args": "[[5, 21, 4, 18, 17, 13, 27, 10, 27, 21, 25, 22, 27, 29, 28, 15, 16, 12, 7, 19, 8, 19, 9, 21, 29, 15, 15, 23, 8, 13, 20, 9, 13, 16, 3, 14, 11, 15, 2, 23, 18, 4], {\"14\": 2, \"12\": 11, \"20\": 5, \"4\": 2, \"23\": 12, \"28\": 1, \"25\": 8, \"27\": 3, \"19\": 1, \"21\": 6, \"16\": 2, \"29\": 7, \"13\": 5, \"17\": 2, \"22\": 15, \"10\": 1, \"15\": 1, \"3\": 2, \"8\": 5, \"5\": 4, \"9\": 1, \"7\": 2, \"2\": 2, \"18\": 17, \"11\": 1}, 295]", "A*_args": "[\"[5, 21, 4, 18, 17, 13, 27, 10, 27, 21, 25, 22, 27, 29, 28, 15, 16, 12, 7, 19, 8, 19, 9, 21, 29, 15, 15, 23, 8, 13, 20, 9, 13, 16, 3, 14, 11, 15, 2, 23, 18, 4]\", \"{14: 2, 12: 11, 20: 5, 4: 2, 23: 12, 28: 1, 25: 8, 27: 3, 19: 1, 21: 6, 16: 2, 29: 7, 13: 5, 17: 2, 22: 15, 10: 1, 15: 1, 3: 2, 8: 5, 5: 4, 9: 1, 7: 2, 2: 2, 18: 17, 11: 1}\", \"295\"]"}
{"diff_sorted_id": "29", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Blue', 'Blue', 'Red'], ['Blue', 'Green', 'Blue', 'Green'], ['Green', 'Red', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[1, 0], [1, 2], [1, 0], [2, 1], [2, 1], [2, 0], [2, 1], [0, 1], [2, 1], [0, 2], [0, 2], [0, 1], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0]]", "opt_solution_cost": "17", "opt_solution_compute_t": "1.9683549404144287", "solution_depth": "17", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Red\"], [\"Blue\", \"Green\", \"Blue\", \"Green\"], [\"Green\", \"Red\", \"Green\", \"Red\"]], 7]", "is_correct_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Red\"], [\"Blue\", \"Green\", \"Blue\", \"Green\"], [\"Green\", \"Red\", \"Green\", \"Red\"]], 7]", "A*_args": "[\"[['Red', 'Blue', 'Blue', 'Red'], ['Blue', 'Green', 'Blue', 'Green'], ['Green', 'Red', 'Green', 'Red']]\", \"7\"]"}
{"diff_sorted_id": "29", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 40 to 88 (40 included in the range but 88 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' '65']\n ['x' '47' '56']\n ['48' '44' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 40], [0, 1, 49], [1, 0, 42], [2, 2, 41]]", "opt_solution_cost": "444", "opt_solution_compute_t": "0.1726534366607666", "solution_depth": "4", "max_successor_states": "48", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', '65'], ['', '47', '56'], ['48', '44', '']]\", 40, 88]", "is_correct_args": "[\"[['', '', '65'], ['', '47', '56'], ['48', '44', '']]\", 40, 88]", "A*_args": "[\"[['', '', '65'], ['', '47', '56'], ['48', '44', '']]\", \"40\", \"88\"]"}
{"diff_sorted_id": "29", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 34 to 78. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 180, and sum of row 1 must be 156. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 127. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '77' 'x']\n ['49' 'x' 'x']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 35], [0, 2, 34], [1, 1, 57], [1, 2, 50], [2, 0, 36], [2, 1, 46], [2, 2, 37]]", "opt_solution_cost": "421", "opt_solution_compute_t": "1.5807371139526367", "solution_depth": "7", "max_successor_states": "34", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '77', ''], ['49', '', ''], ['', '', '']]\", 3, 34, 78]", "is_correct_args": "[\"[['', '77', ''], ['49', '', ''], ['', '', '']]\", 34, 78, [1, 2], [1, 2], [180], [156], 127]", "A*_args": "[\"[['', '77', ''], ['49', '', ''], ['', '', '']]\", \"34\", \"78\", \"[None, 180, None]\", \"[None, 156, None]\", \"127\"]"}
{"diff_sorted_id": "29", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 1, 1: 5, 2: 6, 3: 7, 4: 7, 5: 5}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Yellow', 'Green', 'Green', 'Blue'], [], [], ['Red', 'Green', 'Blue', 'Yellow'], [], ['Yellow', 'Blue', 'Red', 'Red']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[0, 1], [0, 2], [0, 2], [5, 1], [5, 0], [3, 5], [3, 2], [3, 0], [3, 1]]", "opt_solution_cost": "40", "opt_solution_compute_t": "0.0707550048828125", "solution_depth": "9", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Yellow\", \"Green\", \"Green\", \"Blue\"], [], [], [\"Red\", \"Green\", \"Blue\", \"Yellow\"], [], [\"Yellow\", \"Blue\", \"Red\", \"Red\"]], 4, {\"0\": 1, \"1\": 5, \"2\": 6, \"3\": 7, \"4\": 7, \"5\": 5}]", "is_correct_args": "[[[\"Yellow\", \"Green\", \"Green\", \"Blue\"], [], [], [\"Red\", \"Green\", \"Blue\", \"Yellow\"], [], [\"Yellow\", \"Blue\", \"Red\", \"Red\"]], 4, {\"0\": 1, \"1\": 5, \"2\": 6, \"3\": 7, \"4\": 7, \"5\": 5}, 3]", "A*_args": "[\"[['Yellow', 'Green', 'Green', 'Blue'], [], [], ['Red', 'Green', 'Blue', 'Yellow'], [], ['Yellow', 'Blue', 'Red', 'Red']]\", \"{0: 1, 1: 5, 2: 6, 3: 7, 4: 7, 5: 5}\", \"4\", \"3\"]"}
{"diff_sorted_id": "29", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 9) to his destination workshop at index (6, 1), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 5, and district 3 covering rows 6 to 9. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x x 4 6 x 9 15 11 2]\n[19 x 14 3 10 18 x x x 1]\n[x 9 x 11 7 14 x x 16 18]\n[x 5 4 5 2 4 7 5 19 14]\n[x 3 20 x 5 16 x x 1 9]\n[x 3 15 9 4 x x x x 4]\n[11 18 19 8 17 9 x 10 10 19]\n[x x x 17 7 x x 7 12 8]\n[x x 11 19 x 13 10 13 x x]\n[18 x x x 6 10 7 x 8 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "2", "opt_solution": "[[3, 9], [3, 8], [3, 7], [3, 6], [3, 5], [3, 4], [3, 3], [3, 2], [3, 1], [4, 1], [5, 1], [6, 1]]", "opt_solution_cost": "75", "opt_solution_compute_t": "0.03969311714172363", "solution_depth": "12", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"x\", \"4\", \"6\", \"x\", \"9\", \"15\", \"11\", \"2\"], [\"19\", \"x\", \"14\", \"3\", \"10\", \"18\", \"x\", \"x\", \"x\", \"1\"], [\"x\", \"9\", \"x\", \"11\", \"7\", \"14\", \"x\", \"x\", \"16\", \"18\"], [\"x\", \"5\", \"4\", \"5\", \"2\", \"4\", \"7\", \"5\", \"19\", \"14\"], [\"x\", \"3\", \"20\", \"x\", \"5\", \"16\", \"x\", \"x\", \"1\", \"9\"], [\"x\", \"3\", \"15\", \"9\", \"4\", \"x\", \"x\", \"x\", \"x\", \"4\"], [\"11\", \"18\", \"19\", \"8\", \"17\", \"9\", \"x\", \"10\", \"10\", \"19\"], [\"x\", \"x\", \"x\", \"17\", \"7\", \"x\", \"x\", \"7\", \"12\", \"8\"], [\"x\", \"x\", \"11\", \"19\", \"x\", \"13\", \"10\", \"13\", \"x\", \"x\"], [\"18\", \"x\", \"x\", \"x\", \"6\", \"10\", \"7\", \"x\", \"8\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"x\", \"4\", \"6\", \"x\", \"9\", \"15\", \"11\", \"2\"], [\"19\", \"x\", \"14\", \"3\", \"10\", \"18\", \"x\", \"x\", \"x\", \"1\"], [\"x\", \"9\", \"x\", \"11\", \"7\", \"14\", \"x\", \"x\", \"16\", \"18\"], [\"x\", \"5\", \"4\", \"5\", \"2\", \"4\", \"7\", \"5\", \"19\", \"14\"], [\"x\", \"3\", \"20\", \"x\", \"5\", \"16\", \"x\", \"x\", \"1\", \"9\"], [\"x\", \"3\", \"15\", \"9\", \"4\", \"x\", \"x\", \"x\", \"x\", \"4\"], [\"11\", \"18\", \"19\", \"8\", \"17\", \"9\", \"x\", \"10\", \"10\", \"19\"], [\"x\", \"x\", \"x\", \"17\", \"7\", \"x\", \"x\", \"7\", \"12\", \"8\"], [\"x\", \"x\", \"11\", \"19\", \"x\", \"13\", \"10\", \"13\", \"x\", \"x\"], [\"18\", \"x\", \"x\", \"x\", \"6\", \"10\", \"7\", \"x\", \"8\", \"x\"]], [3, 9], [6, 1], 3, 5]", "A*_args": "[\"[['x', 'x', 'x', '4', '6', 'x', '9', '15', '11', '2'], ['19', 'x', '14', '3', '10', '18', 'x', 'x', 'x', '1'], ['x', '9', 'x', '11', '7', '14', 'x', 'x', '16', '18'], ['x', '5', '4', '5', '2', '4', '7', '5', '19', '14'], ['x', '3', '20', 'x', '5', '16', 'x', 'x', '1', '9'], ['x', '3', '15', '9', '4', 'x', 'x', 'x', 'x', '4'], ['11', '18', '19', '8', '17', '9', 'x', '10', '10', '19'], ['x', 'x', 'x', '17', '7', 'x', 'x', '7', '12', '8'], ['x', 'x', '11', '19', 'x', '13', '10', '13', 'x', 'x'], ['18', 'x', 'x', 'x', '6', '10', '7', 'x', '8', 'x']]\", \"(3, 9)\", \"(6, 1)\", \"3\", \"5\"]"}
{"diff_sorted_id": "29", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 10x10. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (9, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (1, 5). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 0 0 0 0 1 1 0\n0 1 1 0 1 0 1 0 1 0\n1 1 0 0 1 0 1 0 1 1\n1 0 0 0 0 0 1 1 0 1\n1 0 0 0 0 0 1 1 1 1\n1 1 0 0 0 1 1 1 0 1\n1 1 0 0 0 0 1 0 1 0\n0 1 0 0 0 0 0 1 1 0\n1 0 0 1 1 1 1 0 0 0\n0 0 1 1 1 1 0 0 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[[9, 0], [8, 1], [7, 2], [6, 2], [5, 2], [4, 2], [3, 2], [3, 3], [3, 4], [2, 5], [1, 5]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.029387712478637695", "solution_depth": "11", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 0, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 1, 0, 0, 1, 0, 1, 0, 1, 1], [1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 1, 1, 1], [1, 1, 0, 0, 0, 1, 1, 1, 0, 1], [1, 1, 0, 0, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0], [1, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 0, 0, 1, 1]]\", 3]", "is_correct_args": "[\"[[1, 1, 1, 0, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 1, 0, 0, 1, 0, 1, 0, 1, 1], [1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 1, 1, 1], [1, 1, 0, 0, 0, 1, 1, 1, 0, 1], [1, 1, 0, 0, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0], [1, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 0, 0, 1, 1]]\", [9, 0], [1, 5], 3]", "A*_args": "[\"[[1, 1, 1, 0, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 1, 0, 0, 1, 0, 1, 0, 1, 1], [1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 1, 1, 1], [1, 1, 0, 0, 0, 1, 1, 1, 0, 1], [1, 1, 0, 0, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0], [1, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 0, 0, 1, 1]]\", \"(9, 0)\", \"(1, 5)\", \"3\"]"}
{"diff_sorted_id": "29", "problem_statement": "Given 7 labeled water jugs with capacities 150, 84, 29, 140, 98, 83, 32 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 243, 250, 446 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 140, 3], [\"+\", 140, 3], [\"+\", 83, 3], [\"+\", 83, 3], [\"+\", 83, 2], [\"+\", 83, 2], [\"+\", 84, 2], [\"+\", 83, 1], [\"+\", 150, 1], [\"-\", 140, 1], [\"+\", 150, 1]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.039078712463378906", "solution_depth": "11", "max_successor_states": "42", "num_vars_per_state": "3", "is_feasible_args": "[[150, 84, 29, 140, 98, 83, 32], [243, 250, 446]]", "is_correct_args": "[[150, 84, 29, 140, 98, 83, 32], [243, 250, 446]]", "A*_args": "[\"[150, 84, 29, 140, 98, 83, 32]\", \"[243, 250, 446]\"]"}
{"diff_sorted_id": "30", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[78, 69, '_'], [68, 49, 95], [74, 15, 39]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[95, 49, 15, 74, 68, 15, 74, 39, 49, 74, 15, 68, 39, 15, 68, 78, 69, 95, 74, 68, 78, 69, 95, 78, 68, 49]", "opt_solution_cost": "26", "opt_solution_compute_t": "0.1302354335784912", "solution_depth": "26", "max_successor_states": "4", "num_vars_per_state": "9", "is_feasible_args": "[[[78, 69, \"_\"], [68, 49, 95], [74, 15, 39]]]", "is_correct_args": "[[[78, 69, \"_\"], [68, 49, 95], [74, 15, 39]]]", "A*_args": "[\"[[78, 69, '_'], [68, 49, 95], [74, 15, 39]]\"]"}
{"diff_sorted_id": "30", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: lete, sarus, bryan, whing   The initial board: [['a', 'l', '_', 't', 'e'], ['s', 'h', 'r', 'b', 's'], ['e', 'r', 'u', 'a', 'n'], ['w', 'y', 'i', 'n', 'g']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.23216724395751953", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"a\", \"l\", \"_\", \"t\", \"e\"], [\"s\", \"h\", \"r\", \"b\", \"s\"], [\"e\", \"r\", \"u\", \"a\", \"n\"], [\"w\", \"y\", \"i\", \"n\", \"g\"]]]", "is_correct_args": "[[[\"a\", \"l\", \"_\", \"t\", \"e\"], [\"s\", \"h\", \"r\", \"b\", \"s\"], [\"e\", \"r\", \"u\", \"a\", \"n\"], [\"w\", \"y\", \"i\", \"n\", \"g\"]], [\"lete\", \"sarus\", \"bryan\", \"whing\"]]", "A*_args": "[\"[['a', 'l', '_', 't', 'e'], ['s', 'h', 'r', 'b', 's'], ['e', 'r', 'u', 'a', 'n'], ['w', 'y', 'i', 'n', 'g']]\", \"['lete', 'sarus', 'bryan', 'whing']\"]"}
{"diff_sorted_id": "30", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'G'. Our task is to visit city P and city H excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from H and P, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  S V U W G E H P T Q Z \nS 0 1 1 0 0 1 1 0 0 0 0 \nV 0 0 0 0 0 0 0 1 0 0 0 \nU 0 1 0 0 0 0 0 1 0 1 0 \nW 1 1 0 0 0 0 0 0 0 0 1 \nG 0 1 1 0 0 0 0 0 0 0 0 \nE 1 0 0 0 0 0 0 0 1 0 0 \nH 0 1 0 1 0 0 0 0 0 0 1 \nP 0 0 0 0 0 1 1 0 1 0 0 \nT 0 0 0 0 1 0 0 1 0 1 0 \nQ 0 0 0 0 0 0 1 1 0 0 0 \nZ 0 1 0 0 0 0 0 1 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[\"G\", \"U\", \"P\", \"H\", \"V\", \"P\", \"H\"]", "opt_solution_cost": "7", "opt_solution_compute_t": "0.02849578857421875", "solution_depth": "7", "max_successor_states": "11", "num_vars_per_state": "14", "is_feasible_args": "[[[0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0]], [\"S\", \"V\", \"U\", \"W\", \"G\", \"E\", \"H\", \"P\", \"T\", \"Q\", \"Z\"], \"P\", \"H\"]", "is_correct_args": "[[[0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0]], [\"S\", \"V\", \"U\", \"W\", \"G\", \"E\", \"H\", \"P\", \"T\", \"Q\", \"Z\"], \"G\", \"P\", \"H\"]", "A*_args": "[\"[[0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0]]\", \"['S', 'V', 'U', 'W', 'G', 'E', 'H', 'P', 'T', 'Q', 'Z']\", \"['G']\", \"['P', 'H']\"]"}
{"diff_sorted_id": "30", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [46, 10, 4, 8, 2, 22, 26, 49, 4, 19, 2, 9, 23, 28, 6, 21, 9, 14, 15, 21, 22, 3, 14, 2, 28, 13, 20, 2, 28, 7, 16, 27, 22, 18, 28, 10, 14, 14, 4, 20, 18], such that the sum of the chosen coins adds up to 294. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {21: 14, 19: 16, 4: 3, 23: 10, 10: 3, 18: 7, 9: 3, 27: 13, 20: 12, 13: 9, 26: 17, 3: 3, 6: 6, 49: 16, 2: 2, 15: 7, 28: 13, 46: 10, 8: 3, 7: 6, 22: 20, 14: 5, 16: 8}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "23", "opt_solution": "[14, 10, 8, 9, 49, 46, 18, 14, 23, 18, 14, 10, 27, 16, 14, 4]", "opt_solution_cost": "106", "opt_solution_compute_t": "0.04515695571899414", "solution_depth": "16", "max_successor_states": "41", "num_vars_per_state": "41", "is_feasible_args": "[[46, 10, 4, 8, 2, 22, 26, 49, 4, 19, 2, 9, 23, 28, 6, 21, 9, 14, 15, 21, 22, 3, 14, 2, 28, 13, 20, 2, 28, 7, 16, 27, 22, 18, 28, 10, 14, 14, 4, 20, 18]]", "is_correct_args": "[[46, 10, 4, 8, 2, 22, 26, 49, 4, 19, 2, 9, 23, 28, 6, 21, 9, 14, 15, 21, 22, 3, 14, 2, 28, 13, 20, 2, 28, 7, 16, 27, 22, 18, 28, 10, 14, 14, 4, 20, 18], {\"21\": 14, \"19\": 16, \"4\": 3, \"23\": 10, \"10\": 3, \"18\": 7, \"9\": 3, \"27\": 13, \"20\": 12, \"13\": 9, \"26\": 17, \"3\": 3, \"6\": 6, \"49\": 16, \"2\": 2, \"15\": 7, \"28\": 13, \"46\": 10, \"8\": 3, \"7\": 6, \"22\": 20, \"14\": 5, \"16\": 8}, 294]", "A*_args": "[\"[46, 10, 4, 8, 2, 22, 26, 49, 4, 19, 2, 9, 23, 28, 6, 21, 9, 14, 15, 21, 22, 3, 14, 2, 28, 13, 20, 2, 28, 7, 16, 27, 22, 18, 28, 10, 14, 14, 4, 20, 18]\", \"{21: 14, 19: 16, 4: 3, 23: 10, 10: 3, 18: 7, 9: 3, 27: 13, 20: 12, 13: 9, 26: 17, 3: 3, 6: 6, 49: 16, 2: 2, 15: 7, 28: 13, 46: 10, 8: 3, 7: 6, 22: 20, 14: 5, 16: 8}\", \"294\"]"}
{"diff_sorted_id": "30", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Blue', 'Green', 'Green'], ['Blue', 'Red', 'Green', 'Blue'], ['Green', 'Blue', 'Red', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[0, 1], [0, 1], [2, 0], [2, 0], [1, 0], [1, 2], [1, 0], [1, 2], [1, 2], [0, 1], [0, 1], [0, 1], [2, 0]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.31441617012023926", "solution_depth": "13", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Blue\", \"Green\", \"Green\"], [\"Blue\", \"Red\", \"Green\", \"Blue\"], [\"Green\", \"Blue\", \"Red\", \"Red\"]], 7]", "is_correct_args": "[[[\"Red\", \"Blue\", \"Green\", \"Green\"], [\"Blue\", \"Red\", \"Green\", \"Blue\"], [\"Green\", \"Blue\", \"Red\", \"Red\"]], 7]", "A*_args": "[\"[['Red', 'Blue', 'Green', 'Green'], ['Blue', 'Red', 'Green', 'Blue'], ['Green', 'Blue', 'Red', 'Red']]\", \"7\"]"}
{"diff_sorted_id": "30", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 39 to 87 (39 included in the range but 87 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '57' 'x']\n ['42' 'x' '72']\n ['39' 'x' '73']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 58], [0, 2, 40], [1, 1, 43], [2, 1, 41]]", "opt_solution_cost": "514", "opt_solution_compute_t": "0.1707303524017334", "solution_depth": "4", "max_successor_states": "48", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '57', ''], ['42', '', '72'], ['39', '', '73']]\", 39, 87]", "is_correct_args": "[\"[['', '57', ''], ['42', '', '72'], ['39', '', '73']]\", 39, 87]", "A*_args": "[\"[['', '57', ''], ['42', '', '72'], ['39', '', '73']]\", \"39\", \"87\"]"}
{"diff_sorted_id": "30", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 34 to 78. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 172, and sum of row 1 must be 212. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 165. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' '59']\n ['x' 'x' 'x']\n ['38' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 34], [0, 1, 37], [1, 0, 69], [1, 1, 68], [1, 2, 75], [2, 1, 67], [2, 2, 35]]", "opt_solution_cost": "482", "opt_solution_compute_t": "8.460258960723877", "solution_depth": "7", "max_successor_states": "34", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', '59'], ['', '', ''], ['38', '', '']]\", 3, 34, 78]", "is_correct_args": "[\"[['', '', '59'], ['', '', ''], ['38', '', '']]\", 34, 78, [1, 2], [1, 2], [172], [212], 165]", "A*_args": "[\"[['', '', '59'], ['', '', ''], ['38', '', '']]\", \"34\", \"78\", \"[None, 172, None]\", \"[None, 212, None]\", \"165\"]"}
{"diff_sorted_id": "30", "problem_statement": "In 'Restricted Sorting', there are 6 stacks each with a capacity of 4 blocks, with 3 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 3 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 3, 1: 6, 2: 3, 3: 2, 4: 1, 5: 1}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Blue', 'Red', 'Blue', 'Red'], [], ['Green', 'Green', 'Green', 'Red'], ['Yellow', 'Yellow', 'Yellow', 'Blue'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "1", "opt_solution": "[[3, 0], [3, 0], [3, 0], [4, 2], [4, 2], [4, 2], [1, 4], [1, 3], [1, 4], [1, 3]]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.20731306076049805", "solution_depth": "10", "max_successor_states": "30", "num_vars_per_state": "12", "is_feasible_args": "[[[], [\"Blue\", \"Red\", \"Blue\", \"Red\"], [], [\"Green\", \"Green\", \"Green\", \"Red\"], [\"Yellow\", \"Yellow\", \"Yellow\", \"Blue\"], []], 4, {\"0\": 3, \"1\": 6, \"2\": 3, \"3\": 2, \"4\": 1, \"5\": 1}]", "is_correct_args": "[[[], [\"Blue\", \"Red\", \"Blue\", \"Red\"], [], [\"Green\", \"Green\", \"Green\", \"Red\"], [\"Yellow\", \"Yellow\", \"Yellow\", \"Blue\"], []], 4, {\"0\": 3, \"1\": 6, \"2\": 3, \"3\": 2, \"4\": 1, \"5\": 1}, 3]", "A*_args": "[\"[[], ['Blue', 'Red', 'Blue', 'Red'], [], ['Green', 'Green', 'Green', 'Red'], ['Yellow', 'Yellow', 'Yellow', 'Blue'], []]\", \"{0: 3, 1: 6, 2: 3, 3: 2, 4: 1, 5: 1}\", \"4\", \"3\"]"}
{"diff_sorted_id": "30", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (4, 9) to his destination workshop at index (6, 1), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 5, and district 3 covering rows 6 to 9. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[8 x x 9 15 13 11 2 x x]\n[13 x x x 5 x x 7 x x]\n[12 3 x x x x x 10 x x]\n[12 x x 9 15 9 11 5 17 x]\n[3 5 12 x 11 5 x 15 1 18]\n[14 3 x x 18 14 19 19 12 15]\n[x 20 17 15 11 x x x x x]\n[12 13 18 x x 5 x 2 x 13]\n[x x 13 19 4 x 12 x x 8]\n[x x 10 x x x 15 x 4 16]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "2", "opt_solution": "[[4, 9], [4, 8], [4, 7], [3, 7], [3, 6], [3, 5], [4, 5], [4, 4], [5, 4], [6, 4], [6, 3], [6, 2], [6, 1]]", "opt_solution_cost": "138", "opt_solution_compute_t": "0.0320286750793457", "solution_depth": "13", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"8\", \"x\", \"x\", \"9\", \"15\", \"13\", \"11\", \"2\", \"x\", \"x\"], [\"13\", \"x\", \"x\", \"x\", \"5\", \"x\", \"x\", \"7\", \"x\", \"x\"], [\"12\", \"3\", \"x\", \"x\", \"x\", \"x\", \"x\", \"10\", \"x\", \"x\"], [\"12\", \"x\", \"x\", \"9\", \"15\", \"9\", \"11\", \"5\", \"17\", \"x\"], [\"3\", \"5\", \"12\", \"x\", \"11\", \"5\", \"x\", \"15\", \"1\", \"18\"], [\"14\", \"3\", \"x\", \"x\", \"18\", \"14\", \"19\", \"19\", \"12\", \"15\"], [\"x\", \"20\", \"17\", \"15\", \"11\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"12\", \"13\", \"18\", \"x\", \"x\", \"5\", \"x\", \"2\", \"x\", \"13\"], [\"x\", \"x\", \"13\", \"19\", \"4\", \"x\", \"12\", \"x\", \"x\", \"8\"], [\"x\", \"x\", \"10\", \"x\", \"x\", \"x\", \"15\", \"x\", \"4\", \"16\"]]]", "is_correct_args": "[[[\"8\", \"x\", \"x\", \"9\", \"15\", \"13\", \"11\", \"2\", \"x\", \"x\"], [\"13\", \"x\", \"x\", \"x\", \"5\", \"x\", \"x\", \"7\", \"x\", \"x\"], [\"12\", \"3\", \"x\", \"x\", \"x\", \"x\", \"x\", \"10\", \"x\", \"x\"], [\"12\", \"x\", \"x\", \"9\", \"15\", \"9\", \"11\", \"5\", \"17\", \"x\"], [\"3\", \"5\", \"12\", \"x\", \"11\", \"5\", \"x\", \"15\", \"1\", \"18\"], [\"14\", \"3\", \"x\", \"x\", \"18\", \"14\", \"19\", \"19\", \"12\", \"15\"], [\"x\", \"20\", \"17\", \"15\", \"11\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"12\", \"13\", \"18\", \"x\", \"x\", \"5\", \"x\", \"2\", \"x\", \"13\"], [\"x\", \"x\", \"13\", \"19\", \"4\", \"x\", \"12\", \"x\", \"x\", \"8\"], [\"x\", \"x\", \"10\", \"x\", \"x\", \"x\", \"15\", \"x\", \"4\", \"16\"]], [4, 9], [6, 1], 3, 5]", "A*_args": "[\"[['8', 'x', 'x', '9', '15', '13', '11', '2', 'x', 'x'], ['13', 'x', 'x', 'x', '5', 'x', 'x', '7', 'x', 'x'], ['12', '3', 'x', 'x', 'x', 'x', 'x', '10', 'x', 'x'], ['12', 'x', 'x', '9', '15', '9', '11', '5', '17', 'x'], ['3', '5', '12', 'x', '11', '5', 'x', '15', '1', '18'], ['14', '3', 'x', 'x', '18', '14', '19', '19', '12', '15'], ['x', '20', '17', '15', '11', 'x', 'x', 'x', 'x', 'x'], ['12', '13', '18', 'x', 'x', '5', 'x', '2', 'x', '13'], ['x', 'x', '13', '19', '4', 'x', '12', 'x', 'x', '8'], ['x', 'x', '10', 'x', 'x', 'x', '15', 'x', '4', '16']]\", \"(4, 9)\", \"(6, 1)\", \"3\", \"5\"]"}
{"diff_sorted_id": "30", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 10x10. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 9) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (7, 3). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 0 1 0 0 0 0 0 0\n1 1 0 1 0 0 1 0 0 0\n1 1 1 0 0 0 0 0 1 1\n1 1 1 1 0 0 0 1 0 1\n1 1 1 0 0 0 0 1 1 1\n1 1 1 1 0 0 0 0 1 1\n1 1 0 0 0 1 0 0 0 1\n1 1 0 0 1 0 1 1 0 0\n0 0 0 0 1 1 1 1 1 1\n0 1 0 0 1 0 0 1 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "10", "opt_solution": "[[0, 9], [1, 8], [1, 7], [2, 7], [2, 6], [3, 6], [4, 6], [4, 5], [5, 5], [6, 4], [7, 3]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.02998661994934082", "solution_depth": "11", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 1, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 1, 1], [1, 1, 1, 1, 0, 0, 0, 1, 0, 1], [1, 1, 1, 0, 0, 0, 0, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 1, 0, 0, 1, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0]]\", 3]", "is_correct_args": "[\"[[0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 1, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 1, 1], [1, 1, 1, 1, 0, 0, 0, 1, 0, 1], [1, 1, 1, 0, 0, 0, 0, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 1, 0, 0, 1, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0]]\", [0, 9], [7, 3], 3]", "A*_args": "[\"[[0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 1, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 1, 1], [1, 1, 1, 1, 0, 0, 0, 1, 0, 1], [1, 1, 1, 0, 0, 0, 0, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 1, 0, 0, 1, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0]]\", \"(0, 9)\", \"(7, 3)\", \"3\"]"}
{"diff_sorted_id": "30", "problem_statement": "Given 7 labeled water jugs with capacities 111, 84, 17, 22, 63, 75, 148, 64 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 253, 280, 448 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 63, 3], [\"+\", 111, 3], [\"+\", 148, 3], [\"-\", 22, 3], [\"+\", 148, 3], [\"+\", 22, 2], [\"+\", 84, 2], [\"+\", 111, 2], [\"+\", 63, 2], [\"+\", 75, 1], [\"+\", 84, 1], [\"-\", 17, 1], [\"+\", 111, 1]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.0519099235534668", "solution_depth": "13", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[111, 84, 17, 22, 63, 75, 148, 64], [253, 280, 448]]", "is_correct_args": "[[111, 84, 17, 22, 63, 75, 148, 64], [253, 280, 448]]", "A*_args": "[\"[111, 84, 17, 22, 63, 75, 148, 64]\", \"[253, 280, 448]\"]"}
{"diff_sorted_id": "31", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[75, 53, 73, 62], ['_', 14, 90, 43], [21, 17, 51, 27]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[21, 17, 14, 90, 51, 14, 17, 21, 90, 53, 75, 90, 53, 51, 43, 27]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.03641033172607422", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[75, 53, 73, 62], [\"_\", 14, 90, 43], [21, 17, 51, 27]]]", "is_correct_args": "[[[75, 53, 73, 62], [\"_\", 14, 90, 43], [21, 17, 51, 27]]]", "A*_args": "[\"[[75, 53, 73, 62], ['_', 14, 90, 43], [21, 17, 51, 27]]\"]"}
{"diff_sorted_id": "31", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: dyke, atoll, amuze, niuan   The initial board: [['t', 'd', 'u', 'k', 'e'], ['a', 'a', 'o', 'l', 'l'], ['a', 'm', '_', 'z', 'i'], ['n', 'e', 'u', 'y', 'n']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-left\"]", "opt_solution_cost": "26", "opt_solution_compute_t": "0.4536299705505371", "solution_depth": "26", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"t\", \"d\", \"u\", \"k\", \"e\"], [\"a\", \"a\", \"o\", \"l\", \"l\"], [\"a\", \"m\", \"_\", \"z\", \"i\"], [\"n\", \"e\", \"u\", \"y\", \"n\"]]]", "is_correct_args": "[[[\"t\", \"d\", \"u\", \"k\", \"e\"], [\"a\", \"a\", \"o\", \"l\", \"l\"], [\"a\", \"m\", \"_\", \"z\", \"i\"], [\"n\", \"e\", \"u\", \"y\", \"n\"]], [\"dyke\", \"atoll\", \"amuze\", \"niuan\"]]", "A*_args": "[\"[['t', 'd', 'u', 'k', 'e'], ['a', 'a', 'o', 'l', 'l'], ['a', 'm', '_', 'z', 'i'], ['n', 'e', 'u', 'y', 'n']]\", \"['dyke', 'atoll', 'amuze', 'niuan']\"]"}
{"diff_sorted_id": "31", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'J'. Our task is to visit city U and city E excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from E and U, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  S A J U E B N P L X F \nS 0 0 0 0 1 0 0 0 0 0 0 \nA 0 0 0 1 0 1 0 0 1 0 1 \nJ 0 0 0 0 0 1 0 0 1 0 0 \nU 1 0 0 0 0 0 1 1 0 0 0 \nE 0 1 0 0 0 0 0 0 0 0 0 \nB 0 0 0 0 1 0 1 1 0 1 0 \nN 0 1 0 1 1 1 0 0 0 1 1 \nP 1 0 0 0 0 0 1 0 1 0 0 \nL 0 0 1 0 0 1 0 0 0 1 0 \nX 0 0 1 1 0 0 0 0 1 0 0 \nF 0 1 0 1 0 0 0 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[\"J\", \"B\", \"E\", \"A\", \"U\", \"N\", \"U\", \"S\", \"E\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.02808380126953125", "solution_depth": "9", "max_successor_states": "11", "num_vars_per_state": "14", "is_feasible_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0], [0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [\"S\", \"A\", \"J\", \"U\", \"E\", \"B\", \"N\", \"P\", \"L\", \"X\", \"F\"], \"U\", \"E\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0], [0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [\"S\", \"A\", \"J\", \"U\", \"E\", \"B\", \"N\", \"P\", \"L\", \"X\", \"F\"], \"J\", \"U\", \"E\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0], [0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]]\", \"['S', 'A', 'J', 'U', 'E', 'B', 'N', 'P', 'L', 'X', 'F']\", \"['J']\", \"['U', 'E']\"]"}
{"diff_sorted_id": "31", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [12, 23, 57, 18, 6, 5, 21, 15, 14, 23, 5, 16, 9, 8, 19, 8, 19, 6, 8, 3, 12, 2, 14, 3, 3, 4, 26, 6, 6, 25, 9, 13, 20, 24, 6, 26, 14, 25, 5, 26], such that the sum of the chosen coins adds up to 260. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {6: 2, 12: 3, 9: 2, 2: 1, 14: 1, 16: 12, 21: 10, 4: 1, 8: 5, 26: 7, 23: 7, 57: 11, 15: 15, 19: 13, 25: 15, 13: 4, 5: 3, 24: 4, 3: 3, 18: 4, 20: 10}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "24", "opt_solution": "[24, 14, 57, 14, 12, 6, 9, 9, 6, 23, 18, 14, 12, 23, 6, 13]", "opt_solution_cost": "56", "opt_solution_compute_t": "0.04410982131958008", "solution_depth": "16", "max_successor_states": "40", "num_vars_per_state": "40", "is_feasible_args": "[[12, 23, 57, 18, 6, 5, 21, 15, 14, 23, 5, 16, 9, 8, 19, 8, 19, 6, 8, 3, 12, 2, 14, 3, 3, 4, 26, 6, 6, 25, 9, 13, 20, 24, 6, 26, 14, 25, 5, 26]]", "is_correct_args": "[[12, 23, 57, 18, 6, 5, 21, 15, 14, 23, 5, 16, 9, 8, 19, 8, 19, 6, 8, 3, 12, 2, 14, 3, 3, 4, 26, 6, 6, 25, 9, 13, 20, 24, 6, 26, 14, 25, 5, 26], {\"6\": 2, \"12\": 3, \"9\": 2, \"2\": 1, \"14\": 1, \"16\": 12, \"21\": 10, \"4\": 1, \"8\": 5, \"26\": 7, \"23\": 7, \"57\": 11, \"15\": 15, \"19\": 13, \"25\": 15, \"13\": 4, \"5\": 3, \"24\": 4, \"3\": 3, \"18\": 4, \"20\": 10}, 260]", "A*_args": "[\"[12, 23, 57, 18, 6, 5, 21, 15, 14, 23, 5, 16, 9, 8, 19, 8, 19, 6, 8, 3, 12, 2, 14, 3, 3, 4, 26, 6, 6, 25, 9, 13, 20, 24, 6, 26, 14, 25, 5, 26]\", \"{6: 2, 12: 3, 9: 2, 2: 1, 14: 1, 16: 12, 21: 10, 4: 1, 8: 5, 26: 7, 23: 7, 57: 11, 15: 15, 19: 13, 25: 15, 13: 4, 5: 3, 24: 4, 3: 3, 18: 4, 20: 10}\", \"260\"]"}
{"diff_sorted_id": "31", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Red', 'Red', 'Green'], ['Blue', 'Green', 'Green', 'Blue'], ['Blue', 'Red', 'Green', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[2, 1], [2, 0], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [1, 2], [1, 0], [1, 2], [1, 2], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1]]", "opt_solution_cost": "17", "opt_solution_compute_t": "1.8599176406860352", "solution_depth": "17", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Red\", \"Red\", \"Green\"], [\"Blue\", \"Green\", \"Green\", \"Blue\"], [\"Blue\", \"Red\", \"Green\", \"Blue\"]], 7]", "is_correct_args": "[[[\"Red\", \"Red\", \"Red\", \"Green\"], [\"Blue\", \"Green\", \"Green\", \"Blue\"], [\"Blue\", \"Red\", \"Green\", \"Blue\"]], 7]", "A*_args": "[\"[['Red', 'Red', 'Red', 'Green'], ['Blue', 'Green', 'Green', 'Blue'], ['Blue', 'Red', 'Green', 'Blue']]\", \"7\"]"}
{"diff_sorted_id": "31", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 5 to 53 (5 included in the range but 53 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['10' '25' 'x']\n ['x' 'x' '45']\n ['x' '7' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 2, 46], [1, 0, 9], [1, 1, 11], [2, 0, 8], [2, 2, 5]]", "opt_solution_cost": "203", "opt_solution_compute_t": "9.56848430633545", "solution_depth": "5", "max_successor_states": "48", "num_vars_per_state": "9", "is_feasible_args": "[\"[['10', '25', ''], ['', '', '45'], ['', '7', '']]\", 5, 53]", "is_correct_args": "[\"[['10', '25', ''], ['', '', '45'], ['', '7', '']]\", 5, 53]", "A*_args": "[\"[['10', '25', ''], ['', '', '45'], ['', '7', '']]\", \"5\", \"53\"]"}
{"diff_sorted_id": "31", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 34 to 78. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 177, and sum of row 1 must be 180. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 183. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x']\n ['x' '73' '47']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 34], [0, 1, 36], [0, 2, 38], [1, 0, 60], [2, 0, 72], [2, 1, 68], [2, 2, 35]]", "opt_solution_cost": "463", "opt_solution_compute_t": "20.116249084472656", "solution_depth": "7", "max_successor_states": "34", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '73', '47'], ['', '', '']]\", 3, 34, 78]", "is_correct_args": "[\"[['', '', ''], ['', '73', '47'], ['', '', '']]\", 34, 78, [1, 2], [1, 2], [177], [180], 183]", "A*_args": "[\"[['', '', ''], ['', '73', '47'], ['', '', '']]\", \"34\", \"78\", \"[None, 177, None]\", \"[None, 180, None]\", \"183\"]"}
{"diff_sorted_id": "31", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 7, 1: 2, 2: 1, 3: 1, 4: 9, 5: 4, 6: 2, 7: 7}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], ['Yellow', 'Yellow', 'Green', 'Black', 'Red'], ['Black', 'Green', 'Black', 'Blue', 'Yellow'], ['Green', 'Blue', 'Yellow', 'Red', 'Blue'], [], [], ['Black', 'Red', 'Green', 'Red', 'Blue']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[4, 5], [3, 1], [3, 5], [3, 1], [3, 6], [2, 3], [2, 3], [2, 5], [2, 1], [7, 1], [7, 2], [7, 5], [4, 6], [7, 2], [7, 6], [4, 3], [4, 2], [4, 6]]", "opt_solution_cost": "38", "opt_solution_compute_t": "7.533451795578003", "solution_depth": "18", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[], [], [\"Yellow\", \"Yellow\", \"Green\", \"Black\", \"Red\"], [\"Black\", \"Green\", \"Black\", \"Blue\", \"Yellow\"], [\"Green\", \"Blue\", \"Yellow\", \"Red\", \"Blue\"], [], [], [\"Black\", \"Red\", \"Green\", \"Red\", \"Blue\"]], 5, {\"0\": 7, \"1\": 2, \"2\": 1, \"3\": 1, \"4\": 9, \"5\": 4, \"6\": 2, \"7\": 7}]", "is_correct_args": "[[[], [], [\"Yellow\", \"Yellow\", \"Green\", \"Black\", \"Red\"], [\"Black\", \"Green\", \"Black\", \"Blue\", \"Yellow\"], [\"Green\", \"Blue\", \"Yellow\", \"Red\", \"Blue\"], [], [], [\"Black\", \"Red\", \"Green\", \"Red\", \"Blue\"]], 5, {\"0\": 7, \"1\": 2, \"2\": 1, \"3\": 1, \"4\": 9, \"5\": 4, \"6\": 2, \"7\": 7}, 4]", "A*_args": "[\"[[], [], ['Yellow', 'Yellow', 'Green', 'Black', 'Red'], ['Black', 'Green', 'Black', 'Blue', 'Yellow'], ['Green', 'Blue', 'Yellow', 'Red', 'Blue'], [], [], ['Black', 'Red', 'Green', 'Red', 'Blue']]\", \"{0: 7, 1: 2, 2: 1, 3: 1, 4: 9, 5: 4, 6: 2, 7: 7}\", \"5\", \"4\"]"}
{"diff_sorted_id": "31", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 7) to his destination workshop at index (7, 0), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 6, and district 3 covering rows 7 to 10. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[10 x 19 11 x x 6 12 x x x]\n[2 9 10 x x 10 17 x x 11 5]\n[x 15 8 9 x 7 17 20 x x 13]\n[1 9 15 14 9 9 13 7 12 x 10]\n[9 x 17 x x 7 x x 1 x 14]\n[16 18 11 x 14 18 9 13 x x x]\n[9 3 5 8 17 15 19 x 3 x 14]\n[2 13 x x 17 13 14 18 9 x 6]\n[3 x 18 6 x 14 x x x 8 19]\n[2 4 x x x x 3 4 x 19 x]\n[x x x x 11 x x x x 5 5]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "3", "opt_solution": "[[3, 7], [3, 6], [3, 5], [2, 5], [3, 5], [4, 5], [5, 5], [5, 4], [6, 4], [6, 3], [6, 2], [6, 1], [6, 0], [7, 0]]", "opt_solution_cost": "121", "opt_solution_compute_t": "0.03958845138549805", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"10\", \"x\", \"19\", \"11\", \"x\", \"x\", \"6\", \"12\", \"x\", \"x\", \"x\"], [\"2\", \"9\", \"10\", \"x\", \"x\", \"10\", \"17\", \"x\", \"x\", \"11\", \"5\"], [\"x\", \"15\", \"8\", \"9\", \"x\", \"7\", \"17\", \"20\", \"x\", \"x\", \"13\"], [\"1\", \"9\", \"15\", \"14\", \"9\", \"9\", \"13\", \"7\", \"12\", \"x\", \"10\"], [\"9\", \"x\", \"17\", \"x\", \"x\", \"7\", \"x\", \"x\", \"1\", \"x\", \"14\"], [\"16\", \"18\", \"11\", \"x\", \"14\", \"18\", \"9\", \"13\", \"x\", \"x\", \"x\"], [\"9\", \"3\", \"5\", \"8\", \"17\", \"15\", \"19\", \"x\", \"3\", \"x\", \"14\"], [\"2\", \"13\", \"x\", \"x\", \"17\", \"13\", \"14\", \"18\", \"9\", \"x\", \"6\"], [\"3\", \"x\", \"18\", \"6\", \"x\", \"14\", \"x\", \"x\", \"x\", \"8\", \"19\"], [\"2\", \"4\", \"x\", \"x\", \"x\", \"x\", \"3\", \"4\", \"x\", \"19\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"11\", \"x\", \"x\", \"x\", \"x\", \"5\", \"5\"]]]", "is_correct_args": "[[[\"10\", \"x\", \"19\", \"11\", \"x\", \"x\", \"6\", \"12\", \"x\", \"x\", \"x\"], [\"2\", \"9\", \"10\", \"x\", \"x\", \"10\", \"17\", \"x\", \"x\", \"11\", \"5\"], [\"x\", \"15\", \"8\", \"9\", \"x\", \"7\", \"17\", \"20\", \"x\", \"x\", \"13\"], [\"1\", \"9\", \"15\", \"14\", \"9\", \"9\", \"13\", \"7\", \"12\", \"x\", \"10\"], [\"9\", \"x\", \"17\", \"x\", \"x\", \"7\", \"x\", \"x\", \"1\", \"x\", \"14\"], [\"16\", \"18\", \"11\", \"x\", \"14\", \"18\", \"9\", \"13\", \"x\", \"x\", \"x\"], [\"9\", \"3\", \"5\", \"8\", \"17\", \"15\", \"19\", \"x\", \"3\", \"x\", \"14\"], [\"2\", \"13\", \"x\", \"x\", \"17\", \"13\", \"14\", \"18\", \"9\", \"x\", \"6\"], [\"3\", \"x\", \"18\", \"6\", \"x\", \"14\", \"x\", \"x\", \"x\", \"8\", \"19\"], [\"2\", \"4\", \"x\", \"x\", \"x\", \"x\", \"3\", \"4\", \"x\", \"19\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"11\", \"x\", \"x\", \"x\", \"x\", \"5\", \"5\"]], [3, 7], [7, 0], 2, 6]", "A*_args": "[\"[['10', 'x', '19', '11', 'x', 'x', '6', '12', 'x', 'x', 'x'], ['2', '9', '10', 'x', 'x', '10', '17', 'x', 'x', '11', '5'], ['x', '15', '8', '9', 'x', '7', '17', '20', 'x', 'x', '13'], ['1', '9', '15', '14', '9', '9', '13', '7', '12', 'x', '10'], ['9', 'x', '17', 'x', 'x', '7', 'x', 'x', '1', 'x', '14'], ['16', '18', '11', 'x', '14', '18', '9', '13', 'x', 'x', 'x'], ['9', '3', '5', '8', '17', '15', '19', 'x', '3', 'x', '14'], ['2', '13', 'x', 'x', '17', '13', '14', '18', '9', 'x', '6'], ['3', 'x', '18', '6', 'x', '14', 'x', 'x', 'x', '8', '19'], ['2', '4', 'x', 'x', 'x', 'x', '3', '4', 'x', '19', 'x'], ['x', 'x', 'x', 'x', '11', 'x', 'x', 'x', 'x', '5', '5']]\", \"(3, 7)\", \"(7, 0)\", \"2\", \"6\"]"}
{"diff_sorted_id": "31", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 11x11. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 10) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (9, 3). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 0 1 1 1 0 0 1 0 0\n1 0 1 0 1 0 1 1 0 0 0\n1 1 1 1 1 1 1 0 0 0 0\n0 0 1 0 1 1 1 0 0 0 1\n0 0 1 1 0 0 0 0 0 0 1\n0 0 1 0 0 1 0 1 1 0 0\n0 0 0 0 1 0 0 1 1 0 1\n0 0 0 0 1 0 1 1 0 1 0\n1 1 0 0 1 0 0 0 0 0 1\n0 0 0 0 1 1 1 0 1 1 1\n1 1 0 0 0 1 0 0 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[[1, 10], [2, 9], [3, 8], [4, 7], [4, 6], [4, 5], [4, 4], [5, 4], [5, 3], [6, 3], [7, 3], [8, 3], [9, 3]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.029936790466308594", "solution_depth": "13", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1]]\", 3]", "is_correct_args": "[\"[[1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1]]\", [1, 10], [9, 3], 3]", "A*_args": "[\"[[1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1]]\", \"(1, 10)\", \"(9, 3)\", \"3\"]"}
{"diff_sorted_id": "31", "problem_statement": "Given 7 labeled water jugs with capacities 14, 46, 13, 110, 38, 21, 45, 130 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 215, 219, 262 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 21, 3], [\"+\", 110, 3], [\"+\", 110, 3], [\"+\", 21, 3], [\"+\", 130, 2], [\"-\", 21, 2], [\"+\", 110, 2], [\"+\", 130, 1], [\"-\", 45, 1], [\"+\", 130, 1]]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.0400242805480957", "solution_depth": "10", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[14, 46, 13, 110, 38, 21, 45, 130], [215, 219, 262]]", "is_correct_args": "[[14, 46, 13, 110, 38, 21, 45, 130], [215, 219, 262]]", "A*_args": "[\"[14, 46, 13, 110, 38, 21, 45, 130]\", \"[215, 219, 262]\"]"}
{"diff_sorted_id": "32", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[69, 56, 8, 67], [15, 47, 44, 30], [73, '_', 24, 63]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[24, 44, 30, 63, 44, 30, 8, 67, 63, 44, 30, 8, 47, 15, 73, 24, 15, 56, 69, 73, 56, 47, 44, 30]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.1358938217163086", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[69, 56, 8, 67], [15, 47, 44, 30], [73, \"_\", 24, 63]]]", "is_correct_args": "[[[69, 56, 8, 67], [15, 47, 44, 30], [73, \"_\", 24, 63]]]", "A*_args": "[\"[[69, 56, 8, 67], [15, 47, 44, 30], [73, '_', 24, 63]]\"]"}
{"diff_sorted_id": "32", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: fack, sofia, nisse, nosey   The initial board: [['o', 'f', '_', 'c', 'k'], ['s', 'n', 'f', 's', 'a'], ['o', 'i', 'i', 's', 'e'], ['n', 'e', 's', 'a', 'y']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-right\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.24036526679992676", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"o\", \"f\", \"_\", \"c\", \"k\"], [\"s\", \"n\", \"f\", \"s\", \"a\"], [\"o\", \"i\", \"i\", \"s\", \"e\"], [\"n\", \"e\", \"s\", \"a\", \"y\"]]]", "is_correct_args": "[[[\"o\", \"f\", \"_\", \"c\", \"k\"], [\"s\", \"n\", \"f\", \"s\", \"a\"], [\"o\", \"i\", \"i\", \"s\", \"e\"], [\"n\", \"e\", \"s\", \"a\", \"y\"]], [\"fack\", \"sofia\", \"nisse\", \"nosey\"]]", "A*_args": "[\"[['o', 'f', '_', 'c', 'k'], ['s', 'n', 'f', 's', 'a'], ['o', 'i', 'i', 's', 'e'], ['n', 'e', 's', 'a', 'y']]\", \"['fack', 'sofia', 'nisse', 'nosey']\"]"}
{"diff_sorted_id": "32", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'J'. Our task is to visit city E and city D excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from D and E, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  D T L E C J Q O K X F \nD 0 1 0 1 0 1 1 0 0 0 0 \nT 0 0 1 1 0 0 1 1 0 0 0 \nL 0 0 0 1 0 0 0 0 0 0 0 \nE 0 0 0 0 0 1 1 1 1 0 0 \nC 1 0 0 0 0 0 0 0 0 0 0 \nJ 0 0 0 0 0 0 0 0 0 0 1 \nQ 0 0 1 0 0 0 0 1 0 0 1 \nO 1 0 0 0 0 1 0 0 1 1 0 \nK 0 1 1 0 1 0 0 0 0 1 0 \nX 1 0 0 0 0 0 0 0 0 0 0 \nF 1 1 1 0 1 1 0 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[\"J\", \"F\", \"D\", \"E\", \"O\", \"D\", \"E\"]", "opt_solution_cost": "7", "opt_solution_compute_t": "0.02650594711303711", "solution_depth": "7", "max_successor_states": "11", "num_vars_per_state": "14", "is_feasible_args": "[[[0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0]], [\"D\", \"T\", \"L\", \"E\", \"C\", \"J\", \"Q\", \"O\", \"K\", \"X\", \"F\"], \"E\", \"D\"]", "is_correct_args": "[[[0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0]], [\"D\", \"T\", \"L\", \"E\", \"C\", \"J\", \"Q\", \"O\", \"K\", \"X\", \"F\"], \"J\", \"E\", \"D\"]", "A*_args": "[\"[[0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0]]\", \"['D', 'T', 'L', 'E', 'C', 'J', 'Q', 'O', 'K', 'X', 'F']\", \"['J']\", \"['E', 'D']\"]"}
{"diff_sorted_id": "32", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [19, 2, 25, 9, 6, 24, 4, 26, 17, 11, 11, 2, 17, 2, 5, 6, 3, 3, 3, 18, 26, 18, 21, 3, 5, 8, 12, 15, 8, 18, 24, 5, 19, 7, 18, 25, 12, 13, 12, 2, 25, 16, 17, 16, 3, 3], such that the sum of the chosen coins adds up to 264. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {26: 12, 25: 20, 17: 13, 13: 4, 16: 13, 11: 10, 24: 5, 5: 4, 8: 6, 7: 5, 4: 4, 12: 9, 18: 12, 3: 2, 21: 17, 19: 7, 2: 2, 9: 9, 6: 2, 15: 4}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "25", "opt_solution": "[24, 6, 13, 15, 2, 3, 19, 6, 19, 18, 12, 17, 25, 24, 18, 25, 18]", "opt_solution_cost": "138", "opt_solution_compute_t": "0.046419620513916016", "solution_depth": "17", "max_successor_states": "46", "num_vars_per_state": "46", "is_feasible_args": "[[19, 2, 25, 9, 6, 24, 4, 26, 17, 11, 11, 2, 17, 2, 5, 6, 3, 3, 3, 18, 26, 18, 21, 3, 5, 8, 12, 15, 8, 18, 24, 5, 19, 7, 18, 25, 12, 13, 12, 2, 25, 16, 17, 16, 3, 3]]", "is_correct_args": "[[19, 2, 25, 9, 6, 24, 4, 26, 17, 11, 11, 2, 17, 2, 5, 6, 3, 3, 3, 18, 26, 18, 21, 3, 5, 8, 12, 15, 8, 18, 24, 5, 19, 7, 18, 25, 12, 13, 12, 2, 25, 16, 17, 16, 3, 3], {\"26\": 12, \"25\": 20, \"17\": 13, \"13\": 4, \"16\": 13, \"11\": 10, \"24\": 5, \"5\": 4, \"8\": 6, \"7\": 5, \"4\": 4, \"12\": 9, \"18\": 12, \"3\": 2, \"21\": 17, \"19\": 7, \"2\": 2, \"9\": 9, \"6\": 2, \"15\": 4}, 264]", "A*_args": "[\"[19, 2, 25, 9, 6, 24, 4, 26, 17, 11, 11, 2, 17, 2, 5, 6, 3, 3, 3, 18, 26, 18, 21, 3, 5, 8, 12, 15, 8, 18, 24, 5, 19, 7, 18, 25, 12, 13, 12, 2, 25, 16, 17, 16, 3, 3]\", \"{26: 12, 25: 20, 17: 13, 13: 4, 16: 13, 11: 10, 24: 5, 5: 4, 8: 6, 7: 5, 4: 4, 12: 9, 18: 12, 3: 2, 21: 17, 19: 7, 2: 2, 9: 9, 6: 2, 15: 4}\", \"264\"]"}
{"diff_sorted_id": "32", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Red', 'Blue', 'Green'], ['Blue', 'Blue', 'Red', 'Blue'], ['Red', 'Red', 'Green', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[0, 2], [0, 2], [1, 0], [1, 0], [1, 2], [0, 1], [0, 1], [0, 1], [0, 1], [2, 0], [2, 0], [2, 1], [2, 0], [2, 0], [1, 2], [1, 2]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.9227294921875", "solution_depth": "16", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Red\", \"Blue\", \"Green\"], [\"Blue\", \"Blue\", \"Red\", \"Blue\"], [\"Red\", \"Red\", \"Green\", \"Green\"]], 7]", "is_correct_args": "[[[\"Green\", \"Red\", \"Blue\", \"Green\"], [\"Blue\", \"Blue\", \"Red\", \"Blue\"], [\"Red\", \"Red\", \"Green\", \"Green\"]], 7]", "A*_args": "[\"[['Green', 'Red', 'Blue', 'Green'], ['Blue', 'Blue', 'Red', 'Blue'], ['Red', 'Red', 'Green', 'Green']]\", \"7\"]"}
{"diff_sorted_id": "32", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 9 to 57 (9 included in the range but 57 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['49' 'x' 'x']\n ['47' 'x' '54']\n ['x' '35' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 1, 50], [0, 2, 55], [1, 1, 48], [2, 0, 36], [2, 2, 9]]", "opt_solution_cost": "378", "opt_solution_compute_t": "0.3984415531158447", "solution_depth": "5", "max_successor_states": "48", "num_vars_per_state": "9", "is_feasible_args": "[\"[['49', '', ''], ['47', '', '54'], ['', '35', '']]\", 9, 57]", "is_correct_args": "[\"[['49', '', ''], ['47', '', '54'], ['', '35', '']]\", 9, 57]", "A*_args": "[\"[['49', '', ''], ['47', '', '54'], ['', '35', '']]\", \"9\", \"57\"]"}
{"diff_sorted_id": "32", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 31 to 75. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 135, and sum of row 1 must be 134. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 122. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x']\n ['x' 'x' 'x']\n ['41' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 32], [0, 1, 34], [0, 2, 31], [1, 0, 35], [1, 1, 50], [1, 2, 49], [2, 1, 51], [2, 2, 33]]", "opt_solution_cost": "356", "opt_solution_compute_t": "31.9260516166687", "solution_depth": "8", "max_successor_states": "34", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '', ''], ['41', '', '']]\", 3, 31, 75]", "is_correct_args": "[\"[['', '', ''], ['', '', ''], ['41', '', '']]\", 31, 75, [1, 2], [1, 2], [135], [134], 122]", "A*_args": "[\"[['', '', ''], ['', '', ''], ['41', '', '']]\", \"31\", \"75\", \"[None, 135, None]\", \"[None, 134, None]\", \"122\"]"}
{"diff_sorted_id": "32", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 5, 1: 8, 2: 1, 3: 6, 4: 8, 5: 2, 6: 1, 7: 8}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Black', 'Yellow', 'Blue', 'Yellow', 'Red'], [], [], [], [], ['Blue', 'Green', 'Blue', 'Green', 'Blue'], ['Yellow', 'Black', 'Green', 'Yellow', 'Black'], ['Red', 'Red', 'Red', 'Green', 'Black']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[0, 1], [5, 3], [5, 2], [5, 3], [5, 2], [5, 3], [6, 5], [6, 4], [0, 5], [0, 3], [0, 5], [7, 0], [7, 0], [7, 0], [6, 2], [6, 5], [7, 2], [1, 6], [4, 6], [7, 6]]", "opt_solution_cost": "70", "opt_solution_compute_t": "43.11308765411377", "solution_depth": "20", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[\"Black\", \"Yellow\", \"Blue\", \"Yellow\", \"Red\"], [], [], [], [], [\"Blue\", \"Green\", \"Blue\", \"Green\", \"Blue\"], [\"Yellow\", \"Black\", \"Green\", \"Yellow\", \"Black\"], [\"Red\", \"Red\", \"Red\", \"Green\", \"Black\"]], 5, {\"0\": 5, \"1\": 8, \"2\": 1, \"3\": 6, \"4\": 8, \"5\": 2, \"6\": 1, \"7\": 8}]", "is_correct_args": "[[[\"Black\", \"Yellow\", \"Blue\", \"Yellow\", \"Red\"], [], [], [], [], [\"Blue\", \"Green\", \"Blue\", \"Green\", \"Blue\"], [\"Yellow\", \"Black\", \"Green\", \"Yellow\", \"Black\"], [\"Red\", \"Red\", \"Red\", \"Green\", \"Black\"]], 5, {\"0\": 5, \"1\": 8, \"2\": 1, \"3\": 6, \"4\": 8, \"5\": 2, \"6\": 1, \"7\": 8}, 4]", "A*_args": "[\"[['Black', 'Yellow', 'Blue', 'Yellow', 'Red'], [], [], [], [], ['Blue', 'Green', 'Blue', 'Green', 'Blue'], ['Yellow', 'Black', 'Green', 'Yellow', 'Black'], ['Red', 'Red', 'Red', 'Green', 'Black']]\", \"{0: 5, 1: 8, 2: 1, 3: 6, 4: 8, 5: 2, 6: 1, 7: 8}\", \"5\", \"4\"]"}
{"diff_sorted_id": "32", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (5, 2) to his destination workshop at index (2, 10), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 4, and district 3 covering rows 5 to 10. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x 13 x x 7 x 13 3 x 13]\n[10 4 x 4 12 2 x 3 4 x 15]\n[x 3 x x 15 9 x x 18 17 14]\n[5 x x x 3 x 11 x 17 9 17]\n[8 3 13 x 5 7 8 17 7 x x]\n[x x 13 2 2 11 6 8 x x x]\n[x 1 9 6 5 13 16 1 7 5 x]\n[4 x 13 x 10 18 3 x x 19 19]\n[x x x 2 5 9 13 x 7 1 x]\n[x x 7 x x 5 19 x x x x]\n[x x x 6 x 19 x x x x 1]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "3", "opt_solution": "[[5, 2], [5, 3], [5, 4], [4, 4], [4, 5], [4, 6], [4, 7], [4, 8], [3, 8], [3, 9], [2, 9], [2, 10]]", "opt_solution_cost": "105", "opt_solution_compute_t": "0.029694080352783203", "solution_depth": "12", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"13\", \"x\", \"x\", \"7\", \"x\", \"13\", \"3\", \"x\", \"13\"], [\"10\", \"4\", \"x\", \"4\", \"12\", \"2\", \"x\", \"3\", \"4\", \"x\", \"15\"], [\"x\", \"3\", \"x\", \"x\", \"15\", \"9\", \"x\", \"x\", \"18\", \"17\", \"14\"], [\"5\", \"x\", \"x\", \"x\", \"3\", \"x\", \"11\", \"x\", \"17\", \"9\", \"17\"], [\"8\", \"3\", \"13\", \"x\", \"5\", \"7\", \"8\", \"17\", \"7\", \"x\", \"x\"], [\"x\", \"x\", \"13\", \"2\", \"2\", \"11\", \"6\", \"8\", \"x\", \"x\", \"x\"], [\"x\", \"1\", \"9\", \"6\", \"5\", \"13\", \"16\", \"1\", \"7\", \"5\", \"x\"], [\"4\", \"x\", \"13\", \"x\", \"10\", \"18\", \"3\", \"x\", \"x\", \"19\", \"19\"], [\"x\", \"x\", \"x\", \"2\", \"5\", \"9\", \"13\", \"x\", \"7\", \"1\", \"x\"], [\"x\", \"x\", \"7\", \"x\", \"x\", \"5\", \"19\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"6\", \"x\", \"19\", \"x\", \"x\", \"x\", \"x\", \"1\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"13\", \"x\", \"x\", \"7\", \"x\", \"13\", \"3\", \"x\", \"13\"], [\"10\", \"4\", \"x\", \"4\", \"12\", \"2\", \"x\", \"3\", \"4\", \"x\", \"15\"], [\"x\", \"3\", \"x\", \"x\", \"15\", \"9\", \"x\", \"x\", \"18\", \"17\", \"14\"], [\"5\", \"x\", \"x\", \"x\", \"3\", \"x\", \"11\", \"x\", \"17\", \"9\", \"17\"], [\"8\", \"3\", \"13\", \"x\", \"5\", \"7\", \"8\", \"17\", \"7\", \"x\", \"x\"], [\"x\", \"x\", \"13\", \"2\", \"2\", \"11\", \"6\", \"8\", \"x\", \"x\", \"x\"], [\"x\", \"1\", \"9\", \"6\", \"5\", \"13\", \"16\", \"1\", \"7\", \"5\", \"x\"], [\"4\", \"x\", \"13\", \"x\", \"10\", \"18\", \"3\", \"x\", \"x\", \"19\", \"19\"], [\"x\", \"x\", \"x\", \"2\", \"5\", \"9\", \"13\", \"x\", \"7\", \"1\", \"x\"], [\"x\", \"x\", \"7\", \"x\", \"x\", \"5\", \"19\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"6\", \"x\", \"19\", \"x\", \"x\", \"x\", \"x\", \"1\"]], [5, 2], [2, 10], 2, 4]", "A*_args": "[\"[['x', 'x', '13', 'x', 'x', '7', 'x', '13', '3', 'x', '13'], ['10', '4', 'x', '4', '12', '2', 'x', '3', '4', 'x', '15'], ['x', '3', 'x', 'x', '15', '9', 'x', 'x', '18', '17', '14'], ['5', 'x', 'x', 'x', '3', 'x', '11', 'x', '17', '9', '17'], ['8', '3', '13', 'x', '5', '7', '8', '17', '7', 'x', 'x'], ['x', 'x', '13', '2', '2', '11', '6', '8', 'x', 'x', 'x'], ['x', '1', '9', '6', '5', '13', '16', '1', '7', '5', 'x'], ['4', 'x', '13', 'x', '10', '18', '3', 'x', 'x', '19', '19'], ['x', 'x', 'x', '2', '5', '9', '13', 'x', '7', '1', 'x'], ['x', 'x', '7', 'x', 'x', '5', '19', 'x', 'x', 'x', 'x'], ['x', 'x', 'x', '6', 'x', '19', 'x', 'x', 'x', 'x', '1']]\", \"(5, 2)\", \"(2, 10)\", \"2\", \"4\"]"}
{"diff_sorted_id": "32", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 11x11. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 9) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (9, 2). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 1 1 1 0 1 0 0 0\n0 1 1 1 1 0 0 1 1 0 0\n1 1 1 0 1 0 1 0 1 0 1\n0 1 0 1 0 1 0 0 1 0 0\n1 1 0 1 0 1 1 0 1 0 0\n0 0 0 1 0 1 0 1 0 0 1\n1 1 0 0 1 1 0 0 0 0 1\n0 0 1 0 1 0 1 1 0 0 1\n0 1 1 0 1 0 1 1 0 0 1\n1 0 0 0 0 0 1 0 0 0 0\n0 1 1 1 1 0 0 0 0 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[[0, 9], [1, 9], [2, 9], [3, 9], [4, 9], [5, 8], [6, 7], [6, 6], [7, 5], [8, 5], [9, 5], [9, 4], [9, 3], [9, 2]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.03171658515930176", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0], [1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1], [1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1]]\", 3]", "is_correct_args": "[\"[[1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0], [1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1], [1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1]]\", [0, 9], [9, 2], 3]", "A*_args": "[\"[[1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0], [1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1], [1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1]]\", \"(0, 9)\", \"(9, 2)\", \"3\"]"}
{"diff_sorted_id": "32", "problem_statement": "Given 7 labeled water jugs with capacities 137, 29, 70, 138, 47, 64, 87, 16 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 295, 327, 442 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 137, 3], [\"+\", 138, 3], [\"+\", 29, 3], [\"+\", 138, 3], [\"+\", 87, 2], [\"+\", 87, 2], [\"+\", 16, 2], [\"+\", 137, 2], [\"+\", 87, 1], [\"+\", 138, 1], [\"+\", 70, 1]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.042920589447021484", "solution_depth": "11", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[137, 29, 70, 138, 47, 64, 87, 16], [295, 327, 442]]", "is_correct_args": "[[137, 29, 70, 138, 47, 64, 87, 16], [295, 327, 442]]", "A*_args": "[\"[137, 29, 70, 138, 47, 64, 87, 16]\", \"[295, 327, 442]\"]"}
{"diff_sorted_id": "33", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[79, 90, 85, 67], [100, 61, '_', 15], [95, 41, 33, 73]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[61, 100, 95, 41, 33, 73, 15, 61, 73, 15, 61, 67, 85, 90, 100, 95, 79, 100, 95, 73, 67, 61]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.05052661895751953", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[79, 90, 85, 67], [100, 61, \"_\", 15], [95, 41, 33, 73]]]", "is_correct_args": "[[[79, 90, 85, 67], [100, 61, \"_\", 15], [95, 41, 33, 73]]]", "A*_args": "[\"[[79, 90, 85, 67], [100, 61, '_', 15], [95, 41, 33, 73]]\"]"}
{"diff_sorted_id": "33", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: jama, agoho, rudge, scruf   The initial board: [['g', 'j', 'u', 'm', 'a'], ['a', 'r', 'o', 'e', 'o'], ['h', 'u', '_', 'g', 'd'], ['s', 'c', 'r', 'a', 'f']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.28627824783325195", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"g\", \"j\", \"u\", \"m\", \"a\"], [\"a\", \"r\", \"o\", \"e\", \"o\"], [\"h\", \"u\", \"_\", \"g\", \"d\"], [\"s\", \"c\", \"r\", \"a\", \"f\"]]]", "is_correct_args": "[[[\"g\", \"j\", \"u\", \"m\", \"a\"], [\"a\", \"r\", \"o\", \"e\", \"o\"], [\"h\", \"u\", \"_\", \"g\", \"d\"], [\"s\", \"c\", \"r\", \"a\", \"f\"]], [\"jama\", \"agoho\", \"rudge\", \"scruf\"]]", "A*_args": "[\"[['g', 'j', 'u', 'm', 'a'], ['a', 'r', 'o', 'e', 'o'], ['h', 'u', '_', 'g', 'd'], ['s', 'c', 'r', 'a', 'f']]\", \"['jama', 'agoho', 'rudge', 'scruf']\"]"}
{"diff_sorted_id": "33", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'D'. Our task is to visit city Q and city G excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from G and Q, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  G P H I J X D V Q L Y \nG 0 0 0 0 0 1 1 0 0 0 1 \nP 0 0 1 1 1 0 0 0 0 0 0 \nH 1 1 0 0 0 1 0 0 1 0 0 \nI 1 0 0 0 0 0 0 0 0 0 0 \nJ 1 0 1 1 0 0 0 0 0 1 0 \nX 0 0 0 0 0 0 0 0 1 0 1 \nD 0 1 0 0 0 1 0 0 0 0 1 \nV 1 0 0 0 0 1 1 0 0 0 1 \nQ 1 0 1 0 1 0 1 0 0 1 0 \nL 0 0 1 0 0 0 0 1 0 0 0 \nY 1 0 0 1 1 1 0 0 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[\"D\", \"P\", \"H\", \"Q\", \"G\", \"X\", \"Q\", \"G\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.026433229446411133", "solution_depth": "8", "max_successor_states": "11", "num_vars_per_state": "14", "is_feasible_args": "[[[0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0]], [\"G\", \"P\", \"H\", \"I\", \"J\", \"X\", \"D\", \"V\", \"Q\", \"L\", \"Y\"], \"Q\", \"G\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0]], [\"G\", \"P\", \"H\", \"I\", \"J\", \"X\", \"D\", \"V\", \"Q\", \"L\", \"Y\"], \"D\", \"Q\", \"G\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0]]\", \"['G', 'P', 'H', 'I', 'J', 'X', 'D', 'V', 'Q', 'L', 'Y']\", \"['D']\", \"['Q', 'G']\"]"}
{"diff_sorted_id": "33", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [9, 11, 7, 9, 12, 19, 29, 21, 11, 10, 26, 22, 18, 29, 19, 11, 18, 23, 26, 16, 18, 4, 22, 25, 17, 18, 12, 23, 3, 17, 17, 15, 22, 25, 27, 2, 26, 22, 21, 28, 10, 23, 15], such that the sum of the chosen coins adds up to 296. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {28: 16, 10: 8, 21: 8, 18: 12, 27: 6, 7: 7, 2: 2, 19: 4, 17: 13, 26: 11, 12: 1, 9: 5, 25: 15, 29: 20, 11: 2, 15: 8, 22: 1, 16: 13, 4: 4, 3: 3, 23: 18}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "26", "opt_solution": "[22, 12, 27, 22, 2, 11, 11, 11, 19, 25, 22, 12, 19, 21, 25, 22, 4, 9]", "opt_solution_cost": "75", "opt_solution_compute_t": "0.041707515716552734", "solution_depth": "18", "max_successor_states": "43", "num_vars_per_state": "43", "is_feasible_args": "[[9, 11, 7, 9, 12, 19, 29, 21, 11, 10, 26, 22, 18, 29, 19, 11, 18, 23, 26, 16, 18, 4, 22, 25, 17, 18, 12, 23, 3, 17, 17, 15, 22, 25, 27, 2, 26, 22, 21, 28, 10, 23, 15]]", "is_correct_args": "[[9, 11, 7, 9, 12, 19, 29, 21, 11, 10, 26, 22, 18, 29, 19, 11, 18, 23, 26, 16, 18, 4, 22, 25, 17, 18, 12, 23, 3, 17, 17, 15, 22, 25, 27, 2, 26, 22, 21, 28, 10, 23, 15], {\"28\": 16, \"10\": 8, \"21\": 8, \"18\": 12, \"27\": 6, \"7\": 7, \"2\": 2, \"19\": 4, \"17\": 13, \"26\": 11, \"12\": 1, \"9\": 5, \"25\": 15, \"29\": 20, \"11\": 2, \"15\": 8, \"22\": 1, \"16\": 13, \"4\": 4, \"3\": 3, \"23\": 18}, 296]", "A*_args": "[\"[9, 11, 7, 9, 12, 19, 29, 21, 11, 10, 26, 22, 18, 29, 19, 11, 18, 23, 26, 16, 18, 4, 22, 25, 17, 18, 12, 23, 3, 17, 17, 15, 22, 25, 27, 2, 26, 22, 21, 28, 10, 23, 15]\", \"{28: 16, 10: 8, 21: 8, 18: 12, 27: 6, 7: 7, 2: 2, 19: 4, 17: 13, 26: 11, 12: 1, 9: 5, 25: 15, 29: 20, 11: 2, 15: 8, 22: 1, 16: 13, 4: 4, 3: 3, 23: 18}\", \"296\"]"}
{"diff_sorted_id": "33", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Green', 'Green', 'Green'], ['Red', 'Red', 'Blue', 'Blue'], ['Red', 'Blue', 'Blue', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[1, 0], [1, 0], [2, 0], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2]]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.04319334030151367", "solution_depth": "8", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Green\", \"Green\", \"Green\"], [\"Red\", \"Red\", \"Blue\", \"Blue\"], [\"Red\", \"Blue\", \"Blue\", \"Red\"]], 7]", "is_correct_args": "[[[\"Green\", \"Green\", \"Green\", \"Green\"], [\"Red\", \"Red\", \"Blue\", \"Blue\"], [\"Red\", \"Blue\", \"Blue\", \"Red\"]], 7]", "A*_args": "[\"[['Green', 'Green', 'Green', 'Green'], ['Red', 'Red', 'Blue', 'Blue'], ['Red', 'Blue', 'Blue', 'Red']]\", \"7\"]"}
{"diff_sorted_id": "33", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 41 to 89 (41 included in the range but 89 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['79' '63' '43']\n ['x' '68' 'x']\n ['x' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[1, 0, 71], [1, 2, 42], [2, 0, 70], [2, 1, 69], [2, 2, 41]]", "opt_solution_cost": "499", "opt_solution_compute_t": "1.6186437606811523", "solution_depth": "5", "max_successor_states": "48", "num_vars_per_state": "9", "is_feasible_args": "[\"[['79', '63', '43'], ['', '68', ''], ['', '', '']]\", 41, 89]", "is_correct_args": "[\"[['79', '63', '43'], ['', '68', ''], ['', '', '']]\", 41, 89]", "A*_args": "[\"[['79', '63', '43'], ['', '68', ''], ['', '', '']]\", \"41\", \"89\"]"}
{"diff_sorted_id": "33", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 31 to 75. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 138, and sum of row 1 must be 171. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 145. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x']\n ['x' 'x' 'x']\n ['x' 'x' '55']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 0, 32], [0, 1, 31], [0, 2, 34], [1, 0, 35], [1, 1, 74], [1, 2, 62], [2, 0, 37], [2, 1, 33]]", "opt_solution_cost": "393", "opt_solution_compute_t": "62.23959302902222", "solution_depth": "8", "max_successor_states": "39", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '', ''], ['', '', '55']]\", 3, 31, 75]", "is_correct_args": "[\"[['', '', ''], ['', '', ''], ['', '', '55']]\", 31, 75, [1, 2], [1, 2], [138], [171], 145]", "A*_args": "[\"[['', '', ''], ['', '', ''], ['', '', '55']]\", \"31\", \"75\", \"[None, 138, None]\", \"[None, 171, None]\", \"145\"]"}
{"diff_sorted_id": "33", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 1, 1: 6, 2: 6, 3: 2, 4: 9, 5: 2, 6: 9, 7: 6}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Black', 'Yellow', 'Green', 'Red', 'Black'], [], ['Red', 'Yellow', 'Green', 'Blue', 'Green'], [], ['Blue', 'Red', 'Blue', 'Green', 'Yellow'], ['Red', 'Blue', 'Yellow', 'Black', 'Black'], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[2, 1], [2, 3], [2, 6], [2, 7], [4, 7], [4, 1], [4, 7], [5, 1], [5, 7], [5, 3], [0, 5], [0, 3], [0, 2], [0, 1], [0, 5], [4, 0], [4, 3], [2, 0], [2, 0], [6, 0]]", "opt_solution_cost": "79", "opt_solution_compute_t": "3.2149300575256348", "solution_depth": "20", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[\"Black\", \"Yellow\", \"Green\", \"Red\", \"Black\"], [], [\"Red\", \"Yellow\", \"Green\", \"Blue\", \"Green\"], [], [\"Blue\", \"Red\", \"Blue\", \"Green\", \"Yellow\"], [\"Red\", \"Blue\", \"Yellow\", \"Black\", \"Black\"], [], []], 5, {\"0\": 1, \"1\": 6, \"2\": 6, \"3\": 2, \"4\": 9, \"5\": 2, \"6\": 9, \"7\": 6}]", "is_correct_args": "[[[\"Black\", \"Yellow\", \"Green\", \"Red\", \"Black\"], [], [\"Red\", \"Yellow\", \"Green\", \"Blue\", \"Green\"], [], [\"Blue\", \"Red\", \"Blue\", \"Green\", \"Yellow\"], [\"Red\", \"Blue\", \"Yellow\", \"Black\", \"Black\"], [], []], 5, {\"0\": 1, \"1\": 6, \"2\": 6, \"3\": 2, \"4\": 9, \"5\": 2, \"6\": 9, \"7\": 6}, 4]", "A*_args": "[\"[['Black', 'Yellow', 'Green', 'Red', 'Black'], [], ['Red', 'Yellow', 'Green', 'Blue', 'Green'], [], ['Blue', 'Red', 'Blue', 'Green', 'Yellow'], ['Red', 'Blue', 'Yellow', 'Black', 'Black'], [], []]\", \"{0: 1, 1: 6, 2: 6, 3: 2, 4: 9, 5: 2, 6: 9, 7: 6}\", \"5\", \"4\"]"}
{"diff_sorted_id": "33", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (2, 10) to his destination workshop at index (5, 2), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 4, and district 3 covering rows 5 to 10. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[16 10 x 16 1 12 6 12 3 7 x]\n[x 16 10 9 12 19 7 10 12 13 7]\n[5 x 9 x 5 16 16 8 x 16 8]\n[x 4 14 x x x x x x 7 18]\n[13 12 16 14 x 2 4 2 x 6 3]\n[x 11 20 x x x 1 x x 9 x]\n[x x 8 10 x x 3 1 x x 6]\n[x 2 9 x 8 13 x x x 12 11]\n[12 x 2 x x 1 6 x 15 x 1]\n[3 x x x 17 x 18 4 1 x x]\n[x x 6 x x 12 x x x 15 12]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "3", "opt_solution": "[[2, 10], [1, 10], [1, 9], [0, 9], [0, 8], [0, 7], [0, 6], [0, 5], [0, 4], [1, 4], [1, 3], [1, 2], [2, 2], [3, 2], [4, 2], [5, 2]]", "opt_solution_cost": "151", "opt_solution_compute_t": "0.028232812881469727", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"16\", \"10\", \"x\", \"16\", \"1\", \"12\", \"6\", \"12\", \"3\", \"7\", \"x\"], [\"x\", \"16\", \"10\", \"9\", \"12\", \"19\", \"7\", \"10\", \"12\", \"13\", \"7\"], [\"5\", \"x\", \"9\", \"x\", \"5\", \"16\", \"16\", \"8\", \"x\", \"16\", \"8\"], [\"x\", \"4\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"7\", \"18\"], [\"13\", \"12\", \"16\", \"14\", \"x\", \"2\", \"4\", \"2\", \"x\", \"6\", \"3\"], [\"x\", \"11\", \"20\", \"x\", \"x\", \"x\", \"1\", \"x\", \"x\", \"9\", \"x\"], [\"x\", \"x\", \"8\", \"10\", \"x\", \"x\", \"3\", \"1\", \"x\", \"x\", \"6\"], [\"x\", \"2\", \"9\", \"x\", \"8\", \"13\", \"x\", \"x\", \"x\", \"12\", \"11\"], [\"12\", \"x\", \"2\", \"x\", \"x\", \"1\", \"6\", \"x\", \"15\", \"x\", \"1\"], [\"3\", \"x\", \"x\", \"x\", \"17\", \"x\", \"18\", \"4\", \"1\", \"x\", \"x\"], [\"x\", \"x\", \"6\", \"x\", \"x\", \"12\", \"x\", \"x\", \"x\", \"15\", \"12\"]]]", "is_correct_args": "[[[\"16\", \"10\", \"x\", \"16\", \"1\", \"12\", \"6\", \"12\", \"3\", \"7\", \"x\"], [\"x\", \"16\", \"10\", \"9\", \"12\", \"19\", \"7\", \"10\", \"12\", \"13\", \"7\"], [\"5\", \"x\", \"9\", \"x\", \"5\", \"16\", \"16\", \"8\", \"x\", \"16\", \"8\"], [\"x\", \"4\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"7\", \"18\"], [\"13\", \"12\", \"16\", \"14\", \"x\", \"2\", \"4\", \"2\", \"x\", \"6\", \"3\"], [\"x\", \"11\", \"20\", \"x\", \"x\", \"x\", \"1\", \"x\", \"x\", \"9\", \"x\"], [\"x\", \"x\", \"8\", \"10\", \"x\", \"x\", \"3\", \"1\", \"x\", \"x\", \"6\"], [\"x\", \"2\", \"9\", \"x\", \"8\", \"13\", \"x\", \"x\", \"x\", \"12\", \"11\"], [\"12\", \"x\", \"2\", \"x\", \"x\", \"1\", \"6\", \"x\", \"15\", \"x\", \"1\"], [\"3\", \"x\", \"x\", \"x\", \"17\", \"x\", \"18\", \"4\", \"1\", \"x\", \"x\"], [\"x\", \"x\", \"6\", \"x\", \"x\", \"12\", \"x\", \"x\", \"x\", \"15\", \"12\"]], [2, 10], [5, 2], 1, 4]", "A*_args": "[\"[['16', '10', 'x', '16', '1', '12', '6', '12', '3', '7', 'x'], ['x', '16', '10', '9', '12', '19', '7', '10', '12', '13', '7'], ['5', 'x', '9', 'x', '5', '16', '16', '8', 'x', '16', '8'], ['x', '4', '14', 'x', 'x', 'x', 'x', 'x', 'x', '7', '18'], ['13', '12', '16', '14', 'x', '2', '4', '2', 'x', '6', '3'], ['x', '11', '20', 'x', 'x', 'x', '1', 'x', 'x', '9', 'x'], ['x', 'x', '8', '10', 'x', 'x', '3', '1', 'x', 'x', '6'], ['x', '2', '9', 'x', '8', '13', 'x', 'x', 'x', '12', '11'], ['12', 'x', '2', 'x', 'x', '1', '6', 'x', '15', 'x', '1'], ['3', 'x', 'x', 'x', '17', 'x', '18', '4', '1', 'x', 'x'], ['x', 'x', '6', 'x', 'x', '12', 'x', 'x', 'x', '15', '12']]\", \"(2, 10)\", \"(5, 2)\", \"1\", \"4\"]"}
{"diff_sorted_id": "33", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 11x11. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (10, 10) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (0, 4). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 1 0 0 0 0 0 0 0 1\n1 1 1 0 0 0 0 0 0 0 0\n0 1 1 0 0 0 0 1 1 0 0\n1 1 0 1 0 0 1 1 0 1 1\n1 1 0 1 0 0 0 1 0 0 0\n1 0 0 0 0 0 0 0 0 1 1\n0 0 1 0 0 1 1 1 0 1 0\n0 1 0 0 1 0 1 1 0 1 1\n1 1 0 0 1 0 1 1 0 0 0\n0 1 0 1 0 1 1 0 0 0 1\n1 1 1 1 0 1 1 1 0 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[[10, 10], [9, 9], [8, 8], [7, 8], [6, 8], [5, 7], [5, 6], [4, 6], [4, 5], [3, 5], [2, 5], [1, 5], [0, 5], [0, 4]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.030236005783081055", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0], [1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1], [1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1], [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0], [0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1], [1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0]]\", 3]", "is_correct_args": "[\"[[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0], [1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1], [1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1], [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0], [0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1], [1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0]]\", [10, 10], [0, 4], 3]", "A*_args": "[\"[[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0], [1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1], [1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1], [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0], [0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1], [1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0]]\", \"(10, 10)\", \"(0, 4)\", \"3\"]"}
{"diff_sorted_id": "33", "problem_statement": "Given 7 labeled water jugs with capacities 146, 57, 69, 52, 132, 80, 145 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 456, 538, 549 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 69, 3], [\"+\", 145, 3], [\"+\", 146, 3], [\"+\", 132, 3], [\"+\", 57, 3], [\"+\", 57, 2], [\"+\", 146, 2], [\"+\", 146, 2], [\"+\", 57, 2], [\"+\", 132, 2], [\"+\", 52, 1], [\"+\", 69, 1], [\"+\", 146, 1], [\"+\", 57, 1], [\"+\", 132, 1]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.0576624870300293", "solution_depth": "15", "max_successor_states": "42", "num_vars_per_state": "3", "is_feasible_args": "[[146, 57, 69, 52, 132, 80, 145], [456, 538, 549]]", "is_correct_args": "[[146, 57, 69, 52, 132, 80, 145], [456, 538, 549]]", "A*_args": "[\"[146, 57, 69, 52, 132, 80, 145]\", \"[456, 538, 549]\"]"}
{"diff_sorted_id": "34", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[61, '_', 99, 70], [42, 81, 90, 16], [41, 54, 28, 45]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[99, 90, 81, 42, 61, 99, 90, 81, 42, 54, 28, 45, 16, 42, 45, 16]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.027817249298095703", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[61, \"_\", 99, 70], [42, 81, 90, 16], [41, 54, 28, 45]]]", "is_correct_args": "[[[61, \"_\", 99, 70], [42, 81, 90, 16], [41, 54, 28, 45]]]", "A*_args": "[\"[[61, '_', 99, 70], [42, 81, 90, 16], [41, 54, 28, 45]]\"]"}
{"diff_sorted_id": "34", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: soft, tunny, apama, forum   The initial board: [['u', 's', 'o', 'f', 't'], ['t', 'a', 'n', 'n', 'y'], ['a', 'p', '_', 'm', 'o'], ['f', 'u', 'r', 'a', 'm']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.2467634677886963", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"u\", \"s\", \"o\", \"f\", \"t\"], [\"t\", \"a\", \"n\", \"n\", \"y\"], [\"a\", \"p\", \"_\", \"m\", \"o\"], [\"f\", \"u\", \"r\", \"a\", \"m\"]]]", "is_correct_args": "[[[\"u\", \"s\", \"o\", \"f\", \"t\"], [\"t\", \"a\", \"n\", \"n\", \"y\"], [\"a\", \"p\", \"_\", \"m\", \"o\"], [\"f\", \"u\", \"r\", \"a\", \"m\"]], [\"soft\", \"tunny\", \"apama\", \"forum\"]]", "A*_args": "[\"[['u', 's', 'o', 'f', 't'], ['t', 'a', 'n', 'n', 'y'], ['a', 'p', '_', 'm', 'o'], ['f', 'u', 'r', 'a', 'm']]\", \"['soft', 'tunny', 'apama', 'forum']\"]"}
{"diff_sorted_id": "34", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'T'. Our task is to visit city N and city W excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from W and N, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  J S T W G N M Z B P U \nJ 0 0 0 0 0 1 0 0 0 0 0 \nS 0 0 0 1 0 0 0 1 0 0 0 \nT 0 0 0 0 0 0 0 0 1 0 0 \nW 1 1 0 0 1 0 0 0 0 1 1 \nG 0 1 0 1 0 0 0 1 0 0 0 \nN 0 0 1 1 1 0 0 0 0 1 1 \nM 0 0 0 1 0 0 0 0 0 0 0 \nZ 0 0 0 0 0 1 0 0 1 0 1 \nB 1 0 0 0 1 0 1 0 0 0 0 \nP 0 0 1 0 0 1 1 0 0 0 0 \nU 1 0 0 0 1 1 0 0 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[\"T\", \"B\", \"J\", \"N\", \"W\", \"P\", \"N\", \"W\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.02652597427368164", "solution_depth": "8", "max_successor_states": "11", "num_vars_per_state": "14", "is_feasible_args": "[[[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0]], [\"J\", \"S\", \"T\", \"W\", \"G\", \"N\", \"M\", \"Z\", \"B\", \"P\", \"U\"], \"N\", \"W\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0]], [\"J\", \"S\", \"T\", \"W\", \"G\", \"N\", \"M\", \"Z\", \"B\", \"P\", \"U\"], \"T\", \"N\", \"W\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1], [0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0]]\", \"['J', 'S', 'T', 'W', 'G', 'N', 'M', 'Z', 'B', 'P', 'U']\", \"['T']\", \"['N', 'W']\"]"}
{"diff_sorted_id": "34", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [22, 14, 13, 18, 2, 5, 14, 26, 28, 9, 20, 26, 11, 29, 2, 15, 13, 11, 28, 12, 14, 6, 3, 25, 12, 24, 4, 28, 27, 10, 20, 6, 8, 7, 37, 18, 3, 10, 27, 20, 21, 8, 11, 13, 5, 19, 4, 2], such that the sum of the chosen coins adds up to 293. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {2: 2, 14: 13, 29: 2, 13: 3, 25: 20, 28: 18, 11: 7, 9: 1, 3: 2, 15: 3, 8: 2, 7: 1, 12: 6, 26: 9, 19: 11, 24: 1, 22: 9, 27: 17, 6: 4, 18: 14, 21: 12, 4: 3, 37: 6, 20: 16, 5: 5, 10: 6}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "27", "opt_solution": "[3, 7, 29, 24, 8, 15, 37, 8, 9, 13, 13, 13, 27, 26, 22, 12, 6, 21]", "opt_solution_cost": "86", "opt_solution_compute_t": "0.05985426902770996", "solution_depth": "18", "max_successor_states": "48", "num_vars_per_state": "48", "is_feasible_args": "[[22, 14, 13, 18, 2, 5, 14, 26, 28, 9, 20, 26, 11, 29, 2, 15, 13, 11, 28, 12, 14, 6, 3, 25, 12, 24, 4, 28, 27, 10, 20, 6, 8, 7, 37, 18, 3, 10, 27, 20, 21, 8, 11, 13, 5, 19, 4, 2]]", "is_correct_args": "[[22, 14, 13, 18, 2, 5, 14, 26, 28, 9, 20, 26, 11, 29, 2, 15, 13, 11, 28, 12, 14, 6, 3, 25, 12, 24, 4, 28, 27, 10, 20, 6, 8, 7, 37, 18, 3, 10, 27, 20, 21, 8, 11, 13, 5, 19, 4, 2], {\"2\": 2, \"14\": 13, \"29\": 2, \"13\": 3, \"25\": 20, \"28\": 18, \"11\": 7, \"9\": 1, \"3\": 2, \"15\": 3, \"8\": 2, \"7\": 1, \"12\": 6, \"26\": 9, \"19\": 11, \"24\": 1, \"22\": 9, \"27\": 17, \"6\": 4, \"18\": 14, \"21\": 12, \"4\": 3, \"37\": 6, \"20\": 16, \"5\": 5, \"10\": 6}, 293]", "A*_args": "[\"[22, 14, 13, 18, 2, 5, 14, 26, 28, 9, 20, 26, 11, 29, 2, 15, 13, 11, 28, 12, 14, 6, 3, 25, 12, 24, 4, 28, 27, 10, 20, 6, 8, 7, 37, 18, 3, 10, 27, 20, 21, 8, 11, 13, 5, 19, 4, 2]\", \"{2: 2, 14: 13, 29: 2, 13: 3, 25: 20, 28: 18, 11: 7, 9: 1, 3: 2, 15: 3, 8: 2, 7: 1, 12: 6, 26: 9, 19: 11, 24: 1, 22: 9, 27: 17, 6: 4, 18: 14, 21: 12, 4: 3, 37: 6, 20: 16, 5: 5, 10: 6}\", \"293\"]"}
{"diff_sorted_id": "34", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Blue', 'Blue'], ['Blue', 'Red', 'Green', 'Red'], ['Green', 'Blue', 'Red', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[1, 2], [0, 1], [0, 1], [2, 0], [2, 1], [2, 0], [2, 0], [1, 2], [1, 2], [1, 0], [1, 0], [1, 2], [0, 1], [0, 1], [0, 1]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.8411509990692139", "solution_depth": "15", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Green\", \"Blue\", \"Blue\"], [\"Blue\", \"Red\", \"Green\", \"Red\"], [\"Green\", \"Blue\", \"Red\", \"Green\"]], 7]", "is_correct_args": "[[[\"Red\", \"Green\", \"Blue\", \"Blue\"], [\"Blue\", \"Red\", \"Green\", \"Red\"], [\"Green\", \"Blue\", \"Red\", \"Green\"]], 7]", "A*_args": "[\"[['Red', 'Green', 'Blue', 'Blue'], ['Blue', 'Red', 'Green', 'Red'], ['Green', 'Blue', 'Red', 'Green']]\", \"7\"]"}
{"diff_sorted_id": "34", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 38 to 86 (38 included in the range but 86 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['38' 'x' '77']\n ['x' 'x' 'x']\n ['x' '52' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 1, 40], [1, 0, 43], [1, 1, 42], [1, 2, 41], [2, 0, 53], [2, 2, 39]]", "opt_solution_cost": "431", "opt_solution_compute_t": "0.6136000156402588", "solution_depth": "6", "max_successor_states": "48", "num_vars_per_state": "9", "is_feasible_args": "[\"[['38', '', '77'], ['', '', ''], ['', '52', '']]\", 38, 86]", "is_correct_args": "[\"[['38', '', '77'], ['', '', ''], ['', '52', '']]\", 38, 86]", "A*_args": "[\"[['38', '', '77'], ['', '', ''], ['', '52', '']]\", \"38\", \"86\"]"}
{"diff_sorted_id": "34", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 40 to 89. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 183, and sum of row 1 must be 194. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 161. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x']\n ['x' 'x' 'x']\n ['40' 'x' '71']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 0, 42], [0, 1, 43], [0, 2, 41], [1, 0, 44], [1, 1, 80], [1, 2, 70], [2, 1, 60]]", "opt_solution_cost": "491", "opt_solution_compute_t": "38.21377420425415", "solution_depth": "7", "max_successor_states": "39", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '', ''], ['40', '', '71']]\", 3, 40, 89]", "is_correct_args": "[\"[['', '', ''], ['', '', ''], ['40', '', '71']]\", 40, 89, [1, 2], [1, 2], [183], [194], 161]", "A*_args": "[\"[['', '', ''], ['', '', ''], ['40', '', '71']]\", \"40\", \"89\", \"[None, 183, None]\", \"[None, 194, None]\", \"161\"]"}
{"diff_sorted_id": "34", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 6, 1: 3, 2: 5, 3: 2, 4: 8, 5: 3, 6: 8, 7: 5}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Yellow', 'Blue', 'Blue', 'Yellow', 'Green'], ['Black', 'Red', 'Black', 'Green', 'Red'], ['Yellow', 'Yellow', 'Red', 'Black', 'Blue'], [], ['Blue', 'Red', 'Green', 'Green', 'Black'], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[5, 7], [1, 0], [1, 7], [1, 7], [1, 0], [2, 4], [5, 6], [3, 0], [3, 0], [3, 6], [5, 1], [5, 1], [3, 5], [3, 7], [2, 3], [2, 5], [2, 1], [4, 5], [2, 3], [6, 3], [6, 3]]", "opt_solution_cost": "94", "opt_solution_compute_t": "0.048551321029663086", "solution_depth": "21", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[], [\"Yellow\", \"Blue\", \"Blue\", \"Yellow\", \"Green\"], [\"Black\", \"Red\", \"Black\", \"Green\", \"Red\"], [\"Yellow\", \"Yellow\", \"Red\", \"Black\", \"Blue\"], [], [\"Blue\", \"Red\", \"Green\", \"Green\", \"Black\"], [], []], 5, {\"0\": 6, \"1\": 3, \"2\": 5, \"3\": 2, \"4\": 8, \"5\": 3, \"6\": 8, \"7\": 5}]", "is_correct_args": "[[[], [\"Yellow\", \"Blue\", \"Blue\", \"Yellow\", \"Green\"], [\"Black\", \"Red\", \"Black\", \"Green\", \"Red\"], [\"Yellow\", \"Yellow\", \"Red\", \"Black\", \"Blue\"], [], [\"Blue\", \"Red\", \"Green\", \"Green\", \"Black\"], [], []], 5, {\"0\": 6, \"1\": 3, \"2\": 5, \"3\": 2, \"4\": 8, \"5\": 3, \"6\": 8, \"7\": 5}, 4]", "A*_args": "[\"[[], ['Yellow', 'Blue', 'Blue', 'Yellow', 'Green'], ['Black', 'Red', 'Black', 'Green', 'Red'], ['Yellow', 'Yellow', 'Red', 'Black', 'Blue'], [], ['Blue', 'Red', 'Green', 'Green', 'Black'], [], []]\", \"{0: 6, 1: 3, 2: 5, 3: 2, 4: 8, 5: 3, 6: 8, 7: 5}\", \"5\", \"4\"]"}
{"diff_sorted_id": "34", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (7, 0) to his destination workshop at index (2, 9), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 6, and district 3 covering rows 7 to 10. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[12 11 14 10 2 11 13 16 3 x 12]\n[10 9 x 8 x x 1 16 11 x 15]\n[1 18 1 x x x x x 12 9 x]\n[1 14 15 10 7 15 17 10 15 15 6]\n[18 11 x x x 15 x x 1 1 x]\n[14 x x x 18 14 16 7 x 1 x]\n[11 15 x x 15 3 11 13 x x x]\n[5 x x x x x 15 x 6 x x]\n[12 11 7 2 11 x 10 2 17 x x]\n[7 x x x 4 x 4 x x 5 x]\n[x 19 10 7 x 2 3 9 2 6 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "3", "opt_solution": "[[7, 0], [6, 0], [5, 0], [4, 0], [3, 0], [3, 1], [3, 2], [3, 3], [3, 4], [3, 5], [3, 6], [3, 7], [3, 8], [2, 8], [2, 9]]", "opt_solution_cost": "168", "opt_solution_compute_t": "0.027637958526611328", "solution_depth": "15", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"12\", \"11\", \"14\", \"10\", \"2\", \"11\", \"13\", \"16\", \"3\", \"x\", \"12\"], [\"10\", \"9\", \"x\", \"8\", \"x\", \"x\", \"1\", \"16\", \"11\", \"x\", \"15\"], [\"1\", \"18\", \"1\", \"x\", \"x\", \"x\", \"x\", \"x\", \"12\", \"9\", \"x\"], [\"1\", \"14\", \"15\", \"10\", \"7\", \"15\", \"17\", \"10\", \"15\", \"15\", \"6\"], [\"18\", \"11\", \"x\", \"x\", \"x\", \"15\", \"x\", \"x\", \"1\", \"1\", \"x\"], [\"14\", \"x\", \"x\", \"x\", \"18\", \"14\", \"16\", \"7\", \"x\", \"1\", \"x\"], [\"11\", \"15\", \"x\", \"x\", \"15\", \"3\", \"11\", \"13\", \"x\", \"x\", \"x\"], [\"5\", \"x\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\", \"6\", \"x\", \"x\"], [\"12\", \"11\", \"7\", \"2\", \"11\", \"x\", \"10\", \"2\", \"17\", \"x\", \"x\"], [\"7\", \"x\", \"x\", \"x\", \"4\", \"x\", \"4\", \"x\", \"x\", \"5\", \"x\"], [\"x\", \"19\", \"10\", \"7\", \"x\", \"2\", \"3\", \"9\", \"2\", \"6\", \"x\"]]]", "is_correct_args": "[[[\"12\", \"11\", \"14\", \"10\", \"2\", \"11\", \"13\", \"16\", \"3\", \"x\", \"12\"], [\"10\", \"9\", \"x\", \"8\", \"x\", \"x\", \"1\", \"16\", \"11\", \"x\", \"15\"], [\"1\", \"18\", \"1\", \"x\", \"x\", \"x\", \"x\", \"x\", \"12\", \"9\", \"x\"], [\"1\", \"14\", \"15\", \"10\", \"7\", \"15\", \"17\", \"10\", \"15\", \"15\", \"6\"], [\"18\", \"11\", \"x\", \"x\", \"x\", \"15\", \"x\", \"x\", \"1\", \"1\", \"x\"], [\"14\", \"x\", \"x\", \"x\", \"18\", \"14\", \"16\", \"7\", \"x\", \"1\", \"x\"], [\"11\", \"15\", \"x\", \"x\", \"15\", \"3\", \"11\", \"13\", \"x\", \"x\", \"x\"], [\"5\", \"x\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\", \"6\", \"x\", \"x\"], [\"12\", \"11\", \"7\", \"2\", \"11\", \"x\", \"10\", \"2\", \"17\", \"x\", \"x\"], [\"7\", \"x\", \"x\", \"x\", \"4\", \"x\", \"4\", \"x\", \"x\", \"5\", \"x\"], [\"x\", \"19\", \"10\", \"7\", \"x\", \"2\", \"3\", \"9\", \"2\", \"6\", \"x\"]], [7, 0], [2, 9], 2, 6]", "A*_args": "[\"[['12', '11', '14', '10', '2', '11', '13', '16', '3', 'x', '12'], ['10', '9', 'x', '8', 'x', 'x', '1', '16', '11', 'x', '15'], ['1', '18', '1', 'x', 'x', 'x', 'x', 'x', '12', '9', 'x'], ['1', '14', '15', '10', '7', '15', '17', '10', '15', '15', '6'], ['18', '11', 'x', 'x', 'x', '15', 'x', 'x', '1', '1', 'x'], ['14', 'x', 'x', 'x', '18', '14', '16', '7', 'x', '1', 'x'], ['11', '15', 'x', 'x', '15', '3', '11', '13', 'x', 'x', 'x'], ['5', 'x', 'x', 'x', 'x', 'x', '15', 'x', '6', 'x', 'x'], ['12', '11', '7', '2', '11', 'x', '10', '2', '17', 'x', 'x'], ['7', 'x', 'x', 'x', '4', 'x', '4', 'x', 'x', '5', 'x'], ['x', '19', '10', '7', 'x', '2', '3', '9', '2', '6', 'x']]\", \"(7, 0)\", \"(2, 9)\", \"2\", \"6\"]"}
{"diff_sorted_id": "34", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 11x11. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (10, 10) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (5, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 1 0 0 0 1 1 0 1 1\n0 0 0 0 0 1 1 1 0 0 0\n1 1 0 0 1 1 1 1 0 0 1\n0 1 0 1 1 0 1 0 0 0 1\n1 0 1 0 1 0 0 0 0 0 0\n0 0 1 0 1 1 0 1 1 1 0\n0 1 1 1 0 1 0 0 0 1 1\n0 0 1 1 1 1 0 1 0 1 0\n0 0 1 0 1 0 1 1 0 0 1\n0 0 0 0 1 0 0 1 0 1 0\n1 1 0 0 0 0 0 0 0 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[[10, 10], [10, 9], [10, 8], [10, 7], [10, 6], [10, 5], [10, 4], [9, 3], [9, 2], [8, 1], [7, 0], [6, 0], [5, 0]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.03441643714904785", "solution_depth": "13", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1], [0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1], [0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\", 3]", "is_correct_args": "[\"[[0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1], [0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1], [0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\", [10, 10], [5, 0], 3]", "A*_args": "[\"[[0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1], [0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1], [0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\", \"(10, 10)\", \"(5, 0)\", \"3\"]"}
{"diff_sorted_id": "34", "problem_statement": "Given 7 labeled water jugs with capacities 103, 109, 146, 101, 17, 145, 68 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 448, 466, 509 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 109, 3], [\"+\", 145, 3], [\"+\", 146, 3], [\"+\", 109, 3], [\"+\", 103, 2], [\"+\", 109, 2], [\"+\", 109, 2], [\"+\", 145, 2], [\"+\", 101, 1], [\"+\", 101, 1], [\"+\", 101, 1], [\"+\", 145, 1]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.05138897895812988", "solution_depth": "12", "max_successor_states": "42", "num_vars_per_state": "3", "is_feasible_args": "[[103, 109, 146, 101, 17, 145, 68], [448, 466, 509]]", "is_correct_args": "[[103, 109, 146, 101, 17, 145, 68], [448, 466, 509]]", "A*_args": "[\"[103, 109, 146, 101, 17, 145, 68]\", \"[448, 466, 509]\"]"}
{"diff_sorted_id": "35", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[95, '_', 80, 18], [67, 66, 35, 94], [27, 26, 69, 53]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[66, 35, 94, 18, 80, 94, 69, 53, 18, 69, 35, 66, 94, 80, 69, 35, 53, 18]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.03965592384338379", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[95, \"_\", 80, 18], [67, 66, 35, 94], [27, 26, 69, 53]]]", "is_correct_args": "[[[95, \"_\", 80, 18], [67, 66, 35, 94], [27, 26, 69, 53]]]", "A*_args": "[\"[[95, '_', 80, 18], [67, 66, 35, 94], [27, 26, 69, 53]]\"]"}
{"diff_sorted_id": "35", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: supe, cadus, nucal, rouse   The initial board: [['a', 's', '_', 'p', 'e'], ['c', 'u', 'd', 'o', 's'], ['l', 'u', 'u', 'a', 's'], ['r', 'c', 'u', 'n', 'e']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-right\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.3029823303222656", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"a\", \"s\", \"_\", \"p\", \"e\"], [\"c\", \"u\", \"d\", \"o\", \"s\"], [\"l\", \"u\", \"u\", \"a\", \"s\"], [\"r\", \"c\", \"u\", \"n\", \"e\"]]]", "is_correct_args": "[[[\"a\", \"s\", \"_\", \"p\", \"e\"], [\"c\", \"u\", \"d\", \"o\", \"s\"], [\"l\", \"u\", \"u\", \"a\", \"s\"], [\"r\", \"c\", \"u\", \"n\", \"e\"]], [\"supe\", \"cadus\", \"nucal\", \"rouse\"]]", "A*_args": "[\"[['a', 's', '_', 'p', 'e'], ['c', 'u', 'd', 'o', 's'], ['l', 'u', 'u', 'a', 's'], ['r', 'c', 'u', 'n', 'e']]\", \"['supe', 'cadus', 'nucal', 'rouse']\"]"}
{"diff_sorted_id": "35", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'G'. Our task is to visit city L and city P excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from P and L, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  A V N Q P S M E L H W G \nA 0 1 0 0 0 1 1 0 0 0 1 0 \nV 0 0 1 0 0 0 0 0 0 1 0 0 \nN 0 0 0 0 1 0 0 1 1 0 0 0 \nQ 1 1 0 0 1 0 0 0 1 0 0 0 \nP 0 1 0 0 0 0 0 1 0 1 0 0 \nS 0 0 0 1 1 0 0 0 0 0 0 0 \nM 0 1 1 0 1 1 0 1 0 1 1 0 \nE 0 0 0 1 1 0 0 0 0 0 0 0 \nL 0 1 0 0 0 0 0 1 0 1 1 1 \nH 0 0 0 0 0 1 0 0 1 0 0 0 \nW 1 1 1 0 1 1 0 1 0 0 0 0 \nG 1 1 0 0 0 0 0 0 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[\"G\", \"V\", \"N\", \"L\", \"W\", \"P\", \"E\", \"P\", \"H\", \"L\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.03540349006652832", "solution_depth": "10", "max_successor_states": "12", "num_vars_per_state": "15", "is_feasible_args": "[[[0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [\"A\", \"V\", \"N\", \"Q\", \"P\", \"S\", \"M\", \"E\", \"L\", \"H\", \"W\", \"G\"], \"L\", \"P\"]", "is_correct_args": "[[[0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], [\"A\", \"V\", \"N\", \"Q\", \"P\", \"S\", \"M\", \"E\", \"L\", \"H\", \"W\", \"G\"], \"G\", \"L\", \"P\"]", "A*_args": "[\"[[0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\", \"['A', 'V', 'N', 'Q', 'P', 'S', 'M', 'E', 'L', 'H', 'W', 'G']\", \"['G']\", \"['L', 'P']\"]"}
{"diff_sorted_id": "35", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [27, 17, 6, 5, 20, 3, 4, 29, 25, 27, 20, 18, 18, 25, 2, 13, 15, 4, 12, 4, 26, 12, 26, 24, 17, 23, 2, 6, 2, 29, 3, 20, 12, 7, 9, 12, 26, 11, 2, 5, 10, 25, 3, 13, 7, 25], such that the sum of the chosen coins adds up to 295. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {2: 1, 13: 11, 26: 13, 5: 1, 4: 2, 9: 8, 15: 8, 18: 6, 20: 18, 3: 1, 17: 17, 6: 2, 10: 10, 12: 1, 23: 10, 7: 6, 29: 13, 25: 15, 11: 10, 27: 2, 24: 18}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "28", "opt_solution": "[12, 27, 12, 2, 5, 27, 12, 2, 3, 3, 5, 2, 23, 18, 12, 6, 29, 18, 6, 4, 2, 3, 29, 4, 25, 4]", "opt_solution_cost": "90", "opt_solution_compute_t": "0.049031734466552734", "solution_depth": "26", "max_successor_states": "46", "num_vars_per_state": "46", "is_feasible_args": "[[27, 17, 6, 5, 20, 3, 4, 29, 25, 27, 20, 18, 18, 25, 2, 13, 15, 4, 12, 4, 26, 12, 26, 24, 17, 23, 2, 6, 2, 29, 3, 20, 12, 7, 9, 12, 26, 11, 2, 5, 10, 25, 3, 13, 7, 25]]", "is_correct_args": "[[27, 17, 6, 5, 20, 3, 4, 29, 25, 27, 20, 18, 18, 25, 2, 13, 15, 4, 12, 4, 26, 12, 26, 24, 17, 23, 2, 6, 2, 29, 3, 20, 12, 7, 9, 12, 26, 11, 2, 5, 10, 25, 3, 13, 7, 25], {\"2\": 1, \"13\": 11, \"26\": 13, \"5\": 1, \"4\": 2, \"9\": 8, \"15\": 8, \"18\": 6, \"20\": 18, \"3\": 1, \"17\": 17, \"6\": 2, \"10\": 10, \"12\": 1, \"23\": 10, \"7\": 6, \"29\": 13, \"25\": 15, \"11\": 10, \"27\": 2, \"24\": 18}, 295]", "A*_args": "[\"[27, 17, 6, 5, 20, 3, 4, 29, 25, 27, 20, 18, 18, 25, 2, 13, 15, 4, 12, 4, 26, 12, 26, 24, 17, 23, 2, 6, 2, 29, 3, 20, 12, 7, 9, 12, 26, 11, 2, 5, 10, 25, 3, 13, 7, 25]\", \"{2: 1, 13: 11, 26: 13, 5: 1, 4: 2, 9: 8, 15: 8, 18: 6, 20: 18, 3: 1, 17: 17, 6: 2, 10: 10, 12: 1, 23: 10, 7: 6, 29: 13, 25: 15, 11: 10, 27: 2, 24: 18}\", \"295\"]"}
{"diff_sorted_id": "35", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Blue', 'Blue', 'Red'], ['Blue', 'Green', 'Blue', 'Green'], ['Green', 'Red', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[1, 0], [1, 2], [1, 0], [2, 1], [2, 1], [2, 0], [2, 1], [0, 1], [2, 1], [0, 2], [0, 2], [0, 1], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0]]", "opt_solution_cost": "17", "opt_solution_compute_t": "1.9828546047210693", "solution_depth": "17", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Red\"], [\"Blue\", \"Green\", \"Blue\", \"Green\"], [\"Green\", \"Red\", \"Green\", \"Red\"]], 7]", "is_correct_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Red\"], [\"Blue\", \"Green\", \"Blue\", \"Green\"], [\"Green\", \"Red\", \"Green\", \"Red\"]], 7]", "A*_args": "[\"[['Red', 'Blue', 'Blue', 'Red'], ['Blue', 'Green', 'Blue', 'Green'], ['Green', 'Red', 'Green', 'Red']]\", \"7\"]"}
{"diff_sorted_id": "35", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 40 to 88 (40 included in the range but 88 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' 'x']\n ['x' '61' '62']\n ['x' 'x' '63']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 0, 40], [0, 1, 41], [0, 2, 42], [1, 0, 43], [2, 0, 65], [2, 1, 64]]", "opt_solution_cost": "454", "opt_solution_compute_t": "0.1776282787322998", "solution_depth": "6", "max_successor_states": "48", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '61', '62'], ['', '', '63']]\", 40, 88]", "is_correct_args": "[\"[['', '', ''], ['', '61', '62'], ['', '', '63']]\", 40, 88]", "A*_args": "[\"[['', '', ''], ['', '61', '62'], ['', '', '63']]\", \"40\", \"88\"]"}
{"diff_sorted_id": "35", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 40 to 89. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 153, and sum of row 1 must be 186. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 188. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x']\n ['80' '48' 'x']\n ['x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 0, 40], [0, 1, 42], [0, 2, 52], [1, 2, 58], [2, 0, 88], [2, 1, 63], [2, 2, 41]]", "opt_solution_cost": "512", "opt_solution_compute_t": "25.803895473480225", "solution_depth": "7", "max_successor_states": "39", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['80', '48', ''], ['', '', '']]\", 3, 40, 89]", "is_correct_args": "[\"[['', '', ''], ['80', '48', ''], ['', '', '']]\", 40, 89, [1, 2], [1, 2], [153], [186], 188]", "A*_args": "[\"[['', '', ''], ['80', '48', ''], ['', '', '']]\", \"40\", \"89\", \"[None, 153, None]\", \"[None, 186, None]\", \"188\"]"}
{"diff_sorted_id": "35", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 2, 1: 4, 2: 5, 3: 2, 4: 2, 5: 3, 6: 2, 7: 5}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Green', 'Blue', 'Yellow', 'Black', 'Blue'], [], [], ['Blue', 'Black', 'Green', 'Yellow', 'Red'], [], ['Green', 'Red', 'Black', 'Yellow', 'Blue'], ['Red', 'Green', 'Red', 'Black', 'Yellow']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[1, 0], [4, 3], [6, 0], [4, 5], [4, 0], [4, 2], [6, 4], [6, 5], [7, 4], [7, 0], [7, 4], [7, 5], [6, 2], [1, 3], [1, 2], [1, 5], [7, 2], [1, 3], [6, 3]]", "opt_solution_cost": "54", "opt_solution_compute_t": "0.07124614715576172", "solution_depth": "19", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[], [\"Green\", \"Blue\", \"Yellow\", \"Black\", \"Blue\"], [], [], [\"Blue\", \"Black\", \"Green\", \"Yellow\", \"Red\"], [], [\"Green\", \"Red\", \"Black\", \"Yellow\", \"Blue\"], [\"Red\", \"Green\", \"Red\", \"Black\", \"Yellow\"]], 5, {\"0\": 2, \"1\": 4, \"2\": 5, \"3\": 2, \"4\": 2, \"5\": 3, \"6\": 2, \"7\": 5}]", "is_correct_args": "[[[], [\"Green\", \"Blue\", \"Yellow\", \"Black\", \"Blue\"], [], [], [\"Blue\", \"Black\", \"Green\", \"Yellow\", \"Red\"], [], [\"Green\", \"Red\", \"Black\", \"Yellow\", \"Blue\"], [\"Red\", \"Green\", \"Red\", \"Black\", \"Yellow\"]], 5, {\"0\": 2, \"1\": 4, \"2\": 5, \"3\": 2, \"4\": 2, \"5\": 3, \"6\": 2, \"7\": 5}, 4]", "A*_args": "[\"[[], ['Green', 'Blue', 'Yellow', 'Black', 'Blue'], [], [], ['Blue', 'Black', 'Green', 'Yellow', 'Red'], [], ['Green', 'Red', 'Black', 'Yellow', 'Blue'], ['Red', 'Green', 'Red', 'Black', 'Yellow']]\", \"{0: 2, 1: 4, 2: 5, 3: 2, 4: 2, 5: 3, 6: 2, 7: 5}\", \"5\", \"4\"]"}
{"diff_sorted_id": "35", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (7, 8) to his destination workshop at index (2, 1), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 7, and district 3 covering rows 8 to 10. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 18 x 5 x 6 5 x 6 17 x]\n[x x 1 5 9 13 x 2 x x 2]\n[x 17 12 x x x 5 x x 17 x]\n[9 3 13 8 x 7 x x 4 2 x]\n[11 17 x 10 x x x x 17 15 11]\n[x 10 10 14 9 7 1 5 x x 7]\n[x 5 6 12 8 9 4 x x 4 9]\n[11 x 4 13 14 x 12 17 13 x x]\n[x 8 x 19 11 7 7 19 15 14 7]\n[11 8 x 11 10 16 x x 9 x 5]\n[9 4 x x 1 11 14 x x x 10]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "3", "opt_solution": "[[7, 8], [7, 7], [7, 6], [8, 6], [7, 6], [6, 6], [5, 6], [5, 5], [5, 4], [5, 3], [4, 3], [3, 3], [3, 2], [3, 1], [2, 1]]", "opt_solution_cost": "134", "opt_solution_compute_t": "0.027469635009765625", "solution_depth": "15", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"18\", \"x\", \"5\", \"x\", \"6\", \"5\", \"x\", \"6\", \"17\", \"x\"], [\"x\", \"x\", \"1\", \"5\", \"9\", \"13\", \"x\", \"2\", \"x\", \"x\", \"2\"], [\"x\", \"17\", \"12\", \"x\", \"x\", \"x\", \"5\", \"x\", \"x\", \"17\", \"x\"], [\"9\", \"3\", \"13\", \"8\", \"x\", \"7\", \"x\", \"x\", \"4\", \"2\", \"x\"], [\"11\", \"17\", \"x\", \"10\", \"x\", \"x\", \"x\", \"x\", \"17\", \"15\", \"11\"], [\"x\", \"10\", \"10\", \"14\", \"9\", \"7\", \"1\", \"5\", \"x\", \"x\", \"7\"], [\"x\", \"5\", \"6\", \"12\", \"8\", \"9\", \"4\", \"x\", \"x\", \"4\", \"9\"], [\"11\", \"x\", \"4\", \"13\", \"14\", \"x\", \"12\", \"17\", \"13\", \"x\", \"x\"], [\"x\", \"8\", \"x\", \"19\", \"11\", \"7\", \"7\", \"19\", \"15\", \"14\", \"7\"], [\"11\", \"8\", \"x\", \"11\", \"10\", \"16\", \"x\", \"x\", \"9\", \"x\", \"5\"], [\"9\", \"4\", \"x\", \"x\", \"1\", \"11\", \"14\", \"x\", \"x\", \"x\", \"10\"]]]", "is_correct_args": "[[[\"x\", \"18\", \"x\", \"5\", \"x\", \"6\", \"5\", \"x\", \"6\", \"17\", \"x\"], [\"x\", \"x\", \"1\", \"5\", \"9\", \"13\", \"x\", \"2\", \"x\", \"x\", \"2\"], [\"x\", \"17\", \"12\", \"x\", \"x\", \"x\", \"5\", \"x\", \"x\", \"17\", \"x\"], [\"9\", \"3\", \"13\", \"8\", \"x\", \"7\", \"x\", \"x\", \"4\", \"2\", \"x\"], [\"11\", \"17\", \"x\", \"10\", \"x\", \"x\", \"x\", \"x\", \"17\", \"15\", \"11\"], [\"x\", \"10\", \"10\", \"14\", \"9\", \"7\", \"1\", \"5\", \"x\", \"x\", \"7\"], [\"x\", \"5\", \"6\", \"12\", \"8\", \"9\", \"4\", \"x\", \"x\", \"4\", \"9\"], [\"11\", \"x\", \"4\", \"13\", \"14\", \"x\", \"12\", \"17\", \"13\", \"x\", \"x\"], [\"x\", \"8\", \"x\", \"19\", \"11\", \"7\", \"7\", \"19\", \"15\", \"14\", \"7\"], [\"11\", \"8\", \"x\", \"11\", \"10\", \"16\", \"x\", \"x\", \"9\", \"x\", \"5\"], [\"9\", \"4\", \"x\", \"x\", \"1\", \"11\", \"14\", \"x\", \"x\", \"x\", \"10\"]], [7, 8], [2, 1], 2, 7]", "A*_args": "[\"[['x', '18', 'x', '5', 'x', '6', '5', 'x', '6', '17', 'x'], ['x', 'x', '1', '5', '9', '13', 'x', '2', 'x', 'x', '2'], ['x', '17', '12', 'x', 'x', 'x', '5', 'x', 'x', '17', 'x'], ['9', '3', '13', '8', 'x', '7', 'x', 'x', '4', '2', 'x'], ['11', '17', 'x', '10', 'x', 'x', 'x', 'x', '17', '15', '11'], ['x', '10', '10', '14', '9', '7', '1', '5', 'x', 'x', '7'], ['x', '5', '6', '12', '8', '9', '4', 'x', 'x', '4', '9'], ['11', 'x', '4', '13', '14', 'x', '12', '17', '13', 'x', 'x'], ['x', '8', 'x', '19', '11', '7', '7', '19', '15', '14', '7'], ['11', '8', 'x', '11', '10', '16', 'x', 'x', '9', 'x', '5'], ['9', '4', 'x', 'x', '1', '11', '14', 'x', 'x', 'x', '10']]\", \"(7, 8)\", \"(2, 1)\", \"2\", \"7\"]"}
{"diff_sorted_id": "35", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 11x11. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 9) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (8, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 0 0 0 1 0 1 0 1 1\n1 0 0 0 1 0 1 1 0 0 1\n0 0 1 1 1 1 0 0 0 0 1\n1 0 1 1 0 1 0 1 0 0 0\n1 0 1 1 1 0 0 0 1 1 0\n1 1 1 1 0 0 1 1 1 1 1\n1 0 0 0 1 0 0 1 1 1 1\n0 0 0 0 0 0 1 1 1 1 1\n0 0 0 0 1 0 0 0 1 1 1\n1 0 1 0 1 0 0 1 0 1 1\n1 1 1 0 0 1 1 1 0 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[[1, 9], [1, 8], [2, 7], [2, 6], [3, 6], [4, 5], [5, 5], [5, 4], [6, 3], [6, 2], [6, 1], [7, 1], [7, 0], [8, 0]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.02565455436706543", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1], [1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1], [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0], [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1], [1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1], [1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1], [1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1]]\", 3]", "is_correct_args": "[\"[[1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1], [1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1], [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0], [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1], [1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1], [1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1], [1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1]]\", [1, 9], [8, 0], 3]", "A*_args": "[\"[[1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1], [1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1], [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0], [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1], [1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1], [1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1], [1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1]]\", \"(1, 9)\", \"(8, 0)\", \"3\"]"}
{"diff_sorted_id": "35", "problem_statement": "Given 7 labeled water jugs with capacities 120, 95, 49, 150, 83, 97, 44, 43 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 225, 334, 381 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 97, 3], [\"+\", 120, 3], [\"+\", 120, 3], [\"+\", 44, 3], [\"+\", 150, 2], [\"+\", 150, 2], [\"-\", 49, 2], [\"+\", 83, 2], [\"+\", 43, 1], [\"+\", 43, 1], [\"+\", 44, 1], [\"+\", 95, 1]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.03785276412963867", "solution_depth": "12", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[120, 95, 49, 150, 83, 97, 44, 43], [225, 334, 381]]", "is_correct_args": "[[120, 95, 49, 150, 83, 97, 44, 43], [225, 334, 381]]", "A*_args": "[\"[120, 95, 49, 150, 83, 97, 44, 43]\", \"[225, 334, 381]\"]"}
{"diff_sorted_id": "36", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[67, 86, 68, 29], [10, 95, '_', 44], [19, 80, 6, 50]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[44, 29, 68, 86, 95, 80, 6, 50, 29, 44, 80, 10, 67, 95, 86, 80, 50, 6, 10, 50, 44, 29]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.07417702674865723", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[67, 86, 68, 29], [10, 95, \"_\", 44], [19, 80, 6, 50]]]", "is_correct_args": "[[[67, 86, 68, 29], [10, 95, \"_\", 44], [19, 80, 6, 50]]]", "A*_args": "[\"[[67, 86, 68, 29], [10, 95, '_', 44], [19, 80, 6, 50]]\"]"}
{"diff_sorted_id": "36", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: bath, khila, ascon, coast   The initial board: [['h', 'b', 'c', 't', 'h'], ['k', 'n', 'i', 'o', 'a'], ['a', 's', '_', 'o', 'a'], ['c', 'l', 'a', 's', 't']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"up-right\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "26", "opt_solution_compute_t": "0.8642349243164062", "solution_depth": "26", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"h\", \"b\", \"c\", \"t\", \"h\"], [\"k\", \"n\", \"i\", \"o\", \"a\"], [\"a\", \"s\", \"_\", \"o\", \"a\"], [\"c\", \"l\", \"a\", \"s\", \"t\"]]]", "is_correct_args": "[[[\"h\", \"b\", \"c\", \"t\", \"h\"], [\"k\", \"n\", \"i\", \"o\", \"a\"], [\"a\", \"s\", \"_\", \"o\", \"a\"], [\"c\", \"l\", \"a\", \"s\", \"t\"]], [\"bath\", \"khila\", \"ascon\", \"coast\"]]", "A*_args": "[\"[['h', 'b', 'c', 't', 'h'], ['k', 'n', 'i', 'o', 'a'], ['a', 's', '_', 'o', 'a'], ['c', 'l', 'a', 's', 't']]\", \"['bath', 'khila', 'ascon', 'coast']\"]"}
{"diff_sorted_id": "36", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'G'. Our task is to visit city O and city R excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from R and O, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  F I C G N L X Q U R O B \nF 0 0 0 0 0 0 0 0 1 1 0 0 \nI 0 0 1 0 0 1 1 0 1 0 1 0 \nC 0 0 0 1 0 1 0 1 0 0 1 1 \nG 1 1 0 0 0 1 0 0 0 0 0 0 \nN 1 0 0 0 0 0 0 0 0 1 0 0 \nL 1 0 0 0 0 0 1 1 0 0 0 0 \nX 0 0 1 1 1 0 0 0 0 1 0 0 \nQ 0 0 0 1 1 0 0 0 0 1 0 0 \nU 0 0 0 1 0 0 1 1 0 0 1 0 \nR 0 1 1 0 0 1 0 0 1 0 0 1 \nO 0 0 0 0 1 1 1 1 0 1 0 0 \nB 0 0 1 0 0 0 0 1 1 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[\"G\", \"I\", \"O\", \"R\", \"C\", \"O\", \"R\"]", "opt_solution_cost": "7", "opt_solution_compute_t": "0.022314071655273438", "solution_depth": "7", "max_successor_states": "12", "num_vars_per_state": "15", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0], [0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0]], [\"F\", \"I\", \"C\", \"G\", \"N\", \"L\", \"X\", \"Q\", \"U\", \"R\", \"O\", \"B\"], \"O\", \"R\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0], [0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0]], [\"F\", \"I\", \"C\", \"G\", \"N\", \"L\", \"X\", \"Q\", \"U\", \"R\", \"O\", \"B\"], \"G\", \"O\", \"R\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0], [0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0]]\", \"['F', 'I', 'C', 'G', 'N', 'L', 'X', 'Q', 'U', 'R', 'O', 'B']\", \"['G']\", \"['O', 'R']\"]"}
{"diff_sorted_id": "36", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [26, 7, 24, 27, 19, 15, 12, 13, 19, 5, 17, 26, 20, 7, 3, 21, 22, 7, 17, 13, 28, 11, 19, 18, 9, 10, 25, 2, 4, 18, 14, 17, 22, 27, 14, 7, 9, 2, 11, 8, 14, 10, 18, 1, 4, 24, 2, 24, 11, 14, 27], such that the sum of the chosen coins adds up to 281. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {13: 8, 27: 5, 21: 13, 25: 11, 22: 6, 20: 14, 12: 1, 14: 12, 2: 2, 8: 5, 3: 2, 18: 4, 1: 1, 9: 9, 10: 1, 19: 10, 11: 5, 28: 10, 5: 3, 26: 7, 7: 1, 24: 9, 4: 3, 15: 2, 17: 13}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "29", "opt_solution": "[7, 7, 7, 15, 10, 27, 10, 27, 18, 27, 22, 18, 12, 25, 22, 18, 2, 7]", "opt_solution_cost": "61", "opt_solution_compute_t": "0.04955577850341797", "solution_depth": "18", "max_successor_states": "51", "num_vars_per_state": "51", "is_feasible_args": "[[26, 7, 24, 27, 19, 15, 12, 13, 19, 5, 17, 26, 20, 7, 3, 21, 22, 7, 17, 13, 28, 11, 19, 18, 9, 10, 25, 2, 4, 18, 14, 17, 22, 27, 14, 7, 9, 2, 11, 8, 14, 10, 18, 1, 4, 24, 2, 24, 11, 14, 27]]", "is_correct_args": "[[26, 7, 24, 27, 19, 15, 12, 13, 19, 5, 17, 26, 20, 7, 3, 21, 22, 7, 17, 13, 28, 11, 19, 18, 9, 10, 25, 2, 4, 18, 14, 17, 22, 27, 14, 7, 9, 2, 11, 8, 14, 10, 18, 1, 4, 24, 2, 24, 11, 14, 27], {\"13\": 8, \"27\": 5, \"21\": 13, \"25\": 11, \"22\": 6, \"20\": 14, \"12\": 1, \"14\": 12, \"2\": 2, \"8\": 5, \"3\": 2, \"18\": 4, \"1\": 1, \"9\": 9, \"10\": 1, \"19\": 10, \"11\": 5, \"28\": 10, \"5\": 3, \"26\": 7, \"7\": 1, \"24\": 9, \"4\": 3, \"15\": 2, \"17\": 13}, 281]", "A*_args": "[\"[26, 7, 24, 27, 19, 15, 12, 13, 19, 5, 17, 26, 20, 7, 3, 21, 22, 7, 17, 13, 28, 11, 19, 18, 9, 10, 25, 2, 4, 18, 14, 17, 22, 27, 14, 7, 9, 2, 11, 8, 14, 10, 18, 1, 4, 24, 2, 24, 11, 14, 27]\", \"{13: 8, 27: 5, 21: 13, 25: 11, 22: 6, 20: 14, 12: 1, 14: 12, 2: 2, 8: 5, 3: 2, 18: 4, 1: 1, 9: 9, 10: 1, 19: 10, 11: 5, 28: 10, 5: 3, 26: 7, 7: 1, 24: 9, 4: 3, 15: 2, 17: 13}\", \"281\"]"}
{"diff_sorted_id": "36", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Red', 'Red', 'Red'], ['Green', 'Blue', 'Green', 'Green'], ['Blue', 'Blue', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[2, 0], [2, 0], [1, 2], [1, 0], [2, 1], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.14433550834655762", "solution_depth": "12", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Blue\", \"Red\", \"Red\", \"Red\"], [\"Green\", \"Blue\", \"Green\", \"Green\"], [\"Blue\", \"Blue\", \"Green\", \"Red\"]], 7]", "is_correct_args": "[[[\"Blue\", \"Red\", \"Red\", \"Red\"], [\"Green\", \"Blue\", \"Green\", \"Green\"], [\"Blue\", \"Blue\", \"Green\", \"Red\"]], 7]", "A*_args": "[\"[['Blue', 'Red', 'Red', 'Red'], ['Green', 'Blue', 'Green', 'Green'], ['Blue', 'Blue', 'Green', 'Red']]\", \"7\"]"}
{"diff_sorted_id": "36", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 26 to 74 (26 included in the range but 74 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['41' 'x' 'x']\n ['42' '57' 'x']\n ['x' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 1, 27], [0, 2, 26], [1, 2, 58], [2, 0, 61], [2, 1, 60], [2, 2, 59]]", "opt_solution_cost": "394", "opt_solution_compute_t": "207.3310091495514", "solution_depth": "6", "max_successor_states": "48", "num_vars_per_state": "9", "is_feasible_args": "[\"[['41', '', ''], ['42', '57', ''], ['', '', '']]\", 26, 74]", "is_correct_args": "[\"[['41', '', ''], ['42', '57', ''], ['', '', '']]\", 26, 74]", "A*_args": "[\"[['41', '', ''], ['42', '57', ''], ['', '', '']]\", \"26\", \"74\"]"}
{"diff_sorted_id": "36", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 40 to 89. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 198, and sum of row 1 must be 152. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 195. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x']\n ['x' 'x' 'x']\n ['69' '71' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "6", "opt_solution": "[[0, 0, 41], [0, 1, 57], [0, 2, 56], [1, 0, 40], [1, 1, 70], [1, 2, 42], [2, 2, 43]]", "opt_solution_cost": "489", "opt_solution_compute_t": "69.91229152679443", "solution_depth": "7", "max_successor_states": "39", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['', '', ''], ['69', '71', '']]\", 3, 40, 89]", "is_correct_args": "[\"[['', '', ''], ['', '', ''], ['69', '71', '']]\", 40, 89, [1, 2], [1, 2], [198], [152], 195]", "A*_args": "[\"[['', '', ''], ['', '', ''], ['69', '71', '']]\", \"40\", \"89\", \"[None, 198, None]\", \"[None, 152, None]\", \"195\"]"}
{"diff_sorted_id": "36", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 4, 1: 4, 2: 7, 3: 1, 4: 8, 5: 8, 6: 8, 7: 4}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Blue', 'Yellow', 'Yellow', 'Green', 'Black'], [], [], [], ['Blue', 'Red', 'Black', 'Yellow', 'Green'], ['Black', 'Red', 'Green', 'Blue', 'Red'], ['Green', 'Yellow', 'Black', 'Red', 'Blue'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[0, 1], [0, 2], [0, 2], [6, 3], [6, 2], [4, 1], [4, 7], [0, 3], [4, 0], [4, 2], [5, 0], [6, 0], [6, 7], [5, 7], [5, 3], [5, 1], [5, 7], [6, 1], [4, 3]]", "opt_solution_cost": "76", "opt_solution_compute_t": "4.6590895652771", "solution_depth": "19", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[\"Blue\", \"Yellow\", \"Yellow\", \"Green\", \"Black\"], [], [], [], [\"Blue\", \"Red\", \"Black\", \"Yellow\", \"Green\"], [\"Black\", \"Red\", \"Green\", \"Blue\", \"Red\"], [\"Green\", \"Yellow\", \"Black\", \"Red\", \"Blue\"], []], 5, {\"0\": 4, \"1\": 4, \"2\": 7, \"3\": 1, \"4\": 8, \"5\": 8, \"6\": 8, \"7\": 4}]", "is_correct_args": "[[[\"Blue\", \"Yellow\", \"Yellow\", \"Green\", \"Black\"], [], [], [], [\"Blue\", \"Red\", \"Black\", \"Yellow\", \"Green\"], [\"Black\", \"Red\", \"Green\", \"Blue\", \"Red\"], [\"Green\", \"Yellow\", \"Black\", \"Red\", \"Blue\"], []], 5, {\"0\": 4, \"1\": 4, \"2\": 7, \"3\": 1, \"4\": 8, \"5\": 8, \"6\": 8, \"7\": 4}, 4]", "A*_args": "[\"[['Blue', 'Yellow', 'Yellow', 'Green', 'Black'], [], [], [], ['Blue', 'Red', 'Black', 'Yellow', 'Green'], ['Black', 'Red', 'Green', 'Blue', 'Red'], ['Green', 'Yellow', 'Black', 'Red', 'Blue'], []]\", \"{0: 4, 1: 4, 2: 7, 3: 1, 4: 8, 5: 8, 6: 8, 7: 4}\", \"5\", \"4\"]"}
{"diff_sorted_id": "36", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (7, 0) to his destination workshop at index (3, 8), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 6, and district 3 covering rows 7 to 10. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 11 5 18 x 14 7 x 15 11 14]\n[x x x x 13 13 11 17 8 13 x]\n[x 8 1 5 17 x 4 8 20 7 4]\n[x 10 x x 18 1 x x 20 x x]\n[18 15 x 6 x 4 3 4 3 13 x]\n[5 1 x 4 x x x 11 x 14 18]\n[19 19 x x x x 15 x 10 x x]\n[15 5 7 x 14 6 x x x 13 x]\n[18 7 x 19 x 12 x x 15 x x]\n[10 9 x 1 x x 15 x 11 x 2]\n[x x 8 x 19 x 1 3 x x 8]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "3", "opt_solution": "[[7, 0], [7, 1], [6, 1], [5, 1], [4, 1], [3, 1], [2, 1], [2, 2], [2, 3], [2, 4], [1, 4], [2, 4], [3, 4], [3, 5], [4, 5], [4, 6], [4, 7], [4, 8], [3, 8]]", "opt_solution_cost": "164", "opt_solution_compute_t": "0.027472734451293945", "solution_depth": "19", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"11\", \"5\", \"18\", \"x\", \"14\", \"7\", \"x\", \"15\", \"11\", \"14\"], [\"x\", \"x\", \"x\", \"x\", \"13\", \"13\", \"11\", \"17\", \"8\", \"13\", \"x\"], [\"x\", \"8\", \"1\", \"5\", \"17\", \"x\", \"4\", \"8\", \"20\", \"7\", \"4\"], [\"x\", \"10\", \"x\", \"x\", \"18\", \"1\", \"x\", \"x\", \"20\", \"x\", \"x\"], [\"18\", \"15\", \"x\", \"6\", \"x\", \"4\", \"3\", \"4\", \"3\", \"13\", \"x\"], [\"5\", \"1\", \"x\", \"4\", \"x\", \"x\", \"x\", \"11\", \"x\", \"14\", \"18\"], [\"19\", \"19\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\", \"10\", \"x\", \"x\"], [\"15\", \"5\", \"7\", \"x\", \"14\", \"6\", \"x\", \"x\", \"x\", \"13\", \"x\"], [\"18\", \"7\", \"x\", \"19\", \"x\", \"12\", \"x\", \"x\", \"15\", \"x\", \"x\"], [\"10\", \"9\", \"x\", \"1\", \"x\", \"x\", \"15\", \"x\", \"11\", \"x\", \"2\"], [\"x\", \"x\", \"8\", \"x\", \"19\", \"x\", \"1\", \"3\", \"x\", \"x\", \"8\"]]]", "is_correct_args": "[[[\"x\", \"11\", \"5\", \"18\", \"x\", \"14\", \"7\", \"x\", \"15\", \"11\", \"14\"], [\"x\", \"x\", \"x\", \"x\", \"13\", \"13\", \"11\", \"17\", \"8\", \"13\", \"x\"], [\"x\", \"8\", \"1\", \"5\", \"17\", \"x\", \"4\", \"8\", \"20\", \"7\", \"4\"], [\"x\", \"10\", \"x\", \"x\", \"18\", \"1\", \"x\", \"x\", \"20\", \"x\", \"x\"], [\"18\", \"15\", \"x\", \"6\", \"x\", \"4\", \"3\", \"4\", \"3\", \"13\", \"x\"], [\"5\", \"1\", \"x\", \"4\", \"x\", \"x\", \"x\", \"11\", \"x\", \"14\", \"18\"], [\"19\", \"19\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\", \"10\", \"x\", \"x\"], [\"15\", \"5\", \"7\", \"x\", \"14\", \"6\", \"x\", \"x\", \"x\", \"13\", \"x\"], [\"18\", \"7\", \"x\", \"19\", \"x\", \"12\", \"x\", \"x\", \"15\", \"x\", \"x\"], [\"10\", \"9\", \"x\", \"1\", \"x\", \"x\", \"15\", \"x\", \"11\", \"x\", \"2\"], [\"x\", \"x\", \"8\", \"x\", \"19\", \"x\", \"1\", \"3\", \"x\", \"x\", \"8\"]], [7, 0], [3, 8], 1, 6]", "A*_args": "[\"[['x', '11', '5', '18', 'x', '14', '7', 'x', '15', '11', '14'], ['x', 'x', 'x', 'x', '13', '13', '11', '17', '8', '13', 'x'], ['x', '8', '1', '5', '17', 'x', '4', '8', '20', '7', '4'], ['x', '10', 'x', 'x', '18', '1', 'x', 'x', '20', 'x', 'x'], ['18', '15', 'x', '6', 'x', '4', '3', '4', '3', '13', 'x'], ['5', '1', 'x', '4', 'x', 'x', 'x', '11', 'x', '14', '18'], ['19', '19', 'x', 'x', 'x', 'x', '15', 'x', '10', 'x', 'x'], ['15', '5', '7', 'x', '14', '6', 'x', 'x', 'x', '13', 'x'], ['18', '7', 'x', '19', 'x', '12', 'x', 'x', '15', 'x', 'x'], ['10', '9', 'x', '1', 'x', 'x', '15', 'x', '11', 'x', '2'], ['x', 'x', '8', 'x', '19', 'x', '1', '3', 'x', 'x', '8']]\", \"(7, 0)\", \"(3, 8)\", \"1\", \"6\"]"}
{"diff_sorted_id": "36", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 11x11. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 10) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (9, 2). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 1 0 0 1 1 0 0 1 0\n0 1 1 0 1 1 1 0 1 0 1\n1 1 1 1 1 0 1 0 0 0 0\n0 0 1 1 0 0 0 1 1 1 0\n0 1 0 0 1 1 0 1 1 0 0\n1 0 1 1 0 0 0 0 1 1 0\n0 0 0 1 0 0 0 1 1 1 0\n1 1 1 1 1 1 1 0 0 0 0\n0 0 0 0 0 0 0 0 1 0 1\n0 1 0 0 0 1 1 1 0 0 1\n0 0 1 1 1 0 1 1 1 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[[0, 10], [1, 9], [2, 9], [2, 8], [2, 7], [3, 6], [4, 6], [5, 6], [6, 6], [7, 7], [8, 7], [8, 6], [8, 5], [8, 4], [8, 3], [8, 2], [9, 2]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.024544954299926758", "solution_depth": "17", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0], [0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1], [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0], [0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1], [0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0]]\", 3]", "is_correct_args": "[\"[[0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0], [0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1], [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0], [0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1], [0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0]]\", [0, 10], [9, 2], 3]", "A*_args": "[\"[[0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0], [0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1], [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0], [0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1], [0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0]]\", \"(0, 10)\", \"(9, 2)\", \"3\"]"}
{"diff_sorted_id": "36", "problem_statement": "Given 7 labeled water jugs with capacities 15, 138, 24, 10, 30, 82, 11, 94 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 239, 275, 286 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 138, 3], [\"+\", 138, 3], [\"+\", 10, 3], [\"+\", 138, 2], [\"-\", 11, 2], [\"+\", 138, 2], [\"+\", 10, 2], [\"+\", 10, 1], [\"+\", 82, 1], [\"+\", 138, 1], [\"-\", 15, 1], [\"+\", 24, 1]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.038283348083496094", "solution_depth": "12", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[15, 138, 24, 10, 30, 82, 11, 94], [239, 275, 286]]", "is_correct_args": "[[15, 138, 24, 10, 30, 82, 11, 94], [239, 275, 286]]", "A*_args": "[\"[15, 138, 24, 10, 30, 82, 11, 94]\", \"[239, 275, 286]\"]"}
{"diff_sorted_id": "37", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[12, 78, 19, '_'], [94, 66, 67, 49], [28, 83, 31, 47]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[49, 67, 19, 78, 12, 94, 66, 12, 78, 49, 67, 47, 31, 19, 12, 83, 19, 12, 49, 78, 83, 49, 47, 31]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.03918051719665527", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[12, 78, 19, \"_\"], [94, 66, 67, 49], [28, 83, 31, 47]]]", "is_correct_args": "[[[12, 78, 19, \"_\"], [94, 66, 67, 49], [28, 83, 31, 47]]]", "A*_args": "[\"[[12, 78, 19, '_'], [94, 66, 67, 49], [28, 83, 31, 47]]\"]"}
{"diff_sorted_id": "37", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: uvate, dearie, manuka, khanum   The initial board: [['e', 'u', 'n', 'a', '_', 'e'], ['d', 'r', 'a', 'v', 'i', 'e'], ['m', 'a', 'n', 'u', 'k', 'a'], ['k', 'h', 'a', 't', 'u', 'm']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.15983343124389648", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"e\", \"u\", \"n\", \"a\", \"_\", \"e\"], [\"d\", \"r\", \"a\", \"v\", \"i\", \"e\"], [\"m\", \"a\", \"n\", \"u\", \"k\", \"a\"], [\"k\", \"h\", \"a\", \"t\", \"u\", \"m\"]]]", "is_correct_args": "[[[\"e\", \"u\", \"n\", \"a\", \"_\", \"e\"], [\"d\", \"r\", \"a\", \"v\", \"i\", \"e\"], [\"m\", \"a\", \"n\", \"u\", \"k\", \"a\"], [\"k\", \"h\", \"a\", \"t\", \"u\", \"m\"]], [\"uvate\", \"dearie\", \"manuka\", \"khanum\"]]", "A*_args": "[\"[['e', 'u', 'n', 'a', '_', 'e'], ['d', 'r', 'a', 'v', 'i', 'e'], ['m', 'a', 'n', 'u', 'k', 'a'], ['k', 'h', 'a', 't', 'u', 'm']]\", \"['uvate', 'dearie', 'manuka', 'khanum']\"]"}
{"diff_sorted_id": "37", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'L'. Our task is to visit city M and city Q excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from Q and M, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  R Q Y U F K M T X W H L \nR 0 0 0 0 1 0 1 0 1 0 0 1 \nQ 0 0 0 0 0 0 0 0 1 0 1 0 \nY 1 1 0 0 0 0 0 0 0 0 0 1 \nU 0 0 1 0 0 0 0 1 0 0 0 0 \nF 0 1 0 0 0 0 1 0 1 0 0 1 \nK 1 0 0 1 1 0 1 0 1 0 0 0 \nM 0 0 0 0 0 1 0 1 0 0 0 0 \nT 0 1 1 0 0 0 0 0 1 0 0 0 \nX 0 1 0 1 0 0 0 0 0 0 0 1 \nW 1 0 0 1 1 0 0 1 0 0 0 1 \nH 0 1 0 0 1 0 0 0 0 1 0 0 \nL 0 0 0 0 0 0 0 0 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[\"L\", \"W\", \"F\", \"M\", \"K\", \"M\", \"T\", \"Q\", \"H\", \"Q\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.03090953826904297", "solution_depth": "10", "max_successor_states": "12", "num_vars_per_state": "15", "is_feasible_args": "[[[0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]], [\"R\", \"Q\", \"Y\", \"U\", \"F\", \"K\", \"M\", \"T\", \"X\", \"W\", \"H\", \"L\"], \"M\", \"Q\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]], [\"R\", \"Q\", \"Y\", \"U\", \"F\", \"K\", \"M\", \"T\", \"X\", \"W\", \"H\", \"L\"], \"L\", \"M\", \"Q\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]]\", \"['R', 'Q', 'Y', 'U', 'F', 'K', 'M', 'T', 'X', 'W', 'H', 'L']\", \"['L']\", \"['M', 'Q']\"]"}
{"diff_sorted_id": "37", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [22, 15, 4, 23, 19, 3, 5, 28, 22, 27, 13, 18, 14, 11, 22, 20, 27, 24, 21, 13, 25, 11, 6, 2, 30, 29, 4, 16, 3, 13, 3, 28, 28, 20, 15, 27, 4, 18, 20, 5, 16, 21, 25, 24, 23, 15, 22, 26], such that the sum of the chosen coins adds up to 303. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {15: 2, 18: 17, 22: 16, 29: 7, 28: 5, 23: 1, 20: 17, 14: 3, 13: 2, 4: 2, 5: 3, 27: 10, 16: 6, 3: 2, 6: 3, 19: 8, 2: 1, 25: 6, 24: 19, 26: 18, 21: 10, 11: 1, 30: 4}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "30", "opt_solution": "[11, 11, 13, 23, 23, 14, 15, 15, 15, 4, 13, 13, 25, 29, 28, 4, 25, 16, 6]", "opt_solution_cost": "56", "opt_solution_compute_t": "0.050664663314819336", "solution_depth": "19", "max_successor_states": "48", "num_vars_per_state": "48", "is_feasible_args": "[[22, 15, 4, 23, 19, 3, 5, 28, 22, 27, 13, 18, 14, 11, 22, 20, 27, 24, 21, 13, 25, 11, 6, 2, 30, 29, 4, 16, 3, 13, 3, 28, 28, 20, 15, 27, 4, 18, 20, 5, 16, 21, 25, 24, 23, 15, 22, 26]]", "is_correct_args": "[[22, 15, 4, 23, 19, 3, 5, 28, 22, 27, 13, 18, 14, 11, 22, 20, 27, 24, 21, 13, 25, 11, 6, 2, 30, 29, 4, 16, 3, 13, 3, 28, 28, 20, 15, 27, 4, 18, 20, 5, 16, 21, 25, 24, 23, 15, 22, 26], {\"15\": 2, \"18\": 17, \"22\": 16, \"29\": 7, \"28\": 5, \"23\": 1, \"20\": 17, \"14\": 3, \"13\": 2, \"4\": 2, \"5\": 3, \"27\": 10, \"16\": 6, \"3\": 2, \"6\": 3, \"19\": 8, \"2\": 1, \"25\": 6, \"24\": 19, \"26\": 18, \"21\": 10, \"11\": 1, \"30\": 4}, 303]", "A*_args": "[\"[22, 15, 4, 23, 19, 3, 5, 28, 22, 27, 13, 18, 14, 11, 22, 20, 27, 24, 21, 13, 25, 11, 6, 2, 30, 29, 4, 16, 3, 13, 3, 28, 28, 20, 15, 27, 4, 18, 20, 5, 16, 21, 25, 24, 23, 15, 22, 26]\", \"{15: 2, 18: 17, 22: 16, 29: 7, 28: 5, 23: 1, 20: 17, 14: 3, 13: 2, 4: 2, 5: 3, 27: 10, 16: 6, 3: 2, 6: 3, 19: 8, 2: 1, 25: 6, 24: 19, 26: 18, 21: 10, 11: 1, 30: 4}\", \"303\"]"}
{"diff_sorted_id": "37", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Red', 'Blue', 'Red'], ['Red', 'Blue', 'Green', 'Blue'], ['Green', 'Green', 'Blue', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[0, 1], [0, 1], [0, 2], [1, 0], [1, 0], [1, 0], [1, 2], [1, 0], [2, 1], [2, 1], [2, 0], [2, 0], [2, 1], [0, 2], [0, 2], [0, 2]]", "opt_solution_cost": "16", "opt_solution_compute_t": "1.3703632354736328", "solution_depth": "16", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Red\", \"Blue\", \"Red\"], [\"Red\", \"Blue\", \"Green\", \"Blue\"], [\"Green\", \"Green\", \"Blue\", \"Green\"]], 7]", "is_correct_args": "[[[\"Red\", \"Red\", \"Blue\", \"Red\"], [\"Red\", \"Blue\", \"Green\", \"Blue\"], [\"Green\", \"Green\", \"Blue\", \"Green\"]], 7]", "A*_args": "[\"[['Red', 'Red', 'Blue', 'Red'], ['Red', 'Blue', 'Green', 'Blue'], ['Green', 'Green', 'Blue', 'Green']]\", \"7\"]"}
{"diff_sorted_id": "37", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 48 to 101 (48 included in the range but 101 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['57' 'x' '86']\n ['x' '75' 'x']\n ['x' '76' '90']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 1, 58], [1, 0, 49], [1, 2, 87], [2, 0, 48]]", "opt_solution_cost": "686", "opt_solution_compute_t": "0.38043832778930664", "solution_depth": "4", "max_successor_states": "53", "num_vars_per_state": "9", "is_feasible_args": "[\"[['57', '', '86'], ['', '75', ''], ['', '76', '90']]\", 48, 101]", "is_correct_args": "[\"[['57', '', '86'], ['', '75', ''], ['', '76', '90']]\", 48, 101]", "A*_args": "[\"[['57', '', '86'], ['', '75', ''], ['', '76', '90']]\", \"48\", \"101\"]"}
{"diff_sorted_id": "37", "problem_statement": "In the magic square problem, a 3x3 grid is filled with unique integers ranging from 40 to 89. Some numbers are already given, while others are unknown and represented as 'x'. Sum of column 1 (counting from 0) must be 150, and sum of row 1 must be 209. Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 169. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['48' 'x' 'x']\n ['x' 'x' 'x']\n ['x' '49' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 1, 40], [0, 2, 42], [1, 0, 60], [1, 1, 61], [1, 2, 88], [2, 0, 66], [2, 2, 41]]", "opt_solution_cost": "495", "opt_solution_compute_t": "6.065331697463989", "solution_depth": "7", "max_successor_states": "39", "num_vars_per_state": "9", "is_feasible_args": "[\"[['48', '', ''], ['', '', ''], ['', '49', '']]\", 3, 40, 89]", "is_correct_args": "[\"[['48', '', ''], ['', '', ''], ['', '49', '']]\", 40, 89, [1, 2], [1, 2], [150], [209], 169]", "A*_args": "[\"[['48', '', ''], ['', '', ''], ['', '49', '']]\", \"40\", \"89\", \"[None, 150, None]\", \"[None, 209, None]\", \"169\"]"}
{"diff_sorted_id": "37", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 3, 1: 2, 2: 1, 3: 7, 4: 5, 5: 5, 6: 6, 7: 4}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Blue', 'Black', 'Blue', 'Yellow', 'Red'], ['Red', 'Green', 'Black', 'Green', 'Black'], [], ['Red', 'Red', 'Green', 'Yellow', 'Yellow'], [], [], ['Blue', 'Yellow', 'Green', 'Black', 'Blue']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[2, 0], [2, 5], [2, 3], [7, 6], [2, 5], [4, 0], [4, 0], [4, 5], [7, 4], [7, 5], [7, 2], [1, 7], [1, 2], [1, 7], [1, 4], [6, 7], [1, 0], [3, 2]]", "opt_solution_cost": "70", "opt_solution_compute_t": "8.884233713150024", "solution_depth": "18", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[], [\"Blue\", \"Black\", \"Blue\", \"Yellow\", \"Red\"], [\"Red\", \"Green\", \"Black\", \"Green\", \"Black\"], [], [\"Red\", \"Red\", \"Green\", \"Yellow\", \"Yellow\"], [], [], [\"Blue\", \"Yellow\", \"Green\", \"Black\", \"Blue\"]], 5, {\"0\": 3, \"1\": 2, \"2\": 1, \"3\": 7, \"4\": 5, \"5\": 5, \"6\": 6, \"7\": 4}]", "is_correct_args": "[[[], [\"Blue\", \"Black\", \"Blue\", \"Yellow\", \"Red\"], [\"Red\", \"Green\", \"Black\", \"Green\", \"Black\"], [], [\"Red\", \"Red\", \"Green\", \"Yellow\", \"Yellow\"], [], [], [\"Blue\", \"Yellow\", \"Green\", \"Black\", \"Blue\"]], 5, {\"0\": 3, \"1\": 2, \"2\": 1, \"3\": 7, \"4\": 5, \"5\": 5, \"6\": 6, \"7\": 4}, 4]", "A*_args": "[\"[[], ['Blue', 'Black', 'Blue', 'Yellow', 'Red'], ['Red', 'Green', 'Black', 'Green', 'Black'], [], ['Red', 'Red', 'Green', 'Yellow', 'Yellow'], [], [], ['Blue', 'Yellow', 'Green', 'Black', 'Blue']]\", \"{0: 3, 1: 2, 2: 1, 3: 7, 4: 5, 5: 5, 6: 6, 7: 4}\", \"5\", \"4\"]"}
{"diff_sorted_id": "37", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (7, 5) to his destination workshop at index (1, 0), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 6, and district 3 covering rows 7 to 10. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[15 x 12 x 9 19 x x 13 x 16]\n[14 6 3 18 x 8 18 x x x x]\n[16 10 9 4 9 5 15 4 x x 2]\n[5 9 x 8 1 15 7 15 x x x]\n[6 x 3 x 4 6 6 19 x 16 13]\n[17 x 11 5 18 11 18 x x 10 19]\n[6 3 x x 10 18 2 x x x x]\n[x x 4 2 x 13 7 x 3 19 16]\n[x 1 10 x 15 x 2 x 1 7 10]\n[x x x 4 7 x 7 x x 6 x]\n[16 x 15 3 x 8 x x 13 x 14]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "3", "opt_solution": "[[7, 5], [6, 5], [5, 5], [4, 5], [4, 4], [3, 4], [3, 3], [2, 3], [2, 2], [1, 2], [1, 1], [1, 0]]", "opt_solution_cost": "84", "opt_solution_compute_t": "0.0287020206451416", "solution_depth": "12", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"15\", \"x\", \"12\", \"x\", \"9\", \"19\", \"x\", \"x\", \"13\", \"x\", \"16\"], [\"14\", \"6\", \"3\", \"18\", \"x\", \"8\", \"18\", \"x\", \"x\", \"x\", \"x\"], [\"16\", \"10\", \"9\", \"4\", \"9\", \"5\", \"15\", \"4\", \"x\", \"x\", \"2\"], [\"5\", \"9\", \"x\", \"8\", \"1\", \"15\", \"7\", \"15\", \"x\", \"x\", \"x\"], [\"6\", \"x\", \"3\", \"x\", \"4\", \"6\", \"6\", \"19\", \"x\", \"16\", \"13\"], [\"17\", \"x\", \"11\", \"5\", \"18\", \"11\", \"18\", \"x\", \"x\", \"10\", \"19\"], [\"6\", \"3\", \"x\", \"x\", \"10\", \"18\", \"2\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"4\", \"2\", \"x\", \"13\", \"7\", \"x\", \"3\", \"19\", \"16\"], [\"x\", \"1\", \"10\", \"x\", \"15\", \"x\", \"2\", \"x\", \"1\", \"7\", \"10\"], [\"x\", \"x\", \"x\", \"4\", \"7\", \"x\", \"7\", \"x\", \"x\", \"6\", \"x\"], [\"16\", \"x\", \"15\", \"3\", \"x\", \"8\", \"x\", \"x\", \"13\", \"x\", \"14\"]]]", "is_correct_args": "[[[\"15\", \"x\", \"12\", \"x\", \"9\", \"19\", \"x\", \"x\", \"13\", \"x\", \"16\"], [\"14\", \"6\", \"3\", \"18\", \"x\", \"8\", \"18\", \"x\", \"x\", \"x\", \"x\"], [\"16\", \"10\", \"9\", \"4\", \"9\", \"5\", \"15\", \"4\", \"x\", \"x\", \"2\"], [\"5\", \"9\", \"x\", \"8\", \"1\", \"15\", \"7\", \"15\", \"x\", \"x\", \"x\"], [\"6\", \"x\", \"3\", \"x\", \"4\", \"6\", \"6\", \"19\", \"x\", \"16\", \"13\"], [\"17\", \"x\", \"11\", \"5\", \"18\", \"11\", \"18\", \"x\", \"x\", \"10\", \"19\"], [\"6\", \"3\", \"x\", \"x\", \"10\", \"18\", \"2\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"4\", \"2\", \"x\", \"13\", \"7\", \"x\", \"3\", \"19\", \"16\"], [\"x\", \"1\", \"10\", \"x\", \"15\", \"x\", \"2\", \"x\", \"1\", \"7\", \"10\"], [\"x\", \"x\", \"x\", \"4\", \"7\", \"x\", \"7\", \"x\", \"x\", \"6\", \"x\"], [\"16\", \"x\", \"15\", \"3\", \"x\", \"8\", \"x\", \"x\", \"13\", \"x\", \"14\"]], [7, 5], [1, 0], 1, 6]", "A*_args": "[\"[['15', 'x', '12', 'x', '9', '19', 'x', 'x', '13', 'x', '16'], ['14', '6', '3', '18', 'x', '8', '18', 'x', 'x', 'x', 'x'], ['16', '10', '9', '4', '9', '5', '15', '4', 'x', 'x', '2'], ['5', '9', 'x', '8', '1', '15', '7', '15', 'x', 'x', 'x'], ['6', 'x', '3', 'x', '4', '6', '6', '19', 'x', '16', '13'], ['17', 'x', '11', '5', '18', '11', '18', 'x', 'x', '10', '19'], ['6', '3', 'x', 'x', '10', '18', '2', 'x', 'x', 'x', 'x'], ['x', 'x', '4', '2', 'x', '13', '7', 'x', '3', '19', '16'], ['x', '1', '10', 'x', '15', 'x', '2', 'x', '1', '7', '10'], ['x', 'x', 'x', '4', '7', 'x', '7', 'x', 'x', '6', 'x'], ['16', 'x', '15', '3', 'x', '8', 'x', 'x', '13', 'x', '14']]\", \"(7, 5)\", \"(1, 0)\", \"1\", \"6\"]"}
{"diff_sorted_id": "37", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 11x11. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 9) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (6, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 0 1 0 0 1 0 1 0 0\n0 0 1 0 0 1 1 1 1 0 0\n1 1 1 0 1 0 0 1 0 0 1\n1 1 0 1 0 0 0 0 0 1 0\n0 0 1 1 0 0 1 1 0 1 0\n0 0 0 0 1 1 1 1 1 0 1\n0 1 0 0 1 1 0 0 1 1 0\n1 0 0 0 1 0 0 1 1 0 0\n1 0 1 0 0 0 1 0 1 1 0\n0 0 0 1 0 0 0 1 1 1 0\n0 1 1 1 0 1 1 1 0 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[[0, 9], [1, 9], [2, 8], [3, 7], [3, 6], [3, 5], [3, 4], [4, 4], [5, 3], [5, 2], [5, 1], [5, 0], [6, 0]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.02647542953491211", "solution_depth": "13", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0], [1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1], [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0], [1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0], [1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0], [0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1]]\", 3]", "is_correct_args": "[\"[[1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0], [1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1], [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0], [1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0], [1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0], [0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1]]\", [0, 9], [6, 0], 3]", "A*_args": "[\"[[1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0], [1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1], [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0], [1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0], [1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0], [0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1]]\", \"(0, 9)\", \"(6, 0)\", \"3\"]"}
{"diff_sorted_id": "37", "problem_statement": "Given 9 labeled water jugs with capacities 19, 122, 104, 145, 38, 141, 126, 82, 37, 33 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 256, 399, 410 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 145, 3], [\"+\", 145, 3], [\"+\", 38, 3], [\"+\", 82, 3], [\"+\", 122, 2], [\"+\", 122, 2], [\"+\", 33, 2], [\"+\", 122, 2], [\"+\", 82, 1], [\"+\", 141, 1], [\"+\", 33, 1]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.04917335510253906", "solution_depth": "11", "max_successor_states": "60", "num_vars_per_state": "3", "is_feasible_args": "[[19, 122, 104, 145, 38, 141, 126, 82, 37, 33], [256, 399, 410]]", "is_correct_args": "[[19, 122, 104, 145, 38, 141, 126, 82, 37, 33], [256, 399, 410]]", "A*_args": "[\"[19, 122, 104, 145, 38, 141, 126, 82, 37, 33]\", \"[256, 399, 410]\"]"}
{"diff_sorted_id": "38", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[75, 59, 74, 73], ['_', 79, 26, 17], [64, 29, 47, 39]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[79, 26, 17, 73, 74, 59, 75, 79, 64, 29, 47, 17, 59, 74, 73, 39, 17, 47, 26, 59, 47, 17]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.22814416885375977", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[75, 59, 74, 73], [\"_\", 79, 26, 17], [64, 29, 47, 39]]]", "is_correct_args": "[[[75, 59, 74, 73], [\"_\", 79, 26, 17], [64, 29, 47, 39]]]", "A*_args": "[\"[[75, 59, 74, 73], ['_', 79, 26, 17], [64, 29, 47, 39]]\"]"}
{"diff_sorted_id": "38", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: nieve, astely, oecist, mewler   The initial board: [['s', 'n', '_', 'e', 'y', 'e'], ['a', 'e', 't', 'i', 'l', 'e'], ['o', 'e', 'c', 'i', 'v', 't'], ['m', 'l', 'w', 's', 'e', 'r']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-left\"]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.39636731147766113", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"s\", \"n\", \"_\", \"e\", \"y\", \"e\"], [\"a\", \"e\", \"t\", \"i\", \"l\", \"e\"], [\"o\", \"e\", \"c\", \"i\", \"v\", \"t\"], [\"m\", \"l\", \"w\", \"s\", \"e\", \"r\"]]]", "is_correct_args": "[[[\"s\", \"n\", \"_\", \"e\", \"y\", \"e\"], [\"a\", \"e\", \"t\", \"i\", \"l\", \"e\"], [\"o\", \"e\", \"c\", \"i\", \"v\", \"t\"], [\"m\", \"l\", \"w\", \"s\", \"e\", \"r\"]], [\"nieve\", \"astely\", \"oecist\", \"mewler\"]]", "A*_args": "[\"[['s', 'n', '_', 'e', 'y', 'e'], ['a', 'e', 't', 'i', 'l', 'e'], ['o', 'e', 'c', 'i', 'v', 't'], ['m', 'l', 'w', 's', 'e', 'r']]\", \"['nieve', 'astely', 'oecist', 'mewler']\"]"}
{"diff_sorted_id": "38", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'Q'. Our task is to visit city V and city F excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from F and V, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  S X Y Q O R D V H J F C \nS 0 1 0 0 0 0 0 1 0 0 1 1 \nX 0 0 0 0 1 0 1 0 0 0 0 0 \nY 1 1 0 0 0 1 0 0 0 0 1 0 \nQ 0 1 0 0 0 0 1 0 0 0 0 0 \nO 0 0 0 0 0 1 0 1 1 0 0 0 \nR 0 1 0 0 0 0 0 1 0 0 0 1 \nD 1 0 1 0 0 0 0 0 1 0 0 0 \nV 0 0 1 0 0 1 1 0 0 0 0 1 \nH 1 0 1 1 0 0 0 1 0 0 0 1 \nJ 0 1 1 0 0 1 0 0 1 0 0 0 \nF 0 0 1 0 0 0 1 1 0 1 0 0 \nC 1 1 0 0 0 0 0 1 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[\"Q\", \"D\", \"S\", \"F\", \"V\", \"Y\", \"F\", \"V\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.028425216674804688", "solution_depth": "8", "max_successor_states": "12", "num_vars_per_state": "15", "is_feasible_args": "[[[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0]], [\"S\", \"X\", \"Y\", \"Q\", \"O\", \"R\", \"D\", \"V\", \"H\", \"J\", \"F\", \"C\"], \"V\", \"F\"]", "is_correct_args": "[[[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0]], [\"S\", \"X\", \"Y\", \"Q\", \"O\", \"R\", \"D\", \"V\", \"H\", \"J\", \"F\", \"C\"], \"Q\", \"V\", \"F\"]", "A*_args": "[\"[[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0]]\", \"['S', 'X', 'Y', 'Q', 'O', 'R', 'D', 'V', 'H', 'J', 'F', 'C']\", \"['Q']\", \"['V', 'F']\"]"}
{"diff_sorted_id": "38", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [30, 24, 27, 14, 29, 17, 4, 21, 20, 14, 19, 23, 18, 4, 12, 9, 24, 26, 21, 17, 3, 13, 25, 20, 16, 12, 2, 9, 17, 5, 6, 24, 13, 11, 6, 15, 13, 5, 13, 25, 10, 15, 10, 3, 2, 18, 7, 23, 5, 18, 21, 6], such that the sum of the chosen coins adds up to 300. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {14: 11, 3: 1, 18: 5, 21: 1, 27: 2, 19: 14, 6: 6, 25: 8, 5: 3, 29: 4, 7: 6, 24: 10, 10: 2, 13: 9, 9: 1, 11: 8, 16: 10, 2: 1, 12: 12, 15: 4, 23: 17, 17: 9, 26: 13, 30: 17, 4: 3, 20: 6}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "31", "opt_solution": "[9, 9, 21, 21, 10, 27, 29, 18, 10, 15, 25, 20, 18, 21, 25, 20, 2]", "opt_solution_cost": "58", "opt_solution_compute_t": "0.056997060775756836", "solution_depth": "17", "max_successor_states": "52", "num_vars_per_state": "52", "is_feasible_args": "[[30, 24, 27, 14, 29, 17, 4, 21, 20, 14, 19, 23, 18, 4, 12, 9, 24, 26, 21, 17, 3, 13, 25, 20, 16, 12, 2, 9, 17, 5, 6, 24, 13, 11, 6, 15, 13, 5, 13, 25, 10, 15, 10, 3, 2, 18, 7, 23, 5, 18, 21, 6]]", "is_correct_args": "[[30, 24, 27, 14, 29, 17, 4, 21, 20, 14, 19, 23, 18, 4, 12, 9, 24, 26, 21, 17, 3, 13, 25, 20, 16, 12, 2, 9, 17, 5, 6, 24, 13, 11, 6, 15, 13, 5, 13, 25, 10, 15, 10, 3, 2, 18, 7, 23, 5, 18, 21, 6], {\"14\": 11, \"3\": 1, \"18\": 5, \"21\": 1, \"27\": 2, \"19\": 14, \"6\": 6, \"25\": 8, \"5\": 3, \"29\": 4, \"7\": 6, \"24\": 10, \"10\": 2, \"13\": 9, \"9\": 1, \"11\": 8, \"16\": 10, \"2\": 1, \"12\": 12, \"15\": 4, \"23\": 17, \"17\": 9, \"26\": 13, \"30\": 17, \"4\": 3, \"20\": 6}, 300]", "A*_args": "[\"[30, 24, 27, 14, 29, 17, 4, 21, 20, 14, 19, 23, 18, 4, 12, 9, 24, 26, 21, 17, 3, 13, 25, 20, 16, 12, 2, 9, 17, 5, 6, 24, 13, 11, 6, 15, 13, 5, 13, 25, 10, 15, 10, 3, 2, 18, 7, 23, 5, 18, 21, 6]\", \"{14: 11, 3: 1, 18: 5, 21: 1, 27: 2, 19: 14, 6: 6, 25: 8, 5: 3, 29: 4, 7: 6, 24: 10, 10: 2, 13: 9, 9: 1, 11: 8, 16: 10, 2: 1, 12: 12, 15: 4, 23: 17, 17: 9, 26: 13, 30: 17, 4: 3, 20: 6}\", \"300\"]"}
{"diff_sorted_id": "38", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Blue', 'Red'], ['Red', 'Green', 'Blue', 'Red'], ['Green', 'Red', 'Green', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[2, 0], [1, 2], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [0, 2], [0, 1], [0, 1], [0, 2], [0, 1], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [2, 1]]", "opt_solution_cost": "19", "opt_solution_compute_t": "5.927346706390381", "solution_depth": "19", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Blue\", \"Red\"], [\"Red\", \"Green\", \"Blue\", \"Red\"], [\"Green\", \"Red\", \"Green\", \"Blue\"]], 7]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Blue\", \"Red\"], [\"Red\", \"Green\", \"Blue\", \"Red\"], [\"Green\", \"Red\", \"Green\", \"Blue\"]], 7]", "A*_args": "[\"[['Blue', 'Green', 'Blue', 'Red'], ['Red', 'Green', 'Blue', 'Red'], ['Green', 'Red', 'Green', 'Blue']]\", \"7\"]"}
{"diff_sorted_id": "38", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 45 to 98 (45 included in the range but 98 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '89' '95']\n ['x' 'x' '96']\n ['74' '93' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 45], [1, 0, 46], [1, 1, 90], [2, 2, 97]]", "opt_solution_cost": "749", "opt_solution_compute_t": "0.5823245048522949", "solution_depth": "4", "max_successor_states": "53", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '89', '95'], ['', '', '96'], ['74', '93', '']]\", 45, 98]", "is_correct_args": "[\"[['', '89', '95'], ['', '', '96'], ['74', '93', '']]\", 45, 98]", "A*_args": "[\"[['', '89', '95'], ['', '', '96'], ['74', '93', '']]\", \"45\", \"98\"]"}
{"diff_sorted_id": "38", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 40 to 66. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 227, 215, None for columns 1 to 2 respectively, and the sums of rows must be None, 207, 218, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 195. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '56' 'x' '40']\n ['x' 'x' '44' '60']\n ['x' '52' 'x' '45']\n ['x' 'x' '62' '47']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 41], [0, 2, 46], [1, 0, 48], [1, 1, 55], [2, 0, 58], [2, 2, 63], [3, 0, 59], [3, 1, 64]]", "opt_solution_cost": "840", "opt_solution_compute_t": "3.1795032024383545", "solution_depth": "8", "max_successor_states": "39", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '56', '', '40'], ['', '', '44', '60'], ['', '52', '', '45'], ['', '', '62', '47']]\", 4, 40, 66]", "is_correct_args": "[\"[['', '56', '', '40'], ['', '', '44', '60'], ['', '52', '', '45'], ['', '', '62', '47']]\", 40, 66, [1, 3], [1, 3], [227, 215], [207, 218], 195]", "A*_args": "[\"[['', '56', '', '40'], ['', '', '44', '60'], ['', '52', '', '45'], ['', '', '62', '47']]\", \"40\", \"66\", \"[None, 227, 215, None]\", \"[None, 207, 218, None]\", \"195\"]"}
{"diff_sorted_id": "38", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 7, 1: 5, 2: 7, 3: 2, 4: 6, 5: 7, 6: 5, 7: 3}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Blue', 'Black', 'Yellow', 'Black', 'Red'], ['Blue', 'Blue', 'Green', 'Black', 'Yellow'], [], ['Yellow', 'Red', 'Red', 'Green', 'Green'], [], [], ['Red', 'Blue', 'Black', 'Green', 'Yellow'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[0, 7], [6, 4], [6, 7], [3, 2], [3, 4], [3, 4], [1, 7], [1, 7], [1, 3], [1, 5], [6, 5], [6, 3], [0, 5], [0, 1], [0, 5], [0, 4], [2, 1], [6, 1]]", "opt_solution_cost": "90", "opt_solution_compute_t": "0.06386184692382812", "solution_depth": "18", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[\"Blue\", \"Black\", \"Yellow\", \"Black\", \"Red\"], [\"Blue\", \"Blue\", \"Green\", \"Black\", \"Yellow\"], [], [\"Yellow\", \"Red\", \"Red\", \"Green\", \"Green\"], [], [], [\"Red\", \"Blue\", \"Black\", \"Green\", \"Yellow\"], []], 5, {\"0\": 7, \"1\": 5, \"2\": 7, \"3\": 2, \"4\": 6, \"5\": 7, \"6\": 5, \"7\": 3}]", "is_correct_args": "[[[\"Blue\", \"Black\", \"Yellow\", \"Black\", \"Red\"], [\"Blue\", \"Blue\", \"Green\", \"Black\", \"Yellow\"], [], [\"Yellow\", \"Red\", \"Red\", \"Green\", \"Green\"], [], [], [\"Red\", \"Blue\", \"Black\", \"Green\", \"Yellow\"], []], 5, {\"0\": 7, \"1\": 5, \"2\": 7, \"3\": 2, \"4\": 6, \"5\": 7, \"6\": 5, \"7\": 3}, 4]", "A*_args": "[\"[['Blue', 'Black', 'Yellow', 'Black', 'Red'], ['Blue', 'Blue', 'Green', 'Black', 'Yellow'], [], ['Yellow', 'Red', 'Red', 'Green', 'Green'], [], [], ['Red', 'Blue', 'Black', 'Green', 'Yellow'], []]\", \"{0: 7, 1: 5, 2: 7, 3: 2, 4: 6, 5: 7, 6: 5, 7: 3}\", \"5\", \"4\"]"}
{"diff_sorted_id": "38", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 6) to his destination workshop at index (8, 0), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 7, and district 3 covering rows 8 to 10. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x x 3 x x 16 x 2 16 3]\n[8 x 8 5 x x 10 x 19 4 x]\n[x x 18 1 16 x 9 15 x x 11]\n[x x 17 16 4 19 2 x 1 11 x]\n[9 x 5 16 18 x x 7 x 18 6]\n[x 15 7 x x x 19 8 9 17 x]\n[x 15 19 x x x 6 2 6 x 5]\n[x 12 11 3 11 4 x x x 3 x]\n[18 12 4 x 3 10 x 3 x 7 14]\n[15 11 12 x 13 2 x x 5 14 x]\n[x x 15 x 16 4 10 13 x x 4]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "3", "opt_solution": "[[3, 6], [3, 5], [3, 4], [3, 3], [4, 3], [4, 2], [5, 2], [6, 2], [7, 2], [8, 2], [8, 1], [8, 0]]", "opt_solution_cost": "131", "opt_solution_compute_t": "0.035286903381347656", "solution_depth": "12", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"x\", \"3\", \"x\", \"x\", \"16\", \"x\", \"2\", \"16\", \"3\"], [\"8\", \"x\", \"8\", \"5\", \"x\", \"x\", \"10\", \"x\", \"19\", \"4\", \"x\"], [\"x\", \"x\", \"18\", \"1\", \"16\", \"x\", \"9\", \"15\", \"x\", \"x\", \"11\"], [\"x\", \"x\", \"17\", \"16\", \"4\", \"19\", \"2\", \"x\", \"1\", \"11\", \"x\"], [\"9\", \"x\", \"5\", \"16\", \"18\", \"x\", \"x\", \"7\", \"x\", \"18\", \"6\"], [\"x\", \"15\", \"7\", \"x\", \"x\", \"x\", \"19\", \"8\", \"9\", \"17\", \"x\"], [\"x\", \"15\", \"19\", \"x\", \"x\", \"x\", \"6\", \"2\", \"6\", \"x\", \"5\"], [\"x\", \"12\", \"11\", \"3\", \"11\", \"4\", \"x\", \"x\", \"x\", \"3\", \"x\"], [\"18\", \"12\", \"4\", \"x\", \"3\", \"10\", \"x\", \"3\", \"x\", \"7\", \"14\"], [\"15\", \"11\", \"12\", \"x\", \"13\", \"2\", \"x\", \"x\", \"5\", \"14\", \"x\"], [\"x\", \"x\", \"15\", \"x\", \"16\", \"4\", \"10\", \"13\", \"x\", \"x\", \"4\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"x\", \"3\", \"x\", \"x\", \"16\", \"x\", \"2\", \"16\", \"3\"], [\"8\", \"x\", \"8\", \"5\", \"x\", \"x\", \"10\", \"x\", \"19\", \"4\", \"x\"], [\"x\", \"x\", \"18\", \"1\", \"16\", \"x\", \"9\", \"15\", \"x\", \"x\", \"11\"], [\"x\", \"x\", \"17\", \"16\", \"4\", \"19\", \"2\", \"x\", \"1\", \"11\", \"x\"], [\"9\", \"x\", \"5\", \"16\", \"18\", \"x\", \"x\", \"7\", \"x\", \"18\", \"6\"], [\"x\", \"15\", \"7\", \"x\", \"x\", \"x\", \"19\", \"8\", \"9\", \"17\", \"x\"], [\"x\", \"15\", \"19\", \"x\", \"x\", \"x\", \"6\", \"2\", \"6\", \"x\", \"5\"], [\"x\", \"12\", \"11\", \"3\", \"11\", \"4\", \"x\", \"x\", \"x\", \"3\", \"x\"], [\"18\", \"12\", \"4\", \"x\", \"3\", \"10\", \"x\", \"3\", \"x\", \"7\", \"14\"], [\"15\", \"11\", \"12\", \"x\", \"13\", \"2\", \"x\", \"x\", \"5\", \"14\", \"x\"], [\"x\", \"x\", \"15\", \"x\", \"16\", \"4\", \"10\", \"13\", \"x\", \"x\", \"4\"]], [3, 6], [8, 0], 3, 7]", "A*_args": "[\"[['x', 'x', 'x', '3', 'x', 'x', '16', 'x', '2', '16', '3'], ['8', 'x', '8', '5', 'x', 'x', '10', 'x', '19', '4', 'x'], ['x', 'x', '18', '1', '16', 'x', '9', '15', 'x', 'x', '11'], ['x', 'x', '17', '16', '4', '19', '2', 'x', '1', '11', 'x'], ['9', 'x', '5', '16', '18', 'x', 'x', '7', 'x', '18', '6'], ['x', '15', '7', 'x', 'x', 'x', '19', '8', '9', '17', 'x'], ['x', '15', '19', 'x', 'x', 'x', '6', '2', '6', 'x', '5'], ['x', '12', '11', '3', '11', '4', 'x', 'x', 'x', '3', 'x'], ['18', '12', '4', 'x', '3', '10', 'x', '3', 'x', '7', '14'], ['15', '11', '12', 'x', '13', '2', 'x', 'x', '5', '14', 'x'], ['x', 'x', '15', 'x', '16', '4', '10', '13', 'x', 'x', '4']]\", \"(3, 6)\", \"(8, 0)\", \"3\", \"7\"]"}
{"diff_sorted_id": "38", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 11x11. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (8, 8) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (0, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 0 0 0 0 1 1 1 0 1\n1 1 0 0 1 1 0 0 0 1 0\n1 0 0 0 1 0 0 1 0 0 1\n0 1 1 0 0 1 0 0 0 1 0\n0 1 0 0 0 0 1 1 1 0 1\n1 1 1 1 0 1 1 0 0 1 1\n1 1 1 1 0 0 1 1 0 0 0\n0 0 0 1 1 0 0 0 0 0 1\n1 1 1 0 1 1 0 0 0 1 1\n0 1 1 1 0 1 0 0 0 0 1\n1 1 0 1 0 1 0 0 0 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[[8, 8], [7, 7], [7, 6], [6, 5], [5, 4], [4, 4], [3, 4], [3, 3], [2, 3], [2, 2], [1, 2], [0, 2], [0, 1], [0, 0]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.025176048278808594", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1], [1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0], [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1], [1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1], [0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1], [1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0]]\", 3]", "is_correct_args": "[\"[[0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1], [1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0], [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1], [1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1], [0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1], [1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0]]\", [8, 8], [0, 0], 3]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1], [1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0], [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1], [1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1], [0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1], [1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0]]\", \"(8, 8)\", \"(0, 0)\", \"3\"]"}
{"diff_sorted_id": "38", "problem_statement": "Given 9 labeled water jugs with capacities 117, 128, 36, 129, 103, 53, 21, 119, 105, 26 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 394, 425, 426 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 53, 3], [\"+\", 117, 3], [\"+\", 128, 3], [\"+\", 128, 3], [\"+\", 26, 2], [\"+\", 128, 2], [\"+\", 128, 2], [\"+\", 26, 2], [\"+\", 117, 2], [\"+\", 117, 1], [\"+\", 128, 1], [\"+\", 21, 1], [\"+\", 128, 1]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.05204272270202637", "solution_depth": "13", "max_successor_states": "60", "num_vars_per_state": "3", "is_feasible_args": "[[117, 128, 36, 129, 103, 53, 21, 119, 105, 26], [394, 425, 426]]", "is_correct_args": "[[117, 128, 36, 129, 103, 53, 21, 119, 105, 26], [394, 425, 426]]", "A*_args": "[\"[117, 128, 36, 129, 103, 53, 21, 119, 105, 26]\", \"[394, 425, 426]\"]"}
{"diff_sorted_id": "39", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[30, 39, 59, 78], [100, 57, 55, 48], [82, '_', 15, 88]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[15, 88, 48, 55, 57, 39, 59, 57, 88, 15, 39, 100, 30, 59, 100, 30, 82, 39, 30, 82, 59, 100, 57, 88, 82, 57, 88, 82, 55, 48]", "opt_solution_cost": "30", "opt_solution_compute_t": "0.43415212631225586", "solution_depth": "30", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[30, 39, 59, 78], [100, 57, 55, 48], [82, \"_\", 15, 88]]]", "is_correct_args": "[[[30, 39, 59, 78], [100, 57, 55, 48], [82, \"_\", 15, 88]]]", "A*_args": "[\"[[30, 39, 59, 78], [100, 57, 55, 48], [82, '_', 15, 88]]\"]"}
{"diff_sorted_id": "39", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: jibby, entone, xenium, enwomb   The initial board: [['n', 'j', '_', 'b', 'e', 'y'], ['e', 'i', 't', 'u', 'n', 'o'], ['x', 'e', 'n', 'i', 'b', 'm'], ['e', 'n', 'w', 'o', 'm', 'b']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.235795259475708", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"n\", \"j\", \"_\", \"b\", \"e\", \"y\"], [\"e\", \"i\", \"t\", \"u\", \"n\", \"o\"], [\"x\", \"e\", \"n\", \"i\", \"b\", \"m\"], [\"e\", \"n\", \"w\", \"o\", \"m\", \"b\"]]]", "is_correct_args": "[[[\"n\", \"j\", \"_\", \"b\", \"e\", \"y\"], [\"e\", \"i\", \"t\", \"u\", \"n\", \"o\"], [\"x\", \"e\", \"n\", \"i\", \"b\", \"m\"], [\"e\", \"n\", \"w\", \"o\", \"m\", \"b\"]], [\"jibby\", \"entone\", \"xenium\", \"enwomb\"]]", "A*_args": "[\"[['n', 'j', '_', 'b', 'e', 'y'], ['e', 'i', 't', 'u', 'n', 'o'], ['x', 'e', 'n', 'i', 'b', 'm'], ['e', 'n', 'w', 'o', 'm', 'b']]\", \"['jibby', 'entone', 'xenium', 'enwomb']\"]"}
{"diff_sorted_id": "39", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'O'. Our task is to visit city N and city T excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from T and N, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  O Z J K E M T W N Q U Y \nO 0 1 0 0 0 1 0 0 0 0 0 0 \nZ 0 0 0 0 0 0 0 0 1 0 0 1 \nJ 1 0 0 0 0 1 0 0 1 0 1 0 \nK 1 0 0 0 0 0 0 1 0 1 0 0 \nE 1 0 1 0 0 0 1 0 0 0 0 1 \nM 0 1 0 1 0 0 0 0 0 0 0 0 \nT 0 1 1 0 1 0 0 0 0 0 0 1 \nW 0 0 1 0 0 1 1 0 1 0 0 0 \nN 1 0 0 1 1 1 0 0 0 0 0 1 \nQ 0 0 0 0 1 0 0 1 0 0 0 0 \nU 0 0 0 0 1 0 0 0 1 1 0 0 \nY 1 0 1 1 0 1 0 1 0 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[\"O\", \"Z\", \"N\", \"E\", \"T\", \"Y\", \"W\", \"T\", \"J\", \"N\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.033557891845703125", "solution_depth": "10", "max_successor_states": "12", "num_vars_per_state": "15", "is_feasible_args": "[[[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0], [1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0]], [\"O\", \"Z\", \"J\", \"K\", \"E\", \"M\", \"T\", \"W\", \"N\", \"Q\", \"U\", \"Y\"], \"N\", \"T\"]", "is_correct_args": "[[[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0], [1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0]], [\"O\", \"Z\", \"J\", \"K\", \"E\", \"M\", \"T\", \"W\", \"N\", \"Q\", \"U\", \"Y\"], \"O\", \"N\", \"T\"]", "A*_args": "[\"[[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0], [1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0]]\", \"['O', 'Z', 'J', 'K', 'E', 'M', 'T', 'W', 'N', 'Q', 'U', 'Y']\", \"['O']\", \"['N', 'T']\"]"}
{"diff_sorted_id": "39", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [26, 24, 8, 2, 11, 10, 11, 14, 20, 9, 13, 10, 25, 21, 7, 20, 15, 27, 18, 12, 23, 4, 2, 4, 22, 23, 15, 16, 24, 14, 22, 13, 15, 21, 5, 14, 2, 21, 14, 10, 2, 2, 24, 26, 17, 2, 20, 22, 3, 27, 8, 20, 2, 25, 7], such that the sum of the chosen coins adds up to 273. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {24: 18, 14: 4, 15: 10, 23: 15, 26: 12, 22: 4, 17: 8, 5: 2, 18: 2, 16: 3, 11: 3, 2: 1, 27: 9, 3: 3, 10: 5, 20: 4, 4: 2, 21: 4, 12: 1, 8: 6, 13: 2, 7: 2, 9: 6, 25: 15}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "32", "opt_solution": "[22, 18, 16, 12, 13, 13, 21, 21, 20, 21, 20, 27, 22, 20, 2, 5]", "opt_solution_cost": "54", "opt_solution_compute_t": "0.061914682388305664", "solution_depth": "16", "max_successor_states": "55", "num_vars_per_state": "55", "is_feasible_args": "[[26, 24, 8, 2, 11, 10, 11, 14, 20, 9, 13, 10, 25, 21, 7, 20, 15, 27, 18, 12, 23, 4, 2, 4, 22, 23, 15, 16, 24, 14, 22, 13, 15, 21, 5, 14, 2, 21, 14, 10, 2, 2, 24, 26, 17, 2, 20, 22, 3, 27, 8, 20, 2, 25, 7]]", "is_correct_args": "[[26, 24, 8, 2, 11, 10, 11, 14, 20, 9, 13, 10, 25, 21, 7, 20, 15, 27, 18, 12, 23, 4, 2, 4, 22, 23, 15, 16, 24, 14, 22, 13, 15, 21, 5, 14, 2, 21, 14, 10, 2, 2, 24, 26, 17, 2, 20, 22, 3, 27, 8, 20, 2, 25, 7], {\"24\": 18, \"14\": 4, \"15\": 10, \"23\": 15, \"26\": 12, \"22\": 4, \"17\": 8, \"5\": 2, \"18\": 2, \"16\": 3, \"11\": 3, \"2\": 1, \"27\": 9, \"3\": 3, \"10\": 5, \"20\": 4, \"4\": 2, \"21\": 4, \"12\": 1, \"8\": 6, \"13\": 2, \"7\": 2, \"9\": 6, \"25\": 15}, 273]", "A*_args": "[\"[26, 24, 8, 2, 11, 10, 11, 14, 20, 9, 13, 10, 25, 21, 7, 20, 15, 27, 18, 12, 23, 4, 2, 4, 22, 23, 15, 16, 24, 14, 22, 13, 15, 21, 5, 14, 2, 21, 14, 10, 2, 2, 24, 26, 17, 2, 20, 22, 3, 27, 8, 20, 2, 25, 7]\", \"{24: 18, 14: 4, 15: 10, 23: 15, 26: 12, 22: 4, 17: 8, 5: 2, 18: 2, 16: 3, 11: 3, 2: 1, 27: 9, 3: 3, 10: 5, 20: 4, 4: 2, 21: 4, 12: 1, 8: 6, 13: 2, 7: 2, 9: 6, 25: 15}\", \"273\"]"}
{"diff_sorted_id": "39", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Blue', 'Red'], ['Blue', 'Red', 'Blue', 'Green'], ['Green', 'Red', 'Blue', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[2, 0], [2, 1], [2, 1], [0, 2], [0, 1], [0, 2], [0, 2], [1, 0], [1, 2], [1, 0], [1, 2], [1, 0], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [0, 2], [0, 1]]", "opt_solution_cost": "19", "opt_solution_compute_t": "6.7476325035095215", "solution_depth": "19", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Green\", \"Blue\", \"Red\"], [\"Blue\", \"Red\", \"Blue\", \"Green\"], [\"Green\", \"Red\", \"Blue\", \"Green\"]], 7]", "is_correct_args": "[[[\"Red\", \"Green\", \"Blue\", \"Red\"], [\"Blue\", \"Red\", \"Blue\", \"Green\"], [\"Green\", \"Red\", \"Blue\", \"Green\"]], 7]", "A*_args": "[\"[['Red', 'Green', 'Blue', 'Red'], ['Blue', 'Red', 'Blue', 'Green'], ['Green', 'Red', 'Blue', 'Green']]\", \"7\"]"}
{"diff_sorted_id": "39", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 18 to 71 (18 included in the range but 71 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '60' 'x']\n ['x' 'x' '53']\n ['52' '39' '20']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 18], [0, 2, 61], [1, 0, 19], [1, 1, 40]]", "opt_solution_cost": "351", "opt_solution_compute_t": "0.6906087398529053", "solution_depth": "4", "max_successor_states": "53", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '60', ''], ['', '', '53'], ['52', '39', '20']]\", 18, 71]", "is_correct_args": "[\"[['', '60', ''], ['', '', '53'], ['52', '39', '20']]\", 18, 71]", "A*_args": "[\"[['', '60', ''], ['', '', '53'], ['52', '39', '20']]\", \"18\", \"71\"]"}
{"diff_sorted_id": "39", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 24 to 50. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 174, 158, None for columns 1 to 2 respectively, and the sums of rows must be None, 158, 131, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 156. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '35' 'x' 'x']\n ['43' 'x' '41' '30']\n ['x' '46' '33' 'x']\n ['x' '49' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 24], [0, 2, 36], [0, 3, 29], [1, 1, 44], [2, 0, 25], [2, 3, 27], [3, 0, 40], [3, 2, 48], [3, 3, 26]]", "opt_solution_cost": "576", "opt_solution_compute_t": "7.876656532287598", "solution_depth": "9", "max_successor_states": "39", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '35', '', ''], ['43', '', '41', '30'], ['', '46', '33', ''], ['', '49', '', '']]\", 4, 24, 50]", "is_correct_args": "[\"[['', '35', '', ''], ['43', '', '41', '30'], ['', '46', '33', ''], ['', '49', '', '']]\", 24, 50, [1, 3], [1, 3], [174, 158], [158, 131], 156]", "A*_args": "[\"[['', '35', '', ''], ['43', '', '41', '30'], ['', '46', '33', ''], ['', '49', '', '']]\", \"24\", \"50\", \"[None, 174, 158, None]\", \"[None, 158, 131, None]\", \"156\"]"}
{"diff_sorted_id": "39", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 8, 1: 8, 2: 1, 3: 2, 4: 9, 5: 4, 6: 7, 7: 8}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Green', 'Green', 'Black', 'Blue', 'Black'], [], [], [], ['Yellow', 'Red', 'Black', 'Red', 'Blue'], ['Yellow', 'Blue', 'Red', 'Black', 'Blue'], ['Red', 'Green', 'Green', 'Yellow', 'Yellow'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[0, 1], [0, 1], [6, 2], [6, 1], [6, 1], [5, 6], [5, 7], [4, 6], [5, 2], [5, 3], [7, 5], [0, 3], [0, 5], [4, 2], [4, 3], [4, 2], [4, 5], [0, 3]]", "opt_solution_cost": "78", "opt_solution_compute_t": "4.903253078460693", "solution_depth": "18", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[\"Green\", \"Green\", \"Black\", \"Blue\", \"Black\"], [], [], [], [\"Yellow\", \"Red\", \"Black\", \"Red\", \"Blue\"], [\"Yellow\", \"Blue\", \"Red\", \"Black\", \"Blue\"], [\"Red\", \"Green\", \"Green\", \"Yellow\", \"Yellow\"], []], 5, {\"0\": 8, \"1\": 8, \"2\": 1, \"3\": 2, \"4\": 9, \"5\": 4, \"6\": 7, \"7\": 8}]", "is_correct_args": "[[[\"Green\", \"Green\", \"Black\", \"Blue\", \"Black\"], [], [], [], [\"Yellow\", \"Red\", \"Black\", \"Red\", \"Blue\"], [\"Yellow\", \"Blue\", \"Red\", \"Black\", \"Blue\"], [\"Red\", \"Green\", \"Green\", \"Yellow\", \"Yellow\"], []], 5, {\"0\": 8, \"1\": 8, \"2\": 1, \"3\": 2, \"4\": 9, \"5\": 4, \"6\": 7, \"7\": 8}, 4]", "A*_args": "[\"[['Green', 'Green', 'Black', 'Blue', 'Black'], [], [], [], ['Yellow', 'Red', 'Black', 'Red', 'Blue'], ['Yellow', 'Blue', 'Red', 'Black', 'Blue'], ['Red', 'Green', 'Green', 'Yellow', 'Yellow'], []]\", \"{0: 8, 1: 8, 2: 1, 3: 2, 4: 9, 5: 4, 6: 7, 7: 8}\", \"5\", \"4\"]"}
{"diff_sorted_id": "39", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 1) to his destination workshop at index (5, 10), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 4, and district 3 covering rows 5 to 10. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[15 8 18 3 19 x 17 x x x x]\n[19 16 x 18 20 2 5 7 11 12 3]\n[18 x 18 1 2 x x x 12 16 4]\n[9 20 4 19 5 15 x x x 6 4]\n[x 18 8 1 x 7 1 7 10 1 4]\n[x 18 x 18 19 9 18 5 15 1 7]\n[3 x 12 14 x x x x 1 x x]\n[x 12 6 x 6 x 1 x 1 7 x]\n[x 5 10 14 2 x x 7 11 3 x]\n[6 9 13 x x x x x x x 3]\n[19 12 x 15 x 14 x 9 x x 19]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "3", "opt_solution": "[[3, 1], [3, 2], [2, 2], [2, 3], [2, 4], [3, 4], [3, 5], [4, 5], [4, 6], [4, 7], [4, 8], [4, 9], [5, 9], [5, 10]]", "opt_solution_cost": "79", "opt_solution_compute_t": "0.028283357620239258", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"15\", \"8\", \"18\", \"3\", \"19\", \"x\", \"17\", \"x\", \"x\", \"x\", \"x\"], [\"19\", \"16\", \"x\", \"18\", \"20\", \"2\", \"5\", \"7\", \"11\", \"12\", \"3\"], [\"18\", \"x\", \"18\", \"1\", \"2\", \"x\", \"x\", \"x\", \"12\", \"16\", \"4\"], [\"9\", \"20\", \"4\", \"19\", \"5\", \"15\", \"x\", \"x\", \"x\", \"6\", \"4\"], [\"x\", \"18\", \"8\", \"1\", \"x\", \"7\", \"1\", \"7\", \"10\", \"1\", \"4\"], [\"x\", \"18\", \"x\", \"18\", \"19\", \"9\", \"18\", \"5\", \"15\", \"1\", \"7\"], [\"3\", \"x\", \"12\", \"14\", \"x\", \"x\", \"x\", \"x\", \"1\", \"x\", \"x\"], [\"x\", \"12\", \"6\", \"x\", \"6\", \"x\", \"1\", \"x\", \"1\", \"7\", \"x\"], [\"x\", \"5\", \"10\", \"14\", \"2\", \"x\", \"x\", \"7\", \"11\", \"3\", \"x\"], [\"6\", \"9\", \"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"3\"], [\"19\", \"12\", \"x\", \"15\", \"x\", \"14\", \"x\", \"9\", \"x\", \"x\", \"19\"]]]", "is_correct_args": "[[[\"15\", \"8\", \"18\", \"3\", \"19\", \"x\", \"17\", \"x\", \"x\", \"x\", \"x\"], [\"19\", \"16\", \"x\", \"18\", \"20\", \"2\", \"5\", \"7\", \"11\", \"12\", \"3\"], [\"18\", \"x\", \"18\", \"1\", \"2\", \"x\", \"x\", \"x\", \"12\", \"16\", \"4\"], [\"9\", \"20\", \"4\", \"19\", \"5\", \"15\", \"x\", \"x\", \"x\", \"6\", \"4\"], [\"x\", \"18\", \"8\", \"1\", \"x\", \"7\", \"1\", \"7\", \"10\", \"1\", \"4\"], [\"x\", \"18\", \"x\", \"18\", \"19\", \"9\", \"18\", \"5\", \"15\", \"1\", \"7\"], [\"3\", \"x\", \"12\", \"14\", \"x\", \"x\", \"x\", \"x\", \"1\", \"x\", \"x\"], [\"x\", \"12\", \"6\", \"x\", \"6\", \"x\", \"1\", \"x\", \"1\", \"7\", \"x\"], [\"x\", \"5\", \"10\", \"14\", \"2\", \"x\", \"x\", \"7\", \"11\", \"3\", \"x\"], [\"6\", \"9\", \"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"3\"], [\"19\", \"12\", \"x\", \"15\", \"x\", \"14\", \"x\", \"9\", \"x\", \"x\", \"19\"]], [3, 1], [5, 10], 2, 4]", "A*_args": "[\"[['15', '8', '18', '3', '19', 'x', '17', 'x', 'x', 'x', 'x'], ['19', '16', 'x', '18', '20', '2', '5', '7', '11', '12', '3'], ['18', 'x', '18', '1', '2', 'x', 'x', 'x', '12', '16', '4'], ['9', '20', '4', '19', '5', '15', 'x', 'x', 'x', '6', '4'], ['x', '18', '8', '1', 'x', '7', '1', '7', '10', '1', '4'], ['x', '18', 'x', '18', '19', '9', '18', '5', '15', '1', '7'], ['3', 'x', '12', '14', 'x', 'x', 'x', 'x', '1', 'x', 'x'], ['x', '12', '6', 'x', '6', 'x', '1', 'x', '1', '7', 'x'], ['x', '5', '10', '14', '2', 'x', 'x', '7', '11', '3', 'x'], ['6', '9', '13', 'x', 'x', 'x', 'x', 'x', 'x', 'x', '3'], ['19', '12', 'x', '15', 'x', '14', 'x', '9', 'x', 'x', '19']]\", \"(3, 1)\", \"(5, 10)\", \"2\", \"4\"]"}
{"diff_sorted_id": "39", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 11x11. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (9, 9) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (0, 3). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 1 0 0 0 0 0 0 0 0\n0 0 0 1 0 1 0 0 0 0 0\n0 1 1 1 0 1 0 1 1 1 0\n1 1 0 0 0 0 0 0 1 1 0\n0 0 0 1 1 1 1 1 0 1 0\n1 1 0 0 1 1 1 1 0 1 0\n1 1 1 1 1 0 1 1 0 0 0\n1 1 1 0 1 0 0 1 1 0 0\n1 1 1 0 1 0 1 1 0 1 0\n1 1 1 0 0 0 1 1 0 0 1\n0 1 1 1 0 1 0 0 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[[9, 9], [8, 8], [7, 9], [6, 9], [6, 8], [5, 8], [4, 8], [3, 7], [3, 6], [3, 5], [3, 4], [2, 4], [1, 4], [0, 4], [0, 3]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.025874614715576172", "solution_depth": "15", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0], [1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0], [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0], [1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0], [1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0], [1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1], [0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1]]\", 3]", "is_correct_args": "[\"[[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0], [1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0], [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0], [1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0], [1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0], [1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1], [0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1]]\", [9, 9], [0, 3], 3]", "A*_args": "[\"[[0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0], [1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0], [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0], [1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0], [1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0], [1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1], [0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1]]\", \"(9, 9)\", \"(0, 3)\", \"3\"]"}
{"diff_sorted_id": "39", "problem_statement": "Given 9 labeled water jugs with capacities 76, 63, 111, 59, 11, 108, 16, 66, 75, 67 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 191, 269, 328 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 66, 3], [\"+\", 75, 3], [\"+\", 76, 3], [\"+\", 111, 3], [\"+\", 59, 2], [\"+\", 75, 2], [\"+\", 76, 2], [\"+\", 59, 2], [\"+\", 75, 1], [\"+\", 108, 1], [\"-\", 67, 1], [\"+\", 75, 1]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.045966386795043945", "solution_depth": "12", "max_successor_states": "60", "num_vars_per_state": "3", "is_feasible_args": "[[76, 63, 111, 59, 11, 108, 16, 66, 75, 67], [191, 269, 328]]", "is_correct_args": "[[76, 63, 111, 59, 11, 108, 16, 66, 75, 67], [191, 269, 328]]", "A*_args": "[\"[76, 63, 111, 59, 11, 108, 16, 66, 75, 67]\", \"[191, 269, 328]\"]"}
{"diff_sorted_id": "40", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[28, 11, 50, 15], [94, 93, '_', 26], [34, 7, 3, 82]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[26, 82, 3, 7, 34, 94, 93, 11, 28, 93, 94, 34, 11, 26, 82, 15, 50, 82, 26, 28, 93, 94, 34, 11, 7, 3]", "opt_solution_cost": "26", "opt_solution_compute_t": "0.45993494987487793", "solution_depth": "26", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[28, 11, 50, 15], [94, 93, \"_\", 26], [34, 7, 3, 82]]]", "is_correct_args": "[[[28, 11, 50, 15], [94, 93, \"_\", 26], [34, 7, 3, 82]]]", "A*_args": "[\"[[28, 11, 50, 15], [94, 93, '_', 26], [34, 7, 3, 82]]\"]"}
{"diff_sorted_id": "40", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: nolle, yapman, pitaya, crawly   The initial board: [['a', 'n', '_', 'l', 'l', 'e'], ['y', 'p', 'p', 'o', 'a', 'n'], ['r', 'i', 'm', 'a', 'y', 'a'], ['c', 't', 'a', 'w', 'l', 'y']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "6", "opt_solution_compute_t": "0.2233717441558838", "solution_depth": "6", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"a\", \"n\", \"_\", \"l\", \"l\", \"e\"], [\"y\", \"p\", \"p\", \"o\", \"a\", \"n\"], [\"r\", \"i\", \"m\", \"a\", \"y\", \"a\"], [\"c\", \"t\", \"a\", \"w\", \"l\", \"y\"]]]", "is_correct_args": "[[[\"a\", \"n\", \"_\", \"l\", \"l\", \"e\"], [\"y\", \"p\", \"p\", \"o\", \"a\", \"n\"], [\"r\", \"i\", \"m\", \"a\", \"y\", \"a\"], [\"c\", \"t\", \"a\", \"w\", \"l\", \"y\"]], [\"nolle\", \"yapman\", \"pitaya\", \"crawly\"]]", "A*_args": "[\"[['a', 'n', '_', 'l', 'l', 'e'], ['y', 'p', 'p', 'o', 'a', 'n'], ['r', 'i', 'm', 'a', 'y', 'a'], ['c', 't', 'a', 'w', 'l', 'y']]\", \"['nolle', 'yapman', 'pitaya', 'crawly']\"]"}
{"diff_sorted_id": "40", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'F'. Our task is to visit city R and city A excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from A and R, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  R L F E D Q G U H T Z A \nR 0 0 0 1 0 0 1 0 0 0 1 0 \nL 0 0 0 0 0 0 1 0 0 0 0 1 \nF 0 0 0 0 0 1 0 0 0 0 0 0 \nE 0 0 0 0 0 1 0 1 0 0 0 0 \nD 1 0 0 1 0 0 0 0 1 0 0 1 \nQ 1 1 0 0 0 0 0 1 1 0 0 0 \nG 0 1 1 1 1 0 0 1 1 0 0 0 \nU 0 0 0 0 1 0 0 0 1 0 1 0 \nH 1 0 1 0 0 0 0 0 0 0 0 0 \nT 0 1 0 0 1 0 0 0 1 0 1 0 \nZ 1 0 1 0 1 1 0 0 1 0 0 0 \nA 0 0 0 0 1 1 0 0 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[\"F\", \"Q\", \"R\", \"Z\", \"R\", \"G\", \"L\", \"A\", \"D\", \"A\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.030649185180664062", "solution_depth": "10", "max_successor_states": "12", "num_vars_per_state": "15", "is_feasible_args": "[[[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0]], [\"R\", \"L\", \"F\", \"E\", \"D\", \"Q\", \"G\", \"U\", \"H\", \"T\", \"Z\", \"A\"], \"R\", \"A\"]", "is_correct_args": "[[[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0]], [\"R\", \"L\", \"F\", \"E\", \"D\", \"Q\", \"G\", \"U\", \"H\", \"T\", \"Z\", \"A\"], \"F\", \"R\", \"A\"]", "A*_args": "[\"[[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0]]\", \"['R', 'L', 'F', 'E', 'D', 'Q', 'G', 'U', 'H', 'T', 'Z', 'A']\", \"['F']\", \"['R', 'A']\"]"}
{"diff_sorted_id": "40", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [25, 22, 26, 12, 18, 12, 5, 6, 6, 21, 28, 26, 6, 26, 9, 11, 27, 24, 16, 1, 12, 5, 10, 23, 11, 10, 28, 2, 3, 7, 23, 28, 27, 12, 3, 3, 27, 21, 13, 8, 18, 25, 6, 7, 9, 25, 18, 18, 23, 12, 11, 15, 2, 16], such that the sum of the chosen coins adds up to 289. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {10: 6, 24: 14, 5: 3, 3: 1, 16: 6, 27: 10, 13: 1, 12: 4, 21: 17, 8: 2, 28: 10, 6: 3, 1: 1, 18: 2, 25: 14, 11: 3, 23: 7, 7: 6, 26: 16, 15: 4, 2: 1, 9: 3, 22: 8}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "33", "opt_solution": "[18, 23, 18, 23, 18, 23, 18, 8, 11, 15, 2, 11, 11, 27, 12, 2, 3, 3, 9, 9, 13, 12]", "opt_solution_cost": "73", "opt_solution_compute_t": "0.06098175048828125", "solution_depth": "22", "max_successor_states": "54", "num_vars_per_state": "54", "is_feasible_args": "[[25, 22, 26, 12, 18, 12, 5, 6, 6, 21, 28, 26, 6, 26, 9, 11, 27, 24, 16, 1, 12, 5, 10, 23, 11, 10, 28, 2, 3, 7, 23, 28, 27, 12, 3, 3, 27, 21, 13, 8, 18, 25, 6, 7, 9, 25, 18, 18, 23, 12, 11, 15, 2, 16]]", "is_correct_args": "[[25, 22, 26, 12, 18, 12, 5, 6, 6, 21, 28, 26, 6, 26, 9, 11, 27, 24, 16, 1, 12, 5, 10, 23, 11, 10, 28, 2, 3, 7, 23, 28, 27, 12, 3, 3, 27, 21, 13, 8, 18, 25, 6, 7, 9, 25, 18, 18, 23, 12, 11, 15, 2, 16], {\"10\": 6, \"24\": 14, \"5\": 3, \"3\": 1, \"16\": 6, \"27\": 10, \"13\": 1, \"12\": 4, \"21\": 17, \"8\": 2, \"28\": 10, \"6\": 3, \"1\": 1, \"18\": 2, \"25\": 14, \"11\": 3, \"23\": 7, \"7\": 6, \"26\": 16, \"15\": 4, \"2\": 1, \"9\": 3, \"22\": 8}, 289]", "A*_args": "[\"[25, 22, 26, 12, 18, 12, 5, 6, 6, 21, 28, 26, 6, 26, 9, 11, 27, 24, 16, 1, 12, 5, 10, 23, 11, 10, 28, 2, 3, 7, 23, 28, 27, 12, 3, 3, 27, 21, 13, 8, 18, 25, 6, 7, 9, 25, 18, 18, 23, 12, 11, 15, 2, 16]\", \"{10: 6, 24: 14, 5: 3, 3: 1, 16: 6, 27: 10, 13: 1, 12: 4, 21: 17, 8: 2, 28: 10, 6: 3, 1: 1, 18: 2, 25: 14, 11: 3, 23: 7, 7: 6, 26: 16, 15: 4, 2: 1, 9: 3, 22: 8}\", \"289\"]"}
{"diff_sorted_id": "40", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Green', 'Blue'], ['Red', 'Blue', 'Green', 'Green'], ['Red', 'Red', 'Red', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[0, 2], [1, 2], [1, 2], [0, 1], [0, 1], [2, 1], [0, 1], [2, 0], [2, 1], [2, 0], [2, 0], [2, 0], [1, 2], [1, 2], [1, 2]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.6760032176971436", "solution_depth": "15", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Green\", \"Blue\"], [\"Red\", \"Blue\", \"Green\", \"Green\"], [\"Red\", \"Red\", \"Red\", \"Blue\"]], 7]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Green\", \"Blue\"], [\"Red\", \"Blue\", \"Green\", \"Green\"], [\"Red\", \"Red\", \"Red\", \"Blue\"]], 7]", "A*_args": "[\"[['Blue', 'Green', 'Green', 'Blue'], ['Red', 'Blue', 'Green', 'Green'], ['Red', 'Red', 'Red', 'Blue']]\", \"7\"]"}
{"diff_sorted_id": "40", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 34 to 87 (34 included in the range but 87 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' 'x']\n ['65' 'x' 'x']\n ['79' '73' '50']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 0, 34], [0, 1, 35], [0, 2, 36], [1, 1, 38], [1, 2, 37]]", "opt_solution_cost": "350", "opt_solution_compute_t": "0.1763606071472168", "solution_depth": "5", "max_successor_states": "53", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['65', '', ''], ['79', '73', '50']]\", 34, 87]", "is_correct_args": "[\"[['', '', ''], ['65', '', ''], ['79', '73', '50']]\", 34, 87]", "A*_args": "[\"[['', '', ''], ['65', '', ''], ['79', '73', '50']]\", \"34\", \"87\"]"}
{"diff_sorted_id": "40", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 24 to 50. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 149, 178, None for columns 1 to 2 respectively, and the sums of rows must be None, 135, 130, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 151. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['38' 'x' 'x' 'x']\n ['x' 'x' 'x' 'x']\n ['x' '39' '40' '27']\n ['32' '46' 'x' '25']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 1, 30], [0, 2, 42], [0, 3, 33], [1, 0, 26], [1, 1, 34], [1, 2, 47], [1, 3, 28], [2, 0, 24], [3, 2, 49]]", "opt_solution_cost": "560", "opt_solution_compute_t": "11.717026948928833", "solution_depth": "9", "max_successor_states": "39", "num_vars_per_state": "9", "is_feasible_args": "[\"[['38', '', '', ''], ['', '', '', ''], ['', '39', '40', '27'], ['32', '46', '', '25']]\", 4, 24, 50]", "is_correct_args": "[\"[['38', '', '', ''], ['', '', '', ''], ['', '39', '40', '27'], ['32', '46', '', '25']]\", 24, 50, [1, 3], [1, 3], [149, 178], [135, 130], 151]", "A*_args": "[\"[['38', '', '', ''], ['', '', '', ''], ['', '39', '40', '27'], ['32', '46', '', '25']]\", \"24\", \"50\", \"[None, 149, 178, None]\", \"[None, 135, 130, None]\", \"151\"]"}
{"diff_sorted_id": "40", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 5, 1: 5, 2: 1, 3: 7, 4: 7, 5: 9, 6: 1, 7: 6}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], ['Green', 'Yellow', 'Black', 'Red', 'Black'], ['Black', 'Red', 'Yellow', 'Blue', 'Yellow'], ['Green', 'Blue', 'Blue', 'Red', 'Black'], [], [], ['Red', 'Green', 'Blue', 'Green', 'Yellow']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[2, 0], [2, 5], [4, 0], [4, 6], [4, 6], [4, 1], [3, 4], [2, 4], [2, 1], [2, 4], [3, 1], [7, 1], [7, 0], [7, 6], [7, 0], [3, 2], [3, 6], [3, 2], [5, 2], [7, 2]]", "opt_solution_cost": "78", "opt_solution_compute_t": "9.45132565498352", "solution_depth": "20", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[], [], [\"Green\", \"Yellow\", \"Black\", \"Red\", \"Black\"], [\"Black\", \"Red\", \"Yellow\", \"Blue\", \"Yellow\"], [\"Green\", \"Blue\", \"Blue\", \"Red\", \"Black\"], [], [], [\"Red\", \"Green\", \"Blue\", \"Green\", \"Yellow\"]], 5, {\"0\": 5, \"1\": 5, \"2\": 1, \"3\": 7, \"4\": 7, \"5\": 9, \"6\": 1, \"7\": 6}]", "is_correct_args": "[[[], [], [\"Green\", \"Yellow\", \"Black\", \"Red\", \"Black\"], [\"Black\", \"Red\", \"Yellow\", \"Blue\", \"Yellow\"], [\"Green\", \"Blue\", \"Blue\", \"Red\", \"Black\"], [], [], [\"Red\", \"Green\", \"Blue\", \"Green\", \"Yellow\"]], 5, {\"0\": 5, \"1\": 5, \"2\": 1, \"3\": 7, \"4\": 7, \"5\": 9, \"6\": 1, \"7\": 6}, 4]", "A*_args": "[\"[[], [], ['Green', 'Yellow', 'Black', 'Red', 'Black'], ['Black', 'Red', 'Yellow', 'Blue', 'Yellow'], ['Green', 'Blue', 'Blue', 'Red', 'Black'], [], [], ['Red', 'Green', 'Blue', 'Green', 'Yellow']]\", \"{0: 5, 1: 5, 2: 1, 3: 7, 4: 7, 5: 9, 6: 1, 7: 6}\", \"5\", \"4\"]"}
{"diff_sorted_id": "40", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 10) to his destination workshop at index (5, 1), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 4, and district 3 covering rows 5 to 10. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 10 x 8 13 8 4 3 15 x 17]\n[9 x 6 4 17 x 16 3 19 x x]\n[8 3 18 x x 3 x 7 12 16 17]\n[8 x x 13 x 7 x 8 x 12 9]\n[2 9 x x 9 4 18 x x 11 x]\n[14 20 x x x x 10 x x 7 x]\n[x x 18 16 12 10 x x 10 x x]\n[x x 16 x x 10 x x 3 18 18]\n[x x x x x x 13 3 x x x]\n[5 13 1 x x 8 x 19 x x x]\n[x x 16 x x 7 18 4 11 x 16]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "3", "opt_solution": "[[3, 10], [3, 9], [2, 9], [2, 8], [2, 7], [1, 7], [0, 7], [0, 6], [0, 5], [0, 4], [0, 3], [1, 3], [1, 2], [2, 2], [2, 1], [2, 0], [3, 0], [4, 0], [4, 1], [5, 1]]", "opt_solution_cost": "164", "opt_solution_compute_t": "0.028056621551513672", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"10\", \"x\", \"8\", \"13\", \"8\", \"4\", \"3\", \"15\", \"x\", \"17\"], [\"9\", \"x\", \"6\", \"4\", \"17\", \"x\", \"16\", \"3\", \"19\", \"x\", \"x\"], [\"8\", \"3\", \"18\", \"x\", \"x\", \"3\", \"x\", \"7\", \"12\", \"16\", \"17\"], [\"8\", \"x\", \"x\", \"13\", \"x\", \"7\", \"x\", \"8\", \"x\", \"12\", \"9\"], [\"2\", \"9\", \"x\", \"x\", \"9\", \"4\", \"18\", \"x\", \"x\", \"11\", \"x\"], [\"14\", \"20\", \"x\", \"x\", \"x\", \"x\", \"10\", \"x\", \"x\", \"7\", \"x\"], [\"x\", \"x\", \"18\", \"16\", \"12\", \"10\", \"x\", \"x\", \"10\", \"x\", \"x\"], [\"x\", \"x\", \"16\", \"x\", \"x\", \"10\", \"x\", \"x\", \"3\", \"18\", \"18\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"13\", \"3\", \"x\", \"x\", \"x\"], [\"5\", \"13\", \"1\", \"x\", \"x\", \"8\", \"x\", \"19\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"16\", \"x\", \"x\", \"7\", \"18\", \"4\", \"11\", \"x\", \"16\"]]]", "is_correct_args": "[[[\"x\", \"10\", \"x\", \"8\", \"13\", \"8\", \"4\", \"3\", \"15\", \"x\", \"17\"], [\"9\", \"x\", \"6\", \"4\", \"17\", \"x\", \"16\", \"3\", \"19\", \"x\", \"x\"], [\"8\", \"3\", \"18\", \"x\", \"x\", \"3\", \"x\", \"7\", \"12\", \"16\", \"17\"], [\"8\", \"x\", \"x\", \"13\", \"x\", \"7\", \"x\", \"8\", \"x\", \"12\", \"9\"], [\"2\", \"9\", \"x\", \"x\", \"9\", \"4\", \"18\", \"x\", \"x\", \"11\", \"x\"], [\"14\", \"20\", \"x\", \"x\", \"x\", \"x\", \"10\", \"x\", \"x\", \"7\", \"x\"], [\"x\", \"x\", \"18\", \"16\", \"12\", \"10\", \"x\", \"x\", \"10\", \"x\", \"x\"], [\"x\", \"x\", \"16\", \"x\", \"x\", \"10\", \"x\", \"x\", \"3\", \"18\", \"18\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"13\", \"3\", \"x\", \"x\", \"x\"], [\"5\", \"13\", \"1\", \"x\", \"x\", \"8\", \"x\", \"19\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"16\", \"x\", \"x\", \"7\", \"18\", \"4\", \"11\", \"x\", \"16\"]], [3, 10], [5, 1], 1, 4]", "A*_args": "[\"[['x', '10', 'x', '8', '13', '8', '4', '3', '15', 'x', '17'], ['9', 'x', '6', '4', '17', 'x', '16', '3', '19', 'x', 'x'], ['8', '3', '18', 'x', 'x', '3', 'x', '7', '12', '16', '17'], ['8', 'x', 'x', '13', 'x', '7', 'x', '8', 'x', '12', '9'], ['2', '9', 'x', 'x', '9', '4', '18', 'x', 'x', '11', 'x'], ['14', '20', 'x', 'x', 'x', 'x', '10', 'x', 'x', '7', 'x'], ['x', 'x', '18', '16', '12', '10', 'x', 'x', '10', 'x', 'x'], ['x', 'x', '16', 'x', 'x', '10', 'x', 'x', '3', '18', '18'], ['x', 'x', 'x', 'x', 'x', 'x', '13', '3', 'x', 'x', 'x'], ['5', '13', '1', 'x', 'x', '8', 'x', '19', 'x', 'x', 'x'], ['x', 'x', '16', 'x', 'x', '7', '18', '4', '11', 'x', '16']]\", \"(3, 10)\", \"(5, 1)\", \"1\", \"4\"]"}
{"diff_sorted_id": "40", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 11x11. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (9, 9) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (2, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 0 1 1 0 1 0 1 1\n1 0 1 1 1 0 1 1 1 1 1\n0 1 0 0 0 0 1 1 1 1 1\n0 1 0 1 1 0 1 1 1 1 0\n0 0 0 1 1 1 1 1 1 0 0\n1 0 0 0 1 1 0 0 0 1 1\n0 0 1 0 0 0 1 0 1 1 0\n1 1 1 1 0 0 0 0 1 1 1\n0 1 0 0 1 1 0 0 0 0 0\n1 0 0 1 1 1 1 0 0 0 1\n0 0 1 1 1 1 1 1 0 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[[9, 9], [8, 8], [7, 7], [7, 6], [6, 5], [6, 4], [6, 3], [5, 3], [5, 2], [4, 2], [4, 1], [4, 0], [3, 0], [2, 0]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.03258109092712402", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1], [0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1], [0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1]]\", 3]", "is_correct_args": "[\"[[1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1], [0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1], [0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1]]\", [9, 9], [2, 0], 3]", "A*_args": "[\"[[1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1], [0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1], [0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1]]\", \"(9, 9)\", \"(2, 0)\", \"3\"]"}
{"diff_sorted_id": "40", "problem_statement": "Given 9 labeled water jugs with capacities 62, 144, 80, 72, 100, 127, 18, 82, 42, 99 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 258, 310, 514 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 82, 3], [\"+\", 144, 3], [\"+\", 144, 3], [\"+\", 144, 3], [\"+\", 62, 2], [\"+\", 144, 2], [\"+\", 42, 2], [\"+\", 62, 2], [\"+\", 42, 1], [\"+\", 72, 1], [\"+\", 144, 1]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.03391599655151367", "solution_depth": "11", "max_successor_states": "60", "num_vars_per_state": "3", "is_feasible_args": "[[62, 144, 80, 72, 100, 127, 18, 82, 42, 99], [258, 310, 514]]", "is_correct_args": "[[62, 144, 80, 72, 100, 127, 18, 82, 42, 99], [258, 310, 514]]", "A*_args": "[\"[62, 144, 80, 72, 100, 127, 18, 82, 42, 99]\", \"[258, 310, 514]\"]"}
{"diff_sorted_id": "41", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[81, 10, 54, '_'], [89, 77, 33, 29], [26, 44, 61, 18]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[54, 33, 61, 18, 29, 54, 33, 61, 54, 33, 61, 10, 77, 54, 10, 77, 81, 89, 54, 44, 18, 10, 33, 29]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.06885409355163574", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[81, 10, 54, \"_\"], [89, 77, 33, 29], [26, 44, 61, 18]]]", "is_correct_args": "[[[81, 10, 54, \"_\"], [89, 77, 33, 29], [26, 44, 61, 18]]]", "A*_args": "[\"[[81, 10, 54, '_'], [89, 77, 33, 29], [26, 44, 61, 18]]\"]"}
{"diff_sorted_id": "41", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: alias, doocot, cerite, commie   The initial board: [['o', 'a', '_', 'i', 't', 's'], ['d', 'r', 'o', 'o', 'o', 'a'], ['c', 'e', 'm', 'i', 'l', 'e'], ['c', 'c', 'm', 't', 'i', 'e']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-left\"]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.3230454921722412", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"o\", \"a\", \"_\", \"i\", \"t\", \"s\"], [\"d\", \"r\", \"o\", \"o\", \"o\", \"a\"], [\"c\", \"e\", \"m\", \"i\", \"l\", \"e\"], [\"c\", \"c\", \"m\", \"t\", \"i\", \"e\"]]]", "is_correct_args": "[[[\"o\", \"a\", \"_\", \"i\", \"t\", \"s\"], [\"d\", \"r\", \"o\", \"o\", \"o\", \"a\"], [\"c\", \"e\", \"m\", \"i\", \"l\", \"e\"], [\"c\", \"c\", \"m\", \"t\", \"i\", \"e\"]], [\"alias\", \"doocot\", \"cerite\", \"commie\"]]", "A*_args": "[\"[['o', 'a', '_', 'i', 't', 's'], ['d', 'r', 'o', 'o', 'o', 'a'], ['c', 'e', 'm', 'i', 'l', 'e'], ['c', 'c', 'm', 't', 'i', 'e']]\", \"['alias', 'doocot', 'cerite', 'commie']\"]"}
{"diff_sorted_id": "41", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'E'. Our task is to visit city Y and city A excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from A and Y, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  L Y V E A M C Q F Z G O \nL 0 0 0 0 1 1 0 0 0 0 0 0 \nY 0 0 0 0 1 0 0 0 1 0 0 1 \nV 1 0 0 0 0 1 0 1 0 0 0 0 \nE 0 0 0 0 0 0 0 0 0 0 1 0 \nA 0 0 0 1 0 0 1 0 0 0 0 0 \nM 0 0 0 1 1 0 0 1 0 0 1 0 \nC 0 0 0 0 0 1 0 0 0 1 0 0 \nQ 0 1 0 0 1 0 0 0 0 0 0 0 \nF 1 1 1 1 0 1 0 0 0 0 1 0 \nZ 0 1 0 0 0 0 0 0 1 0 0 0 \nG 1 0 1 0 0 0 0 1 0 0 0 0 \nO 1 1 1 1 0 0 1 1 1 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[\"E\", \"G\", \"Q\", \"Y\", \"A\", \"C\", \"Z\", \"Y\", \"A\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.02761673927307129", "solution_depth": "9", "max_successor_states": "12", "num_vars_per_state": "15", "is_feasible_args": "[[[0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0]], [\"L\", \"Y\", \"V\", \"E\", \"A\", \"M\", \"C\", \"Q\", \"F\", \"Z\", \"G\", \"O\"], \"Y\", \"A\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0]], [\"L\", \"Y\", \"V\", \"E\", \"A\", \"M\", \"C\", \"Q\", \"F\", \"Z\", \"G\", \"O\"], \"E\", \"Y\", \"A\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0]]\", \"['L', 'Y', 'V', 'E', 'A', 'M', 'C', 'Q', 'F', 'Z', 'G', 'O']\", \"['E']\", \"['Y', 'A']\"]"}
{"diff_sorted_id": "41", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [20, 27, 20, 26, 2, 19, 25, 5, 14, 28, 7, 4, 20, 25, 9, 7, 3, 9, 27, 23, 2, 17, 25, 19, 10, 2, 8, 15, 3, 6, 24, 6, 22, 3, 10, 3, 2, 24, 7, 16, 2, 24, 21, 5, 23, 25, 10, 5, 20, 14, 24, 12, 11, 11, 13], such that the sum of the chosen coins adds up to 284. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {14: 7, 15: 15, 2: 2, 22: 7, 7: 1, 25: 7, 10: 4, 11: 11, 16: 11, 27: 8, 3: 2, 13: 5, 19: 10, 8: 5, 23: 18, 5: 4, 12: 4, 28: 6, 6: 4, 21: 3, 20: 15, 26: 1, 4: 4, 9: 9, 24: 6, 17: 13}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "34", "opt_solution": "[7, 7, 21, 25, 24, 25, 24, 25, 24, 27, 26, 24, 25]", "opt_solution_cost": "66", "opt_solution_compute_t": "0.05327725410461426", "solution_depth": "13", "max_successor_states": "55", "num_vars_per_state": "55", "is_feasible_args": "[[20, 27, 20, 26, 2, 19, 25, 5, 14, 28, 7, 4, 20, 25, 9, 7, 3, 9, 27, 23, 2, 17, 25, 19, 10, 2, 8, 15, 3, 6, 24, 6, 22, 3, 10, 3, 2, 24, 7, 16, 2, 24, 21, 5, 23, 25, 10, 5, 20, 14, 24, 12, 11, 11, 13]]", "is_correct_args": "[[20, 27, 20, 26, 2, 19, 25, 5, 14, 28, 7, 4, 20, 25, 9, 7, 3, 9, 27, 23, 2, 17, 25, 19, 10, 2, 8, 15, 3, 6, 24, 6, 22, 3, 10, 3, 2, 24, 7, 16, 2, 24, 21, 5, 23, 25, 10, 5, 20, 14, 24, 12, 11, 11, 13], {\"14\": 7, \"15\": 15, \"2\": 2, \"22\": 7, \"7\": 1, \"25\": 7, \"10\": 4, \"11\": 11, \"16\": 11, \"27\": 8, \"3\": 2, \"13\": 5, \"19\": 10, \"8\": 5, \"23\": 18, \"5\": 4, \"12\": 4, \"28\": 6, \"6\": 4, \"21\": 3, \"20\": 15, \"26\": 1, \"4\": 4, \"9\": 9, \"24\": 6, \"17\": 13}, 284]", "A*_args": "[\"[20, 27, 20, 26, 2, 19, 25, 5, 14, 28, 7, 4, 20, 25, 9, 7, 3, 9, 27, 23, 2, 17, 25, 19, 10, 2, 8, 15, 3, 6, 24, 6, 22, 3, 10, 3, 2, 24, 7, 16, 2, 24, 21, 5, 23, 25, 10, 5, 20, 14, 24, 12, 11, 11, 13]\", \"{14: 7, 15: 15, 2: 2, 22: 7, 7: 1, 25: 7, 10: 4, 11: 11, 16: 11, 27: 8, 3: 2, 13: 5, 19: 10, 8: 5, 23: 18, 5: 4, 12: 4, 28: 6, 6: 4, 21: 3, 20: 15, 26: 1, 4: 4, 9: 9, 24: 6, 17: 13}\", \"284\"]"}
{"diff_sorted_id": "41", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Blue', 'Red', 'Blue'], ['Red', 'Green', 'Blue', 'Green'], ['Red', 'Blue', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[0, 1], [0, 2], [0, 1], [2, 0], [2, 1], [2, 0], [2, 0], [1, 2], [1, 2], [1, 0], [1, 2], [1, 0], [1, 2], [0, 1], [0, 1], [0, 1], [2, 0]]", "opt_solution_cost": "17", "opt_solution_compute_t": "2.059692859649658", "solution_depth": "17", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Blue\", \"Red\", \"Blue\"], [\"Red\", \"Green\", \"Blue\", \"Green\"], [\"Red\", \"Blue\", \"Green\", \"Red\"]], 7]", "is_correct_args": "[[[\"Green\", \"Blue\", \"Red\", \"Blue\"], [\"Red\", \"Green\", \"Blue\", \"Green\"], [\"Red\", \"Blue\", \"Green\", \"Red\"]], 7]", "A*_args": "[\"[['Green', 'Blue', 'Red', 'Blue'], ['Red', 'Green', 'Blue', 'Green'], ['Red', 'Blue', 'Green', 'Red']]\", \"7\"]"}
{"diff_sorted_id": "41", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 29 to 82 (29 included in the range but 82 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' 'x']\n ['39' 'x' '50']\n ['32' 'x' '55']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 0, 40], [0, 1, 30], [0, 2, 29], [1, 1, 41], [2, 1, 42]]", "opt_solution_cost": "369", "opt_solution_compute_t": "0.19344615936279297", "solution_depth": "5", "max_successor_states": "53", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', ''], ['39', '', '50'], ['32', '', '55']]\", 29, 82]", "is_correct_args": "[\"[['', '', ''], ['39', '', '50'], ['32', '', '55']]\", 29, 82]", "A*_args": "[\"[['', '', ''], ['39', '', '50'], ['32', '', '55']]\", \"29\", \"82\"]"}
{"diff_sorted_id": "41", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 24 to 50. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 135, 160, None for columns 1 to 2 respectively, and the sums of rows must be None, 125, 164, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 146. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' '40' 'x']\n ['x' '31' 'x' '43']\n ['37' 'x' 'x' '32']\n ['34' '29' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 25], [0, 1, 26], [0, 3, 36], [1, 0, 24], [1, 2, 27], [2, 1, 49], [2, 2, 46], [3, 2, 47], [3, 3, 28]]", "opt_solution_cost": "554", "opt_solution_compute_t": "4.838366508483887", "solution_depth": "9", "max_successor_states": "44", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', '40', ''], ['', '31', '', '43'], ['37', '', '', '32'], ['34', '29', '', '']]\", 4, 24, 50]", "is_correct_args": "[\"[['', '', '40', ''], ['', '31', '', '43'], ['37', '', '', '32'], ['34', '29', '', '']]\", 24, 50, [1, 3], [1, 3], [135, 160], [125, 164], 146]", "A*_args": "[\"[['', '', '40', ''], ['', '31', '', '43'], ['37', '', '', '32'], ['34', '29', '', '']]\", \"24\", \"50\", \"[None, 135, 160, None]\", \"[None, 125, 164, None]\", \"146\"]"}
{"diff_sorted_id": "41", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 2, 1: 1, 2: 2, 3: 8, 4: 4, 5: 3, 6: 6, 7: 3}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Green', 'Blue', 'Yellow', 'Green', 'Blue'], ['Black', 'Green', 'Red', 'Red', 'Black'], [], ['Blue', 'Yellow', 'Red', 'Black', 'Yellow'], [], [], ['Blue', 'Red', 'Black', 'Yellow', 'Green'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[6, 2], [6, 4], [6, 5], [6, 7], [0, 6], [1, 5], [1, 6], [0, 2], [0, 7], [0, 6], [1, 4], [1, 4], [3, 2], [3, 7], [3, 4], [1, 5], [3, 5], [3, 7], [0, 2]]", "opt_solution_cost": "66", "opt_solution_compute_t": "34.940831422805786", "solution_depth": "19", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[\"Green\", \"Blue\", \"Yellow\", \"Green\", \"Blue\"], [\"Black\", \"Green\", \"Red\", \"Red\", \"Black\"], [], [\"Blue\", \"Yellow\", \"Red\", \"Black\", \"Yellow\"], [], [], [\"Blue\", \"Red\", \"Black\", \"Yellow\", \"Green\"], []], 5, {\"0\": 2, \"1\": 1, \"2\": 2, \"3\": 8, \"4\": 4, \"5\": 3, \"6\": 6, \"7\": 3}]", "is_correct_args": "[[[\"Green\", \"Blue\", \"Yellow\", \"Green\", \"Blue\"], [\"Black\", \"Green\", \"Red\", \"Red\", \"Black\"], [], [\"Blue\", \"Yellow\", \"Red\", \"Black\", \"Yellow\"], [], [], [\"Blue\", \"Red\", \"Black\", \"Yellow\", \"Green\"], []], 5, {\"0\": 2, \"1\": 1, \"2\": 2, \"3\": 8, \"4\": 4, \"5\": 3, \"6\": 6, \"7\": 3}, 4]", "A*_args": "[\"[['Green', 'Blue', 'Yellow', 'Green', 'Blue'], ['Black', 'Green', 'Red', 'Red', 'Black'], [], ['Blue', 'Yellow', 'Red', 'Black', 'Yellow'], [], [], ['Blue', 'Red', 'Black', 'Yellow', 'Green'], []]\", \"{0: 2, 1: 1, 2: 2, 3: 8, 4: 4, 5: 3, 6: 6, 7: 3}\", \"5\", \"4\"]"}
{"diff_sorted_id": "41", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (5, 10) to his destination workshop at index (3, 0), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 4, and district 3 covering rows 5 to 10. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[19 7 11 x 3 18 8 x x x x]\n[12 18 6 1 13 12 14 11 13 5 19]\n[11 10 10 18 15 x 12 x 4 17 10]\n[4 3 3 7 x 19 x x x 12 9]\n[x x 6 19 x 4 14 x 9 4 15]\n[4 7 6 5 8 x 15 3 x 16 3]\n[13 x x 1 9 1 9 x x x x]\n[2 13 5 9 5 x 6 x 18 x 3]\n[19 x 2 9 4 13 x x x 16 6]\n[x x x 12 x 7 9 3 9 8 1]\n[x 10 x 12 3 6 x 4 12 4 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "3", "opt_solution": "[[5, 10], [4, 10], [4, 9], [3, 9], [2, 9], [2, 8], [1, 8], [1, 7], [1, 6], [1, 5], [1, 4], [1, 3], [1, 2], [2, 2], [3, 2], [3, 1], [3, 0]]", "opt_solution_cost": "142", "opt_solution_compute_t": "0.02771902084350586", "solution_depth": "17", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"19\", \"7\", \"11\", \"x\", \"3\", \"18\", \"8\", \"x\", \"x\", \"x\", \"x\"], [\"12\", \"18\", \"6\", \"1\", \"13\", \"12\", \"14\", \"11\", \"13\", \"5\", \"19\"], [\"11\", \"10\", \"10\", \"18\", \"15\", \"x\", \"12\", \"x\", \"4\", \"17\", \"10\"], [\"4\", \"3\", \"3\", \"7\", \"x\", \"19\", \"x\", \"x\", \"x\", \"12\", \"9\"], [\"x\", \"x\", \"6\", \"19\", \"x\", \"4\", \"14\", \"x\", \"9\", \"4\", \"15\"], [\"4\", \"7\", \"6\", \"5\", \"8\", \"x\", \"15\", \"3\", \"x\", \"16\", \"3\"], [\"13\", \"x\", \"x\", \"1\", \"9\", \"1\", \"9\", \"x\", \"x\", \"x\", \"x\"], [\"2\", \"13\", \"5\", \"9\", \"5\", \"x\", \"6\", \"x\", \"18\", \"x\", \"3\"], [\"19\", \"x\", \"2\", \"9\", \"4\", \"13\", \"x\", \"x\", \"x\", \"16\", \"6\"], [\"x\", \"x\", \"x\", \"12\", \"x\", \"7\", \"9\", \"3\", \"9\", \"8\", \"1\"], [\"x\", \"10\", \"x\", \"12\", \"3\", \"6\", \"x\", \"4\", \"12\", \"4\", \"x\"]]]", "is_correct_args": "[[[\"19\", \"7\", \"11\", \"x\", \"3\", \"18\", \"8\", \"x\", \"x\", \"x\", \"x\"], [\"12\", \"18\", \"6\", \"1\", \"13\", \"12\", \"14\", \"11\", \"13\", \"5\", \"19\"], [\"11\", \"10\", \"10\", \"18\", \"15\", \"x\", \"12\", \"x\", \"4\", \"17\", \"10\"], [\"4\", \"3\", \"3\", \"7\", \"x\", \"19\", \"x\", \"x\", \"x\", \"12\", \"9\"], [\"x\", \"x\", \"6\", \"19\", \"x\", \"4\", \"14\", \"x\", \"9\", \"4\", \"15\"], [\"4\", \"7\", \"6\", \"5\", \"8\", \"x\", \"15\", \"3\", \"x\", \"16\", \"3\"], [\"13\", \"x\", \"x\", \"1\", \"9\", \"1\", \"9\", \"x\", \"x\", \"x\", \"x\"], [\"2\", \"13\", \"5\", \"9\", \"5\", \"x\", \"6\", \"x\", \"18\", \"x\", \"3\"], [\"19\", \"x\", \"2\", \"9\", \"4\", \"13\", \"x\", \"x\", \"x\", \"16\", \"6\"], [\"x\", \"x\", \"x\", \"12\", \"x\", \"7\", \"9\", \"3\", \"9\", \"8\", \"1\"], [\"x\", \"10\", \"x\", \"12\", \"3\", \"6\", \"x\", \"4\", \"12\", \"4\", \"x\"]], [5, 10], [3, 0], 3, 4]", "A*_args": "[\"[['19', '7', '11', 'x', '3', '18', '8', 'x', 'x', 'x', 'x'], ['12', '18', '6', '1', '13', '12', '14', '11', '13', '5', '19'], ['11', '10', '10', '18', '15', 'x', '12', 'x', '4', '17', '10'], ['4', '3', '3', '7', 'x', '19', 'x', 'x', 'x', '12', '9'], ['x', 'x', '6', '19', 'x', '4', '14', 'x', '9', '4', '15'], ['4', '7', '6', '5', '8', 'x', '15', '3', 'x', '16', '3'], ['13', 'x', 'x', '1', '9', '1', '9', 'x', 'x', 'x', 'x'], ['2', '13', '5', '9', '5', 'x', '6', 'x', '18', 'x', '3'], ['19', 'x', '2', '9', '4', '13', 'x', 'x', 'x', '16', '6'], ['x', 'x', 'x', '12', 'x', '7', '9', '3', '9', '8', '1'], ['x', '10', 'x', '12', '3', '6', 'x', '4', '12', '4', 'x']]\", \"(5, 10)\", \"(3, 0)\", \"3\", \"4\"]"}
{"diff_sorted_id": "41", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 11x11. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (10, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (2, 7). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 0 1 0 1 1 1 1 1 0\n1 1 1 1 0 1 1 1 1 1 1\n1 1 0 0 1 1 1 0 1 1 1\n0 1 0 0 1 1 0 0 0 1 1\n1 1 1 0 1 0 0 0 0 1 0\n1 1 1 0 0 0 1 1 1 0 1\n0 1 1 0 0 0 0 0 1 0 1\n0 1 0 1 0 0 1 1 1 1 1\n1 0 1 0 0 0 0 1 1 0 1\n1 0 0 0 0 0 1 0 1 1 0\n0 1 0 1 1 0 0 1 1 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[[10, 0], [9, 1], [8, 1], [7, 2], [6, 3], [5, 3], [5, 4], [5, 5], [4, 5], [4, 6], [3, 6], [3, 7], [2, 7]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.023111343383789062", "solution_depth": "13", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1], [0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1], [1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0], [1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1], [1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0], [0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1]]\", 3]", "is_correct_args": "[\"[[1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1], [0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1], [1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0], [1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1], [1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0], [0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1]]\", [10, 0], [2, 7], 3]", "A*_args": "[\"[[1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1], [0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1], [1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0], [1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1], [1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0], [0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1]]\", \"(10, 0)\", \"(2, 7)\", \"3\"]"}
{"diff_sorted_id": "41", "problem_statement": "Given 9 labeled water jugs with capacities 80, 69, 12, 52, 107, 53, 82, 95, 108 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 170, 385, 499 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 69, 3], [\"+\", 107, 3], [\"+\", 107, 3], [\"+\", 108, 3], [\"+\", 108, 3], [\"+\", 52, 2], [\"+\", 107, 2], [\"+\", 107, 2], [\"+\", 107, 2], [\"+\", 12, 2], [\"+\", 52, 1], [\"+\", 107, 1], [\"-\", 69, 1], [\"+\", 80, 1]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.027560949325561523", "solution_depth": "14", "max_successor_states": "54", "num_vars_per_state": "3", "is_feasible_args": "[[80, 69, 12, 52, 107, 53, 82, 95, 108], [170, 385, 499]]", "is_correct_args": "[[80, 69, 12, 52, 107, 53, 82, 95, 108], [170, 385, 499]]", "A*_args": "[\"[80, 69, 12, 52, 107, 53, 82, 95, 108]\", \"[170, 385, 499]\"]"}
{"diff_sorted_id": "42", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[74, 37, 2, 22], [4, 21, '_', 54], [33, 70, 9, 11]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[2, 37, 21, 70, 9, 2, 37, 22, 54, 37, 22, 21, 70, 4, 33, 9, 4, 22, 21, 54, 37, 11]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.05596041679382324", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[74, 37, 2, 22], [4, 21, \"_\", 54], [33, 70, 9, 11]]]", "is_correct_args": "[[[74, 37, 2, 22], [4, 21, \"_\", 54], [33, 70, 9, 11]]]", "A*_args": "[\"[[74, 37, 2, 22], [4, 21, '_', 54], [33, 70, 9, 11]]\"]"}
{"diff_sorted_id": "42", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: jerib, zoysia, reesty, griqua   The initial board: [['_', 'j', 'a', 'r', 'e', 'b'], ['z', 'o', 'y', 's', 'i', 'i'], ['r', 'e', 'r', 's', 't', 'y'], ['g', 'e', 'i', 'q', 'u', 'a']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.27234864234924316", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"_\", \"j\", \"a\", \"r\", \"e\", \"b\"], [\"z\", \"o\", \"y\", \"s\", \"i\", \"i\"], [\"r\", \"e\", \"r\", \"s\", \"t\", \"y\"], [\"g\", \"e\", \"i\", \"q\", \"u\", \"a\"]]]", "is_correct_args": "[[[\"_\", \"j\", \"a\", \"r\", \"e\", \"b\"], [\"z\", \"o\", \"y\", \"s\", \"i\", \"i\"], [\"r\", \"e\", \"r\", \"s\", \"t\", \"y\"], [\"g\", \"e\", \"i\", \"q\", \"u\", \"a\"]], [\"jerib\", \"zoysia\", \"reesty\", \"griqua\"]]", "A*_args": "[\"[['_', 'j', 'a', 'r', 'e', 'b'], ['z', 'o', 'y', 's', 'i', 'i'], ['r', 'e', 'r', 's', 't', 'y'], ['g', 'e', 'i', 'q', 'u', 'a']]\", \"['jerib', 'zoysia', 'reesty', 'griqua']\"]"}
{"diff_sorted_id": "42", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'F'. Our task is to visit city H and city N excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from N and H, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  J U T S N F Y C H A M P \nJ 0 0 0 0 0 0 1 0 0 0 1 0 \nU 0 0 1 0 0 0 1 1 0 0 0 1 \nT 1 0 0 0 1 0 0 0 1 0 0 0 \nS 1 1 0 0 0 0 1 0 0 0 0 1 \nN 1 0 0 1 0 0 0 0 0 1 1 0 \nF 0 0 0 0 0 0 0 0 0 1 0 0 \nY 0 0 0 0 0 0 0 0 1 0 0 0 \nC 0 0 1 0 0 1 0 0 0 0 0 0 \nH 1 1 0 1 0 0 0 1 0 0 0 0 \nA 1 0 0 0 0 1 0 0 1 0 1 0 \nM 0 0 1 0 0 0 0 0 1 0 0 0 \nP 0 0 0 0 1 0 0 1 1 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[\"F\", \"A\", \"H\", \"C\", \"T\", \"N\", \"S\", \"P\", \"N\", \"M\", \"H\"]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.03896760940551758", "solution_depth": "11", "max_successor_states": "12", "num_vars_per_state": "15", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0]], [\"J\", \"U\", \"T\", \"S\", \"N\", \"F\", \"Y\", \"C\", \"H\", \"A\", \"M\", \"P\"], \"H\", \"N\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0]], [\"J\", \"U\", \"T\", \"S\", \"N\", \"F\", \"Y\", \"C\", \"H\", \"A\", \"M\", \"P\"], \"F\", \"H\", \"N\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0]]\", \"['J', 'U', 'T', 'S', 'N', 'F', 'Y', 'C', 'H', 'A', 'M', 'P']\", \"['F']\", \"['H', 'N']\"]"}
{"diff_sorted_id": "42", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [24, 10, 24, 3, 21, 7, 21, 26, 8, 14, 24, 5, 13, 10, 25, 6, 9, 4, 18, 4, 15, 4, 10, 23, 6, 13, 26, 20, 8, 10, 29, 27, 27, 20, 2, 15, 9, 9, 25, 8, 2, 27, 5, 22, 19, 26, 2, 29, 12, 9, 6, 12, 2, 15, 5, 16, 3, 29, 19], such that the sum of the chosen coins adds up to 300. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {5: 2, 9: 8, 12: 5, 14: 4, 22: 8, 26: 3, 8: 7, 27: 2, 20: 13, 3: 3, 13: 3, 2: 1, 19: 19, 29: 4, 10: 3, 18: 14, 21: 12, 15: 12, 4: 3, 23: 5, 16: 9, 25: 16, 7: 4, 24: 17, 6: 6}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "35", "opt_solution": "[27, 27, 26, 2, 13, 29, 26, 27, 29, 29, 26, 2, 23, 14]", "opt_solution_cost": "41", "opt_solution_compute_t": "0.06342601776123047", "solution_depth": "14", "max_successor_states": "59", "num_vars_per_state": "59", "is_feasible_args": "[[24, 10, 24, 3, 21, 7, 21, 26, 8, 14, 24, 5, 13, 10, 25, 6, 9, 4, 18, 4, 15, 4, 10, 23, 6, 13, 26, 20, 8, 10, 29, 27, 27, 20, 2, 15, 9, 9, 25, 8, 2, 27, 5, 22, 19, 26, 2, 29, 12, 9, 6, 12, 2, 15, 5, 16, 3, 29, 19]]", "is_correct_args": "[[24, 10, 24, 3, 21, 7, 21, 26, 8, 14, 24, 5, 13, 10, 25, 6, 9, 4, 18, 4, 15, 4, 10, 23, 6, 13, 26, 20, 8, 10, 29, 27, 27, 20, 2, 15, 9, 9, 25, 8, 2, 27, 5, 22, 19, 26, 2, 29, 12, 9, 6, 12, 2, 15, 5, 16, 3, 29, 19], {\"5\": 2, \"9\": 8, \"12\": 5, \"14\": 4, \"22\": 8, \"26\": 3, \"8\": 7, \"27\": 2, \"20\": 13, \"3\": 3, \"13\": 3, \"2\": 1, \"19\": 19, \"29\": 4, \"10\": 3, \"18\": 14, \"21\": 12, \"15\": 12, \"4\": 3, \"23\": 5, \"16\": 9, \"25\": 16, \"7\": 4, \"24\": 17, \"6\": 6}, 300]", "A*_args": "[\"[24, 10, 24, 3, 21, 7, 21, 26, 8, 14, 24, 5, 13, 10, 25, 6, 9, 4, 18, 4, 15, 4, 10, 23, 6, 13, 26, 20, 8, 10, 29, 27, 27, 20, 2, 15, 9, 9, 25, 8, 2, 27, 5, 22, 19, 26, 2, 29, 12, 9, 6, 12, 2, 15, 5, 16, 3, 29, 19]\", \"{5: 2, 9: 8, 12: 5, 14: 4, 22: 8, 26: 3, 8: 7, 27: 2, 20: 13, 3: 3, 13: 3, 2: 1, 19: 19, 29: 4, 10: 3, 18: 14, 21: 12, 15: 12, 4: 3, 23: 5, 16: 9, 25: 16, 7: 4, 24: 17, 6: 6}\", \"300\"]"}
{"diff_sorted_id": "42", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Blue', 'Red'], ['Red', 'Green', 'Blue', 'Red'], ['Green', 'Red', 'Green', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[2, 0], [1, 2], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [0, 2], [0, 1], [0, 1], [0, 2], [0, 1], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [2, 1]]", "opt_solution_cost": "19", "opt_solution_compute_t": "6.271071672439575", "solution_depth": "19", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Blue\", \"Red\"], [\"Red\", \"Green\", \"Blue\", \"Red\"], [\"Green\", \"Red\", \"Green\", \"Blue\"]], 7]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Blue\", \"Red\"], [\"Red\", \"Green\", \"Blue\", \"Red\"], [\"Green\", \"Red\", \"Green\", \"Blue\"]], 7]", "A*_args": "[\"[['Blue', 'Green', 'Blue', 'Red'], ['Red', 'Green', 'Blue', 'Red'], ['Green', 'Red', 'Green', 'Blue']]\", \"7\"]"}
{"diff_sorted_id": "42", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 45 to 98 (45 included in the range but 98 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['46' '80' '90']\n ['51' 'x' 'x']\n ['x' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[1, 1, 49], [1, 2, 47], [2, 0, 52], [2, 1, 48], [2, 2, 45]]", "opt_solution_cost": "538", "opt_solution_compute_t": "0.20381546020507812", "solution_depth": "5", "max_successor_states": "53", "num_vars_per_state": "9", "is_feasible_args": "[\"[['46', '80', '90'], ['51', '', ''], ['', '', '']]\", 45, 98]", "is_correct_args": "[\"[['46', '80', '90'], ['51', '', ''], ['', '', '']]\", 45, 98]", "A*_args": "[\"[['46', '80', '90'], ['51', '', ''], ['', '', '']]\", \"45\", \"98\"]"}
{"diff_sorted_id": "42", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 24 to 50. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 141, 134, None for columns 1 to 2 respectively, and the sums of rows must be None, 133, 150, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 155. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '42' 'x' 'x']\n ['x' '38' 'x' 'x']\n ['x' '36' '46' 'x']\n ['49' '25' '24' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 26], [0, 2, 27], [0, 3, 33], [1, 0, 28], [1, 2, 37], [1, 3, 30], [2, 0, 29], [2, 3, 39], [3, 3, 31]]", "opt_solution_cost": "540", "opt_solution_compute_t": "0.6481747627258301", "solution_depth": "9", "max_successor_states": "44", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '42', '', ''], ['', '38', '', ''], ['', '36', '46', ''], ['49', '25', '24', '']]\", 4, 24, 50]", "is_correct_args": "[\"[['', '42', '', ''], ['', '38', '', ''], ['', '36', '46', ''], ['49', '25', '24', '']]\", 24, 50, [1, 3], [1, 3], [141, 134], [133, 150], 155]", "A*_args": "[\"[['', '42', '', ''], ['', '38', '', ''], ['', '36', '46', ''], ['49', '25', '24', '']]\", \"24\", \"50\", \"[None, 141, 134, None]\", \"[None, 133, 150, None]\", \"155\"]"}
{"diff_sorted_id": "42", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 7, 1: 5, 2: 7, 3: 2, 4: 6, 5: 7, 6: 5, 7: 3}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Blue', 'Black', 'Yellow', 'Black', 'Red'], ['Blue', 'Blue', 'Green', 'Black', 'Yellow'], [], ['Yellow', 'Red', 'Red', 'Green', 'Green'], [], [], ['Red', 'Blue', 'Black', 'Green', 'Yellow'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[0, 7], [6, 4], [6, 7], [3, 2], [3, 4], [3, 4], [1, 7], [1, 7], [1, 3], [1, 5], [6, 5], [6, 3], [0, 5], [0, 1], [0, 5], [0, 4], [2, 1], [6, 1]]", "opt_solution_cost": "90", "opt_solution_compute_t": "0.08126401901245117", "solution_depth": "18", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[\"Blue\", \"Black\", \"Yellow\", \"Black\", \"Red\"], [\"Blue\", \"Blue\", \"Green\", \"Black\", \"Yellow\"], [], [\"Yellow\", \"Red\", \"Red\", \"Green\", \"Green\"], [], [], [\"Red\", \"Blue\", \"Black\", \"Green\", \"Yellow\"], []], 5, {\"0\": 7, \"1\": 5, \"2\": 7, \"3\": 2, \"4\": 6, \"5\": 7, \"6\": 5, \"7\": 3}]", "is_correct_args": "[[[\"Blue\", \"Black\", \"Yellow\", \"Black\", \"Red\"], [\"Blue\", \"Blue\", \"Green\", \"Black\", \"Yellow\"], [], [\"Yellow\", \"Red\", \"Red\", \"Green\", \"Green\"], [], [], [\"Red\", \"Blue\", \"Black\", \"Green\", \"Yellow\"], []], 5, {\"0\": 7, \"1\": 5, \"2\": 7, \"3\": 2, \"4\": 6, \"5\": 7, \"6\": 5, \"7\": 3}, 4]", "A*_args": "[\"[['Blue', 'Black', 'Yellow', 'Black', 'Red'], ['Blue', 'Blue', 'Green', 'Black', 'Yellow'], [], ['Yellow', 'Red', 'Red', 'Green', 'Green'], [], [], ['Red', 'Blue', 'Black', 'Green', 'Yellow'], []]\", \"{0: 7, 1: 5, 2: 7, 3: 2, 4: 6, 5: 7, 6: 5, 7: 3}\", \"5\", \"4\"]"}
{"diff_sorted_id": "42", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (6, 10) to his destination workshop at index (3, 2), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 5, and district 3 covering rows 6 to 10. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[14 x 11 x x 8 15 17 18 x 11]\n[13 9 2 7 9 12 7 x x x 12]\n[x 2 8 13 5 x x 7 18 x x]\n[19 6 1 6 19 13 14 x x 17 x]\n[x 9 6 x x 14 10 x x 5 x]\n[12 x x x 7 17 11 x x 1 x]\n[x 16 x 2 11 15 6 x 14 14 4]\n[x 15 14 11 x 17 20 18 4 16 8]\n[x 3 6 4 1 5 x x 3 7 9]\n[18 14 3 4 x x x 12 15 10 x]\n[x 8 x 1 18 x x x x x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "3", "opt_solution": "[[6, 10], [7, 10], [7, 9], [7, 8], [7, 7], [7, 6], [6, 6], [5, 6], [4, 6], [3, 6], [3, 5], [3, 4], [3, 3], [3, 2]]", "opt_solution_cost": "146", "opt_solution_compute_t": "0.027129411697387695", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"14\", \"x\", \"11\", \"x\", \"x\", \"8\", \"15\", \"17\", \"18\", \"x\", \"11\"], [\"13\", \"9\", \"2\", \"7\", \"9\", \"12\", \"7\", \"x\", \"x\", \"x\", \"12\"], [\"x\", \"2\", \"8\", \"13\", \"5\", \"x\", \"x\", \"7\", \"18\", \"x\", \"x\"], [\"19\", \"6\", \"1\", \"6\", \"19\", \"13\", \"14\", \"x\", \"x\", \"17\", \"x\"], [\"x\", \"9\", \"6\", \"x\", \"x\", \"14\", \"10\", \"x\", \"x\", \"5\", \"x\"], [\"12\", \"x\", \"x\", \"x\", \"7\", \"17\", \"11\", \"x\", \"x\", \"1\", \"x\"], [\"x\", \"16\", \"x\", \"2\", \"11\", \"15\", \"6\", \"x\", \"14\", \"14\", \"4\"], [\"x\", \"15\", \"14\", \"11\", \"x\", \"17\", \"20\", \"18\", \"4\", \"16\", \"8\"], [\"x\", \"3\", \"6\", \"4\", \"1\", \"5\", \"x\", \"x\", \"3\", \"7\", \"9\"], [\"18\", \"14\", \"3\", \"4\", \"x\", \"x\", \"x\", \"12\", \"15\", \"10\", \"x\"], [\"x\", \"8\", \"x\", \"1\", \"18\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"14\", \"x\", \"11\", \"x\", \"x\", \"8\", \"15\", \"17\", \"18\", \"x\", \"11\"], [\"13\", \"9\", \"2\", \"7\", \"9\", \"12\", \"7\", \"x\", \"x\", \"x\", \"12\"], [\"x\", \"2\", \"8\", \"13\", \"5\", \"x\", \"x\", \"7\", \"18\", \"x\", \"x\"], [\"19\", \"6\", \"1\", \"6\", \"19\", \"13\", \"14\", \"x\", \"x\", \"17\", \"x\"], [\"x\", \"9\", \"6\", \"x\", \"x\", \"14\", \"10\", \"x\", \"x\", \"5\", \"x\"], [\"12\", \"x\", \"x\", \"x\", \"7\", \"17\", \"11\", \"x\", \"x\", \"1\", \"x\"], [\"x\", \"16\", \"x\", \"2\", \"11\", \"15\", \"6\", \"x\", \"14\", \"14\", \"4\"], [\"x\", \"15\", \"14\", \"11\", \"x\", \"17\", \"20\", \"18\", \"4\", \"16\", \"8\"], [\"x\", \"3\", \"6\", \"4\", \"1\", \"5\", \"x\", \"x\", \"3\", \"7\", \"9\"], [\"18\", \"14\", \"3\", \"4\", \"x\", \"x\", \"x\", \"12\", \"15\", \"10\", \"x\"], [\"x\", \"8\", \"x\", \"1\", \"18\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"]], [6, 10], [3, 2], 3, 5]", "A*_args": "[\"[['14', 'x', '11', 'x', 'x', '8', '15', '17', '18', 'x', '11'], ['13', '9', '2', '7', '9', '12', '7', 'x', 'x', 'x', '12'], ['x', '2', '8', '13', '5', 'x', 'x', '7', '18', 'x', 'x'], ['19', '6', '1', '6', '19', '13', '14', 'x', 'x', '17', 'x'], ['x', '9', '6', 'x', 'x', '14', '10', 'x', 'x', '5', 'x'], ['12', 'x', 'x', 'x', '7', '17', '11', 'x', 'x', '1', 'x'], ['x', '16', 'x', '2', '11', '15', '6', 'x', '14', '14', '4'], ['x', '15', '14', '11', 'x', '17', '20', '18', '4', '16', '8'], ['x', '3', '6', '4', '1', '5', 'x', 'x', '3', '7', '9'], ['18', '14', '3', '4', 'x', 'x', 'x', '12', '15', '10', 'x'], ['x', '8', 'x', '1', '18', 'x', 'x', 'x', 'x', 'x', 'x']]\", \"(6, 10)\", \"(3, 2)\", \"3\", \"5\"]"}
{"diff_sorted_id": "42", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 11x11. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (10, 9) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (3, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 1 0 0 0 1 1 1 0 0\n1 0 1 1 1 0 0 1 1 1 0\n0 1 1 1 0 0 1 1 1 0 1\n0 0 1 1 1 0 1 1 1 0 1\n1 0 0 0 0 0 1 1 1 1 0\n1 0 0 1 1 1 1 1 1 0 0\n1 0 0 1 1 1 1 1 1 0 1\n0 1 0 0 0 1 0 0 1 1 1\n1 0 0 1 1 0 0 1 0 0 0\n1 0 0 0 0 0 0 0 1 0 1\n1 0 0 0 0 0 0 0 0 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[[10, 9], [10, 8], [9, 7], [8, 6], [8, 5], [7, 4], [7, 3], [7, 2], [6, 2], [5, 2], [4, 2], [4, 1], [3, 1]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.029900312423706055", "solution_depth": "13", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0], [1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0], [0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1], [0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0], [1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1], [1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]]\", 3]", "is_correct_args": "[\"[[0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0], [1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0], [0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1], [0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0], [1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1], [1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]]\", [10, 9], [3, 1], 3]", "A*_args": "[\"[[0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0], [1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0], [0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1], [0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0], [1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1], [1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]]\", \"(10, 9)\", \"(3, 1)\", \"3\"]"}
{"diff_sorted_id": "42", "problem_statement": "Given 9 labeled water jugs with capacities 36, 72, 16, 80, 45, 67, 38, 32, 149, 37 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 201, 202, 233 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 32, 3], [\"+\", 36, 3], [\"+\", 149, 3], [\"+\", 16, 3], [\"+\", 37, 2], [\"+\", 149, 2], [\"+\", 16, 2], [\"+\", 36, 1], [\"+\", 149, 1], [\"+\", 16, 1]]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.032448768615722656", "solution_depth": "10", "max_successor_states": "60", "num_vars_per_state": "3", "is_feasible_args": "[[36, 72, 16, 80, 45, 67, 38, 32, 149, 37], [201, 202, 233]]", "is_correct_args": "[[36, 72, 16, 80, 45, 67, 38, 32, 149, 37], [201, 202, 233]]", "A*_args": "[\"[36, 72, 16, 80, 45, 67, 38, 32, 149, 37]\", \"[201, 202, 233]\"]"}
{"diff_sorted_id": "43", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[52, '_', 99, 42], [56, 67, 49, 68], [88, 23, 33, 26]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[99, 49, 68, 42, 49, 68, 67, 23, 88, 56, 52, 99, 68, 67, 23, 88, 33, 26, 42, 49, 67, 68, 88, 52, 56, 33, 26, 23, 49, 42]", "opt_solution_cost": "30", "opt_solution_compute_t": "0.6710901260375977", "solution_depth": "30", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[52, \"_\", 99, 42], [56, 67, 49, 68], [88, 23, 33, 26]]]", "is_correct_args": "[[[52, \"_\", 99, 42], [56, 67, 49, 68], [88, 23, 33, 26]]]", "A*_args": "[\"[[52, '_', 99, 42], [56, 67, 49, 68], [88, 23, 33, 26]]\"]"}
{"diff_sorted_id": "43", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: dione, palmad, ancona, saltly   The initial board: [['a', 'd', 'a', 'o', 'n', 'e'], ['p', 'm', 'l', 'n', 'a', 'i'], ['_', 'n', 'c', 'o', 'd', 'a'], ['s', 'a', 'l', 't', 'l', 'y']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-right\", \"up-right\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"down-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.4346792697906494", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"a\", \"d\", \"a\", \"o\", \"n\", \"e\"], [\"p\", \"m\", \"l\", \"n\", \"a\", \"i\"], [\"_\", \"n\", \"c\", \"o\", \"d\", \"a\"], [\"s\", \"a\", \"l\", \"t\", \"l\", \"y\"]]]", "is_correct_args": "[[[\"a\", \"d\", \"a\", \"o\", \"n\", \"e\"], [\"p\", \"m\", \"l\", \"n\", \"a\", \"i\"], [\"_\", \"n\", \"c\", \"o\", \"d\", \"a\"], [\"s\", \"a\", \"l\", \"t\", \"l\", \"y\"]], [\"dione\", \"palmad\", \"ancona\", \"saltly\"]]", "A*_args": "[\"[['a', 'd', 'a', 'o', 'n', 'e'], ['p', 'm', 'l', 'n', 'a', 'i'], ['_', 'n', 'c', 'o', 'd', 'a'], ['s', 'a', 'l', 't', 'l', 'y']]\", \"['dione', 'palmad', 'ancona', 'saltly']\"]"}
{"diff_sorted_id": "43", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'Y'. Our task is to visit city E and city M excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from M and E, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  Y E L P M C B I G V J T \nY 0 0 0 0 0 0 0 0 0 0 1 0 \nE 0 0 0 1 0 0 1 0 0 0 0 0 \nL 0 1 0 0 1 1 0 0 0 0 0 1 \nP 0 0 1 0 0 0 0 0 0 0 0 0 \nM 0 0 0 1 0 0 0 0 0 0 0 1 \nC 0 0 0 1 1 0 1 0 0 0 0 0 \nB 0 1 0 1 0 0 0 0 0 1 0 0 \nI 1 1 0 0 1 0 1 0 1 0 0 0 \nG 1 1 0 0 0 0 0 0 0 0 0 0 \nV 0 0 0 0 1 0 0 0 0 0 0 0 \nJ 0 0 0 1 0 0 1 1 1 0 0 1 \nT 0 0 0 0 0 1 0 1 1 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[\"Y\", \"J\", \"I\", \"M\", \"P\", \"L\", \"M\", \"T\", \"G\", \"E\", \"B\", \"E\"]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.034844398498535156", "solution_depth": "12", "max_successor_states": "12", "num_vars_per_state": "15", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0]], [\"Y\", \"E\", \"L\", \"P\", \"M\", \"C\", \"B\", \"I\", \"G\", \"V\", \"J\", \"T\"], \"E\", \"M\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0]], [\"Y\", \"E\", \"L\", \"P\", \"M\", \"C\", \"B\", \"I\", \"G\", \"V\", \"J\", \"T\"], \"Y\", \"E\", \"M\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0]]\", \"['Y', 'E', 'L', 'P', 'M', 'C', 'B', 'I', 'G', 'V', 'J', 'T']\", \"['Y']\", \"['E', 'M']\"]"}
{"diff_sorted_id": "43", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [69, 32, 32, 6, 19, 13, 21, 68, 32, 16, 21, 29, 20, 13, 21, 24, 26, 5, 23, 18, 16, 24, 2, 17, 15, 30, 26], such that the sum of the chosen coins adds up to 322. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {30: 3, 20: 11, 24: 15, 26: 6, 68: 2, 29: 5, 13: 2, 2: 1, 17: 2, 32: 11, 18: 4, 15: 9, 5: 3, 21: 11, 69: 19, 6: 3, 16: 4, 23: 17, 19: 15}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "15", "opt_solution": "[68, 30, 16, 17, 29, 26, 6, 13, 69, 32, 16]", "opt_solution_cost": "61", "opt_solution_compute_t": "0.04106879234313965", "solution_depth": "11", "max_successor_states": "27", "num_vars_per_state": "27", "is_feasible_args": "[[69, 32, 32, 6, 19, 13, 21, 68, 32, 16, 21, 29, 20, 13, 21, 24, 26, 5, 23, 18, 16, 24, 2, 17, 15, 30, 26]]", "is_correct_args": "[[69, 32, 32, 6, 19, 13, 21, 68, 32, 16, 21, 29, 20, 13, 21, 24, 26, 5, 23, 18, 16, 24, 2, 17, 15, 30, 26], {\"30\": 3, \"20\": 11, \"24\": 15, \"26\": 6, \"68\": 2, \"29\": 5, \"13\": 2, \"2\": 1, \"17\": 2, \"32\": 11, \"18\": 4, \"15\": 9, \"5\": 3, \"21\": 11, \"69\": 19, \"6\": 3, \"16\": 4, \"23\": 17, \"19\": 15}, 322]", "A*_args": "[\"[69, 32, 32, 6, 19, 13, 21, 68, 32, 16, 21, 29, 20, 13, 21, 24, 26, 5, 23, 18, 16, 24, 2, 17, 15, 30, 26]\", \"{30: 3, 20: 11, 24: 15, 26: 6, 68: 2, 29: 5, 13: 2, 2: 1, 17: 2, 32: 11, 18: 4, 15: 9, 5: 3, 21: 11, 69: 19, 6: 3, 16: 4, 23: 17, 19: 15}\", \"322\"]"}
{"diff_sorted_id": "43", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Green', 'Blue', 'Red'], ['Red', 'Blue', 'Green', 'Blue'], ['Green', 'Blue', 'Red', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[0, 2], [0, 2], [0, 1], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [1, 2], [1, 0], [1, 2], [1, 0], [1, 2], [0, 1], [0, 1], [0, 1], [2, 0]]", "opt_solution_cost": "17", "opt_solution_compute_t": "2.007240056991577", "solution_depth": "17", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Green\", \"Green\", \"Blue\", \"Red\"], [\"Red\", \"Blue\", \"Green\", \"Blue\"], [\"Green\", \"Blue\", \"Red\", \"Red\"]], 7]", "is_correct_args": "[[[\"Green\", \"Green\", \"Blue\", \"Red\"], [\"Red\", \"Blue\", \"Green\", \"Blue\"], [\"Green\", \"Blue\", \"Red\", \"Red\"]], 7]", "A*_args": "[\"[['Green', 'Green', 'Blue', 'Red'], ['Red', 'Blue', 'Green', 'Blue'], ['Green', 'Blue', 'Red', 'Red']]\", \"7\"]"}
{"diff_sorted_id": "43", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 7 to 60 (7 included in the range but 60 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['13' 'x' 'x']\n ['x' 'x' '27']\n ['x' '26' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 1, 8], [0, 2, 7], [1, 0, 10], [1, 1, 11], [2, 0, 9], [2, 2, 28]]", "opt_solution_cost": "142", "opt_solution_compute_t": "20.925482749938965", "solution_depth": "6", "max_successor_states": "53", "num_vars_per_state": "9", "is_feasible_args": "[\"[['13', '', ''], ['', '', '27'], ['', '26', '']]\", 7, 60]", "is_correct_args": "[\"[['13', '', ''], ['', '', '27'], ['', '26', '']]\", 7, 60]", "A*_args": "[\"[['13', '', ''], ['', '', '27'], ['', '26', '']]\", \"7\", \"60\"]"}
{"diff_sorted_id": "43", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 35 to 61. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 212, 185, None for columns 1 to 2 respectively, and the sums of rows must be None, 180, 202, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 193. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '51' '39' 'x']\n ['x' 'x' '48' '37']\n ['54' 'x' 'x' 'x']\n ['x' 'x' 'x' '53']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 35], [0, 3, 40], [1, 0, 38], [1, 1, 57], [2, 1, 60], [2, 2, 52], [2, 3, 36], [3, 0, 45], [3, 1, 44], [3, 2, 46]]", "opt_solution_cost": "735", "opt_solution_compute_t": "81.89644312858582", "solution_depth": "10", "max_successor_states": "44", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '51', '39', ''], ['', '', '48', '37'], ['54', '', '', ''], ['', '', '', '53']]\", 4, 35, 61]", "is_correct_args": "[\"[['', '51', '39', ''], ['', '', '48', '37'], ['54', '', '', ''], ['', '', '', '53']]\", 35, 61, [1, 3], [1, 3], [212, 185], [180, 202], 193]", "A*_args": "[\"[['', '51', '39', ''], ['', '', '48', '37'], ['54', '', '', ''], ['', '', '', '53']]\", \"35\", \"61\", \"[None, 212, 185, None]\", \"[None, 180, 202, None]\", \"193\"]"}
{"diff_sorted_id": "43", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 5, 1: 2, 2: 8, 3: 7, 4: 5, 5: 6, 6: 1, 7: 1}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Green', 'Green', 'Red', 'Blue', 'Red'], ['Black', 'Red', 'Black', 'Red', 'Green'], ['Yellow', 'Green', 'Black', 'Black', 'Blue'], [], ['Blue', 'Yellow', 'Blue', 'Yellow', 'Yellow'], [], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[1, 5], [4, 7], [4, 3], [1, 6], [1, 5], [4, 7], [2, 4], [1, 6], [2, 1], [2, 5], [2, 5], [3, 4], [0, 1], [0, 1], [0, 6], [0, 7], [0, 6], [2, 7]]", "opt_solution_cost": "55", "opt_solution_compute_t": "19.498444318771362", "solution_depth": "18", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[\"Green\", \"Green\", \"Red\", \"Blue\", \"Red\"], [\"Black\", \"Red\", \"Black\", \"Red\", \"Green\"], [\"Yellow\", \"Green\", \"Black\", \"Black\", \"Blue\"], [], [\"Blue\", \"Yellow\", \"Blue\", \"Yellow\", \"Yellow\"], [], [], []], 5, {\"0\": 5, \"1\": 2, \"2\": 8, \"3\": 7, \"4\": 5, \"5\": 6, \"6\": 1, \"7\": 1}]", "is_correct_args": "[[[\"Green\", \"Green\", \"Red\", \"Blue\", \"Red\"], [\"Black\", \"Red\", \"Black\", \"Red\", \"Green\"], [\"Yellow\", \"Green\", \"Black\", \"Black\", \"Blue\"], [], [\"Blue\", \"Yellow\", \"Blue\", \"Yellow\", \"Yellow\"], [], [], []], 5, {\"0\": 5, \"1\": 2, \"2\": 8, \"3\": 7, \"4\": 5, \"5\": 6, \"6\": 1, \"7\": 1}, 4]", "A*_args": "[\"[['Green', 'Green', 'Red', 'Blue', 'Red'], ['Black', 'Red', 'Black', 'Red', 'Green'], ['Yellow', 'Green', 'Black', 'Black', 'Blue'], [], ['Blue', 'Yellow', 'Blue', 'Yellow', 'Yellow'], [], [], []]\", \"{0: 5, 1: 2, 2: 8, 3: 7, 4: 5, 5: 6, 6: 1, 7: 1}\", \"5\", \"4\"]"}
{"diff_sorted_id": "43", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 10) to his destination workshop at index (6, 2), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 5, and district 3 covering rows 6 to 10. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 10 2 x x x 3 x 4 x 14]\n[x x 17 16 8 x x x x 1 x]\n[18 18 16 16 15 x x 17 12 16 15]\n[x 4 x x 18 9 x 15 x 1 9]\n[3 2 7 x x 17 2 14 x 4 2]\n[16 17 6 4 9 2 5 7 x x 7]\n[x x 12 x x 16 1 11 x x 4]\n[x x 13 x x 19 16 9 x x x]\n[x x x 9 7 x 11 5 x x x]\n[x 2 x x x 4 5 x 10 x x]\n[x x x 12 16 x 6 16 x 18 7]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "3", "opt_solution": "[[3, 10], [3, 9], [2, 9], [2, 8], [2, 7], [3, 7], [4, 7], [4, 6], [5, 6], [5, 5], [5, 4], [5, 3], [5, 2], [6, 2]]", "opt_solution_cost": "115", "opt_solution_compute_t": "0.026669740676879883", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"10\", \"2\", \"x\", \"x\", \"x\", \"3\", \"x\", \"4\", \"x\", \"14\"], [\"x\", \"x\", \"17\", \"16\", \"8\", \"x\", \"x\", \"x\", \"x\", \"1\", \"x\"], [\"18\", \"18\", \"16\", \"16\", \"15\", \"x\", \"x\", \"17\", \"12\", \"16\", \"15\"], [\"x\", \"4\", \"x\", \"x\", \"18\", \"9\", \"x\", \"15\", \"x\", \"1\", \"9\"], [\"3\", \"2\", \"7\", \"x\", \"x\", \"17\", \"2\", \"14\", \"x\", \"4\", \"2\"], [\"16\", \"17\", \"6\", \"4\", \"9\", \"2\", \"5\", \"7\", \"x\", \"x\", \"7\"], [\"x\", \"x\", \"12\", \"x\", \"x\", \"16\", \"1\", \"11\", \"x\", \"x\", \"4\"], [\"x\", \"x\", \"13\", \"x\", \"x\", \"19\", \"16\", \"9\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"9\", \"7\", \"x\", \"11\", \"5\", \"x\", \"x\", \"x\"], [\"x\", \"2\", \"x\", \"x\", \"x\", \"4\", \"5\", \"x\", \"10\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"12\", \"16\", \"x\", \"6\", \"16\", \"x\", \"18\", \"7\"]]]", "is_correct_args": "[[[\"x\", \"10\", \"2\", \"x\", \"x\", \"x\", \"3\", \"x\", \"4\", \"x\", \"14\"], [\"x\", \"x\", \"17\", \"16\", \"8\", \"x\", \"x\", \"x\", \"x\", \"1\", \"x\"], [\"18\", \"18\", \"16\", \"16\", \"15\", \"x\", \"x\", \"17\", \"12\", \"16\", \"15\"], [\"x\", \"4\", \"x\", \"x\", \"18\", \"9\", \"x\", \"15\", \"x\", \"1\", \"9\"], [\"3\", \"2\", \"7\", \"x\", \"x\", \"17\", \"2\", \"14\", \"x\", \"4\", \"2\"], [\"16\", \"17\", \"6\", \"4\", \"9\", \"2\", \"5\", \"7\", \"x\", \"x\", \"7\"], [\"x\", \"x\", \"12\", \"x\", \"x\", \"16\", \"1\", \"11\", \"x\", \"x\", \"4\"], [\"x\", \"x\", \"13\", \"x\", \"x\", \"19\", \"16\", \"9\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"9\", \"7\", \"x\", \"11\", \"5\", \"x\", \"x\", \"x\"], [\"x\", \"2\", \"x\", \"x\", \"x\", \"4\", \"5\", \"x\", \"10\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"12\", \"16\", \"x\", \"6\", \"16\", \"x\", \"18\", \"7\"]], [3, 10], [6, 2], 3, 5]", "A*_args": "[\"[['x', '10', '2', 'x', 'x', 'x', '3', 'x', '4', 'x', '14'], ['x', 'x', '17', '16', '8', 'x', 'x', 'x', 'x', '1', 'x'], ['18', '18', '16', '16', '15', 'x', 'x', '17', '12', '16', '15'], ['x', '4', 'x', 'x', '18', '9', 'x', '15', 'x', '1', '9'], ['3', '2', '7', 'x', 'x', '17', '2', '14', 'x', '4', '2'], ['16', '17', '6', '4', '9', '2', '5', '7', 'x', 'x', '7'], ['x', 'x', '12', 'x', 'x', '16', '1', '11', 'x', 'x', '4'], ['x', 'x', '13', 'x', 'x', '19', '16', '9', 'x', 'x', 'x'], ['x', 'x', 'x', '9', '7', 'x', '11', '5', 'x', 'x', 'x'], ['x', '2', 'x', 'x', 'x', '4', '5', 'x', '10', 'x', 'x'], ['x', 'x', 'x', '12', '16', 'x', '6', '16', 'x', '18', '7']]\", \"(3, 10)\", \"(6, 2)\", \"3\", \"5\"]"}
{"diff_sorted_id": "43", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 11x11. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (10, 10) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (2, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 0 1 1 0 1 0 1 1 1\n1 0 1 0 0 1 1 1 1 0 1\n0 0 0 0 0 1 0 0 1 1 0\n0 1 0 0 0 0 1 1 0 1 1\n1 0 1 1 1 0 0 0 1 1 1\n1 0 0 0 0 0 0 0 0 0 0\n1 1 1 1 1 1 1 0 0 1 0\n0 1 1 1 0 0 1 0 0 1 1\n0 0 1 0 0 0 1 1 1 0 0\n1 0 1 1 0 1 1 0 0 0 0\n1 0 1 0 0 1 1 0 1 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[[10, 10], [9, 9], [8, 9], [7, 8], [6, 7], [5, 7], [5, 6], [5, 5], [4, 5], [3, 5], [3, 4], [3, 3], [3, 2], [2, 2], [2, 1]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.028983116149902344", "solution_depth": "15", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0], [0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1], [0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0], [1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0]]\", 3]", "is_correct_args": "[\"[[1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0], [0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1], [0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0], [1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0]]\", [10, 10], [2, 1], 3]", "A*_args": "[\"[[1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0], [0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1], [0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0], [1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0]]\", \"(10, 10)\", \"(2, 1)\", \"3\"]"}
{"diff_sorted_id": "43", "problem_statement": "Given 9 labeled water jugs with capacities 104, 14, 83, 46, 128, 34, 137, 15, 19, 126 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 342, 373, 447 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 34, 3], [\"+\", 126, 3], [\"+\", 137, 3], [\"+\", 46, 3], [\"+\", 104, 3], [\"+\", 104, 2], [\"+\", 126, 2], [\"+\", 15, 2], [\"+\", 128, 2], [\"+\", 104, 1], [\"+\", 126, 1], [\"-\", 14, 1], [\"+\", 126, 1]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.06156110763549805", "solution_depth": "13", "max_successor_states": "60", "num_vars_per_state": "3", "is_feasible_args": "[[104, 14, 83, 46, 128, 34, 137, 15, 19, 126], [342, 373, 447]]", "is_correct_args": "[[104, 14, 83, 46, 128, 34, 137, 15, 19, 126], [342, 373, 447]]", "A*_args": "[\"[104, 14, 83, 46, 128, 34, 137, 15, 19, 126]\", \"[342, 373, 447]\"]"}
{"diff_sorted_id": "44", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[81, '_', 58, 10], [85, 22, 23, 54], [100, 21, 27, 12]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[22, 23, 54, 10, 58, 22, 23, 54, 22, 23, 81, 85, 100, 21, 27, 12, 10, 22, 23, 81, 85, 100, 54, 27, 12, 10]", "opt_solution_cost": "26", "opt_solution_compute_t": "0.062206268310546875", "solution_depth": "26", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[81, \"_\", 58, 10], [85, 22, 23, 54], [100, 21, 27, 12]]]", "is_correct_args": "[[[81, \"_\", 58, 10], [85, 22, 23, 54], [100, 21, 27, 12]]]", "A*_args": "[\"[[81, '_', 58, 10], [85, 22, 23, 54], [100, 21, 27, 12]]\"]"}
{"diff_sorted_id": "44", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: besit, thrive, kincob, humate   The initial board: [['h', 'b', 'n', 's', 'i', 't'], ['t', 'e', 'r', 'k', 'v', 'e'], ['i', 'i', '_', 'c', 'o', 'b'], ['h', 'u', 'm', 'a', 't', 'e']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.3068218231201172", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"h\", \"b\", \"n\", \"s\", \"i\", \"t\"], [\"t\", \"e\", \"r\", \"k\", \"v\", \"e\"], [\"i\", \"i\", \"_\", \"c\", \"o\", \"b\"], [\"h\", \"u\", \"m\", \"a\", \"t\", \"e\"]]]", "is_correct_args": "[[[\"h\", \"b\", \"n\", \"s\", \"i\", \"t\"], [\"t\", \"e\", \"r\", \"k\", \"v\", \"e\"], [\"i\", \"i\", \"_\", \"c\", \"o\", \"b\"], [\"h\", \"u\", \"m\", \"a\", \"t\", \"e\"]], [\"besit\", \"thrive\", \"kincob\", \"humate\"]]", "A*_args": "[\"[['h', 'b', 'n', 's', 'i', 't'], ['t', 'e', 'r', 'k', 'v', 'e'], ['i', 'i', '_', 'c', 'o', 'b'], ['h', 'u', 'm', 'a', 't', 'e']]\", \"['besit', 'thrive', 'kincob', 'humate']\"]"}
{"diff_sorted_id": "44", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'E'. Our task is to visit city D and city T excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from T and D, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  H F C E T V R I M Z L D \nH 0 0 0 0 1 0 0 0 0 0 0 0 \nF 0 0 0 0 0 0 1 0 0 0 1 1 \nC 0 0 0 0 0 0 0 0 0 0 1 0 \nE 0 0 1 0 0 1 0 0 0 0 0 0 \nT 1 0 0 0 0 0 0 0 1 1 0 1 \nV 0 1 1 0 0 0 0 1 0 0 0 0 \nR 0 0 0 0 0 0 0 1 1 0 0 1 \nI 0 1 1 1 0 0 0 0 1 0 0 0 \nM 1 0 1 0 0 0 0 0 0 0 0 0 \nZ 1 0 0 0 0 0 1 0 1 0 0 0 \nL 0 0 1 0 1 0 1 0 1 0 0 0 \nD 1 1 1 0 0 1 0 1 1 1 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[\"E\", \"C\", \"L\", \"T\", \"D\", \"H\", \"T\", \"D\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.028389930725097656", "solution_depth": "8", "max_successor_states": "12", "num_vars_per_state": "15", "is_feasible_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1], [0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1], [0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0], [1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0]], [\"H\", \"F\", \"C\", \"E\", \"T\", \"V\", \"R\", \"I\", \"M\", \"Z\", \"L\", \"D\"], \"D\", \"T\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1], [0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1], [0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0], [1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0]], [\"H\", \"F\", \"C\", \"E\", \"T\", \"V\", \"R\", \"I\", \"M\", \"Z\", \"L\", \"D\"], \"E\", \"D\", \"T\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1], [0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1], [0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0], [1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0]]\", \"['H', 'F', 'C', 'E', 'T', 'V', 'R', 'I', 'M', 'Z', 'L', 'D']\", \"['E']\", \"['D', 'T']\"]"}
{"diff_sorted_id": "44", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [2, 27, 9, 80, 20, 81, 13, 24, 16, 6, 26, 12, 3, 26, 20, 8, 16, 8, 20, 22, 9, 34, 23, 8, 12, 34, 4, 6, 22, 19], such that the sum of the chosen coins adds up to 346. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {12: 9, 16: 12, 13: 5, 34: 8, 9: 9, 23: 4, 81: 2, 80: 20, 8: 1, 19: 19, 2: 2, 22: 13, 20: 7, 26: 11, 4: 1, 6: 2, 27: 4, 3: 1, 24: 12}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "16", "opt_solution": "[8, 4, 27, 8, 23, 6, 81, 80, 34, 26, 20, 8, 6, 2, 13]", "opt_solution_cost": "71", "opt_solution_compute_t": "0.03767251968383789", "solution_depth": "15", "max_successor_states": "30", "num_vars_per_state": "30", "is_feasible_args": "[[2, 27, 9, 80, 20, 81, 13, 24, 16, 6, 26, 12, 3, 26, 20, 8, 16, 8, 20, 22, 9, 34, 23, 8, 12, 34, 4, 6, 22, 19]]", "is_correct_args": "[[2, 27, 9, 80, 20, 81, 13, 24, 16, 6, 26, 12, 3, 26, 20, 8, 16, 8, 20, 22, 9, 34, 23, 8, 12, 34, 4, 6, 22, 19], {\"12\": 9, \"16\": 12, \"13\": 5, \"34\": 8, \"9\": 9, \"23\": 4, \"81\": 2, \"80\": 20, \"8\": 1, \"19\": 19, \"2\": 2, \"22\": 13, \"20\": 7, \"26\": 11, \"4\": 1, \"6\": 2, \"27\": 4, \"3\": 1, \"24\": 12}, 346]", "A*_args": "[\"[2, 27, 9, 80, 20, 81, 13, 24, 16, 6, 26, 12, 3, 26, 20, 8, 16, 8, 20, 22, 9, 34, 23, 8, 12, 34, 4, 6, 22, 19]\", \"{12: 9, 16: 12, 13: 5, 34: 8, 9: 9, 23: 4, 81: 2, 80: 20, 8: 1, 19: 19, 2: 2, 22: 13, 20: 7, 26: 11, 4: 1, 6: 2, 27: 4, 3: 1, 24: 12}\", \"346\"]"}
{"diff_sorted_id": "44", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Red', 'Blue', 'Blue'], ['Red', 'Green', 'Green', 'Green'], ['Red', 'Blue', 'Blue', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[0, 1], [0, 1], [2, 1], [2, 0], [2, 0], [2, 0], [1, 2], [1, 2], [1, 2], [1, 2], [0, 1]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.07266616821289062", "solution_depth": "11", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Red\", \"Blue\", \"Blue\"], [\"Red\", \"Green\", \"Green\", \"Green\"], [\"Red\", \"Blue\", \"Blue\", \"Green\"]], 7]", "is_correct_args": "[[[\"Red\", \"Red\", \"Blue\", \"Blue\"], [\"Red\", \"Green\", \"Green\", \"Green\"], [\"Red\", \"Blue\", \"Blue\", \"Green\"]], 7]", "A*_args": "[\"[['Red', 'Red', 'Blue', 'Blue'], ['Red', 'Green', 'Green', 'Green'], ['Red', 'Blue', 'Blue', 'Green']]\", \"7\"]"}
{"diff_sorted_id": "44", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 31 to 84 (31 included in the range but 84 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '58' 'x']\n ['42' 'x' '70']\n ['x' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 0, 31], [0, 2, 71], [1, 1, 43], [2, 0, 44], [2, 1, 33], [2, 2, 32]]", "opt_solution_cost": "439", "opt_solution_compute_t": "185.86225056648254", "solution_depth": "6", "max_successor_states": "53", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '58', ''], ['42', '', '70'], ['', '', '']]\", 31, 84]", "is_correct_args": "[\"[['', '58', ''], ['42', '', '70'], ['', '', '']]\", 31, 84]", "A*_args": "[\"[['', '58', ''], ['42', '', '70'], ['', '', '']]\", \"31\", \"84\"]"}
{"diff_sorted_id": "44", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 35 to 61. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 188, 188, None for columns 1 to 2 respectively, and the sums of rows must be None, 177, 160, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 173. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' '39' 'x']\n ['x' 'x' 'x' '43']\n ['x' 'x' 'x' '47']\n ['46' '49' 'x' '53']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 36], [0, 1, 60], [0, 3, 38], [1, 0, 40], [1, 1, 42], [1, 2, 52], [2, 0, 35], [2, 1, 37], [2, 2, 41], [3, 2, 56]]", "opt_solution_cost": "714", "opt_solution_compute_t": "512.5996880531311", "solution_depth": "10", "max_successor_states": "44", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', '39', ''], ['', '', '', '43'], ['', '', '', '47'], ['46', '49', '', '53']]\", 4, 35, 61]", "is_correct_args": "[\"[['', '', '39', ''], ['', '', '', '43'], ['', '', '', '47'], ['46', '49', '', '53']]\", 35, 61, [1, 3], [1, 3], [188, 188], [177, 160], 173]", "A*_args": "[\"[['', '', '39', ''], ['', '', '', '43'], ['', '', '', '47'], ['46', '49', '', '53']]\", \"35\", \"61\", \"[None, 188, 188, None]\", \"[None, 177, 160, None]\", \"173\"]"}
{"diff_sorted_id": "44", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 6, 1: 2, 2: 7, 3: 1, 4: 1, 5: 5, 6: 3, 7: 2}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], ['Blue', 'Blue', 'Green', 'Black', 'Red'], [], ['Red', 'Green', 'Red', 'Black', 'Yellow'], [], ['Blue', 'Yellow', 'Green', 'Yellow', 'Black'], ['Yellow', 'Green', 'Black', 'Red', 'Blue']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[6, 0], [7, 5], [6, 5], [6, 1], [6, 5], [4, 3], [4, 1], [4, 3], [4, 6], [4, 5], [7, 1], [7, 6], [7, 3], [2, 7], [2, 7], [2, 1], [2, 6], [0, 7], [2, 3]]", "opt_solution_cost": "53", "opt_solution_compute_t": "14.416839361190796", "solution_depth": "19", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[], [], [\"Blue\", \"Blue\", \"Green\", \"Black\", \"Red\"], [], [\"Red\", \"Green\", \"Red\", \"Black\", \"Yellow\"], [], [\"Blue\", \"Yellow\", \"Green\", \"Yellow\", \"Black\"], [\"Yellow\", \"Green\", \"Black\", \"Red\", \"Blue\"]], 5, {\"0\": 6, \"1\": 2, \"2\": 7, \"3\": 1, \"4\": 1, \"5\": 5, \"6\": 3, \"7\": 2}]", "is_correct_args": "[[[], [], [\"Blue\", \"Blue\", \"Green\", \"Black\", \"Red\"], [], [\"Red\", \"Green\", \"Red\", \"Black\", \"Yellow\"], [], [\"Blue\", \"Yellow\", \"Green\", \"Yellow\", \"Black\"], [\"Yellow\", \"Green\", \"Black\", \"Red\", \"Blue\"]], 5, {\"0\": 6, \"1\": 2, \"2\": 7, \"3\": 1, \"4\": 1, \"5\": 5, \"6\": 3, \"7\": 2}, 4]", "A*_args": "[\"[[], [], ['Blue', 'Blue', 'Green', 'Black', 'Red'], [], ['Red', 'Green', 'Red', 'Black', 'Yellow'], [], ['Blue', 'Yellow', 'Green', 'Yellow', 'Black'], ['Yellow', 'Green', 'Black', 'Red', 'Blue']]\", \"{0: 6, 1: 2, 2: 7, 3: 1, 4: 1, 5: 5, 6: 3, 7: 2}\", \"5\", \"4\"]"}
{"diff_sorted_id": "44", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (8, 10) to his destination workshop at index (3, 4), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 7, and district 3 covering rows 8 to 10. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 16 5 13 x x 2 x 6 x x]\n[x x 17 x 15 x 10 x 5 17 x]\n[x x x x 15 3 10 2 4 13 14]\n[x x x x 17 2 4 x 1 4 5]\n[2 x x 2 6 17 x x x 4 19]\n[19 5 x x x x 10 12 1 18 10]\n[x 3 x 12 x 10 15 11 x 4 15]\n[2 x 11 9 x 12 11 x 15 10 6]\n[19 x 16 5 x x x 11 x 11 8]\n[12 2 x 3 x 4 x x 15 x x]\n[x x 18 16 x x 4 x 12 13 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "3", "opt_solution": "[[8, 10], [7, 10], [7, 9], [6, 9], [5, 9], [4, 9], [3, 9], [3, 8], [2, 8], [2, 7], [2, 6], [2, 5], [3, 5], [3, 4]]", "opt_solution_cost": "85", "opt_solution_compute_t": "0.02710127830505371", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"16\", \"5\", \"13\", \"x\", \"x\", \"2\", \"x\", \"6\", \"x\", \"x\"], [\"x\", \"x\", \"17\", \"x\", \"15\", \"x\", \"10\", \"x\", \"5\", \"17\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"15\", \"3\", \"10\", \"2\", \"4\", \"13\", \"14\"], [\"x\", \"x\", \"x\", \"x\", \"17\", \"2\", \"4\", \"x\", \"1\", \"4\", \"5\"], [\"2\", \"x\", \"x\", \"2\", \"6\", \"17\", \"x\", \"x\", \"x\", \"4\", \"19\"], [\"19\", \"5\", \"x\", \"x\", \"x\", \"x\", \"10\", \"12\", \"1\", \"18\", \"10\"], [\"x\", \"3\", \"x\", \"12\", \"x\", \"10\", \"15\", \"11\", \"x\", \"4\", \"15\"], [\"2\", \"x\", \"11\", \"9\", \"x\", \"12\", \"11\", \"x\", \"15\", \"10\", \"6\"], [\"19\", \"x\", \"16\", \"5\", \"x\", \"x\", \"x\", \"11\", \"x\", \"11\", \"8\"], [\"12\", \"2\", \"x\", \"3\", \"x\", \"4\", \"x\", \"x\", \"15\", \"x\", \"x\"], [\"x\", \"x\", \"18\", \"16\", \"x\", \"x\", \"4\", \"x\", \"12\", \"13\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"16\", \"5\", \"13\", \"x\", \"x\", \"2\", \"x\", \"6\", \"x\", \"x\"], [\"x\", \"x\", \"17\", \"x\", \"15\", \"x\", \"10\", \"x\", \"5\", \"17\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"15\", \"3\", \"10\", \"2\", \"4\", \"13\", \"14\"], [\"x\", \"x\", \"x\", \"x\", \"17\", \"2\", \"4\", \"x\", \"1\", \"4\", \"5\"], [\"2\", \"x\", \"x\", \"2\", \"6\", \"17\", \"x\", \"x\", \"x\", \"4\", \"19\"], [\"19\", \"5\", \"x\", \"x\", \"x\", \"x\", \"10\", \"12\", \"1\", \"18\", \"10\"], [\"x\", \"3\", \"x\", \"12\", \"x\", \"10\", \"15\", \"11\", \"x\", \"4\", \"15\"], [\"2\", \"x\", \"11\", \"9\", \"x\", \"12\", \"11\", \"x\", \"15\", \"10\", \"6\"], [\"19\", \"x\", \"16\", \"5\", \"x\", \"x\", \"x\", \"11\", \"x\", \"11\", \"8\"], [\"12\", \"2\", \"x\", \"3\", \"x\", \"4\", \"x\", \"x\", \"15\", \"x\", \"x\"], [\"x\", \"x\", \"18\", \"16\", \"x\", \"x\", \"4\", \"x\", \"12\", \"13\", \"x\"]], [8, 10], [3, 4], 2, 7]", "A*_args": "[\"[['x', '16', '5', '13', 'x', 'x', '2', 'x', '6', 'x', 'x'], ['x', 'x', '17', 'x', '15', 'x', '10', 'x', '5', '17', 'x'], ['x', 'x', 'x', 'x', '15', '3', '10', '2', '4', '13', '14'], ['x', 'x', 'x', 'x', '17', '2', '4', 'x', '1', '4', '5'], ['2', 'x', 'x', '2', '6', '17', 'x', 'x', 'x', '4', '19'], ['19', '5', 'x', 'x', 'x', 'x', '10', '12', '1', '18', '10'], ['x', '3', 'x', '12', 'x', '10', '15', '11', 'x', '4', '15'], ['2', 'x', '11', '9', 'x', '12', '11', 'x', '15', '10', '6'], ['19', 'x', '16', '5', 'x', 'x', 'x', '11', 'x', '11', '8'], ['12', '2', 'x', '3', 'x', '4', 'x', 'x', '15', 'x', 'x'], ['x', 'x', '18', '16', 'x', 'x', '4', 'x', '12', '13', 'x']]\", \"(8, 10)\", \"(3, 4)\", \"2\", \"7\"]"}
{"diff_sorted_id": "44", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 11x11. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (2, 1) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (10, 9). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 1 1 0 1 0 1 1 1\n0 0 1 1 1 0 1 0 0 1 1\n0 0 0 1 1 1 0 0 1 0 1\n1 0 0 1 1 0 0 0 1 0 1\n1 0 0 1 0 1 1 0 1 1 0\n0 0 0 1 0 0 1 1 0 1 1\n0 1 1 0 1 1 1 1 0 1 0\n0 0 1 1 0 1 1 1 1 1 1\n0 0 1 1 1 0 0 0 0 0 0\n0 0 0 0 0 0 0 1 1 0 0\n0 1 0 1 0 0 0 0 1 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[[2, 1], [2, 2], [3, 2], [4, 2], [5, 2], [6, 3], [7, 4], [8, 5], [8, 6], [8, 7], [8, 8], [8, 9], [9, 9], [10, 9]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.028450727462768555", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1], [0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1], [1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1], [0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0], [0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1]]\", 3]", "is_correct_args": "[\"[[1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1], [0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1], [1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1], [0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0], [0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1]]\", [2, 1], [10, 9], 3]", "A*_args": "[\"[[1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1], [0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1], [1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1], [0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0], [0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1]]\", \"(2, 1)\", \"(10, 9)\", \"3\"]"}
{"diff_sorted_id": "44", "problem_statement": "Given 9 labeled water jugs with capacities 67, 55, 84, 148, 107, 114, 17, 143, 40, 39 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 192, 247, 479 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 143, 3], [\"+\", 148, 3], [\"+\", 40, 3], [\"+\", 148, 3], [\"+\", 143, 2], [\"-\", 39, 2], [\"+\", 143, 2], [\"+\", 39, 1], [\"+\", 39, 1], [\"+\", 114, 1]]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.030488252639770508", "solution_depth": "10", "max_successor_states": "60", "num_vars_per_state": "3", "is_feasible_args": "[[67, 55, 84, 148, 107, 114, 17, 143, 40, 39], [192, 247, 479]]", "is_correct_args": "[[67, 55, 84, 148, 107, 114, 17, 143, 40, 39], [192, 247, 479]]", "A*_args": "[\"[67, 55, 84, 148, 107, 114, 17, 143, 40, 39]\", \"[192, 247, 479]\"]"}
{"diff_sorted_id": "45", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[11, 55, 69, 67], [19, 31, '_', 35], [64, 65, 88, 96]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[31, 19, 64, 65, 19, 31, 88, 96, 35, 67, 69, 88, 96, 19, 31, 96, 88, 55, 11, 64, 96, 11, 55, 88, 11, 55, 64, 96, 65, 31, 19, 11, 55, 64, 88, 69, 67, 35]", "opt_solution_cost": "38", "opt_solution_compute_t": "18.521990299224854", "solution_depth": "38", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[11, 55, 69, 67], [19, 31, \"_\", 35], [64, 65, 88, 96]]]", "is_correct_args": "[[[11, 55, 69, 67], [19, 31, \"_\", 35], [64, 65, 88, 96]]]", "A*_args": "[\"[[11, 55, 69, 67], [19, 31, '_', 35], [64, 65, 88, 96]]\"]"}
{"diff_sorted_id": "45", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: khadi, swarmy, aguish, wheaty   The initial board: [['w', 'k', 'u', 'a', 'd', 'i'], ['s', 'a', 'a', 'r', 'm', 'y'], ['h', 'g', '_', 'i', 's', 'h'], ['w', 'h', 'e', 'a', 't', 'y']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.26326990127563477", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"w\", \"k\", \"u\", \"a\", \"d\", \"i\"], [\"s\", \"a\", \"a\", \"r\", \"m\", \"y\"], [\"h\", \"g\", \"_\", \"i\", \"s\", \"h\"], [\"w\", \"h\", \"e\", \"a\", \"t\", \"y\"]]]", "is_correct_args": "[[[\"w\", \"k\", \"u\", \"a\", \"d\", \"i\"], [\"s\", \"a\", \"a\", \"r\", \"m\", \"y\"], [\"h\", \"g\", \"_\", \"i\", \"s\", \"h\"], [\"w\", \"h\", \"e\", \"a\", \"t\", \"y\"]], [\"khadi\", \"swarmy\", \"aguish\", \"wheaty\"]]", "A*_args": "[\"[['w', 'k', 'u', 'a', 'd', 'i'], ['s', 'a', 'a', 'r', 'm', 'y'], ['h', 'g', '_', 'i', 's', 'h'], ['w', 'h', 'e', 'a', 't', 'y']]\", \"['khadi', 'swarmy', 'aguish', 'wheaty']\"]"}
{"diff_sorted_id": "45", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'C'. Our task is to visit city Q and city M excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from M and Q, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  Z H M P B I E L Q Y V C \nZ 0 0 0 1 1 0 0 0 0 1 0 1 \nH 1 0 0 1 0 0 0 1 1 1 1 1 \nM 0 1 0 0 0 0 0 0 0 1 1 0 \nP 0 0 0 0 1 0 1 0 0 0 0 1 \nB 0 1 0 0 0 1 0 0 0 0 0 0 \nI 0 1 0 0 1 0 1 0 1 0 0 1 \nE 1 1 1 0 0 0 0 0 0 0 0 0 \nL 1 1 1 0 1 1 1 0 1 0 0 0 \nQ 1 0 1 1 1 0 1 1 0 0 0 0 \nY 0 0 0 0 0 0 0 1 0 0 1 0 \nV 0 0 1 0 0 0 0 0 0 0 0 0 \nC 0 0 0 0 1 0 0 0 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[\"C\", \"B\", \"I\", \"Q\", \"M\", \"H\", \"Q\", \"M\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.029607534408569336", "solution_depth": "8", "max_successor_states": "12", "num_vars_per_state": "15", "is_feasible_args": "[[[0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [\"Z\", \"H\", \"M\", \"P\", \"B\", \"I\", \"E\", \"L\", \"Q\", \"Y\", \"V\", \"C\"], \"Q\", \"M\"]", "is_correct_args": "[[[0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [\"Z\", \"H\", \"M\", \"P\", \"B\", \"I\", \"E\", \"L\", \"Q\", \"Y\", \"V\", \"C\"], \"C\", \"Q\", \"M\"]", "A*_args": "[\"[[0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]]\", \"['Z', 'H', 'M', 'P', 'B', 'I', 'E', 'L', 'Q', 'Y', 'V', 'C']\", \"['C']\", \"['Q', 'M']\"]"}
{"diff_sorted_id": "45", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [21, 10, 19, 6, 20, 7, 23, 18, 4, 15, 4, 13, 2, 5, 32, 28, 113, 3, 9, 9, 11, 21, 112, 6, 6, 11, 29], such that the sum of the chosen coins adds up to 337. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {10: 7, 5: 3, 11: 3, 23: 2, 21: 13, 19: 3, 18: 18, 29: 20, 3: 2, 9: 7, 20: 18, 6: 2, 112: 20, 2: 1, 4: 4, 7: 4, 32: 1, 15: 8, 13: 10, 28: 17, 113: 18}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "17", "opt_solution": "[23, 6, 19, 6, 11, 11, 113, 112, 32, 4]", "opt_solution_cost": "58", "opt_solution_compute_t": "0.0367283821105957", "solution_depth": "10", "max_successor_states": "27", "num_vars_per_state": "27", "is_feasible_args": "[[21, 10, 19, 6, 20, 7, 23, 18, 4, 15, 4, 13, 2, 5, 32, 28, 113, 3, 9, 9, 11, 21, 112, 6, 6, 11, 29]]", "is_correct_args": "[[21, 10, 19, 6, 20, 7, 23, 18, 4, 15, 4, 13, 2, 5, 32, 28, 113, 3, 9, 9, 11, 21, 112, 6, 6, 11, 29], {\"10\": 7, \"5\": 3, \"11\": 3, \"23\": 2, \"21\": 13, \"19\": 3, \"18\": 18, \"29\": 20, \"3\": 2, \"9\": 7, \"20\": 18, \"6\": 2, \"112\": 20, \"2\": 1, \"4\": 4, \"7\": 4, \"32\": 1, \"15\": 8, \"13\": 10, \"28\": 17, \"113\": 18}, 337]", "A*_args": "[\"[21, 10, 19, 6, 20, 7, 23, 18, 4, 15, 4, 13, 2, 5, 32, 28, 113, 3, 9, 9, 11, 21, 112, 6, 6, 11, 29]\", \"{10: 7, 5: 3, 11: 3, 23: 2, 21: 13, 19: 3, 18: 18, 29: 20, 3: 2, 9: 7, 20: 18, 6: 2, 112: 20, 2: 1, 4: 4, 7: 4, 32: 1, 15: 8, 13: 10, 28: 17, 113: 18}\", \"337\"]"}
{"diff_sorted_id": "45", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Green', 'Green'], ['Blue', 'Red', 'Blue', 'Blue'], ['Green', 'Red', 'Red', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[0, 1], [2, 0], [2, 0], [2, 1], [2, 0], [1, 2], [1, 2], [1, 0], [1, 2], [0, 1], [0, 1], [0, 2]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.17496824264526367", "solution_depth": "12", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Green\", \"Green\", \"Green\"], [\"Blue\", \"Red\", \"Blue\", \"Blue\"], [\"Green\", \"Red\", \"Red\", \"Blue\"]], 7]", "is_correct_args": "[[[\"Red\", \"Green\", \"Green\", \"Green\"], [\"Blue\", \"Red\", \"Blue\", \"Blue\"], [\"Green\", \"Red\", \"Red\", \"Blue\"]], 7]", "A*_args": "[\"[['Red', 'Green', 'Green', 'Green'], ['Blue', 'Red', 'Blue', 'Blue'], ['Green', 'Red', 'Red', 'Blue']]\", \"7\"]"}
{"diff_sorted_id": "45", "problem_statement": "We have a 3x3 numerical grid, with numbers ranging from 22 to 75 (22 included in the range but 75 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third or first < second < third in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '51' 'x']\n ['48' '50' 'x']\n ['x' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 0, 22], [0, 2, 53], [1, 2, 52], [2, 0, 49], [2, 1, 24], [2, 2, 23]]", "opt_solution_cost": "349", "opt_solution_compute_t": "2.575047731399536", "solution_depth": "6", "max_successor_states": "53", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '51', ''], ['48', '50', ''], ['', '', '']]\", 22, 75]", "is_correct_args": "[\"[['', '51', ''], ['48', '50', ''], ['', '', '']]\", 22, 75]", "A*_args": "[\"[['', '51', ''], ['48', '50', ''], ['', '', '']]\", \"22\", \"75\"]"}
{"diff_sorted_id": "45", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 35 to 61. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 177, 196, None for columns 1 to 2 respectively, and the sums of rows must be None, 183, 190, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 188. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '50' 'x' 'x']\n ['58' 'x' 'x' 'x']\n ['x' '49' 'x' '59']\n ['39' '41' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 36], [0, 2, 42], [0, 3, 47], [1, 1, 37], [1, 2, 53], [1, 3, 35], [2, 0, 38], [2, 2, 44], [3, 2, 57], [3, 3, 40]]", "opt_solution_cost": "725", "opt_solution_compute_t": "2.623443365097046", "solution_depth": "10", "max_successor_states": "44", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '50', '', ''], ['58', '', '', ''], ['', '49', '', '59'], ['39', '41', '', '']]\", 4, 35, 61]", "is_correct_args": "[\"[['', '50', '', ''], ['58', '', '', ''], ['', '49', '', '59'], ['39', '41', '', '']]\", 35, 61, [1, 3], [1, 3], [177, 196], [183, 190], 188]", "A*_args": "[\"[['', '50', '', ''], ['58', '', '', ''], ['', '49', '', '59'], ['39', '41', '', '']]\", \"35\", \"61\", \"[None, 177, 196, None]\", \"[None, 183, 190, None]\", \"188\"]"}
{"diff_sorted_id": "45", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 2, 1: 3, 2: 5, 3: 9, 4: 8, 5: 5, 6: 8, 7: 1}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Red', 'Yellow', 'Red', 'Yellow', 'Black'], ['Black', 'Blue', 'Green', 'Green', 'Blue'], [], [], [], [], ['Black', 'Blue', 'Green', 'Black', 'Yellow'], ['Blue', 'Green', 'Yellow', 'Red', 'Red']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[1, 3], [0, 4], [1, 2], [1, 5], [1, 5], [7, 2], [7, 5], [1, 2], [7, 1], [0, 1], [0, 7], [0, 1], [6, 0], [6, 2], [6, 5], [6, 0], [6, 1], [3, 0], [4, 7]]", "opt_solution_cost": "77", "opt_solution_compute_t": "4.278231382369995", "solution_depth": "19", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[\"Red\", \"Yellow\", \"Red\", \"Yellow\", \"Black\"], [\"Black\", \"Blue\", \"Green\", \"Green\", \"Blue\"], [], [], [], [], [\"Black\", \"Blue\", \"Green\", \"Black\", \"Yellow\"], [\"Blue\", \"Green\", \"Yellow\", \"Red\", \"Red\"]], 5, {\"0\": 2, \"1\": 3, \"2\": 5, \"3\": 9, \"4\": 8, \"5\": 5, \"6\": 8, \"7\": 1}]", "is_correct_args": "[[[\"Red\", \"Yellow\", \"Red\", \"Yellow\", \"Black\"], [\"Black\", \"Blue\", \"Green\", \"Green\", \"Blue\"], [], [], [], [], [\"Black\", \"Blue\", \"Green\", \"Black\", \"Yellow\"], [\"Blue\", \"Green\", \"Yellow\", \"Red\", \"Red\"]], 5, {\"0\": 2, \"1\": 3, \"2\": 5, \"3\": 9, \"4\": 8, \"5\": 5, \"6\": 8, \"7\": 1}, 4]", "A*_args": "[\"[['Red', 'Yellow', 'Red', 'Yellow', 'Black'], ['Black', 'Blue', 'Green', 'Green', 'Blue'], [], [], [], [], ['Black', 'Blue', 'Green', 'Black', 'Yellow'], ['Blue', 'Green', 'Yellow', 'Red', 'Red']]\", \"{0: 2, 1: 3, 2: 5, 3: 9, 4: 8, 5: 5, 6: 8, 7: 1}\", \"5\", \"4\"]"}
{"diff_sorted_id": "45", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 10) to his destination workshop at index (6, 1), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 5, and district 3 covering rows 6 to 10. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x 17 12 12 10 9 9 18 x 1]\n[x 8 x 9 x x 18 5 1 12 14]\n[2 19 4 x x x x x x 15 x]\n[17 8 6 x x 10 15 x x x 13]\n[x x x 9 17 x x x x 12 17]\n[x 20 3 1 14 8 9 20 10 8 8]\n[18 19 4 12 3 1 x x 20 6 3]\n[4 6 9 x 8 10 x x 6 9 6]\n[15 x x x x x 16 x 15 4 x]\n[x x x 4 x x x 13 x x x]\n[x 3 x x x x 1 x x 5 13]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "3", "opt_solution": "[[3, 10], [4, 10], [5, 10], [5, 9], [5, 8], [5, 7], [5, 6], [5, 5], [6, 5], [6, 4], [6, 3], [6, 2], [6, 1]]", "opt_solution_cost": "119", "opt_solution_compute_t": "0.02744436264038086", "solution_depth": "13", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"17\", \"12\", \"12\", \"10\", \"9\", \"9\", \"18\", \"x\", \"1\"], [\"x\", \"8\", \"x\", \"9\", \"x\", \"x\", \"18\", \"5\", \"1\", \"12\", \"14\"], [\"2\", \"19\", \"4\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\"], [\"17\", \"8\", \"6\", \"x\", \"x\", \"10\", \"15\", \"x\", \"x\", \"x\", \"13\"], [\"x\", \"x\", \"x\", \"9\", \"17\", \"x\", \"x\", \"x\", \"x\", \"12\", \"17\"], [\"x\", \"20\", \"3\", \"1\", \"14\", \"8\", \"9\", \"20\", \"10\", \"8\", \"8\"], [\"18\", \"19\", \"4\", \"12\", \"3\", \"1\", \"x\", \"x\", \"20\", \"6\", \"3\"], [\"4\", \"6\", \"9\", \"x\", \"8\", \"10\", \"x\", \"x\", \"6\", \"9\", \"6\"], [\"15\", \"x\", \"x\", \"x\", \"x\", \"x\", \"16\", \"x\", \"15\", \"4\", \"x\"], [\"x\", \"x\", \"x\", \"4\", \"x\", \"x\", \"x\", \"13\", \"x\", \"x\", \"x\"], [\"x\", \"3\", \"x\", \"x\", \"x\", \"x\", \"1\", \"x\", \"x\", \"5\", \"13\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"17\", \"12\", \"12\", \"10\", \"9\", \"9\", \"18\", \"x\", \"1\"], [\"x\", \"8\", \"x\", \"9\", \"x\", \"x\", \"18\", \"5\", \"1\", \"12\", \"14\"], [\"2\", \"19\", \"4\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\"], [\"17\", \"8\", \"6\", \"x\", \"x\", \"10\", \"15\", \"x\", \"x\", \"x\", \"13\"], [\"x\", \"x\", \"x\", \"9\", \"17\", \"x\", \"x\", \"x\", \"x\", \"12\", \"17\"], [\"x\", \"20\", \"3\", \"1\", \"14\", \"8\", \"9\", \"20\", \"10\", \"8\", \"8\"], [\"18\", \"19\", \"4\", \"12\", \"3\", \"1\", \"x\", \"x\", \"20\", \"6\", \"3\"], [\"4\", \"6\", \"9\", \"x\", \"8\", \"10\", \"x\", \"x\", \"6\", \"9\", \"6\"], [\"15\", \"x\", \"x\", \"x\", \"x\", \"x\", \"16\", \"x\", \"15\", \"4\", \"x\"], [\"x\", \"x\", \"x\", \"4\", \"x\", \"x\", \"x\", \"13\", \"x\", \"x\", \"x\"], [\"x\", \"3\", \"x\", \"x\", \"x\", \"x\", \"1\", \"x\", \"x\", \"5\", \"13\"]], [3, 10], [6, 1], 3, 5]", "A*_args": "[\"[['x', 'x', '17', '12', '12', '10', '9', '9', '18', 'x', '1'], ['x', '8', 'x', '9', 'x', 'x', '18', '5', '1', '12', '14'], ['2', '19', '4', 'x', 'x', 'x', 'x', 'x', 'x', '15', 'x'], ['17', '8', '6', 'x', 'x', '10', '15', 'x', 'x', 'x', '13'], ['x', 'x', 'x', '9', '17', 'x', 'x', 'x', 'x', '12', '17'], ['x', '20', '3', '1', '14', '8', '9', '20', '10', '8', '8'], ['18', '19', '4', '12', '3', '1', 'x', 'x', '20', '6', '3'], ['4', '6', '9', 'x', '8', '10', 'x', 'x', '6', '9', '6'], ['15', 'x', 'x', 'x', 'x', 'x', '16', 'x', '15', '4', 'x'], ['x', 'x', 'x', '4', 'x', 'x', 'x', '13', 'x', 'x', 'x'], ['x', '3', 'x', 'x', 'x', 'x', '1', 'x', 'x', '5', '13']]\", \"(3, 10)\", \"(6, 1)\", \"3\", \"5\"]"}
{"diff_sorted_id": "45", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 11x11. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 3 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (8, 9). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 0 0 0 0 0 0 0 0 0\n0 0 1 0 1 1 0 1 0 0 1\n0 1 1 1 0 0 0 1 1 0 1\n1 0 1 0 0 1 1 1 1 0 1\n1 1 0 1 0 1 1 1 1 0 0\n1 0 1 0 1 1 1 1 1 1 0\n1 1 0 1 1 1 1 1 0 0 0\n1 1 1 1 1 1 0 0 1 0 0\n0 1 1 1 1 1 0 0 1 0 0\n1 0 0 1 0 0 1 0 1 1 1\n1 0 1 0 1 1 1 1 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "11", "opt_solution": "[[1, 0], [1, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], [1, 8], [1, 9], [2, 9], [3, 9], [4, 9], [5, 10], [6, 10], [7, 10], [8, 9]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.029386281967163086", "solution_depth": "18", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1], [0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1], [1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1], [1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0], [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0], [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1]]\", 3]", "is_correct_args": "[\"[[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1], [0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1], [1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1], [1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0], [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0], [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1]]\", [1, 0], [8, 9], 3]", "A*_args": "[\"[[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1], [0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1], [1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1], [1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0], [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0], [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1]]\", \"(1, 0)\", \"(8, 9)\", \"3\"]"}
{"diff_sorted_id": "45", "problem_statement": "Given 9 labeled water jugs with capacities 116, 16, 79, 75, 30, 87, 28, 96, 15, 134 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 155, 208, 295 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 30, 3], [\"+\", 116, 3], [\"+\", 134, 3], [\"+\", 15, 3], [\"+\", 96, 2], [\"+\", 96, 2], [\"+\", 16, 2], [\"+\", 75, 1], [\"-\", 16, 1], [\"+\", 96, 1]]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.038698434829711914", "solution_depth": "10", "max_successor_states": "60", "num_vars_per_state": "3", "is_feasible_args": "[[116, 16, 79, 75, 30, 87, 28, 96, 15, 134], [155, 208, 295]]", "is_correct_args": "[[116, 16, 79, 75, 30, 87, 28, 96, 15, 134], [155, 208, 295]]", "A*_args": "[\"[116, 16, 79, 75, 30, 87, 28, 96, 15, 134]\", \"[155, 208, 295]\"]"}
{"diff_sorted_id": "46", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[85, '_', 61, 100], [45, 77, 10, 91], [83, 57, 95, 39]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[85, 45, 77, 85, 61, 100, 91, 10, 85, 57, 95, 39, 10, 85, 57, 61, 100, 91, 85, 57, 61, 95, 83, 77, 45, 100, 95, 83, 77, 45, 83, 77, 39, 10]", "opt_solution_cost": "34", "opt_solution_compute_t": "2.4867141246795654", "solution_depth": "34", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[85, \"_\", 61, 100], [45, 77, 10, 91], [83, 57, 95, 39]]]", "is_correct_args": "[[[85, \"_\", 61, 100], [45, 77, 10, 91], [83, 57, 95, 39]]]", "A*_args": "[\"[[85, '_', 61, 100], [45, 77, 10, 91], [83, 57, 95, 39]]\"]"}
{"diff_sorted_id": "46", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: akule, mesode, callid, gyrous   The initial board: [['e', 'a', 'y', 'u', 'i', 'e'], ['m', 'k', 's', 'o', 'd', 'l'], ['c', 'a', '_', 'l', 'e', 'd'], ['g', 'l', 'r', 'o', 'u', 's']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.27361011505126953", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"e\", \"a\", \"y\", \"u\", \"i\", \"e\"], [\"m\", \"k\", \"s\", \"o\", \"d\", \"l\"], [\"c\", \"a\", \"_\", \"l\", \"e\", \"d\"], [\"g\", \"l\", \"r\", \"o\", \"u\", \"s\"]]]", "is_correct_args": "[[[\"e\", \"a\", \"y\", \"u\", \"i\", \"e\"], [\"m\", \"k\", \"s\", \"o\", \"d\", \"l\"], [\"c\", \"a\", \"_\", \"l\", \"e\", \"d\"], [\"g\", \"l\", \"r\", \"o\", \"u\", \"s\"]], [\"akule\", \"mesode\", \"callid\", \"gyrous\"]]", "A*_args": "[\"[['e', 'a', 'y', 'u', 'i', 'e'], ['m', 'k', 's', 'o', 'd', 'l'], ['c', 'a', '_', 'l', 'e', 'd'], ['g', 'l', 'r', 'o', 'u', 's']]\", \"['akule', 'mesode', 'callid', 'gyrous']\"]"}
{"diff_sorted_id": "46", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'O'. Our task is to visit city M and city K excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from K and M, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  O T F C K U X G A M W Y \nO 0 0 0 0 0 0 0 0 0 0 0 1 \nT 1 0 0 0 0 0 0 1 0 1 0 0 \nF 0 1 0 1 0 0 0 0 0 0 0 0 \nC 0 0 0 0 1 0 1 0 0 0 0 1 \nK 1 0 1 0 0 0 0 0 1 1 0 0 \nU 0 0 0 0 0 0 0 1 0 0 1 0 \nX 0 0 1 0 0 1 0 0 1 0 0 0 \nG 0 0 0 0 1 1 0 0 0 0 0 1 \nA 0 1 0 1 0 0 0 0 0 0 0 0 \nM 0 1 0 0 0 1 1 0 1 0 0 0 \nW 1 0 0 0 1 0 0 0 0 1 0 0 \nY 0 1 1 0 0 0 0 0 0 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[\"O\", \"Y\", \"W\", \"K\", \"M\", \"A\", \"C\", \"K\", \"M\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.027652263641357422", "solution_depth": "9", "max_successor_states": "12", "num_vars_per_state": "15", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]], [\"O\", \"T\", \"F\", \"C\", \"K\", \"U\", \"X\", \"G\", \"A\", \"M\", \"W\", \"Y\"], \"M\", \"K\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]], [\"O\", \"T\", \"F\", \"C\", \"K\", \"U\", \"X\", \"G\", \"A\", \"M\", \"W\", \"Y\"], \"O\", \"M\", \"K\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]]\", \"['O', 'T', 'F', 'C', 'K', 'U', 'X', 'G', 'A', 'M', 'W', 'Y']\", \"['O']\", \"['M', 'K']\"]"}
{"diff_sorted_id": "46", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [11, 6, 147, 6, 19, 29, 28, 32, 18, 20, 12, 22, 4, 20, 27, 3, 3, 18, 19, 9, 2, 28, 31, 20, 2, 27, 22, 30, 3], such that the sum of the chosen coins adds up to 324. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {27: 18, 6: 2, 22: 12, 18: 11, 4: 3, 12: 4, 28: 6, 147: 10, 32: 6, 19: 3, 29: 12, 31: 19, 20: 4, 2: 2, 30: 17, 3: 2, 11: 10, 9: 2}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "18", "opt_solution": "[32, 28, 12, 19, 19, 147, 28, 20, 6, 9, 4]", "opt_solution_cost": "49", "opt_solution_compute_t": "0.04179191589355469", "solution_depth": "11", "max_successor_states": "29", "num_vars_per_state": "29", "is_feasible_args": "[[11, 6, 147, 6, 19, 29, 28, 32, 18, 20, 12, 22, 4, 20, 27, 3, 3, 18, 19, 9, 2, 28, 31, 20, 2, 27, 22, 30, 3]]", "is_correct_args": "[[11, 6, 147, 6, 19, 29, 28, 32, 18, 20, 12, 22, 4, 20, 27, 3, 3, 18, 19, 9, 2, 28, 31, 20, 2, 27, 22, 30, 3], {\"27\": 18, \"6\": 2, \"22\": 12, \"18\": 11, \"4\": 3, \"12\": 4, \"28\": 6, \"147\": 10, \"32\": 6, \"19\": 3, \"29\": 12, \"31\": 19, \"20\": 4, \"2\": 2, \"30\": 17, \"3\": 2, \"11\": 10, \"9\": 2}, 324]", "A*_args": "[\"[11, 6, 147, 6, 19, 29, 28, 32, 18, 20, 12, 22, 4, 20, 27, 3, 3, 18, 19, 9, 2, 28, 31, 20, 2, 27, 22, 30, 3]\", \"{27: 18, 6: 2, 22: 12, 18: 11, 4: 3, 12: 4, 28: 6, 147: 10, 32: 6, 19: 3, 29: 12, 31: 19, 20: 4, 2: 2, 30: 17, 3: 2, 11: 10, 9: 2}\", \"324\"]"}
{"diff_sorted_id": "46", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Blue', 'Red', 'Red'], ['Blue', 'Green', 'Green', 'Blue'], ['Green', 'Blue', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[2, 1], [2, 0], [2, 1], [2, 0], [1, 2], [1, 2], [1, 0], [1, 2], [1, 2], [0, 1], [0, 2], [0, 1], [0, 2], [0, 1], [2, 0], [2, 0]]", "opt_solution_cost": "16", "opt_solution_compute_t": "1.27297043800354", "solution_depth": "16", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Blue\", \"Red\", \"Red\"], [\"Blue\", \"Green\", \"Green\", \"Blue\"], [\"Green\", \"Blue\", \"Green\", \"Red\"]], 7]", "is_correct_args": "[[[\"Red\", \"Blue\", \"Red\", \"Red\"], [\"Blue\", \"Green\", \"Green\", \"Blue\"], [\"Green\", \"Blue\", \"Green\", \"Red\"]], 7]", "A*_args": "[\"[['Red', 'Blue', 'Red', 'Red'], ['Blue', 'Green', 'Green', 'Blue'], ['Green', 'Blue', 'Green', 'Red']]\", \"7\"]"}
{"diff_sorted_id": "46", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 9 to 49 (9 included in the range but 49 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '29' '41' 'x']\n ['x' 'x' '32' '43']\n ['23' '25' '29' '44']\n ['12' 'x' '20' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 0, 26], [0, 3, 42], [1, 0, 24], [1, 1, 27], [3, 1, 13], [3, 3, 45]]", "opt_solution_cost": "439", "opt_solution_compute_t": "0.18374395370483398", "solution_depth": "6", "max_successor_states": "40", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '29', '41', ''], ['', '', '32', '43'], ['23', '25', '29', '44'], ['12', '', '20', '']]\", 9, 49]", "is_correct_args": "[\"[['', '29', '41', ''], ['', '', '32', '43'], ['23', '25', '29', '44'], ['12', '', '20', '']]\", 9, 49]", "A*_args": "[\"[['', '29', '41', ''], ['', '', '32', '43'], ['23', '25', '29', '44'], ['12', '', '20', '']]\", \"9\", \"49\"]"}
{"diff_sorted_id": "46", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 35 to 61. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 151, 189, None for columns 1 to 2 respectively, and the sums of rows must be None, 180, 176, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 184. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x' 'x']\n ['x' '37' 'x' '41']\n ['48' 'x' 'x' 'x']\n ['49' 'x' '46' '38']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 36], [0, 1, 39], [0, 2, 44], [0, 3, 43], [1, 0, 45], [1, 2, 57], [2, 1, 35], [2, 2, 42], [2, 3, 51], [3, 1, 40]]", "opt_solution_cost": "691", "opt_solution_compute_t": "5.864994525909424", "solution_depth": "10", "max_successor_states": "44", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', '', ''], ['', '37', '', '41'], ['48', '', '', ''], ['49', '', '46', '38']]\", 4, 35, 61]", "is_correct_args": "[\"[['', '', '', ''], ['', '37', '', '41'], ['48', '', '', ''], ['49', '', '46', '38']]\", 35, 61, [1, 3], [1, 3], [151, 189], [180, 176], 184]", "A*_args": "[\"[['', '', '', ''], ['', '37', '', '41'], ['48', '', '', ''], ['49', '', '46', '38']]\", \"35\", \"61\", \"[None, 151, 189, None]\", \"[None, 180, 176, None]\", \"184\"]"}
{"diff_sorted_id": "46", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 2, 1: 1, 2: 6, 3: 3, 4: 1, 5: 5, 6: 4, 7: 2}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], [], ['Yellow', 'Black', 'Yellow', 'Black', 'Green'], ['Red', 'Yellow', 'Blue', 'Black', 'Black'], [], ['Red', 'Blue', 'Green', 'Red', 'Blue'], ['Green', 'Blue', 'Red', 'Yellow', 'Green']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[4, 2], [3, 5], [4, 5], [4, 0], [3, 4], [3, 5], [3, 4], [7, 3], [7, 0], [7, 1], [7, 5], [6, 1], [6, 0], [6, 3], [7, 3], [6, 1], [6, 0], [2, 1]]", "opt_solution_cost": "49", "opt_solution_compute_t": "12.073513269424438", "solution_depth": "18", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[], [], [], [\"Yellow\", \"Black\", \"Yellow\", \"Black\", \"Green\"], [\"Red\", \"Yellow\", \"Blue\", \"Black\", \"Black\"], [], [\"Red\", \"Blue\", \"Green\", \"Red\", \"Blue\"], [\"Green\", \"Blue\", \"Red\", \"Yellow\", \"Green\"]], 5, {\"0\": 2, \"1\": 1, \"2\": 6, \"3\": 3, \"4\": 1, \"5\": 5, \"6\": 4, \"7\": 2}]", "is_correct_args": "[[[], [], [], [\"Yellow\", \"Black\", \"Yellow\", \"Black\", \"Green\"], [\"Red\", \"Yellow\", \"Blue\", \"Black\", \"Black\"], [], [\"Red\", \"Blue\", \"Green\", \"Red\", \"Blue\"], [\"Green\", \"Blue\", \"Red\", \"Yellow\", \"Green\"]], 5, {\"0\": 2, \"1\": 1, \"2\": 6, \"3\": 3, \"4\": 1, \"5\": 5, \"6\": 4, \"7\": 2}, 4]", "A*_args": "[\"[[], [], [], ['Yellow', 'Black', 'Yellow', 'Black', 'Green'], ['Red', 'Yellow', 'Blue', 'Black', 'Black'], [], ['Red', 'Blue', 'Green', 'Red', 'Blue'], ['Green', 'Blue', 'Red', 'Yellow', 'Green']]\", \"{0: 2, 1: 1, 2: 6, 3: 3, 4: 1, 5: 5, 6: 4, 7: 2}\", \"5\", \"4\"]"}
{"diff_sorted_id": "46", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (1, 0) to his destination workshop at index (8, 10), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 7, and district 3 covering rows 8 to 11. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[3 14 2 x x x 19 13 17 12 8 x]\n[1 2 13 1 4 19 x x 16 x x 12]\n[9 8 9 15 x 12 x x x x x 14]\n[11 1 10 18 x 16 1 x 12 x x x]\n[7 16 13 10 13 x 14 x x 9 x 7]\n[19 7 7 20 13 14 18 x x 7 5 x]\n[4 x 11 x x 2 7 1 5 x x x]\n[x x x x x x x x 18 x 1 x]\n[4 x x 9 19 2 18 8 16 14 19 7]\n[x x x x 9 x 17 17 1 2 2 15]\n[18 x x x x x x 11 10 x 17 x]\n[9 x x x 10 3 x x 13 x 2 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "4", "opt_solution": "[[1, 0], [1, 1], [2, 1], [3, 1], [3, 2], [4, 2], [4, 3], [4, 4], [5, 4], [5, 5], [6, 5], [6, 6], [6, 7], [6, 8], [7, 8], [8, 8], [9, 8], [9, 9], [9, 10], [8, 10]]", "opt_solution_cost": "157", "opt_solution_compute_t": "0.030195236206054688", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"3\", \"14\", \"2\", \"x\", \"x\", \"x\", \"19\", \"13\", \"17\", \"12\", \"8\", \"x\"], [\"1\", \"2\", \"13\", \"1\", \"4\", \"19\", \"x\", \"x\", \"16\", \"x\", \"x\", \"12\"], [\"9\", \"8\", \"9\", \"15\", \"x\", \"12\", \"x\", \"x\", \"x\", \"x\", \"x\", \"14\"], [\"11\", \"1\", \"10\", \"18\", \"x\", \"16\", \"1\", \"x\", \"12\", \"x\", \"x\", \"x\"], [\"7\", \"16\", \"13\", \"10\", \"13\", \"x\", \"14\", \"x\", \"x\", \"9\", \"x\", \"7\"], [\"19\", \"7\", \"7\", \"20\", \"13\", \"14\", \"18\", \"x\", \"x\", \"7\", \"5\", \"x\"], [\"4\", \"x\", \"11\", \"x\", \"x\", \"2\", \"7\", \"1\", \"5\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"18\", \"x\", \"1\", \"x\"], [\"4\", \"x\", \"x\", \"9\", \"19\", \"2\", \"18\", \"8\", \"16\", \"14\", \"19\", \"7\"], [\"x\", \"x\", \"x\", \"x\", \"9\", \"x\", \"17\", \"17\", \"1\", \"2\", \"2\", \"15\"], [\"18\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"11\", \"10\", \"x\", \"17\", \"x\"], [\"9\", \"x\", \"x\", \"x\", \"10\", \"3\", \"x\", \"x\", \"13\", \"x\", \"2\", \"x\"]]]", "is_correct_args": "[[[\"3\", \"14\", \"2\", \"x\", \"x\", \"x\", \"19\", \"13\", \"17\", \"12\", \"8\", \"x\"], [\"1\", \"2\", \"13\", \"1\", \"4\", \"19\", \"x\", \"x\", \"16\", \"x\", \"x\", \"12\"], [\"9\", \"8\", \"9\", \"15\", \"x\", \"12\", \"x\", \"x\", \"x\", \"x\", \"x\", \"14\"], [\"11\", \"1\", \"10\", \"18\", \"x\", \"16\", \"1\", \"x\", \"12\", \"x\", \"x\", \"x\"], [\"7\", \"16\", \"13\", \"10\", \"13\", \"x\", \"14\", \"x\", \"x\", \"9\", \"x\", \"7\"], [\"19\", \"7\", \"7\", \"20\", \"13\", \"14\", \"18\", \"x\", \"x\", \"7\", \"5\", \"x\"], [\"4\", \"x\", \"11\", \"x\", \"x\", \"2\", \"7\", \"1\", \"5\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"18\", \"x\", \"1\", \"x\"], [\"4\", \"x\", \"x\", \"9\", \"19\", \"2\", \"18\", \"8\", \"16\", \"14\", \"19\", \"7\"], [\"x\", \"x\", \"x\", \"x\", \"9\", \"x\", \"17\", \"17\", \"1\", \"2\", \"2\", \"15\"], [\"18\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"11\", \"10\", \"x\", \"17\", \"x\"], [\"9\", \"x\", \"x\", \"x\", \"10\", \"3\", \"x\", \"x\", \"13\", \"x\", \"2\", \"x\"]], [1, 0], [8, 10], 1, 7]", "A*_args": "[\"[['3', '14', '2', 'x', 'x', 'x', '19', '13', '17', '12', '8', 'x'], ['1', '2', '13', '1', '4', '19', 'x', 'x', '16', 'x', 'x', '12'], ['9', '8', '9', '15', 'x', '12', 'x', 'x', 'x', 'x', 'x', '14'], ['11', '1', '10', '18', 'x', '16', '1', 'x', '12', 'x', 'x', 'x'], ['7', '16', '13', '10', '13', 'x', '14', 'x', 'x', '9', 'x', '7'], ['19', '7', '7', '20', '13', '14', '18', 'x', 'x', '7', '5', 'x'], ['4', 'x', '11', 'x', 'x', '2', '7', '1', '5', 'x', 'x', 'x'], ['x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', '18', 'x', '1', 'x'], ['4', 'x', 'x', '9', '19', '2', '18', '8', '16', '14', '19', '7'], ['x', 'x', 'x', 'x', '9', 'x', '17', '17', '1', '2', '2', '15'], ['18', 'x', 'x', 'x', 'x', 'x', 'x', '11', '10', 'x', '17', 'x'], ['9', 'x', 'x', 'x', '10', '3', 'x', 'x', '13', 'x', '2', 'x']]\", \"(1, 0)\", \"(8, 10)\", \"1\", \"7\"]"}
{"diff_sorted_id": "46", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 12x12. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (7, 11). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 1 1 0 0 1 1 1 0 0 0\n0 1 1 0 1 0 1 0 0 1 0 1\n0 0 0 0 1 1 0 1 1 1 0 1\n0 0 0 0 1 0 0 0 1 1 1 1\n1 0 1 1 0 1 1 1 1 0 1 1\n0 1 0 0 0 1 0 0 0 0 0 0\n1 1 1 1 0 0 0 0 1 0 0 0\n1 0 1 0 0 0 0 0 1 0 0 0\n1 0 1 1 1 0 0 0 0 1 0 1\n0 1 1 1 1 1 1 1 1 1 1 0\n1 1 1 0 0 1 0 0 0 0 1 1\n0 1 1 0 1 1 1 0 1 0 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[[1, 0], [2, 0], [2, 1], [2, 2], [2, 3], [3, 3], [4, 4], [5, 4], [6, 4], [6, 5], [6, 6], [6, 7], [5, 8], [5, 9], [6, 10], [7, 11]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.028974056243896484", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0], [0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1], [0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1], [0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1]]\", 4]", "is_correct_args": "[\"[[0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0], [0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1], [0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1], [0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1]]\", [1, 0], [7, 11], 4]", "A*_args": "[\"[[0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0], [0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1], [0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1], [1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1], [0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1]]\", \"(1, 0)\", \"(7, 11)\", \"4\"]"}
{"diff_sorted_id": "46", "problem_statement": "Given 9 labeled water jugs with capacities 20, 142, 147, 48, 29, 113, 17, 18, 112, 68 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 287, 423, 583 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 142, 3], [\"+\", 147, 3], [\"+\", 147, 3], [\"+\", 147, 3], [\"+\", 112, 2], [\"+\", 147, 2], [\"+\", 17, 2], [\"+\", 147, 2], [\"+\", 142, 1], [\"+\", 142, 1], [\"-\", 17, 1], [\"+\", 20, 1]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.04404854774475098", "solution_depth": "12", "max_successor_states": "60", "num_vars_per_state": "3", "is_feasible_args": "[[20, 142, 147, 48, 29, 113, 17, 18, 112, 68], [287, 423, 583]]", "is_correct_args": "[[20, 142, 147, 48, 29, 113, 17, 18, 112, 68], [287, 423, 583]]", "A*_args": "[\"[20, 142, 147, 48, 29, 113, 17, 18, 112, 68]\", \"[287, 423, 583]\"]"}
{"diff_sorted_id": "47", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[69, 92, 89, 72], [82, 13, 65, 59], [45, '_', 67, 8]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[13, 82, 45, 13, 67, 65, 82, 67, 13, 45, 69, 92, 89, 82, 65, 8]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.043500661849975586", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[69, 92, 89, 72], [82, 13, 65, 59], [45, \"_\", 67, 8]]]", "is_correct_args": "[[[69, 92, 89, 72], [82, 13, 65, 59], [45, \"_\", 67, 8]]]", "A*_args": "[\"[[69, 92, 89, 72], [82, 13, 65, 59], [45, '_', 67, 8]]\"]"}
{"diff_sorted_id": "47", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: pongo, urchin, ondine, blinks   The initial board: [['r', 'p', '_', 'n', 'n', 'o'], ['u', 'o', 'c', 'o', 'i', 'n'], ['l', 'n', 'h', 'i', 'g', 'e'], ['b', 'd', 'i', 'n', 'k', 's']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.1886446475982666", "solution_depth": "10", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"r\", \"p\", \"_\", \"n\", \"n\", \"o\"], [\"u\", \"o\", \"c\", \"o\", \"i\", \"n\"], [\"l\", \"n\", \"h\", \"i\", \"g\", \"e\"], [\"b\", \"d\", \"i\", \"n\", \"k\", \"s\"]]]", "is_correct_args": "[[[\"r\", \"p\", \"_\", \"n\", \"n\", \"o\"], [\"u\", \"o\", \"c\", \"o\", \"i\", \"n\"], [\"l\", \"n\", \"h\", \"i\", \"g\", \"e\"], [\"b\", \"d\", \"i\", \"n\", \"k\", \"s\"]], [\"pongo\", \"urchin\", \"ondine\", \"blinks\"]]", "A*_args": "[\"[['r', 'p', '_', 'n', 'n', 'o'], ['u', 'o', 'c', 'o', 'i', 'n'], ['l', 'n', 'h', 'i', 'g', 'e'], ['b', 'd', 'i', 'n', 'k', 's']]\", \"['pongo', 'urchin', 'ondine', 'blinks']\"]"}
{"diff_sorted_id": "47", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'Z'. Our task is to visit city C and city D excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from D and C, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  Z O F M C K B U D R S J \nZ 0 0 0 0 0 1 0 0 0 1 0 0 \nO 0 0 0 0 1 0 0 0 0 0 0 0 \nF 0 1 0 0 0 0 1 1 1 0 0 0 \nM 1 0 1 0 0 1 0 0 1 0 0 0 \nC 0 0 1 0 0 0 0 1 0 1 0 1 \nK 0 1 0 0 0 0 0 0 1 1 0 0 \nB 0 0 1 0 1 0 0 1 0 0 1 0 \nU 1 0 0 1 0 0 0 0 1 1 0 1 \nD 0 1 0 0 0 1 0 0 0 0 1 0 \nR 0 0 1 0 0 0 1 0 0 0 1 0 \nS 0 0 1 1 1 0 0 0 0 1 0 0 \nJ 0 1 0 0 0 0 1 0 1 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[\"Z\", \"K\", \"D\", \"O\", \"C\", \"F\", \"D\", \"S\", \"C\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.02916431427001953", "solution_depth": "9", "max_successor_states": "12", "num_vars_per_state": "15", "is_feasible_args": "[[[0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0]], [\"Z\", \"O\", \"F\", \"M\", \"C\", \"K\", \"B\", \"U\", \"D\", \"R\", \"S\", \"J\"], \"C\", \"D\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0]], [\"Z\", \"O\", \"F\", \"M\", \"C\", \"K\", \"B\", \"U\", \"D\", \"R\", \"S\", \"J\"], \"Z\", \"C\", \"D\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0]]\", \"['Z', 'O', 'F', 'M', 'C', 'K', 'B', 'U', 'D', 'R', 'S', 'J']\", \"['Z']\", \"['C', 'D']\"]"}
{"diff_sorted_id": "47", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [18, 26, 17, 17, 16, 27, 30, 3, 4, 2, 24, 26, 29, 23, 2, 31, 25, 25, 4, 24, 14, 29, 4, 34, 34, 23, 35, 23, 28, 18, 8, 10, 17, 8, 22, 32], such that the sum of the chosen coins adds up to 342. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {27: 14, 14: 1, 18: 3, 22: 9, 10: 8, 3: 2, 32: 20, 35: 16, 8: 3, 30: 20, 25: 18, 4: 3, 28: 12, 26: 16, 29: 2, 24: 20, 16: 6, 17: 3, 31: 9, 2: 2, 23: 17, 34: 17}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "19", "opt_solution": "[17, 29, 29, 18, 8, 17, 17, 31, 22, 18, 16, 8, 4, 35, 28, 14, 4, 27]", "opt_solution_cost": "98", "opt_solution_compute_t": "0.0500178337097168", "solution_depth": "18", "max_successor_states": "36", "num_vars_per_state": "36", "is_feasible_args": "[[18, 26, 17, 17, 16, 27, 30, 3, 4, 2, 24, 26, 29, 23, 2, 31, 25, 25, 4, 24, 14, 29, 4, 34, 34, 23, 35, 23, 28, 18, 8, 10, 17, 8, 22, 32]]", "is_correct_args": "[[18, 26, 17, 17, 16, 27, 30, 3, 4, 2, 24, 26, 29, 23, 2, 31, 25, 25, 4, 24, 14, 29, 4, 34, 34, 23, 35, 23, 28, 18, 8, 10, 17, 8, 22, 32], {\"27\": 14, \"14\": 1, \"18\": 3, \"22\": 9, \"10\": 8, \"3\": 2, \"32\": 20, \"35\": 16, \"8\": 3, \"30\": 20, \"25\": 18, \"4\": 3, \"28\": 12, \"26\": 16, \"29\": 2, \"24\": 20, \"16\": 6, \"17\": 3, \"31\": 9, \"2\": 2, \"23\": 17, \"34\": 17}, 342]", "A*_args": "[\"[18, 26, 17, 17, 16, 27, 30, 3, 4, 2, 24, 26, 29, 23, 2, 31, 25, 25, 4, 24, 14, 29, 4, 34, 34, 23, 35, 23, 28, 18, 8, 10, 17, 8, 22, 32]\", \"{27: 14, 14: 1, 18: 3, 22: 9, 10: 8, 3: 2, 32: 20, 35: 16, 8: 3, 30: 20, 25: 18, 4: 3, 28: 12, 26: 16, 29: 2, 24: 20, 16: 6, 17: 3, 31: 9, 2: 2, 23: 17, 34: 17}\", \"342\"]"}
{"diff_sorted_id": "47", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Red', 'Green', 'Green'], ['Green', 'Blue', 'Red', 'Blue'], ['Red', 'Green', 'Blue', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[1, 2], [0, 1], [0, 1], [2, 0], [2, 1], [2, 0], [2, 0], [1, 2], [1, 2], [1, 0], [1, 0], [1, 2], [0, 1], [0, 1], [0, 1]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.9043323993682861", "solution_depth": "15", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Blue\", \"Red\", \"Green\", \"Green\"], [\"Green\", \"Blue\", \"Red\", \"Blue\"], [\"Red\", \"Green\", \"Blue\", \"Red\"]], 7]", "is_correct_args": "[[[\"Blue\", \"Red\", \"Green\", \"Green\"], [\"Green\", \"Blue\", \"Red\", \"Blue\"], [\"Red\", \"Green\", \"Blue\", \"Red\"]], 7]", "A*_args": "[\"[['Blue', 'Red', 'Green', 'Green'], ['Green', 'Blue', 'Red', 'Blue'], ['Red', 'Green', 'Blue', 'Red']]\", \"7\"]"}
{"diff_sorted_id": "47", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 27 to 67 (27 included in the range but 67 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['27' '37' 'x' 'x']\n ['30' 'x' 'x' 'x']\n ['32' '44' '53' '61']\n ['33' '54' 'x' '64']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 2, 38], [0, 3, 39], [1, 1, 40], [1, 2, 41], [1, 3, 42], [3, 2, 55]]", "opt_solution_cost": "531", "opt_solution_compute_t": "0.3982374668121338", "solution_depth": "6", "max_successor_states": "40", "num_vars_per_state": "16", "is_feasible_args": "[\"[['27', '37', '', ''], ['30', '', '', ''], ['32', '44', '53', '61'], ['33', '54', '', '64']]\", 27, 67]", "is_correct_args": "[\"[['27', '37', '', ''], ['30', '', '', ''], ['32', '44', '53', '61'], ['33', '54', '', '64']]\", 27, 67]", "A*_args": "[\"[['27', '37', '', ''], ['30', '', '', ''], ['32', '44', '53', '61'], ['33', '54', '', '64']]\", \"27\", \"67\"]"}
{"diff_sorted_id": "47", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 34 to 60. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 198, 175, None for columns 1 to 2 respectively, and the sums of rows must be None, 201, 190, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 193. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '46' 'x' 'x']\n ['44' 'x' 'x' '53']\n ['39' 'x' 'x' 'x']\n ['x' 'x' 'x' '38']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 35], [0, 2, 34], [0, 3, 37], [1, 1, 48], [1, 2, 56], [2, 1, 59], [2, 2, 49], [2, 3, 43], [3, 0, 41], [3, 1, 45], [3, 2, 36]]", "opt_solution_cost": "703", "opt_solution_compute_t": "98.62403774261475", "solution_depth": "11", "max_successor_states": "44", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '46', '', ''], ['44', '', '', '53'], ['39', '', '', ''], ['', '', '', '38']]\", 4, 34, 60]", "is_correct_args": "[\"[['', '46', '', ''], ['44', '', '', '53'], ['39', '', '', ''], ['', '', '', '38']]\", 34, 60, [1, 3], [1, 3], [198, 175], [201, 190], 193]", "A*_args": "[\"[['', '46', '', ''], ['44', '', '', '53'], ['39', '', '', ''], ['', '', '', '38']]\", \"34\", \"60\", \"[None, 198, 175, None]\", \"[None, 201, 190, None]\", \"193\"]"}
{"diff_sorted_id": "47", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 4, 1: 6, 2: 8, 3: 2, 4: 4, 5: 7, 6: 7, 7: 5}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], ['Red', 'Yellow', 'Black', 'Yellow', 'Green'], ['Red', 'Red', 'Blue', 'Red', 'Black'], [], ['Black', 'Blue', 'Yellow', 'Blue', 'Black'], [], ['Green', 'Green', 'Yellow', 'Blue', 'Green']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[2, 0], [5, 1], [2, 4], [2, 1], [2, 4], [5, 6], [5, 4], [5, 6], [3, 0], [3, 0], [3, 6], [3, 0], [3, 1], [7, 3], [7, 3], [7, 4], [7, 6], [5, 1], [2, 3], [7, 3]]", "opt_solution_cost": "92", "opt_solution_compute_t": "0.5225863456726074", "solution_depth": "20", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[], [], [\"Red\", \"Yellow\", \"Black\", \"Yellow\", \"Green\"], [\"Red\", \"Red\", \"Blue\", \"Red\", \"Black\"], [], [\"Black\", \"Blue\", \"Yellow\", \"Blue\", \"Black\"], [], [\"Green\", \"Green\", \"Yellow\", \"Blue\", \"Green\"]], 5, {\"0\": 4, \"1\": 6, \"2\": 8, \"3\": 2, \"4\": 4, \"5\": 7, \"6\": 7, \"7\": 5}]", "is_correct_args": "[[[], [], [\"Red\", \"Yellow\", \"Black\", \"Yellow\", \"Green\"], [\"Red\", \"Red\", \"Blue\", \"Red\", \"Black\"], [], [\"Black\", \"Blue\", \"Yellow\", \"Blue\", \"Black\"], [], [\"Green\", \"Green\", \"Yellow\", \"Blue\", \"Green\"]], 5, {\"0\": 4, \"1\": 6, \"2\": 8, \"3\": 2, \"4\": 4, \"5\": 7, \"6\": 7, \"7\": 5}, 4]", "A*_args": "[\"[[], [], ['Red', 'Yellow', 'Black', 'Yellow', 'Green'], ['Red', 'Red', 'Blue', 'Red', 'Black'], [], ['Black', 'Blue', 'Yellow', 'Blue', 'Black'], [], ['Green', 'Green', 'Yellow', 'Blue', 'Green']]\", \"{0: 4, 1: 6, 2: 8, 3: 2, 4: 4, 5: 7, 6: 7, 7: 5}\", \"5\", \"4\"]"}
{"diff_sorted_id": "47", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (4, 11) to his destination workshop at index (6, 0), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 4, district 2 covering rows 5 to 5, and district 3 covering rows 6 to 11. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[5 x x 4 x 12 7 11 8 3 19 x]\n[x x 6 15 16 x x 4 x 7 8 19]\n[18 x x 15 x x x 8 4 16 7 9]\n[x 19 x x x 16 x x 17 15 x 9]\n[15 8 19 x 4 4 x x x 3 3 10]\n[18 6 14 5 x 18 19 15 18 19 12 5]\n[12 x 2 2 6 3 3 8 3 1 x 15]\n[10 4 x 9 15 3 x 7 x 17 x x]\n[5 18 x 17 x 17 x x 15 x 18 x]\n[4 x 16 11 10 3 12 x 11 14 3 x]\n[x 9 9 14 19 15 x 1 10 19 6 x]\n[x x 17 4 x 2 x 7 x 4 4 18]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "4", "opt_solution": "[[4, 11], [4, 10], [4, 9], [5, 9], [6, 9], [6, 8], [6, 7], [6, 6], [6, 5], [6, 4], [6, 3], [6, 2], [5, 2], [5, 1], [5, 0], [6, 0]]", "opt_solution_cost": "103", "opt_solution_compute_t": "0.027801036834716797", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"5\", \"x\", \"x\", \"4\", \"x\", \"12\", \"7\", \"11\", \"8\", \"3\", \"19\", \"x\"], [\"x\", \"x\", \"6\", \"15\", \"16\", \"x\", \"x\", \"4\", \"x\", \"7\", \"8\", \"19\"], [\"18\", \"x\", \"x\", \"15\", \"x\", \"x\", \"x\", \"8\", \"4\", \"16\", \"7\", \"9\"], [\"x\", \"19\", \"x\", \"x\", \"x\", \"16\", \"x\", \"x\", \"17\", \"15\", \"x\", \"9\"], [\"15\", \"8\", \"19\", \"x\", \"4\", \"4\", \"x\", \"x\", \"x\", \"3\", \"3\", \"10\"], [\"18\", \"6\", \"14\", \"5\", \"x\", \"18\", \"19\", \"15\", \"18\", \"19\", \"12\", \"5\"], [\"12\", \"x\", \"2\", \"2\", \"6\", \"3\", \"3\", \"8\", \"3\", \"1\", \"x\", \"15\"], [\"10\", \"4\", \"x\", \"9\", \"15\", \"3\", \"x\", \"7\", \"x\", \"17\", \"x\", \"x\"], [\"5\", \"18\", \"x\", \"17\", \"x\", \"17\", \"x\", \"x\", \"15\", \"x\", \"18\", \"x\"], [\"4\", \"x\", \"16\", \"11\", \"10\", \"3\", \"12\", \"x\", \"11\", \"14\", \"3\", \"x\"], [\"x\", \"9\", \"9\", \"14\", \"19\", \"15\", \"x\", \"1\", \"10\", \"19\", \"6\", \"x\"], [\"x\", \"x\", \"17\", \"4\", \"x\", \"2\", \"x\", \"7\", \"x\", \"4\", \"4\", \"18\"]]]", "is_correct_args": "[[[\"5\", \"x\", \"x\", \"4\", \"x\", \"12\", \"7\", \"11\", \"8\", \"3\", \"19\", \"x\"], [\"x\", \"x\", \"6\", \"15\", \"16\", \"x\", \"x\", \"4\", \"x\", \"7\", \"8\", \"19\"], [\"18\", \"x\", \"x\", \"15\", \"x\", \"x\", \"x\", \"8\", \"4\", \"16\", \"7\", \"9\"], [\"x\", \"19\", \"x\", \"x\", \"x\", \"16\", \"x\", \"x\", \"17\", \"15\", \"x\", \"9\"], [\"15\", \"8\", \"19\", \"x\", \"4\", \"4\", \"x\", \"x\", \"x\", \"3\", \"3\", \"10\"], [\"18\", \"6\", \"14\", \"5\", \"x\", \"18\", \"19\", \"15\", \"18\", \"19\", \"12\", \"5\"], [\"12\", \"x\", \"2\", \"2\", \"6\", \"3\", \"3\", \"8\", \"3\", \"1\", \"x\", \"15\"], [\"10\", \"4\", \"x\", \"9\", \"15\", \"3\", \"x\", \"7\", \"x\", \"17\", \"x\", \"x\"], [\"5\", \"18\", \"x\", \"17\", \"x\", \"17\", \"x\", \"x\", \"15\", \"x\", \"18\", \"x\"], [\"4\", \"x\", \"16\", \"11\", \"10\", \"3\", \"12\", \"x\", \"11\", \"14\", \"3\", \"x\"], [\"x\", \"9\", \"9\", \"14\", \"19\", \"15\", \"x\", \"1\", \"10\", \"19\", \"6\", \"x\"], [\"x\", \"x\", \"17\", \"4\", \"x\", \"2\", \"x\", \"7\", \"x\", \"4\", \"4\", \"18\"]], [4, 11], [6, 0], 4, 5]", "A*_args": "[\"[['5', 'x', 'x', '4', 'x', '12', '7', '11', '8', '3', '19', 'x'], ['x', 'x', '6', '15', '16', 'x', 'x', '4', 'x', '7', '8', '19'], ['18', 'x', 'x', '15', 'x', 'x', 'x', '8', '4', '16', '7', '9'], ['x', '19', 'x', 'x', 'x', '16', 'x', 'x', '17', '15', 'x', '9'], ['15', '8', '19', 'x', '4', '4', 'x', 'x', 'x', '3', '3', '10'], ['18', '6', '14', '5', 'x', '18', '19', '15', '18', '19', '12', '5'], ['12', 'x', '2', '2', '6', '3', '3', '8', '3', '1', 'x', '15'], ['10', '4', 'x', '9', '15', '3', 'x', '7', 'x', '17', 'x', 'x'], ['5', '18', 'x', '17', 'x', '17', 'x', 'x', '15', 'x', '18', 'x'], ['4', 'x', '16', '11', '10', '3', '12', 'x', '11', '14', '3', 'x'], ['x', '9', '9', '14', '19', '15', 'x', '1', '10', '19', '6', 'x'], ['x', 'x', '17', '4', 'x', '2', 'x', '7', 'x', '4', '4', '18']]\", \"(4, 11)\", \"(6, 0)\", \"4\", \"5\"]"}
{"diff_sorted_id": "47", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 12x12. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (11, 9) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (0, 3). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 0 0 0 0 0 0 0 0 1\n1 1 1 1 0 0 0 0 0 0 1 1\n1 1 0 0 0 0 1 0 0 0 0 1\n1 1 1 0 1 1 1 0 1 1 0 1\n1 0 1 1 1 0 0 0 1 0 0 1\n0 1 0 1 1 0 1 0 0 1 1 0\n1 0 1 1 0 0 1 0 1 1 1 1\n1 1 1 1 1 1 1 0 0 0 0 1\n1 0 1 0 1 0 1 0 0 0 0 1\n1 0 0 1 1 1 1 0 0 0 1 1\n1 1 1 1 0 1 0 0 0 1 1 1\n1 1 1 1 0 1 1 0 0 0 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[[11, 9], [10, 8], [9, 7], [8, 7], [7, 7], [6, 7], [5, 7], [4, 7], [3, 7], [2, 7], [1, 6], [0, 5], [0, 4], [0, 3]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.03473663330078125", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0], [1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1], [1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1]]\", 4]", "is_correct_args": "[\"[[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0], [1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1], [1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1]]\", [11, 9], [0, 3], 4]", "A*_args": "[\"[[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0], [1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1], [1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1]]\", \"(11, 9)\", \"(0, 3)\", \"4\"]"}
{"diff_sorted_id": "47", "problem_statement": "Given 9 labeled water jugs with capacities 141, 101, 126, 26, 120, 75, 110, 108, 97, 100 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 254, 456, 579 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 75, 3], [\"+\", 126, 3], [\"+\", 126, 3], [\"+\", 126, 3], [\"+\", 126, 3], [\"+\", 75, 2], [\"+\", 120, 2], [\"+\", 120, 2], [\"+\", 141, 2], [\"+\", 108, 1], [\"+\", 120, 1], [\"+\", 26, 1]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.051166534423828125", "solution_depth": "12", "max_successor_states": "60", "num_vars_per_state": "3", "is_feasible_args": "[[141, 101, 126, 26, 120, 75, 110, 108, 97, 100], [254, 456, 579]]", "is_correct_args": "[[141, 101, 126, 26, 120, 75, 110, 108, 97, 100], [254, 456, 579]]", "A*_args": "[\"[141, 101, 126, 26, 120, 75, 110, 108, 97, 100]\", \"[254, 456, 579]\"]"}
{"diff_sorted_id": "48", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[79, 98, 87, 83], [56, 76, 65, 91], [25, '_', 36, 70]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[25, 56, 76, 25, 36, 65, 91, 83, 87, 91, 25, 76, 79, 98, 91, 87, 83, 70, 65, 25, 70, 65]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.1393580436706543", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[79, 98, 87, 83], [56, 76, 65, 91], [25, \"_\", 36, 70]]]", "is_correct_args": "[[[79, 98, 87, 83], [56, 76, 65, 91], [25, \"_\", 36, 70]]]", "A*_args": "[\"[[79, 98, 87, 83], [56, 76, 65, 91], [25, '_', 36, 70]]\"]"}
{"diff_sorted_id": "48", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: added, althea, indign, patron   The initial board: [['l', 'a', 'd', 'd', 'e', 'd'], ['a', 'h', 't', 'g', 'e', 'a'], ['_', 'n', 'd', 'i', 'r', 'n'], ['p', 'a', 't', 'i', 'o', 'n']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-right\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.18565845489501953", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"l\", \"a\", \"d\", \"d\", \"e\", \"d\"], [\"a\", \"h\", \"t\", \"g\", \"e\", \"a\"], [\"_\", \"n\", \"d\", \"i\", \"r\", \"n\"], [\"p\", \"a\", \"t\", \"i\", \"o\", \"n\"]]]", "is_correct_args": "[[[\"l\", \"a\", \"d\", \"d\", \"e\", \"d\"], [\"a\", \"h\", \"t\", \"g\", \"e\", \"a\"], [\"_\", \"n\", \"d\", \"i\", \"r\", \"n\"], [\"p\", \"a\", \"t\", \"i\", \"o\", \"n\"]], [\"added\", \"althea\", \"indign\", \"patron\"]]", "A*_args": "[\"[['l', 'a', 'd', 'd', 'e', 'd'], ['a', 'h', 't', 'g', 'e', 'a'], ['_', 'n', 'd', 'i', 'r', 'n'], ['p', 'a', 't', 'i', 'o', 'n']]\", \"['added', 'althea', 'indign', 'patron']\"]"}
{"diff_sorted_id": "48", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'I'. Our task is to visit city A and city X excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from X and A, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  A Q S O N V I X D B E Y \nA 0 1 1 1 1 0 0 0 0 1 0 0 \nQ 1 0 0 0 1 0 0 0 0 1 0 0 \nS 0 1 0 0 1 0 0 0 1 0 0 0 \nO 0 0 1 0 1 0 0 1 1 0 0 0 \nN 0 0 0 0 0 1 1 1 0 0 0 0 \nV 1 1 0 0 0 0 0 0 1 0 0 0 \nI 0 0 0 0 0 0 0 0 0 0 0 1 \nX 1 1 0 0 1 0 1 0 0 0 1 0 \nD 0 1 0 0 1 0 0 1 0 1 0 0 \nB 0 0 1 1 1 1 1 1 0 0 0 0 \nE 1 1 1 0 0 1 1 0 1 1 0 0 \nY 0 0 1 0 0 1 1 0 0 1 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[\"I\", \"Y\", \"B\", \"X\", \"A\", \"N\", \"X\", \"A\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.028223037719726562", "solution_depth": "8", "max_successor_states": "12", "num_vars_per_state": "15", "is_feasible_args": "[[[0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0]], [\"A\", \"Q\", \"S\", \"O\", \"N\", \"V\", \"I\", \"X\", \"D\", \"B\", \"E\", \"Y\"], \"A\", \"X\"]", "is_correct_args": "[[[0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0]], [\"A\", \"Q\", \"S\", \"O\", \"N\", \"V\", \"I\", \"X\", \"D\", \"B\", \"E\", \"Y\"], \"I\", \"A\", \"X\"]", "A*_args": "[\"[[0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0]]\", \"['A', 'Q', 'S', 'O', 'N', 'V', 'I', 'X', 'D', 'B', 'E', 'Y']\", \"['I']\", \"['A', 'X']\"]"}
{"diff_sorted_id": "48", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [19, 21, 16, 6, 34, 23, 8, 10, 14, 10, 59, 15, 17, 32, 11, 15, 8, 29, 58, 12, 3, 5, 11, 34, 2, 12, 20, 6, 29, 23, 10, 34, 33, 18], such that the sum of the chosen coins adds up to 355. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {6: 5, 17: 7, 12: 10, 34: 9, 5: 1, 11: 7, 10: 8, 21: 19, 15: 3, 33: 6, 3: 2, 16: 12, 58: 19, 8: 7, 14: 5, 20: 8, 2: 2, 19: 19, 59: 14, 18: 15, 29: 8, 23: 6, 32: 5}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "20", "opt_solution": "[5, 15, 15, 23, 23, 33, 59, 58, 32, 14, 29, 29, 20]", "opt_solution_cost": "92", "opt_solution_compute_t": "0.04211783409118652", "solution_depth": "13", "max_successor_states": "34", "num_vars_per_state": "34", "is_feasible_args": "[[19, 21, 16, 6, 34, 23, 8, 10, 14, 10, 59, 15, 17, 32, 11, 15, 8, 29, 58, 12, 3, 5, 11, 34, 2, 12, 20, 6, 29, 23, 10, 34, 33, 18]]", "is_correct_args": "[[19, 21, 16, 6, 34, 23, 8, 10, 14, 10, 59, 15, 17, 32, 11, 15, 8, 29, 58, 12, 3, 5, 11, 34, 2, 12, 20, 6, 29, 23, 10, 34, 33, 18], {\"6\": 5, \"17\": 7, \"12\": 10, \"34\": 9, \"5\": 1, \"11\": 7, \"10\": 8, \"21\": 19, \"15\": 3, \"33\": 6, \"3\": 2, \"16\": 12, \"58\": 19, \"8\": 7, \"14\": 5, \"20\": 8, \"2\": 2, \"19\": 19, \"59\": 14, \"18\": 15, \"29\": 8, \"23\": 6, \"32\": 5}, 355]", "A*_args": "[\"[19, 21, 16, 6, 34, 23, 8, 10, 14, 10, 59, 15, 17, 32, 11, 15, 8, 29, 58, 12, 3, 5, 11, 34, 2, 12, 20, 6, 29, 23, 10, 34, 33, 18]\", \"{6: 5, 17: 7, 12: 10, 34: 9, 5: 1, 11: 7, 10: 8, 21: 19, 15: 3, 33: 6, 3: 2, 16: 12, 58: 19, 8: 7, 14: 5, 20: 8, 2: 2, 19: 19, 59: 14, 18: 15, 29: 8, 23: 6, 32: 5}\", \"355\"]"}
{"diff_sorted_id": "48", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Blue', 'Blue', 'Red'], ['Blue', 'Green', 'Blue', 'Green'], ['Green', 'Red', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[1, 0], [1, 2], [1, 0], [2, 1], [2, 1], [2, 0], [2, 1], [0, 1], [2, 1], [0, 2], [0, 2], [0, 1], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0]]", "opt_solution_cost": "17", "opt_solution_compute_t": "2.2611169815063477", "solution_depth": "17", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Red\"], [\"Blue\", \"Green\", \"Blue\", \"Green\"], [\"Green\", \"Red\", \"Green\", \"Red\"]], 7]", "is_correct_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Red\"], [\"Blue\", \"Green\", \"Blue\", \"Green\"], [\"Green\", \"Red\", \"Green\", \"Red\"]], 7]", "A*_args": "[\"[['Red', 'Blue', 'Blue', 'Red'], ['Blue', 'Green', 'Blue', 'Green'], ['Green', 'Red', 'Green', 'Red']]\", \"7\"]"}
{"diff_sorted_id": "48", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 40 to 80 (40 included in the range but 80 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '53' 'x' '79']\n ['46' '51' 'x' '78']\n ['45' 'x' '73' '77']\n ['42' '47' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 0, 48], [0, 2, 75], [1, 2, 74], [2, 1, 49], [3, 2, 50], [3, 3, 52]]", "opt_solution_cost": "765", "opt_solution_compute_t": "1.6650187969207764", "solution_depth": "6", "max_successor_states": "40", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '53', '', '79'], ['46', '51', '', '78'], ['45', '', '73', '77'], ['42', '47', '', '']]\", 40, 80]", "is_correct_args": "[\"[['', '53', '', '79'], ['46', '51', '', '78'], ['45', '', '73', '77'], ['42', '47', '', '']]\", 40, 80]", "A*_args": "[\"[['', '53', '', '79'], ['46', '51', '', '78'], ['45', '', '73', '77'], ['42', '47', '', '']]\", \"40\", \"80\"]"}
{"diff_sorted_id": "48", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 34 to 60. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 179, 194, None for columns 1 to 2 respectively, and the sums of rows must be None, 179, 190, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 205. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x' 'x']\n ['x' '46' 'x' '41']\n ['x' '57' '55' 'x']\n ['x' '37' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 34], [0, 1, 39], [0, 2, 40], [0, 3, 43], [1, 0, 38], [1, 2, 54], [2, 0, 36], [2, 3, 42], [3, 0, 51], [3, 2, 45], [3, 3, 35]]", "opt_solution_cost": "693", "opt_solution_compute_t": "68.24673676490784", "solution_depth": "11", "max_successor_states": "44", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', '', ''], ['', '46', '', '41'], ['', '57', '55', ''], ['', '37', '', '']]\", 4, 34, 60]", "is_correct_args": "[\"[['', '', '', ''], ['', '46', '', '41'], ['', '57', '55', ''], ['', '37', '', '']]\", 34, 60, [1, 3], [1, 3], [179, 194], [179, 190], 205]", "A*_args": "[\"[['', '', '', ''], ['', '46', '', '41'], ['', '57', '55', ''], ['', '37', '', '']]\", \"34\", \"60\", \"[None, 179, 194, None]\", \"[None, 179, 190, None]\", \"205\"]"}
{"diff_sorted_id": "48", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 2, 1: 4, 2: 5, 3: 2, 4: 2, 5: 3, 6: 2, 7: 5}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Green', 'Blue', 'Yellow', 'Black', 'Blue'], [], [], ['Blue', 'Black', 'Green', 'Yellow', 'Red'], [], ['Green', 'Red', 'Black', 'Yellow', 'Blue'], ['Red', 'Green', 'Red', 'Black', 'Yellow']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[1, 0], [4, 3], [6, 0], [4, 5], [4, 0], [4, 2], [6, 4], [6, 5], [7, 4], [7, 0], [7, 4], [7, 5], [6, 2], [1, 3], [1, 2], [1, 5], [7, 2], [1, 3], [6, 3]]", "opt_solution_cost": "54", "opt_solution_compute_t": "0.07503151893615723", "solution_depth": "19", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[], [\"Green\", \"Blue\", \"Yellow\", \"Black\", \"Blue\"], [], [], [\"Blue\", \"Black\", \"Green\", \"Yellow\", \"Red\"], [], [\"Green\", \"Red\", \"Black\", \"Yellow\", \"Blue\"], [\"Red\", \"Green\", \"Red\", \"Black\", \"Yellow\"]], 5, {\"0\": 2, \"1\": 4, \"2\": 5, \"3\": 2, \"4\": 2, \"5\": 3, \"6\": 2, \"7\": 5}]", "is_correct_args": "[[[], [\"Green\", \"Blue\", \"Yellow\", \"Black\", \"Blue\"], [], [], [\"Blue\", \"Black\", \"Green\", \"Yellow\", \"Red\"], [], [\"Green\", \"Red\", \"Black\", \"Yellow\", \"Blue\"], [\"Red\", \"Green\", \"Red\", \"Black\", \"Yellow\"]], 5, {\"0\": 2, \"1\": 4, \"2\": 5, \"3\": 2, \"4\": 2, \"5\": 3, \"6\": 2, \"7\": 5}, 4]", "A*_args": "[\"[[], ['Green', 'Blue', 'Yellow', 'Black', 'Blue'], [], [], ['Blue', 'Black', 'Green', 'Yellow', 'Red'], [], ['Green', 'Red', 'Black', 'Yellow', 'Blue'], ['Red', 'Green', 'Red', 'Black', 'Yellow']]\", \"{0: 2, 1: 4, 2: 5, 3: 2, 4: 2, 5: 3, 6: 2, 7: 5}\", \"5\", \"4\"]"}
{"diff_sorted_id": "48", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 3) to his destination workshop at index (8, 11), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 7, and district 3 covering rows 8 to 11. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[10 x x 1 1 x x x x x x x]\n[11 9 17 x 14 3 x 13 x x 6 x]\n[x 5 x x 10 13 13 19 10 x 1 12]\n[6 x x 17 5 6 17 4 5 x 1 x]\n[4 11 1 x x x 14 7 19 4 x 6]\n[x x 6 18 x x x 5 8 2 1 x]\n[19 19 10 9 19 19 x 6 x 1 14 11]\n[x x x 18 11 x 7 5 15 13 1 11]\n[x 4 x 8 x 11 x x 9 x x 15]\n[10 8 10 2 x x x x x 12 x 17]\n[19 x 3 11 x x 9 3 15 x 5 17]\n[18 x x x 11 14 x 14 13 x x 8]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "4", "opt_solution": "[[3, 3], [3, 4], [2, 4], [3, 4], [3, 5], [3, 6], [3, 7], [4, 7], [5, 7], [5, 8], [5, 9], [6, 9], [7, 9], [7, 10], [7, 11], [8, 11]]", "opt_solution_cost": "110", "opt_solution_compute_t": "0.02734541893005371", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"10\", \"x\", \"x\", \"1\", \"1\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"11\", \"9\", \"17\", \"x\", \"14\", \"3\", \"x\", \"13\", \"x\", \"x\", \"6\", \"x\"], [\"x\", \"5\", \"x\", \"x\", \"10\", \"13\", \"13\", \"19\", \"10\", \"x\", \"1\", \"12\"], [\"6\", \"x\", \"x\", \"17\", \"5\", \"6\", \"17\", \"4\", \"5\", \"x\", \"1\", \"x\"], [\"4\", \"11\", \"1\", \"x\", \"x\", \"x\", \"14\", \"7\", \"19\", \"4\", \"x\", \"6\"], [\"x\", \"x\", \"6\", \"18\", \"x\", \"x\", \"x\", \"5\", \"8\", \"2\", \"1\", \"x\"], [\"19\", \"19\", \"10\", \"9\", \"19\", \"19\", \"x\", \"6\", \"x\", \"1\", \"14\", \"11\"], [\"x\", \"x\", \"x\", \"18\", \"11\", \"x\", \"7\", \"5\", \"15\", \"13\", \"1\", \"11\"], [\"x\", \"4\", \"x\", \"8\", \"x\", \"11\", \"x\", \"x\", \"9\", \"x\", \"x\", \"15\"], [\"10\", \"8\", \"10\", \"2\", \"x\", \"x\", \"x\", \"x\", \"x\", \"12\", \"x\", \"17\"], [\"19\", \"x\", \"3\", \"11\", \"x\", \"x\", \"9\", \"3\", \"15\", \"x\", \"5\", \"17\"], [\"18\", \"x\", \"x\", \"x\", \"11\", \"14\", \"x\", \"14\", \"13\", \"x\", \"x\", \"8\"]]]", "is_correct_args": "[[[\"10\", \"x\", \"x\", \"1\", \"1\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"11\", \"9\", \"17\", \"x\", \"14\", \"3\", \"x\", \"13\", \"x\", \"x\", \"6\", \"x\"], [\"x\", \"5\", \"x\", \"x\", \"10\", \"13\", \"13\", \"19\", \"10\", \"x\", \"1\", \"12\"], [\"6\", \"x\", \"x\", \"17\", \"5\", \"6\", \"17\", \"4\", \"5\", \"x\", \"1\", \"x\"], [\"4\", \"11\", \"1\", \"x\", \"x\", \"x\", \"14\", \"7\", \"19\", \"4\", \"x\", \"6\"], [\"x\", \"x\", \"6\", \"18\", \"x\", \"x\", \"x\", \"5\", \"8\", \"2\", \"1\", \"x\"], [\"19\", \"19\", \"10\", \"9\", \"19\", \"19\", \"x\", \"6\", \"x\", \"1\", \"14\", \"11\"], [\"x\", \"x\", \"x\", \"18\", \"11\", \"x\", \"7\", \"5\", \"15\", \"13\", \"1\", \"11\"], [\"x\", \"4\", \"x\", \"8\", \"x\", \"11\", \"x\", \"x\", \"9\", \"x\", \"x\", \"15\"], [\"10\", \"8\", \"10\", \"2\", \"x\", \"x\", \"x\", \"x\", \"x\", \"12\", \"x\", \"17\"], [\"19\", \"x\", \"3\", \"11\", \"x\", \"x\", \"9\", \"3\", \"15\", \"x\", \"5\", \"17\"], [\"18\", \"x\", \"x\", \"x\", \"11\", \"14\", \"x\", \"14\", \"13\", \"x\", \"x\", \"8\"]], [3, 3], [8, 11], 2, 7]", "A*_args": "[\"[['10', 'x', 'x', '1', '1', 'x', 'x', 'x', 'x', 'x', 'x', 'x'], ['11', '9', '17', 'x', '14', '3', 'x', '13', 'x', 'x', '6', 'x'], ['x', '5', 'x', 'x', '10', '13', '13', '19', '10', 'x', '1', '12'], ['6', 'x', 'x', '17', '5', '6', '17', '4', '5', 'x', '1', 'x'], ['4', '11', '1', 'x', 'x', 'x', '14', '7', '19', '4', 'x', '6'], ['x', 'x', '6', '18', 'x', 'x', 'x', '5', '8', '2', '1', 'x'], ['19', '19', '10', '9', '19', '19', 'x', '6', 'x', '1', '14', '11'], ['x', 'x', 'x', '18', '11', 'x', '7', '5', '15', '13', '1', '11'], ['x', '4', 'x', '8', 'x', '11', 'x', 'x', '9', 'x', 'x', '15'], ['10', '8', '10', '2', 'x', 'x', 'x', 'x', 'x', '12', 'x', '17'], ['19', 'x', '3', '11', 'x', 'x', '9', '3', '15', 'x', '5', '17'], ['18', 'x', 'x', 'x', '11', '14', 'x', '14', '13', 'x', 'x', '8']]\", \"(3, 3)\", \"(8, 11)\", \"2\", \"7\"]"}
{"diff_sorted_id": "48", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 12x12. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 9) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (10, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 0 1 0 0 0 0 0 1 1\n1 1 1 1 0 1 0 0 0 0 1 1\n0 1 1 1 0 0 0 0 0 0 0 0\n1 1 0 0 0 0 0 0 0 1 1 1\n0 0 0 0 1 1 0 0 1 0 1 0\n1 0 1 0 1 1 1 1 1 0 1 0\n0 1 0 0 1 0 1 1 1 0 1 0\n1 0 0 1 1 0 1 1 1 1 1 1\n0 0 1 1 1 0 1 0 1 1 1 0\n0 0 0 1 1 1 1 0 0 0 0 1\n0 0 1 0 0 0 1 1 0 1 1 0\n1 1 0 1 1 1 1 0 0 0 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[[0, 9], [1, 8], [2, 7], [3, 6], [3, 5], [3, 4], [3, 3], [4, 3], [5, 3], [6, 3], [6, 2], [7, 2], [7, 1], [8, 1], [9, 1], [10, 0]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.024382352828979492", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1], [1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0], [1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0]]\", 4]", "is_correct_args": "[\"[[1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1], [1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0], [1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0]]\", [0, 9], [10, 0], 4]", "A*_args": "[\"[[1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1], [1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0], [1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0]]\", \"(0, 9)\", \"(10, 0)\", \"4\"]"}
{"diff_sorted_id": "48", "problem_statement": "Given 9 labeled water jugs with capacities 121, 87, 150, 52, 43, 139, 90, 44, 59, 146 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 249, 446, 530 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 43, 3], [\"+\", 146, 3], [\"+\", 150, 3], [\"+\", 52, 3], [\"+\", 139, 3], [\"+\", 146, 2], [\"+\", 150, 2], [\"+\", 150, 2], [\"+\", 59, 1], [\"+\", 146, 1], [\"+\", 44, 1]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.052127838134765625", "solution_depth": "11", "max_successor_states": "60", "num_vars_per_state": "3", "is_feasible_args": "[[121, 87, 150, 52, 43, 139, 90, 44, 59, 146], [249, 446, 530]]", "is_correct_args": "[[121, 87, 150, 52, 43, 139, 90, 44, 59, 146], [249, 446, 530]]", "A*_args": "[\"[121, 87, 150, 52, 43, 139, 90, 44, 59, 146]\", \"[249, 446, 530]\"]"}
{"diff_sorted_id": "49", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[82, '_', 39, 54], [55, 62, 53, 35], [69, 16, 11, 71]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[62, 53, 35, 71, 11, 35, 53, 16, 35, 53, 71, 54, 39, 62, 82, 55, 69, 35, 16, 69, 55, 82, 69, 71, 54, 39, 62, 69, 71, 54, 53, 11]", "opt_solution_cost": "32", "opt_solution_compute_t": "0.6614413261413574", "solution_depth": "32", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[82, \"_\", 39, 54], [55, 62, 53, 35], [69, 16, 11, 71]]]", "is_correct_args": "[[[82, \"_\", 39, 54], [55, 62, 53, 35], [69, 16, 11, 71]]]", "A*_args": "[\"[[82, '_', 39, 54], [55, 62, 53, 35], [69, 16, 11, 71]]\"]"}
{"diff_sorted_id": "49", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: leath, fanman, tragic, carone   The initial board: [['a', 'l', 'o', 'a', 'm', 'h'], ['f', 'e', 'n', 'n', 'a', 't'], ['t', 'r', 'a', 'g', '_', 'c'], ['c', 'i', 'r', 'a', 'n', 'e']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"up-left\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "26", "opt_solution_compute_t": "1.3822917938232422", "solution_depth": "26", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"a\", \"l\", \"o\", \"a\", \"m\", \"h\"], [\"f\", \"e\", \"n\", \"n\", \"a\", \"t\"], [\"t\", \"r\", \"a\", \"g\", \"_\", \"c\"], [\"c\", \"i\", \"r\", \"a\", \"n\", \"e\"]]]", "is_correct_args": "[[[\"a\", \"l\", \"o\", \"a\", \"m\", \"h\"], [\"f\", \"e\", \"n\", \"n\", \"a\", \"t\"], [\"t\", \"r\", \"a\", \"g\", \"_\", \"c\"], [\"c\", \"i\", \"r\", \"a\", \"n\", \"e\"]], [\"leath\", \"fanman\", \"tragic\", \"carone\"]]", "A*_args": "[\"[['a', 'l', 'o', 'a', 'm', 'h'], ['f', 'e', 'n', 'n', 'a', 't'], ['t', 'r', 'a', 'g', '_', 'c'], ['c', 'i', 'r', 'a', 'n', 'e']]\", \"['leath', 'fanman', 'tragic', 'carone']\"]"}
{"diff_sorted_id": "49", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'E'. Our task is to visit city R and city D excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from D and R, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  W D R A Y F C S N E K Q \nW 0 0 0 0 1 0 0 0 0 0 1 1 \nD 0 0 0 1 0 0 0 0 0 1 0 0 \nR 1 0 0 0 0 0 1 0 0 0 0 0 \nA 0 1 1 0 1 0 0 1 1 0 0 0 \nY 0 0 0 0 0 0 0 0 0 0 0 1 \nF 1 0 1 0 0 0 0 1 0 0 0 0 \nC 0 1 0 0 1 1 0 1 1 1 0 1 \nS 1 1 0 0 1 0 0 0 1 0 0 0 \nN 0 1 1 1 0 1 0 0 0 0 0 0 \nE 0 0 0 0 0 0 0 0 0 0 1 0 \nK 0 0 0 1 0 1 0 0 1 0 0 0 \nQ 0 1 0 1 0 0 0 1 1 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[\"E\", \"K\", \"F\", \"R\", \"C\", \"D\", \"A\", \"R\", \"W\", \"Q\", \"D\"]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.03518843650817871", "solution_depth": "11", "max_successor_states": "12", "num_vars_per_state": "15", "is_feasible_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1], [1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0]], [\"W\", \"D\", \"R\", \"A\", \"Y\", \"F\", \"C\", \"S\", \"N\", \"E\", \"K\", \"Q\"], \"R\", \"D\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1], [1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0]], [\"W\", \"D\", \"R\", \"A\", \"Y\", \"F\", \"C\", \"S\", \"N\", \"E\", \"K\", \"Q\"], \"E\", \"R\", \"D\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1], [1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0]]\", \"['W', 'D', 'R', 'A', 'Y', 'F', 'C', 'S', 'N', 'E', 'K', 'Q']\", \"['E']\", \"['R', 'D']\"]"}
{"diff_sorted_id": "49", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [18, 20, 11, 6, 81, 3, 9, 5, 14, 19, 30, 2, 19, 3, 9, 22, 21, 29, 6, 25, 10, 18, 27, 26, 25, 13, 15, 16, 3, 5, 23, 26, 25, 31, 15, 12], such that the sum of the chosen coins adds up to 324. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {11: 6, 6: 3, 16: 11, 23: 16, 18: 3, 31: 4, 9: 2, 3: 1, 22: 10, 10: 1, 30: 4, 81: 14, 2: 1, 14: 1, 13: 11, 15: 7, 19: 16, 25: 6, 12: 12, 29: 11, 26: 9, 5: 1, 27: 15, 20: 7, 21: 14}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "21", "opt_solution": "[3, 5, 5, 31, 30, 18, 81, 18, 10, 2, 3, 25, 25, 25, 14, 29]", "opt_solution_cost": "64", "opt_solution_compute_t": "0.04390406608581543", "solution_depth": "16", "max_successor_states": "36", "num_vars_per_state": "36", "is_feasible_args": "[[18, 20, 11, 6, 81, 3, 9, 5, 14, 19, 30, 2, 19, 3, 9, 22, 21, 29, 6, 25, 10, 18, 27, 26, 25, 13, 15, 16, 3, 5, 23, 26, 25, 31, 15, 12]]", "is_correct_args": "[[18, 20, 11, 6, 81, 3, 9, 5, 14, 19, 30, 2, 19, 3, 9, 22, 21, 29, 6, 25, 10, 18, 27, 26, 25, 13, 15, 16, 3, 5, 23, 26, 25, 31, 15, 12], {\"11\": 6, \"6\": 3, \"16\": 11, \"23\": 16, \"18\": 3, \"31\": 4, \"9\": 2, \"3\": 1, \"22\": 10, \"10\": 1, \"30\": 4, \"81\": 14, \"2\": 1, \"14\": 1, \"13\": 11, \"15\": 7, \"19\": 16, \"25\": 6, \"12\": 12, \"29\": 11, \"26\": 9, \"5\": 1, \"27\": 15, \"20\": 7, \"21\": 14}, 324]", "A*_args": "[\"[18, 20, 11, 6, 81, 3, 9, 5, 14, 19, 30, 2, 19, 3, 9, 22, 21, 29, 6, 25, 10, 18, 27, 26, 25, 13, 15, 16, 3, 5, 23, 26, 25, 31, 15, 12]\", \"{11: 6, 6: 3, 16: 11, 23: 16, 18: 3, 31: 4, 9: 2, 3: 1, 22: 10, 10: 1, 30: 4, 81: 14, 2: 1, 14: 1, 13: 11, 15: 7, 19: 16, 25: 6, 12: 12, 29: 11, 26: 9, 5: 1, 27: 15, 20: 7, 21: 14}\", \"324\"]"}
{"diff_sorted_id": "49", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Blue', 'Blue', 'Green'], ['Green', 'Green', 'Red', 'Blue'], ['Red', 'Red', 'Blue', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[0, 2], [0, 1], [0, 1], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [1, 2], [1, 0], [1, 0], [1, 2], [1, 2], [1, 2], [0, 1], [0, 1], [0, 1], [2, 0]]", "opt_solution_cost": "18", "opt_solution_compute_t": "2.9103639125823975", "solution_depth": "18", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Green\"], [\"Green\", \"Green\", \"Red\", \"Blue\"], [\"Red\", \"Red\", \"Blue\", \"Green\"]], 7]", "is_correct_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Green\"], [\"Green\", \"Green\", \"Red\", \"Blue\"], [\"Red\", \"Red\", \"Blue\", \"Green\"]], 7]", "A*_args": "[\"[['Red', 'Blue', 'Blue', 'Green'], ['Green', 'Green', 'Red', 'Blue'], ['Red', 'Red', 'Blue', 'Green']]\", \"7\"]"}
{"diff_sorted_id": "49", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 9 to 49 (9 included in the range but 49 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['22' '35' '40' '47']\n ['x' 'x' '37' '45']\n ['18' '24' 'x' 'x']\n ['x' '17' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "11", "opt_solution": "[[1, 0, 21], [1, 1, 25], [2, 2, 26], [2, 3, 27], [3, 0, 9], [3, 2, 19], [3, 3, 20]]", "opt_solution_cost": "376", "opt_solution_compute_t": "36.16464829444885", "solution_depth": "7", "max_successor_states": "40", "num_vars_per_state": "16", "is_feasible_args": "[\"[['22', '35', '40', '47'], ['', '', '37', '45'], ['18', '24', '', ''], ['', '17', '', '']]\", 9, 49]", "is_correct_args": "[\"[['22', '35', '40', '47'], ['', '', '37', '45'], ['18', '24', '', ''], ['', '17', '', '']]\", 9, 49]", "A*_args": "[\"[['22', '35', '40', '47'], ['', '', '37', '45'], ['18', '24', '', ''], ['', '17', '', '']]\", \"9\", \"49\"]"}
{"diff_sorted_id": "49", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 34 to 60. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 165, 155, None for columns 1 to 2 respectively, and the sums of rows must be None, 169, 190, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 201. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['37' 'x' 'x' '56']\n ['52' 'x' 'x' 'x']\n ['x' '50' 'x' 'x']\n ['x' 'x' 'x' '46']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 1, 36], [0, 2, 34], [1, 1, 40], [1, 2, 42], [1, 3, 35], [2, 0, 44], [2, 2, 41], [2, 3, 55], [3, 0, 53], [3, 1, 39], [3, 2, 38]]", "opt_solution_cost": "698", "opt_solution_compute_t": "238.42562222480774", "solution_depth": "11", "max_successor_states": "49", "num_vars_per_state": "9", "is_feasible_args": "[\"[['37', '', '', '56'], ['52', '', '', ''], ['', '50', '', ''], ['', '', '', '46']]\", 4, 34, 60]", "is_correct_args": "[\"[['37', '', '', '56'], ['52', '', '', ''], ['', '50', '', ''], ['', '', '', '46']]\", 34, 60, [1, 3], [1, 3], [165, 155], [169, 190], 201]", "A*_args": "[\"[['37', '', '', '56'], ['52', '', '', ''], ['', '50', '', ''], ['', '', '', '46']]\", \"34\", \"60\", \"[None, 165, 155, None]\", \"[None, 169, 190, None]\", \"201\"]"}
{"diff_sorted_id": "49", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 4, 1: 4, 2: 1, 3: 9, 4: 7, 5: 8, 6: 9, 7: 7}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Black', 'Green', 'Red', 'Yellow', 'Black'], [], ['Blue', 'Red', 'Black', 'Black', 'Yellow'], ['Green', 'Red', 'Yellow', 'Blue', 'Green'], [], [], ['Green', 'Blue', 'Red', 'Yellow', 'Blue'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[3, 4], [3, 7], [3, 5], [3, 1], [3, 4], [0, 3], [0, 4], [0, 7], [0, 5], [6, 4], [2, 1], [2, 7], [6, 1], [6, 7], [2, 0], [2, 0], [3, 0], [6, 2], [6, 1], [5, 2], [5, 2]]", "opt_solution_cost": "112", "opt_solution_compute_t": "12.685235738754272", "solution_depth": "21", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[\"Black\", \"Green\", \"Red\", \"Yellow\", \"Black\"], [], [\"Blue\", \"Red\", \"Black\", \"Black\", \"Yellow\"], [\"Green\", \"Red\", \"Yellow\", \"Blue\", \"Green\"], [], [], [\"Green\", \"Blue\", \"Red\", \"Yellow\", \"Blue\"], []], 5, {\"0\": 4, \"1\": 4, \"2\": 1, \"3\": 9, \"4\": 7, \"5\": 8, \"6\": 9, \"7\": 7}]", "is_correct_args": "[[[\"Black\", \"Green\", \"Red\", \"Yellow\", \"Black\"], [], [\"Blue\", \"Red\", \"Black\", \"Black\", \"Yellow\"], [\"Green\", \"Red\", \"Yellow\", \"Blue\", \"Green\"], [], [], [\"Green\", \"Blue\", \"Red\", \"Yellow\", \"Blue\"], []], 5, {\"0\": 4, \"1\": 4, \"2\": 1, \"3\": 9, \"4\": 7, \"5\": 8, \"6\": 9, \"7\": 7}, 4]", "A*_args": "[\"[['Black', 'Green', 'Red', 'Yellow', 'Black'], [], ['Blue', 'Red', 'Black', 'Black', 'Yellow'], ['Green', 'Red', 'Yellow', 'Blue', 'Green'], [], [], ['Green', 'Blue', 'Red', 'Yellow', 'Blue'], []]\", \"{0: 4, 1: 4, 2: 1, 3: 9, 4: 7, 5: 8, 6: 9, 7: 7}\", \"5\", \"4\"]"}
{"diff_sorted_id": "49", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 11) to his destination workshop at index (4, 0), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 5, and district 3 covering rows 6 to 11. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x 13 9 x 15 x x 2 13 9 11]\n[8 x 4 5 13 x x 7 16 x 15 13]\n[x x x x 3 x 4 3 18 x 11 18]\n[6 x 14 5 16 x 11 x 3 16 3 3]\n[15 12 x x 10 3 2 14 x 18 x x]\n[11 1 2 1 17 15 x 2 x 12 x x]\n[x x 3 15 16 1 x x x x x x]\n[x 10 x x x 6 1 8 19 13 7 x]\n[x x x x x x x x x x x 3]\n[3 7 12 x 15 x 19 13 17 14 x x]\n[x x x x 4 4 18 x 5 x x 10]\n[x x 15 9 13 10 8 4 8 6 7 7]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "4", "opt_solution": "[[3, 11], [3, 10], [3, 9], [3, 8], [2, 8], [2, 7], [2, 6], [3, 6], [4, 6], [4, 5], [4, 4], [5, 4], [5, 3], [5, 2], [6, 2], [5, 2], [5, 1], [5, 0], [4, 0]]", "opt_solution_cost": "125", "opt_solution_compute_t": "0.027664661407470703", "solution_depth": "19", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"13\", \"9\", \"x\", \"15\", \"x\", \"x\", \"2\", \"13\", \"9\", \"11\"], [\"8\", \"x\", \"4\", \"5\", \"13\", \"x\", \"x\", \"7\", \"16\", \"x\", \"15\", \"13\"], [\"x\", \"x\", \"x\", \"x\", \"3\", \"x\", \"4\", \"3\", \"18\", \"x\", \"11\", \"18\"], [\"6\", \"x\", \"14\", \"5\", \"16\", \"x\", \"11\", \"x\", \"3\", \"16\", \"3\", \"3\"], [\"15\", \"12\", \"x\", \"x\", \"10\", \"3\", \"2\", \"14\", \"x\", \"18\", \"x\", \"x\"], [\"11\", \"1\", \"2\", \"1\", \"17\", \"15\", \"x\", \"2\", \"x\", \"12\", \"x\", \"x\"], [\"x\", \"x\", \"3\", \"15\", \"16\", \"1\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"10\", \"x\", \"x\", \"x\", \"6\", \"1\", \"8\", \"19\", \"13\", \"7\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"3\"], [\"3\", \"7\", \"12\", \"x\", \"15\", \"x\", \"19\", \"13\", \"17\", \"14\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"4\", \"4\", \"18\", \"x\", \"5\", \"x\", \"x\", \"10\"], [\"x\", \"x\", \"15\", \"9\", \"13\", \"10\", \"8\", \"4\", \"8\", \"6\", \"7\", \"7\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"13\", \"9\", \"x\", \"15\", \"x\", \"x\", \"2\", \"13\", \"9\", \"11\"], [\"8\", \"x\", \"4\", \"5\", \"13\", \"x\", \"x\", \"7\", \"16\", \"x\", \"15\", \"13\"], [\"x\", \"x\", \"x\", \"x\", \"3\", \"x\", \"4\", \"3\", \"18\", \"x\", \"11\", \"18\"], [\"6\", \"x\", \"14\", \"5\", \"16\", \"x\", \"11\", \"x\", \"3\", \"16\", \"3\", \"3\"], [\"15\", \"12\", \"x\", \"x\", \"10\", \"3\", \"2\", \"14\", \"x\", \"18\", \"x\", \"x\"], [\"11\", \"1\", \"2\", \"1\", \"17\", \"15\", \"x\", \"2\", \"x\", \"12\", \"x\", \"x\"], [\"x\", \"x\", \"3\", \"15\", \"16\", \"1\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"10\", \"x\", \"x\", \"x\", \"6\", \"1\", \"8\", \"19\", \"13\", \"7\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"3\"], [\"3\", \"7\", \"12\", \"x\", \"15\", \"x\", \"19\", \"13\", \"17\", \"14\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"4\", \"4\", \"18\", \"x\", \"5\", \"x\", \"x\", \"10\"], [\"x\", \"x\", \"15\", \"9\", \"13\", \"10\", \"8\", \"4\", \"8\", \"6\", \"7\", \"7\"]], [3, 11], [4, 0], 2, 5]", "A*_args": "[\"[['x', 'x', '13', '9', 'x', '15', 'x', 'x', '2', '13', '9', '11'], ['8', 'x', '4', '5', '13', 'x', 'x', '7', '16', 'x', '15', '13'], ['x', 'x', 'x', 'x', '3', 'x', '4', '3', '18', 'x', '11', '18'], ['6', 'x', '14', '5', '16', 'x', '11', 'x', '3', '16', '3', '3'], ['15', '12', 'x', 'x', '10', '3', '2', '14', 'x', '18', 'x', 'x'], ['11', '1', '2', '1', '17', '15', 'x', '2', 'x', '12', 'x', 'x'], ['x', 'x', '3', '15', '16', '1', 'x', 'x', 'x', 'x', 'x', 'x'], ['x', '10', 'x', 'x', 'x', '6', '1', '8', '19', '13', '7', 'x'], ['x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', '3'], ['3', '7', '12', 'x', '15', 'x', '19', '13', '17', '14', 'x', 'x'], ['x', 'x', 'x', 'x', '4', '4', '18', 'x', '5', 'x', 'x', '10'], ['x', 'x', '15', '9', '13', '10', '8', '4', '8', '6', '7', '7']]\", \"(3, 11)\", \"(4, 0)\", \"2\", \"5\"]"}
{"diff_sorted_id": "49", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 12x12. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (6, 11) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (0, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 0 1 1 1 0 1 1 1 1 1\n0 0 0 0 1 1 1 1 0 1 1 0\n0 0 0 1 1 1 1 1 1 1 1 0\n0 0 1 1 1 1 0 1 1 0 1 1\n0 0 1 1 0 1 1 1 0 1 0 1\n0 0 0 0 0 0 1 1 0 0 1 1\n1 0 1 0 0 1 1 1 1 1 0 0\n0 0 0 0 0 1 1 1 0 0 0 0\n1 0 1 1 1 0 0 0 1 0 1 1\n0 1 0 0 0 1 0 0 0 1 1 1\n1 1 1 1 0 0 1 1 1 1 1 1\n1 0 0 0 1 0 0 0 0 1 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[[6, 11], [6, 10], [7, 9], [7, 8], [8, 7], [8, 6], [8, 5], [7, 4], [6, 3], [5, 3], [5, 2], [5, 1], [4, 1], [3, 1], [2, 1], [1, 1], [0, 1], [0, 0]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.025048494338989258", "solution_depth": "18", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1], [0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]]\", 4]", "is_correct_args": "[\"[[0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1], [0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]]\", [6, 11], [0, 0], 4]", "A*_args": "[\"[[0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1], [0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]]\", \"(6, 11)\", \"(0, 0)\", \"4\"]"}
{"diff_sorted_id": "49", "problem_statement": "Given 9 labeled water jugs with capacities 22, 98, 38, 116, 140, 115, 21, 80, 92, 27 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 279, 488, 578 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 116, 3], [\"+\", 140, 3], [\"+\", 92, 3], [\"+\", 115, 3], [\"+\", 115, 3], [\"+\", 92, 2], [\"+\", 140, 2], [\"+\", 140, 2], [\"+\", 116, 2], [\"+\", 21, 1], [\"+\", 115, 1], [\"+\", 116, 1], [\"+\", 27, 1]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.04842829704284668", "solution_depth": "13", "max_successor_states": "60", "num_vars_per_state": "3", "is_feasible_args": "[[22, 98, 38, 116, 140, 115, 21, 80, 92, 27], [279, 488, 578]]", "is_correct_args": "[[22, 98, 38, 116, 140, 115, 21, 80, 92, 27], [279, 488, 578]]", "A*_args": "[\"[22, 98, 38, 116, 140, 115, 21, 80, 92, 27]\", \"[279, 488, 578]\"]"}
{"diff_sorted_id": "50", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[25, 94, 12, '_'], [70, 43, 47, 85], [86, 64, 52, 92]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[85, 47, 12, 94, 25, 70, 43, 64, 86, 43, 64, 12, 52, 92, 47, 52, 92, 86, 12, 25, 94, 92, 86, 12, 25, 64, 70, 94, 92, 86, 52, 47]", "opt_solution_cost": "32", "opt_solution_compute_t": "0.6588661670684814", "solution_depth": "32", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[25, 94, 12, \"_\"], [70, 43, 47, 85], [86, 64, 52, 92]]]", "is_correct_args": "[[[25, 94, 12, \"_\"], [70, 43, 47, 85], [86, 64, 52, 92]]]", "A*_args": "[\"[[25, 94, 12, '_'], [70, 43, 47, 85], [86, 64, 52, 92]]\"]"}
{"diff_sorted_id": "50", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: humus, bywork, cereus, clarty   The initial board: [['y', 'h', 'r', 'm', '_', 's'], ['b', 'o', 'w', 'k', 'r', 'u'], ['r', 'e', 'l', 'e', 'u', 's'], ['c', 'c', 'a', 'u', 't', 'y']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-left\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.46178436279296875", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"y\", \"h\", \"r\", \"m\", \"_\", \"s\"], [\"b\", \"o\", \"w\", \"k\", \"r\", \"u\"], [\"r\", \"e\", \"l\", \"e\", \"u\", \"s\"], [\"c\", \"c\", \"a\", \"u\", \"t\", \"y\"]]]", "is_correct_args": "[[[\"y\", \"h\", \"r\", \"m\", \"_\", \"s\"], [\"b\", \"o\", \"w\", \"k\", \"r\", \"u\"], [\"r\", \"e\", \"l\", \"e\", \"u\", \"s\"], [\"c\", \"c\", \"a\", \"u\", \"t\", \"y\"]], [\"humus\", \"bywork\", \"cereus\", \"clarty\"]]", "A*_args": "[\"[['y', 'h', 'r', 'm', '_', 's'], ['b', 'o', 'w', 'k', 'r', 'u'], ['r', 'e', 'l', 'e', 'u', 's'], ['c', 'c', 'a', 'u', 't', 'y']]\", \"['humus', 'bywork', 'cereus', 'clarty']\"]"}
{"diff_sorted_id": "50", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'E'. Our task is to visit city O and city N excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from N and O, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  I E A G V K B N F W J O \nI 0 0 1 0 0 0 0 0 0 0 0 0 \nE 1 0 0 0 1 0 0 0 0 0 0 0 \nA 1 1 0 0 0 1 1 0 0 0 0 1 \nG 0 0 0 0 0 1 0 1 0 0 0 0 \nV 0 1 1 0 0 0 0 1 0 1 0 0 \nK 1 0 0 0 0 0 1 0 0 0 0 0 \nB 1 0 0 0 0 0 0 0 1 0 0 0 \nN 1 0 1 0 0 0 0 0 0 0 0 0 \nF 0 0 0 1 0 1 0 1 0 0 0 0 \nW 1 1 0 0 1 0 0 0 0 0 0 1 \nJ 0 0 0 1 0 1 0 0 0 0 0 1 \nO 1 0 1 0 0 1 0 1 1 1 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[\"E\", \"V\", \"N\", \"A\", \"O\", \"J\", \"O\", \"N\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.029204368591308594", "solution_depth": "8", "max_successor_states": "12", "num_vars_per_state": "15", "is_feasible_args": "[[[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0]], [\"I\", \"E\", \"A\", \"G\", \"V\", \"K\", \"B\", \"N\", \"F\", \"W\", \"J\", \"O\"], \"O\", \"N\"]", "is_correct_args": "[[[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0]], [\"I\", \"E\", \"A\", \"G\", \"V\", \"K\", \"B\", \"N\", \"F\", \"W\", \"J\", \"O\"], \"E\", \"O\", \"N\"]", "A*_args": "[\"[[0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0]]\", \"['I', 'E', 'A', 'G', 'V', 'K', 'B', 'N', 'F', 'W', 'J', 'O']\", \"['E']\", \"['O', 'N']\"]"}
{"diff_sorted_id": "50", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [19, 14, 29, 19, 29, 9, 17, 16, 25, 7, 8, 2, 23, 11, 28, 6, 29, 16, 19, 31, 30, 15, 7, 16, 23, 23, 10, 32, 8, 14, 7, 9, 6, 23, 77, 24, 22, 24, 22], such that the sum of the chosen coins adds up to 351. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {15: 6, 29: 12, 19: 3, 30: 18, 14: 2, 77: 3, 6: 5, 17: 1, 32: 16, 9: 8, 22: 15, 31: 17, 25: 10, 24: 1, 28: 11, 2: 2, 7: 4, 8: 7, 11: 7, 23: 19, 10: 2, 16: 2}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "22", "opt_solution": "[24, 77, 24, 16, 14, 10, 19, 16, 19, 16, 14, 19, 2, 7, 17, 29, 28]", "opt_solution_cost": "56", "opt_solution_compute_t": "0.05440521240234375", "solution_depth": "17", "max_successor_states": "39", "num_vars_per_state": "39", "is_feasible_args": "[[19, 14, 29, 19, 29, 9, 17, 16, 25, 7, 8, 2, 23, 11, 28, 6, 29, 16, 19, 31, 30, 15, 7, 16, 23, 23, 10, 32, 8, 14, 7, 9, 6, 23, 77, 24, 22, 24, 22]]", "is_correct_args": "[[19, 14, 29, 19, 29, 9, 17, 16, 25, 7, 8, 2, 23, 11, 28, 6, 29, 16, 19, 31, 30, 15, 7, 16, 23, 23, 10, 32, 8, 14, 7, 9, 6, 23, 77, 24, 22, 24, 22], {\"15\": 6, \"29\": 12, \"19\": 3, \"30\": 18, \"14\": 2, \"77\": 3, \"6\": 5, \"17\": 1, \"32\": 16, \"9\": 8, \"22\": 15, \"31\": 17, \"25\": 10, \"24\": 1, \"28\": 11, \"2\": 2, \"7\": 4, \"8\": 7, \"11\": 7, \"23\": 19, \"10\": 2, \"16\": 2}, 351]", "A*_args": "[\"[19, 14, 29, 19, 29, 9, 17, 16, 25, 7, 8, 2, 23, 11, 28, 6, 29, 16, 19, 31, 30, 15, 7, 16, 23, 23, 10, 32, 8, 14, 7, 9, 6, 23, 77, 24, 22, 24, 22]\", \"{15: 6, 29: 12, 19: 3, 30: 18, 14: 2, 77: 3, 6: 5, 17: 1, 32: 16, 9: 8, 22: 15, 31: 17, 25: 10, 24: 1, 28: 11, 2: 2, 7: 4, 8: 7, 11: 7, 23: 19, 10: 2, 16: 2}\", \"351\"]"}
{"diff_sorted_id": "50", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 4 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 7 balls. It is not allowed to place a ball in a tube that already has 7 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Red', 'Red'], ['Red', 'Blue', 'Green', 'Red'], ['Blue', 'Blue', 'Green', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "8", "opt_solution": "[[0, 2], [0, 2], [1, 0], [1, 2], [1, 0], [1, 0], [2, 1], [2, 0], [2, 1], [2, 1], [2, 1], [0, 2], [0, 1], [0, 2], [1, 0]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.6902930736541748", "solution_depth": "15", "max_successor_states": "6", "num_vars_per_state": "12", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Red\", \"Red\"], [\"Red\", \"Blue\", \"Green\", \"Red\"], [\"Blue\", \"Blue\", \"Green\", \"Green\"]], 7]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Red\", \"Red\"], [\"Red\", \"Blue\", \"Green\", \"Red\"], [\"Blue\", \"Blue\", \"Green\", \"Green\"]], 7]", "A*_args": "[\"[['Blue', 'Green', 'Red', 'Red'], ['Red', 'Blue', 'Green', 'Red'], ['Blue', 'Blue', 'Green', 'Green']]\", \"7\"]"}
{"diff_sorted_id": "50", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 36 to 76 (36 included in the range but 76 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' 'x' '60']\n ['47' 'x' '62' '65']\n ['x' '58' '67' '68']\n ['54' 'x' '74' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "11", "opt_solution": "[[0, 0, 36], [0, 1, 37], [0, 2, 38], [1, 1, 48], [2, 0, 49], [3, 1, 59], [3, 3, 75]]", "opt_solution_cost": "665", "opt_solution_compute_t": "72.83584880828857", "solution_depth": "7", "max_successor_states": "40", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '', '60'], ['47', '', '62', '65'], ['', '58', '67', '68'], ['54', '', '74', '']]\", 36, 76]", "is_correct_args": "[\"[['', '', '', '60'], ['47', '', '62', '65'], ['', '58', '67', '68'], ['54', '', '74', '']]\", 36, 76]", "A*_args": "[\"[['', '', '', '60'], ['47', '', '62', '65'], ['', '58', '67', '68'], ['54', '', '74', '']]\", \"36\", \"76\"]"}
{"diff_sorted_id": "50", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 9 to 40. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 77, 110, None for columns 1 to 2 respectively, and the sums of rows must be None, 114, 84, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 98. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x' '39']\n ['28' 'x' 'x' 'x']\n ['x' '11' '33' 'x']\n ['18' '20' '38' '35']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 10], [0, 1, 12], [0, 2, 9], [1, 1, 34], [1, 2, 30], [1, 3, 22], [2, 0, 13], [2, 3, 27]]", "opt_solution_cost": "379", "opt_solution_compute_t": "0.18021273612976074", "solution_depth": "8", "max_successor_states": "49", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', '', '39'], ['28', '', '', ''], ['', '11', '33', ''], ['18', '20', '38', '35']]\", 4, 9, 40]", "is_correct_args": "[\"[['', '', '', '39'], ['28', '', '', ''], ['', '11', '33', ''], ['18', '20', '38', '35']]\", 9, 40, [1, 3], [1, 3], [77, 110], [114, 84], 98]", "A*_args": "[\"[['', '', '', '39'], ['28', '', '', ''], ['', '11', '33', ''], ['18', '20', '38', '35']]\", \"9\", \"40\", \"[None, 77, 110, None]\", \"[None, 114, 84, None]\", \"98\"]"}
{"diff_sorted_id": "50", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 1, 1: 3, 2: 3, 3: 8, 4: 7, 5: 9, 6: 8, 7: 8}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], ['Blue', 'Green', 'Black', 'Blue', 'Red'], ['Green', 'Red', 'Blue', 'Black', 'Blue'], [], ['Red', 'Green', 'Yellow', 'Yellow', 'Black'], ['Green', 'Black', 'Red', 'Yellow', 'Yellow'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[5, 7], [5, 4], [6, 4], [6, 1], [6, 7], [5, 6], [5, 6], [3, 4], [2, 0], [2, 4], [2, 1], [2, 0], [3, 2], [5, 1], [7, 2], [7, 2], [3, 0], [3, 1], [3, 0]]", "opt_solution_cost": "85", "opt_solution_compute_t": "8.27693510055542", "solution_depth": "19", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[], [], [\"Blue\", \"Green\", \"Black\", \"Blue\", \"Red\"], [\"Green\", \"Red\", \"Blue\", \"Black\", \"Blue\"], [], [\"Red\", \"Green\", \"Yellow\", \"Yellow\", \"Black\"], [\"Green\", \"Black\", \"Red\", \"Yellow\", \"Yellow\"], []], 5, {\"0\": 1, \"1\": 3, \"2\": 3, \"3\": 8, \"4\": 7, \"5\": 9, \"6\": 8, \"7\": 8}]", "is_correct_args": "[[[], [], [\"Blue\", \"Green\", \"Black\", \"Blue\", \"Red\"], [\"Green\", \"Red\", \"Blue\", \"Black\", \"Blue\"], [], [\"Red\", \"Green\", \"Yellow\", \"Yellow\", \"Black\"], [\"Green\", \"Black\", \"Red\", \"Yellow\", \"Yellow\"], []], 5, {\"0\": 1, \"1\": 3, \"2\": 3, \"3\": 8, \"4\": 7, \"5\": 9, \"6\": 8, \"7\": 8}, 4]", "A*_args": "[\"[[], [], ['Blue', 'Green', 'Black', 'Blue', 'Red'], ['Green', 'Red', 'Blue', 'Black', 'Blue'], [], ['Red', 'Green', 'Yellow', 'Yellow', 'Black'], ['Green', 'Black', 'Red', 'Yellow', 'Yellow'], []]\", \"{0: 1, 1: 3, 2: 3, 3: 8, 4: 7, 5: 9, 6: 8, 7: 8}\", \"5\", \"4\"]"}
{"diff_sorted_id": "50", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 9) to his destination workshop at index (7, 1), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 6, and district 3 covering rows 7 to 11. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[12 17 10 x x x x 9 15 5 x x]\n[x x x x x 12 20 9 19 8 12 11]\n[9 x x 2 x 2 1 9 8 14 16 x]\n[19 x 1 20 7 9 18 x 18 7 x x]\n[5 2 11 9 x 5 4 16 x 1 x 10]\n[10 8 8 4 11 11 x x 5 x x x]\n[15 15 x x 13 5 19 x x 15 x x]\n[15 16 9 18 x x 16 x x x 5 12]\n[x x x x x x x x x x x x]\n[x x 14 14 x x 15 6 6 x x x]\n[x x x x x 8 14 x 5 x x 15]\n[x 6 15 x x x x x x 8 x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "4", "opt_solution": "[[3, 9], [2, 9], [2, 8], [2, 7], [2, 6], [2, 5], [3, 5], [4, 5], [5, 5], [5, 4], [5, 3], [5, 2], [5, 1], [6, 1], [7, 1]]", "opt_solution_cost": "121", "opt_solution_compute_t": "0.027498483657836914", "solution_depth": "15", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"12\", \"17\", \"10\", \"x\", \"x\", \"x\", \"x\", \"9\", \"15\", \"5\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"12\", \"20\", \"9\", \"19\", \"8\", \"12\", \"11\"], [\"9\", \"x\", \"x\", \"2\", \"x\", \"2\", \"1\", \"9\", \"8\", \"14\", \"16\", \"x\"], [\"19\", \"x\", \"1\", \"20\", \"7\", \"9\", \"18\", \"x\", \"18\", \"7\", \"x\", \"x\"], [\"5\", \"2\", \"11\", \"9\", \"x\", \"5\", \"4\", \"16\", \"x\", \"1\", \"x\", \"10\"], [\"10\", \"8\", \"8\", \"4\", \"11\", \"11\", \"x\", \"x\", \"5\", \"x\", \"x\", \"x\"], [\"15\", \"15\", \"x\", \"x\", \"13\", \"5\", \"19\", \"x\", \"x\", \"15\", \"x\", \"x\"], [\"15\", \"16\", \"9\", \"18\", \"x\", \"x\", \"16\", \"x\", \"x\", \"x\", \"5\", \"12\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"14\", \"14\", \"x\", \"x\", \"15\", \"6\", \"6\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"8\", \"14\", \"x\", \"5\", \"x\", \"x\", \"15\"], [\"x\", \"6\", \"15\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"8\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"12\", \"17\", \"10\", \"x\", \"x\", \"x\", \"x\", \"9\", \"15\", \"5\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"12\", \"20\", \"9\", \"19\", \"8\", \"12\", \"11\"], [\"9\", \"x\", \"x\", \"2\", \"x\", \"2\", \"1\", \"9\", \"8\", \"14\", \"16\", \"x\"], [\"19\", \"x\", \"1\", \"20\", \"7\", \"9\", \"18\", \"x\", \"18\", \"7\", \"x\", \"x\"], [\"5\", \"2\", \"11\", \"9\", \"x\", \"5\", \"4\", \"16\", \"x\", \"1\", \"x\", \"10\"], [\"10\", \"8\", \"8\", \"4\", \"11\", \"11\", \"x\", \"x\", \"5\", \"x\", \"x\", \"x\"], [\"15\", \"15\", \"x\", \"x\", \"13\", \"5\", \"19\", \"x\", \"x\", \"15\", \"x\", \"x\"], [\"15\", \"16\", \"9\", \"18\", \"x\", \"x\", \"16\", \"x\", \"x\", \"x\", \"5\", \"12\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"14\", \"14\", \"x\", \"x\", \"15\", \"6\", \"6\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"8\", \"14\", \"x\", \"5\", \"x\", \"x\", \"15\"], [\"x\", \"6\", \"15\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"8\", \"x\", \"x\"]], [3, 9], [7, 1], 3, 6]", "A*_args": "[\"[['12', '17', '10', 'x', 'x', 'x', 'x', '9', '15', '5', 'x', 'x'], ['x', 'x', 'x', 'x', 'x', '12', '20', '9', '19', '8', '12', '11'], ['9', 'x', 'x', '2', 'x', '2', '1', '9', '8', '14', '16', 'x'], ['19', 'x', '1', '20', '7', '9', '18', 'x', '18', '7', 'x', 'x'], ['5', '2', '11', '9', 'x', '5', '4', '16', 'x', '1', 'x', '10'], ['10', '8', '8', '4', '11', '11', 'x', 'x', '5', 'x', 'x', 'x'], ['15', '15', 'x', 'x', '13', '5', '19', 'x', 'x', '15', 'x', 'x'], ['15', '16', '9', '18', 'x', 'x', '16', 'x', 'x', 'x', '5', '12'], ['x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x'], ['x', 'x', '14', '14', 'x', 'x', '15', '6', '6', 'x', 'x', 'x'], ['x', 'x', 'x', 'x', 'x', '8', '14', 'x', '5', 'x', 'x', '15'], ['x', '6', '15', 'x', 'x', 'x', 'x', 'x', 'x', '8', 'x', 'x']]\", \"(3, 9)\", \"(7, 1)\", \"3\", \"6\"]"}
{"diff_sorted_id": "50", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 12x12. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (11, 11) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (0, 6). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 1 0 0 0 0 1 1 1 0 1\n0 0 1 1 0 1 0 0 0 0 1 1\n1 1 1 1 0 0 1 1 0 1 1 1\n0 0 1 1 1 0 0 1 1 0 1 0\n0 1 0 0 0 0 0 1 1 0 0 0\n1 1 1 1 1 0 1 1 0 0 0 0\n0 1 1 1 1 1 1 1 0 0 1 0\n1 1 0 1 0 1 1 1 1 0 0 0\n0 0 1 0 0 1 0 1 0 0 0 0\n0 1 0 0 1 1 1 0 1 1 0 0\n0 1 1 0 1 0 0 1 1 1 0 0\n1 1 0 1 0 0 0 0 0 0 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[[11, 11], [10, 10], [9, 10], [8, 9], [7, 9], [6, 9], [5, 9], [4, 9], [3, 9], [2, 8], [1, 7], [1, 6], [0, 6]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.02417731285095215", "solution_depth": "13", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1], [0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0], [1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]]\", 4]", "is_correct_args": "[\"[[1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1], [0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0], [1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]]\", [11, 11], [0, 6], 4]", "A*_args": "[\"[[1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1], [0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0], [1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]]\", \"(11, 11)\", \"(0, 6)\", \"4\"]"}
{"diff_sorted_id": "50", "problem_statement": "Given 9 labeled water jugs with capacities 137, 147, 73, 131, 91, 94, 72, 31, 103, 78 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 263, 298, 505 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 94, 3], [\"+\", 137, 3], [\"+\", 137, 3], [\"+\", 137, 3], [\"+\", 73, 2], [\"+\", 78, 2], [\"+\", 147, 2], [\"+\", 91, 1], [\"+\", 94, 1], [\"+\", 78, 1]]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.048264265060424805", "solution_depth": "10", "max_successor_states": "60", "num_vars_per_state": "3", "is_feasible_args": "[[137, 147, 73, 131, 91, 94, 72, 31, 103, 78], [263, 298, 505]]", "is_correct_args": "[[137, 147, 73, 131, 91, 94, 72, 31, 103, 78], [263, 298, 505]]", "A*_args": "[\"[137, 147, 73, 131, 91, 94, 72, 31, 103, 78]\", \"[263, 298, 505]\"]"}
{"diff_sorted_id": "51", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[96, 53, 19, 15], [37, 32, '_', 87], [78, 100, 17, 13]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[32, 37, 78, 100, 17, 32, 37, 78, 100, 17, 32, 37, 78, 53, 19, 15, 87, 78, 15, 19, 96, 100, 53, 15, 19, 87, 78, 19, 37, 32, 15, 37, 32, 13]", "opt_solution_cost": "34", "opt_solution_compute_t": "2.2093515396118164", "solution_depth": "34", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[96, 53, 19, 15], [37, 32, \"_\", 87], [78, 100, 17, 13]]]", "is_correct_args": "[[[96, 53, 19, 15], [37, 32, \"_\", 87], [78, 100, 17, 13]]]", "A*_args": "[\"[[96, 53, 19, 15], [37, 32, '_', 87], [78, 100, 17, 13]]\"]"}
{"diff_sorted_id": "51", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: biune, algist, palule, noncon   The initial board: [['l', 'b', 'l', 'u', 'i', 'e'], ['a', 't', 'g', 'n', 's', 'c'], ['l', 'a', 'o', 'u', '_', 'e'], ['n', 'i', 'n', 'p', 'o', 'n']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"up-left\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "34", "opt_solution_compute_t": "10.377072811126709", "solution_depth": "34", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"l\", \"b\", \"l\", \"u\", \"i\", \"e\"], [\"a\", \"t\", \"g\", \"n\", \"s\", \"c\"], [\"l\", \"a\", \"o\", \"u\", \"_\", \"e\"], [\"n\", \"i\", \"n\", \"p\", \"o\", \"n\"]]]", "is_correct_args": "[[[\"l\", \"b\", \"l\", \"u\", \"i\", \"e\"], [\"a\", \"t\", \"g\", \"n\", \"s\", \"c\"], [\"l\", \"a\", \"o\", \"u\", \"_\", \"e\"], [\"n\", \"i\", \"n\", \"p\", \"o\", \"n\"]], [\"biune\", \"algist\", \"palule\", \"noncon\"]]", "A*_args": "[\"[['l', 'b', 'l', 'u', 'i', 'e'], ['a', 't', 'g', 'n', 's', 'c'], ['l', 'a', 'o', 'u', '_', 'e'], ['n', 'i', 'n', 'p', 'o', 'n']]\", \"['biune', 'algist', 'palule', 'noncon']\"]"}
{"diff_sorted_id": "51", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'G'. Our task is to visit city F and city U excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from U and F, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  O C F W I P U B H Q G S \nO 0 0 0 0 0 0 0 1 0 0 0 0 \nC 1 0 1 0 0 1 0 0 0 0 0 0 \nF 1 0 0 0 0 0 1 0 0 1 1 0 \nW 1 1 0 0 1 0 1 0 0 0 0 0 \nI 0 1 0 0 0 0 1 1 0 0 1 1 \nP 0 0 1 1 0 0 0 1 1 0 0 0 \nU 0 1 0 0 1 0 0 0 0 0 0 0 \nB 0 0 1 0 0 0 1 0 0 0 0 0 \nH 0 1 1 1 1 1 0 1 0 0 0 0 \nQ 0 1 1 0 1 1 0 0 0 0 1 1 \nG 0 0 0 0 0 1 0 0 0 0 0 0 \nS 0 1 0 1 0 0 0 0 1 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[\"G\", \"P\", \"F\", \"U\", \"C\", \"F\", \"U\"]", "opt_solution_cost": "7", "opt_solution_compute_t": "0.02801227569580078", "solution_depth": "7", "max_successor_states": "12", "num_vars_per_state": "15", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0]], [\"O\", \"C\", \"F\", \"W\", \"I\", \"P\", \"U\", \"B\", \"H\", \"Q\", \"G\", \"S\"], \"F\", \"U\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0]], [\"O\", \"C\", \"F\", \"W\", \"I\", \"P\", \"U\", \"B\", \"H\", \"Q\", \"G\", \"S\"], \"G\", \"F\", \"U\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0]]\", \"['O', 'C', 'F', 'W', 'I', 'P', 'U', 'B', 'H', 'Q', 'G', 'S']\", \"['G']\", \"['F', 'U']\"]"}
{"diff_sorted_id": "51", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [31, 83, 19, 4, 13, 27, 13, 18, 21, 24, 9, 3, 2, 30, 16, 14, 31, 29, 27, 23, 18, 8, 32, 3, 3, 25, 17, 8, 32, 5, 2, 28, 30, 26, 25, 12, 12], such that the sum of the chosen coins adds up to 335. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {32: 1, 19: 12, 3: 1, 27: 14, 5: 3, 9: 5, 13: 11, 14: 10, 28: 6, 31: 15, 8: 8, 18: 18, 17: 7, 2: 2, 12: 9, 24: 16, 83: 6, 23: 9, 16: 15, 29: 4, 25: 5, 26: 18, 4: 1, 21: 10, 30: 10}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "23", "opt_solution": "[32, 2, 25, 25, 83, 32, 28, 29, 31, 30, 4, 5, 9]", "opt_solution_cost": "64", "opt_solution_compute_t": "0.050809383392333984", "solution_depth": "13", "max_successor_states": "37", "num_vars_per_state": "37", "is_feasible_args": "[[31, 83, 19, 4, 13, 27, 13, 18, 21, 24, 9, 3, 2, 30, 16, 14, 31, 29, 27, 23, 18, 8, 32, 3, 3, 25, 17, 8, 32, 5, 2, 28, 30, 26, 25, 12, 12]]", "is_correct_args": "[[31, 83, 19, 4, 13, 27, 13, 18, 21, 24, 9, 3, 2, 30, 16, 14, 31, 29, 27, 23, 18, 8, 32, 3, 3, 25, 17, 8, 32, 5, 2, 28, 30, 26, 25, 12, 12], {\"32\": 1, \"19\": 12, \"3\": 1, \"27\": 14, \"5\": 3, \"9\": 5, \"13\": 11, \"14\": 10, \"28\": 6, \"31\": 15, \"8\": 8, \"18\": 18, \"17\": 7, \"2\": 2, \"12\": 9, \"24\": 16, \"83\": 6, \"23\": 9, \"16\": 15, \"29\": 4, \"25\": 5, \"26\": 18, \"4\": 1, \"21\": 10, \"30\": 10}, 335]", "A*_args": "[\"[31, 83, 19, 4, 13, 27, 13, 18, 21, 24, 9, 3, 2, 30, 16, 14, 31, 29, 27, 23, 18, 8, 32, 3, 3, 25, 17, 8, 32, 5, 2, 28, 30, 26, 25, 12, 12]\", \"{32: 1, 19: 12, 3: 1, 27: 14, 5: 3, 9: 5, 13: 11, 14: 10, 28: 6, 31: 15, 8: 8, 18: 18, 17: 7, 2: 2, 12: 9, 24: 16, 83: 6, 23: 9, 16: 15, 29: 4, 25: 5, 26: 18, 4: 1, 21: 10, 30: 10}\", \"335\"]"}
{"diff_sorted_id": "51", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Green', 'Red', 'Blue', 'Blue'], ['Blue', 'Green', 'Green', 'Red', 'Red'], ['Red', 'Red', 'Blue', 'Green', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[1, 2], [1, 0], [1, 0], [2, 0], [2, 1], [2, 1], [0, 1], [2, 1], [2, 0], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [2, 1]]", "opt_solution_cost": "20", "opt_solution_compute_t": "6.3350279331207275", "solution_depth": "20", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Green\", \"Green\", \"Red\", \"Blue\", \"Blue\"], [\"Blue\", \"Green\", \"Green\", \"Red\", \"Red\"], [\"Red\", \"Red\", \"Blue\", \"Green\", \"Blue\"]], 8]", "is_correct_args": "[[[\"Green\", \"Green\", \"Red\", \"Blue\", \"Blue\"], [\"Blue\", \"Green\", \"Green\", \"Red\", \"Red\"], [\"Red\", \"Red\", \"Blue\", \"Green\", \"Blue\"]], 8]", "A*_args": "[\"[['Green', 'Green', 'Red', 'Blue', 'Blue'], ['Blue', 'Green', 'Green', 'Red', 'Red'], ['Red', 'Red', 'Blue', 'Green', 'Blue']]\", \"8\"]"}
{"diff_sorted_id": "51", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 20 to 60 (20 included in the range but 60 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '36' 'x' '55']\n ['30' '34' 'x' '56']\n ['x' '33' 'x' '57']\n ['x' '32' '46' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "11", "opt_solution": "[[0, 0, 31], [0, 2, 37], [1, 2, 38], [2, 0, 21], [2, 2, 39], [3, 0, 20], [3, 3, 58]]", "opt_solution_cost": "547", "opt_solution_compute_t": "4.27742338180542", "solution_depth": "7", "max_successor_states": "40", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '36', '', '55'], ['30', '34', '', '56'], ['', '33', '', '57'], ['', '32', '46', '']]\", 20, 60]", "is_correct_args": "[\"[['', '36', '', '55'], ['30', '34', '', '56'], ['', '33', '', '57'], ['', '32', '46', '']]\", 20, 60]", "A*_args": "[\"[['', '36', '', '55'], ['30', '34', '', '56'], ['', '33', '', '57'], ['', '32', '46', '']]\", \"20\", \"60\"]"}
{"diff_sorted_id": "51", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 9 to 40. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 102, 100, None for columns 1 to 2 respectively, and the sums of rows must be None, 72, 97, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 46. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' '27' '9']\n ['21' 'x' 'x' '15']\n ['x' '16' '31' 'x']\n ['11' 'x' '32' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 12], [0, 1, 22], [1, 1, 26], [1, 2, 10], [2, 0, 14], [2, 3, 36], [3, 1, 38], [3, 3, 13]]", "opt_solution_cost": "333", "opt_solution_compute_t": "1.8332746028900146", "solution_depth": "8", "max_successor_states": "49", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', '27', '9'], ['21', '', '', '15'], ['', '16', '31', ''], ['11', '', '32', '']]\", 4, 9, 40]", "is_correct_args": "[\"[['', '', '27', '9'], ['21', '', '', '15'], ['', '16', '31', ''], ['11', '', '32', '']]\", 9, 40, [1, 3], [1, 3], [102, 100], [72, 97], 46]", "A*_args": "[\"[['', '', '27', '9'], ['21', '', '', '15'], ['', '16', '31', ''], ['11', '', '32', '']]\", \"9\", \"40\", \"[None, 102, 100, None]\", \"[None, 72, 97, None]\", \"46\"]"}
{"diff_sorted_id": "51", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 7, 1: 8, 2: 2, 3: 8, 4: 9, 5: 6, 6: 8, 7: 1}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], [], ['Green', 'Blue', 'Blue', 'Green', 'Black'], ['Red', 'Green', 'Blue', 'Blue', 'Red'], ['Black', 'Black', 'Yellow', 'Red', 'Yellow'], [], ['Yellow', 'Black', 'Green', 'Red', 'Yellow']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[3, 1], [3, 0], [3, 0], [3, 1], [5, 3], [5, 3], [7, 6], [7, 3], [7, 1], [4, 2], [4, 1], [4, 0], [4, 0], [7, 2], [4, 2], [5, 7], [5, 2], [5, 7], [6, 7]]", "opt_solution_cost": "103", "opt_solution_compute_t": "10.823257684707642", "solution_depth": "19", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[], [], [], [\"Green\", \"Blue\", \"Blue\", \"Green\", \"Black\"], [\"Red\", \"Green\", \"Blue\", \"Blue\", \"Red\"], [\"Black\", \"Black\", \"Yellow\", \"Red\", \"Yellow\"], [], [\"Yellow\", \"Black\", \"Green\", \"Red\", \"Yellow\"]], 5, {\"0\": 7, \"1\": 8, \"2\": 2, \"3\": 8, \"4\": 9, \"5\": 6, \"6\": 8, \"7\": 1}]", "is_correct_args": "[[[], [], [], [\"Green\", \"Blue\", \"Blue\", \"Green\", \"Black\"], [\"Red\", \"Green\", \"Blue\", \"Blue\", \"Red\"], [\"Black\", \"Black\", \"Yellow\", \"Red\", \"Yellow\"], [], [\"Yellow\", \"Black\", \"Green\", \"Red\", \"Yellow\"]], 5, {\"0\": 7, \"1\": 8, \"2\": 2, \"3\": 8, \"4\": 9, \"5\": 6, \"6\": 8, \"7\": 1}, 4]", "A*_args": "[\"[[], [], [], ['Green', 'Blue', 'Blue', 'Green', 'Black'], ['Red', 'Green', 'Blue', 'Blue', 'Red'], ['Black', 'Black', 'Yellow', 'Red', 'Yellow'], [], ['Yellow', 'Black', 'Green', 'Red', 'Yellow']]\", \"{0: 7, 1: 8, 2: 2, 3: 8, 4: 9, 5: 6, 6: 8, 7: 1}\", \"5\", \"4\"]"}
{"diff_sorted_id": "51", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (6, 2) to his destination workshop at index (2, 10), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 5, and district 3 covering rows 6 to 11. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[19 12 x x 2 5 4 13 17 19 x 2]\n[x 18 x 5 5 x x 8 12 18 x 15]\n[x 9 4 10 7 20 x 16 20 13 15 x]\n[8 x x 11 1 19 x 14 6 x 3 x]\n[10 x 4 8 17 x 18 x 7 x 6 5]\n[x x 3 1 8 18 x 4 17 x x 13]\n[x x 6 x x x 14 x x 10 10 x]\n[x x 15 x x x x x 2 x x x]\n[x x 5 11 6 1 x 6 14 x x x]\n[x 1 17 10 15 x 14 6 x x x x]\n[12 2 x 10 x x 7 x x x x x]\n[x 9 14 x 9 18 14 x x x 6 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "4", "opt_solution": "[[6, 2], [5, 2], [5, 3], [4, 3], [3, 3], [3, 4], [2, 4], [1, 4], [0, 4], [0, 5], [0, 6], [0, 7], [1, 7], [1, 8], [1, 9], [2, 9], [2, 10]]", "opt_solution_cost": "126", "opt_solution_compute_t": "0.02806711196899414", "solution_depth": "17", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"19\", \"12\", \"x\", \"x\", \"2\", \"5\", \"4\", \"13\", \"17\", \"19\", \"x\", \"2\"], [\"x\", \"18\", \"x\", \"5\", \"5\", \"x\", \"x\", \"8\", \"12\", \"18\", \"x\", \"15\"], [\"x\", \"9\", \"4\", \"10\", \"7\", \"20\", \"x\", \"16\", \"20\", \"13\", \"15\", \"x\"], [\"8\", \"x\", \"x\", \"11\", \"1\", \"19\", \"x\", \"14\", \"6\", \"x\", \"3\", \"x\"], [\"10\", \"x\", \"4\", \"8\", \"17\", \"x\", \"18\", \"x\", \"7\", \"x\", \"6\", \"5\"], [\"x\", \"x\", \"3\", \"1\", \"8\", \"18\", \"x\", \"4\", \"17\", \"x\", \"x\", \"13\"], [\"x\", \"x\", \"6\", \"x\", \"x\", \"x\", \"14\", \"x\", \"x\", \"10\", \"10\", \"x\"], [\"x\", \"x\", \"15\", \"x\", \"x\", \"x\", \"x\", \"x\", \"2\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"5\", \"11\", \"6\", \"1\", \"x\", \"6\", \"14\", \"x\", \"x\", \"x\"], [\"x\", \"1\", \"17\", \"10\", \"15\", \"x\", \"14\", \"6\", \"x\", \"x\", \"x\", \"x\"], [\"12\", \"2\", \"x\", \"10\", \"x\", \"x\", \"7\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"9\", \"14\", \"x\", \"9\", \"18\", \"14\", \"x\", \"x\", \"x\", \"6\", \"x\"]]]", "is_correct_args": "[[[\"19\", \"12\", \"x\", \"x\", \"2\", \"5\", \"4\", \"13\", \"17\", \"19\", \"x\", \"2\"], [\"x\", \"18\", \"x\", \"5\", \"5\", \"x\", \"x\", \"8\", \"12\", \"18\", \"x\", \"15\"], [\"x\", \"9\", \"4\", \"10\", \"7\", \"20\", \"x\", \"16\", \"20\", \"13\", \"15\", \"x\"], [\"8\", \"x\", \"x\", \"11\", \"1\", \"19\", \"x\", \"14\", \"6\", \"x\", \"3\", \"x\"], [\"10\", \"x\", \"4\", \"8\", \"17\", \"x\", \"18\", \"x\", \"7\", \"x\", \"6\", \"5\"], [\"x\", \"x\", \"3\", \"1\", \"8\", \"18\", \"x\", \"4\", \"17\", \"x\", \"x\", \"13\"], [\"x\", \"x\", \"6\", \"x\", \"x\", \"x\", \"14\", \"x\", \"x\", \"10\", \"10\", \"x\"], [\"x\", \"x\", \"15\", \"x\", \"x\", \"x\", \"x\", \"x\", \"2\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"5\", \"11\", \"6\", \"1\", \"x\", \"6\", \"14\", \"x\", \"x\", \"x\"], [\"x\", \"1\", \"17\", \"10\", \"15\", \"x\", \"14\", \"6\", \"x\", \"x\", \"x\", \"x\"], [\"12\", \"2\", \"x\", \"10\", \"x\", \"x\", \"7\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"9\", \"14\", \"x\", \"9\", \"18\", \"14\", \"x\", \"x\", \"x\", \"6\", \"x\"]], [6, 2], [2, 10], 1, 5]", "A*_args": "[\"[['19', '12', 'x', 'x', '2', '5', '4', '13', '17', '19', 'x', '2'], ['x', '18', 'x', '5', '5', 'x', 'x', '8', '12', '18', 'x', '15'], ['x', '9', '4', '10', '7', '20', 'x', '16', '20', '13', '15', 'x'], ['8', 'x', 'x', '11', '1', '19', 'x', '14', '6', 'x', '3', 'x'], ['10', 'x', '4', '8', '17', 'x', '18', 'x', '7', 'x', '6', '5'], ['x', 'x', '3', '1', '8', '18', 'x', '4', '17', 'x', 'x', '13'], ['x', 'x', '6', 'x', 'x', 'x', '14', 'x', 'x', '10', '10', 'x'], ['x', 'x', '15', 'x', 'x', 'x', 'x', 'x', '2', 'x', 'x', 'x'], ['x', 'x', '5', '11', '6', '1', 'x', '6', '14', 'x', 'x', 'x'], ['x', '1', '17', '10', '15', 'x', '14', '6', 'x', 'x', 'x', 'x'], ['12', '2', 'x', '10', 'x', 'x', '7', 'x', 'x', 'x', 'x', 'x'], ['x', '9', '14', 'x', '9', '18', '14', 'x', 'x', 'x', '6', 'x']]\", \"(6, 2)\", \"(2, 10)\", \"1\", \"5\"]"}
{"diff_sorted_id": "51", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 12x12. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 11) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (11, 3). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 1 1 0 1 1 0 0 1 0 1\n1 0 1 1 1 1 1 0 1 1 0 0\n0 1 0 1 1 0 0 0 0 0 0 0\n0 0 1 0 0 0 0 1 0 1 0 0\n1 1 1 1 0 1 0 1 1 0 0 0\n1 0 1 0 1 0 0 0 1 1 0 0\n0 1 0 1 0 0 0 0 1 0 0 0\n0 1 1 1 0 0 0 0 0 0 0 0\n0 1 1 0 0 1 0 1 1 1 1 1\n1 1 1 1 0 1 0 0 0 1 1 0\n1 1 1 0 0 1 1 0 1 0 0 1\n0 1 0 0 0 0 0 0 0 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[[1, 11], [2, 10], [2, 9], [2, 8], [2, 7], [3, 6], [4, 6], [5, 5], [6, 4], [7, 4], [8, 4], [9, 4], [10, 4], [10, 3], [11, 3]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.0235440731048584", "solution_depth": "15", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0], [1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1], [1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0], [1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1]]\", 4]", "is_correct_args": "[\"[[1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0], [1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1], [1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0], [1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1]]\", [1, 11], [11, 3], 4]", "A*_args": "[\"[[1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0], [1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1], [1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0], [1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1]]\", \"(1, 11)\", \"(11, 3)\", \"4\"]"}
{"diff_sorted_id": "51", "problem_statement": "Given 9 labeled water jugs with capacities 51, 129, 150, 138, 128, 72, 69, 111, 75 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 454, 547, 601 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 128, 3], [\"+\", 128, 3], [\"+\", 69, 3], [\"+\", 138, 3], [\"+\", 138, 3], [\"+\", 69, 2], [\"+\", 128, 2], [\"+\", 150, 2], [\"+\", 72, 2], [\"+\", 128, 2], [\"+\", 128, 1], [\"+\", 128, 1], [\"+\", 69, 1], [\"+\", 129, 1]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.07053852081298828", "solution_depth": "14", "max_successor_states": "54", "num_vars_per_state": "3", "is_feasible_args": "[[51, 129, 150, 138, 128, 72, 69, 111, 75], [454, 547, 601]]", "is_correct_args": "[[51, 129, 150, 138, 128, 72, 69, 111, 75], [454, 547, 601]]", "A*_args": "[\"[51, 129, 150, 138, 128, 72, 69, 111, 75]\", \"[454, 547, 601]\"]"}
{"diff_sorted_id": "52", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[26, 39, 50, 35], ['_', 67, 2, 71], [48, 41, 37, 56]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[67, 2, 71, 56, 37, 41, 2, 71, 50, 35, 56, 50, 35, 39, 26, 67, 71, 35, 41, 2, 35, 26, 67, 71, 48, 35, 26, 41, 39, 56, 50, 37]", "opt_solution_cost": "32", "opt_solution_compute_t": "0.40317821502685547", "solution_depth": "32", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[26, 39, 50, 35], [\"_\", 67, 2, 71], [48, 41, 37, 56]]]", "is_correct_args": "[[[26, 39, 50, 35], [\"_\", 67, 2, 71], [48, 41, 37, 56]]]", "A*_args": "[\"[[26, 39, 50, 35], ['_', 67, 2, 71], [48, 41, 37, 56]]\"]"}
{"diff_sorted_id": "52", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: saiph, lierre, accend, evenly   The initial board: [['i', 's', 'n', 'i', 'a', 'h'], ['l', 'p', 'e', 'a', 'r', 'c'], ['_', 'c', 'e', 'e', 'n', 'd'], ['e', 'v', 'e', 'r', 'l', 'y']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-right\", \"up-right\", \"up-left\", \"up-right\", \"down-right\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"down-right\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "38", "opt_solution_compute_t": "29.637394189834595", "solution_depth": "38", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"i\", \"s\", \"n\", \"i\", \"a\", \"h\"], [\"l\", \"p\", \"e\", \"a\", \"r\", \"c\"], [\"_\", \"c\", \"e\", \"e\", \"n\", \"d\"], [\"e\", \"v\", \"e\", \"r\", \"l\", \"y\"]]]", "is_correct_args": "[[[\"i\", \"s\", \"n\", \"i\", \"a\", \"h\"], [\"l\", \"p\", \"e\", \"a\", \"r\", \"c\"], [\"_\", \"c\", \"e\", \"e\", \"n\", \"d\"], [\"e\", \"v\", \"e\", \"r\", \"l\", \"y\"]], [\"saiph\", \"lierre\", \"accend\", \"evenly\"]]", "A*_args": "[\"[['i', 's', 'n', 'i', 'a', 'h'], ['l', 'p', 'e', 'a', 'r', 'c'], ['_', 'c', 'e', 'e', 'n', 'd'], ['e', 'v', 'e', 'r', 'l', 'y']]\", \"['saiph', 'lierre', 'accend', 'evenly']\"]"}
{"diff_sorted_id": "52", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'C'. Our task is to visit city J and city D excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from D and J, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  C L D O A Z M H K R Q N J \nC 0 0 0 0 1 0 0 0 0 0 0 0 0 \nL 1 0 0 1 0 0 1 0 1 0 0 0 0 \nD 1 0 0 0 0 0 0 1 1 0 0 1 1 \nO 0 0 1 0 1 0 0 0 0 0 0 0 0 \nA 0 1 0 0 0 0 1 0 0 0 0 0 0 \nZ 0 0 0 0 0 0 0 1 0 1 0 0 1 \nM 0 0 0 0 0 0 0 0 0 0 0 0 1 \nH 0 0 0 1 0 0 0 0 0 0 0 1 0 \nK 1 0 0 1 0 1 1 0 0 0 1 0 0 \nR 0 1 1 1 1 0 1 1 1 0 1 0 0 \nQ 0 1 1 0 1 0 0 1 0 0 0 1 0 \nN 0 1 1 1 0 1 0 0 1 0 0 0 0 \nJ 0 0 0 0 0 0 0 1 1 1 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[\"C\", \"A\", \"M\", \"J\", \"N\", \"D\", \"J\", \"R\", \"D\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.023613929748535156", "solution_depth": "9", "max_successor_states": "13", "num_vars_per_state": "16", "is_feasible_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0]], [\"C\", \"L\", \"D\", \"O\", \"A\", \"Z\", \"M\", \"H\", \"K\", \"R\", \"Q\", \"N\", \"J\"], \"J\", \"D\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0]], [\"C\", \"L\", \"D\", \"O\", \"A\", \"Z\", \"M\", \"H\", \"K\", \"R\", \"Q\", \"N\", \"J\"], \"C\", \"J\", \"D\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0]]\", \"['C', 'L', 'D', 'O', 'A', 'Z', 'M', 'H', 'K', 'R', 'Q', 'N', 'J']\", \"['C']\", \"['J', 'D']\"]"}
{"diff_sorted_id": "52", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [31, 9, 2, 24, 32, 6, 13, 29, 33, 22, 12, 28, 10, 7, 33, 15, 28, 7, 14, 26, 1, 10, 28, 30, 7, 29, 17, 2, 28, 13, 28, 17, 3, 4, 4, 4, 13, 3, 19, 2, 4, 26, 27, 27, 11, 25, 12], such that the sum of the chosen coins adds up to 337. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {2: 1, 33: 8, 9: 9, 31: 3, 19: 11, 17: 8, 28: 3, 24: 12, 6: 1, 22: 7, 26: 7, 27: 5, 29: 9, 4: 4, 10: 3, 3: 2, 11: 3, 15: 12, 7: 2, 1: 1, 12: 3, 30: 2, 14: 12, 32: 7, 13: 2, 25: 9}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "24", "opt_solution": "[28, 31, 28, 6, 13, 13, 33, 30, 28, 33, 28, 12, 27, 27]", "opt_solution_cost": "51", "opt_solution_compute_t": "0.062195539474487305", "solution_depth": "14", "max_successor_states": "47", "num_vars_per_state": "47", "is_feasible_args": "[[31, 9, 2, 24, 32, 6, 13, 29, 33, 22, 12, 28, 10, 7, 33, 15, 28, 7, 14, 26, 1, 10, 28, 30, 7, 29, 17, 2, 28, 13, 28, 17, 3, 4, 4, 4, 13, 3, 19, 2, 4, 26, 27, 27, 11, 25, 12]]", "is_correct_args": "[[31, 9, 2, 24, 32, 6, 13, 29, 33, 22, 12, 28, 10, 7, 33, 15, 28, 7, 14, 26, 1, 10, 28, 30, 7, 29, 17, 2, 28, 13, 28, 17, 3, 4, 4, 4, 13, 3, 19, 2, 4, 26, 27, 27, 11, 25, 12], {\"2\": 1, \"33\": 8, \"9\": 9, \"31\": 3, \"19\": 11, \"17\": 8, \"28\": 3, \"24\": 12, \"6\": 1, \"22\": 7, \"26\": 7, \"27\": 5, \"29\": 9, \"4\": 4, \"10\": 3, \"3\": 2, \"11\": 3, \"15\": 12, \"7\": 2, \"1\": 1, \"12\": 3, \"30\": 2, \"14\": 12, \"32\": 7, \"13\": 2, \"25\": 9}, 337]", "A*_args": "[\"[31, 9, 2, 24, 32, 6, 13, 29, 33, 22, 12, 28, 10, 7, 33, 15, 28, 7, 14, 26, 1, 10, 28, 30, 7, 29, 17, 2, 28, 13, 28, 17, 3, 4, 4, 4, 13, 3, 19, 2, 4, 26, 27, 27, 11, 25, 12]\", \"{2: 1, 33: 8, 9: 9, 31: 3, 19: 11, 17: 8, 28: 3, 24: 12, 6: 1, 22: 7, 26: 7, 27: 5, 29: 9, 4: 4, 10: 3, 3: 2, 11: 3, 15: 12, 7: 2, 1: 1, 12: 3, 30: 2, 14: 12, 32: 7, 13: 2, 25: 9}\", \"337\"]"}
{"diff_sorted_id": "52", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Green', 'Blue', 'Red', 'Green'], ['Red', 'Red', 'Blue', 'Red', 'Blue'], ['Green', 'Blue', 'Blue', 'Red', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[2, 1], [0, 1], [0, 1], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 2], [1, 0], [2, 1], [2, 0], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 2]]", "opt_solution_cost": "25", "opt_solution_compute_t": "80.31313681602478", "solution_depth": "25", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Green\", \"Green\", \"Blue\", \"Red\", \"Green\"], [\"Red\", \"Red\", \"Blue\", \"Red\", \"Blue\"], [\"Green\", \"Blue\", \"Blue\", \"Red\", \"Green\"]], 8]", "is_correct_args": "[[[\"Green\", \"Green\", \"Blue\", \"Red\", \"Green\"], [\"Red\", \"Red\", \"Blue\", \"Red\", \"Blue\"], [\"Green\", \"Blue\", \"Blue\", \"Red\", \"Green\"]], 8]", "A*_args": "[\"[['Green', 'Green', 'Blue', 'Red', 'Green'], ['Red', 'Red', 'Blue', 'Red', 'Blue'], ['Green', 'Blue', 'Blue', 'Red', 'Green']]\", \"8\"]"}
{"diff_sorted_id": "52", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 22 to 62 (22 included in the range but 62 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['43' '48' 'x' 'x']\n ['x' 'x' 'x' '58']\n ['x' '37' '41' '60']\n ['x' '34' 'x' '61']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "12", "opt_solution": "[[0, 2, 49], [0, 3, 50], [1, 0, 24], [1, 1, 38], [1, 2, 42], [2, 0, 23], [3, 0, 22], [3, 2, 35]]", "opt_solution_cost": "602", "opt_solution_compute_t": "0.3810865879058838", "solution_depth": "8", "max_successor_states": "40", "num_vars_per_state": "16", "is_feasible_args": "[\"[['43', '48', '', ''], ['', '', '', '58'], ['', '37', '41', '60'], ['', '34', '', '61']]\", 22, 62]", "is_correct_args": "[\"[['43', '48', '', ''], ['', '', '', '58'], ['', '37', '41', '60'], ['', '34', '', '61']]\", 22, 62]", "A*_args": "[\"[['43', '48', '', ''], ['', '', '', '58'], ['', '37', '41', '60'], ['', '34', '', '61']]\", \"22\", \"62\"]"}
{"diff_sorted_id": "52", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 9 to 40. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 121, 107, None for columns 1 to 2 respectively, and the sums of rows must be None, 89, 103, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 102. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['14' '35' 'x' 'x']\n ['x' 'x' 'x' '18']\n ['x' '31' '27' '21']\n ['30' 'x' 'x' '19']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 2, 11], [0, 3, 9], [1, 0, 10], [1, 1, 29], [1, 2, 32], [2, 0, 24], [3, 1, 26], [3, 2, 37]]", "opt_solution_cost": "373", "opt_solution_compute_t": "18.999568462371826", "solution_depth": "8", "max_successor_states": "49", "num_vars_per_state": "9", "is_feasible_args": "[\"[['14', '35', '', ''], ['', '', '', '18'], ['', '31', '27', '21'], ['30', '', '', '19']]\", 4, 9, 40]", "is_correct_args": "[\"[['14', '35', '', ''], ['', '', '', '18'], ['', '31', '27', '21'], ['30', '', '', '19']]\", 9, 40, [1, 3], [1, 3], [121, 107], [89, 103], 102]", "A*_args": "[\"[['14', '35', '', ''], ['', '', '', '18'], ['', '31', '27', '21'], ['30', '', '', '19']]\", \"9\", \"40\", \"[None, 121, 107, None]\", \"[None, 89, 103, None]\", \"102\"]"}
{"diff_sorted_id": "52", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 6, 1: 4, 2: 3, 3: 8, 4: 7, 5: 5, 6: 9, 7: 9}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], [], ['Blue', 'Yellow', 'Red', 'Blue', 'Black'], ['Red', 'Yellow', 'Blue', 'Yellow', 'Blue'], ['Green', 'Red', 'Black', 'Red', 'Yellow'], [], ['Green', 'Green', 'Black', 'Green', 'Black']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[5, 2], [4, 1], [7, 2], [7, 2], [5, 1], [5, 0], [5, 1], [4, 5], [7, 0], [7, 2], [3, 6], [3, 5], [3, 1], [3, 6], [4, 6], [4, 5], [4, 6], [3, 0], [7, 0]]", "opt_solution_cost": "103", "opt_solution_compute_t": "0.04401803016662598", "solution_depth": "19", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[], [], [], [\"Blue\", \"Yellow\", \"Red\", \"Blue\", \"Black\"], [\"Red\", \"Yellow\", \"Blue\", \"Yellow\", \"Blue\"], [\"Green\", \"Red\", \"Black\", \"Red\", \"Yellow\"], [], [\"Green\", \"Green\", \"Black\", \"Green\", \"Black\"]], 5, {\"0\": 6, \"1\": 4, \"2\": 3, \"3\": 8, \"4\": 7, \"5\": 5, \"6\": 9, \"7\": 9}]", "is_correct_args": "[[[], [], [], [\"Blue\", \"Yellow\", \"Red\", \"Blue\", \"Black\"], [\"Red\", \"Yellow\", \"Blue\", \"Yellow\", \"Blue\"], [\"Green\", \"Red\", \"Black\", \"Red\", \"Yellow\"], [], [\"Green\", \"Green\", \"Black\", \"Green\", \"Black\"]], 5, {\"0\": 6, \"1\": 4, \"2\": 3, \"3\": 8, \"4\": 7, \"5\": 5, \"6\": 9, \"7\": 9}, 4]", "A*_args": "[\"[[], [], [], ['Blue', 'Yellow', 'Red', 'Blue', 'Black'], ['Red', 'Yellow', 'Blue', 'Yellow', 'Blue'], ['Green', 'Red', 'Black', 'Red', 'Yellow'], [], ['Green', 'Green', 'Black', 'Green', 'Black']]\", \"{0: 6, 1: 4, 2: 3, 3: 8, 4: 7, 5: 5, 6: 9, 7: 9}\", \"5\", \"4\"]"}
{"diff_sorted_id": "52", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (8, 1) to his destination workshop at index (5, 11), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 4, district 2 covering rows 5 to 8, and district 3 covering rows 9 to 11. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 3 11 7 x x 1 3 x x x 3]\n[x 10 x x 3 9 7 8 x 2 x 17]\n[6 16 x 18 10 5 x 6 x x 7 x]\n[x 10 x 8 13 10 x x x x 6 13]\n[6 11 3 16 8 15 x x x 13 12 20]\n[15 x 16 x 17 13 x x 8 6 19 9]\n[14 10 16 14 x x 10 11 19 15 17 x]\n[x x x x 18 13 14 19 12 1 3 x]\n[15 1 3 17 4 18 x 18 2 7 12 x]\n[19 x 13 17 2 14 8 x x 8 16 x]\n[x 19 x 15 x 18 x 13 x 13 x x]\n[7 14 2 x 10 3 x x 2 5 10 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "4", "opt_solution": "[[8, 1], [8, 2], [8, 3], [8, 4], [9, 4], [8, 4], [7, 4], [7, 5], [7, 6], [7, 7], [7, 8], [7, 9], [6, 9], [5, 9], [4, 9], [5, 9], [5, 10], [5, 11]]", "opt_solution_cost": "175", "opt_solution_compute_t": "0.027495384216308594", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"3\", \"11\", \"7\", \"x\", \"x\", \"1\", \"3\", \"x\", \"x\", \"x\", \"3\"], [\"x\", \"10\", \"x\", \"x\", \"3\", \"9\", \"7\", \"8\", \"x\", \"2\", \"x\", \"17\"], [\"6\", \"16\", \"x\", \"18\", \"10\", \"5\", \"x\", \"6\", \"x\", \"x\", \"7\", \"x\"], [\"x\", \"10\", \"x\", \"8\", \"13\", \"10\", \"x\", \"x\", \"x\", \"x\", \"6\", \"13\"], [\"6\", \"11\", \"3\", \"16\", \"8\", \"15\", \"x\", \"x\", \"x\", \"13\", \"12\", \"20\"], [\"15\", \"x\", \"16\", \"x\", \"17\", \"13\", \"x\", \"x\", \"8\", \"6\", \"19\", \"9\"], [\"14\", \"10\", \"16\", \"14\", \"x\", \"x\", \"10\", \"11\", \"19\", \"15\", \"17\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"18\", \"13\", \"14\", \"19\", \"12\", \"1\", \"3\", \"x\"], [\"15\", \"1\", \"3\", \"17\", \"4\", \"18\", \"x\", \"18\", \"2\", \"7\", \"12\", \"x\"], [\"19\", \"x\", \"13\", \"17\", \"2\", \"14\", \"8\", \"x\", \"x\", \"8\", \"16\", \"x\"], [\"x\", \"19\", \"x\", \"15\", \"x\", \"18\", \"x\", \"13\", \"x\", \"13\", \"x\", \"x\"], [\"7\", \"14\", \"2\", \"x\", \"10\", \"3\", \"x\", \"x\", \"2\", \"5\", \"10\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"3\", \"11\", \"7\", \"x\", \"x\", \"1\", \"3\", \"x\", \"x\", \"x\", \"3\"], [\"x\", \"10\", \"x\", \"x\", \"3\", \"9\", \"7\", \"8\", \"x\", \"2\", \"x\", \"17\"], [\"6\", \"16\", \"x\", \"18\", \"10\", \"5\", \"x\", \"6\", \"x\", \"x\", \"7\", \"x\"], [\"x\", \"10\", \"x\", \"8\", \"13\", \"10\", \"x\", \"x\", \"x\", \"x\", \"6\", \"13\"], [\"6\", \"11\", \"3\", \"16\", \"8\", \"15\", \"x\", \"x\", \"x\", \"13\", \"12\", \"20\"], [\"15\", \"x\", \"16\", \"x\", \"17\", \"13\", \"x\", \"x\", \"8\", \"6\", \"19\", \"9\"], [\"14\", \"10\", \"16\", \"14\", \"x\", \"x\", \"10\", \"11\", \"19\", \"15\", \"17\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"18\", \"13\", \"14\", \"19\", \"12\", \"1\", \"3\", \"x\"], [\"15\", \"1\", \"3\", \"17\", \"4\", \"18\", \"x\", \"18\", \"2\", \"7\", \"12\", \"x\"], [\"19\", \"x\", \"13\", \"17\", \"2\", \"14\", \"8\", \"x\", \"x\", \"8\", \"16\", \"x\"], [\"x\", \"19\", \"x\", \"15\", \"x\", \"18\", \"x\", \"13\", \"x\", \"13\", \"x\", \"x\"], [\"7\", \"14\", \"2\", \"x\", \"10\", \"3\", \"x\", \"x\", \"2\", \"5\", \"10\", \"x\"]], [8, 1], [5, 11], 4, 8]", "A*_args": "[\"[['x', '3', '11', '7', 'x', 'x', '1', '3', 'x', 'x', 'x', '3'], ['x', '10', 'x', 'x', '3', '9', '7', '8', 'x', '2', 'x', '17'], ['6', '16', 'x', '18', '10', '5', 'x', '6', 'x', 'x', '7', 'x'], ['x', '10', 'x', '8', '13', '10', 'x', 'x', 'x', 'x', '6', '13'], ['6', '11', '3', '16', '8', '15', 'x', 'x', 'x', '13', '12', '20'], ['15', 'x', '16', 'x', '17', '13', 'x', 'x', '8', '6', '19', '9'], ['14', '10', '16', '14', 'x', 'x', '10', '11', '19', '15', '17', 'x'], ['x', 'x', 'x', 'x', '18', '13', '14', '19', '12', '1', '3', 'x'], ['15', '1', '3', '17', '4', '18', 'x', '18', '2', '7', '12', 'x'], ['19', 'x', '13', '17', '2', '14', '8', 'x', 'x', '8', '16', 'x'], ['x', '19', 'x', '15', 'x', '18', 'x', '13', 'x', '13', 'x', 'x'], ['7', '14', '2', 'x', '10', '3', 'x', 'x', '2', '5', '10', 'x']]\", \"(8, 1)\", \"(5, 11)\", \"4\", \"8\"]"}
{"diff_sorted_id": "52", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 12x12. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (8, 1) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (1, 11). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 1 1 0 1 0 0 0 0 0 0\n1 0 0 0 1 0 1 0 1 1 1 0\n1 0 0 0 0 0 0 0 1 0 1 1\n0 0 1 1 0 0 0 0 1 0 1 1\n0 0 1 1 0 0 1 1 0 1 0 1\n0 0 1 1 0 0 1 1 1 1 0 1\n1 0 1 0 1 0 1 1 0 1 0 0\n0 0 0 0 0 1 0 1 1 1 1 1\n0 0 1 1 1 0 1 1 0 0 1 0\n1 1 0 0 0 1 1 1 1 0 1 0\n1 1 0 0 1 1 0 1 1 1 0 0\n1 1 1 1 1 1 1 0 1 1 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[[8, 1], [7, 1], [7, 2], [7, 3], [7, 4], [6, 5], [5, 5], [4, 5], [3, 6], [3, 7], [2, 7], [1, 7], [0, 8], [0, 9], [0, 10], [1, 11]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.023190736770629883", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1], [0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0], [1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0], [1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0]]\", 4]", "is_correct_args": "[\"[[1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1], [0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0], [1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0], [1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0]]\", [8, 1], [1, 11], 4]", "A*_args": "[\"[[1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1], [0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0], [1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0], [1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0]]\", \"(8, 1)\", \"(1, 11)\", \"4\"]"}
{"diff_sorted_id": "52", "problem_statement": "Given 9 labeled water jugs with capacities 45, 141, 50, 114, 104, 19, 78, 18, 23, 133 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 253, 337, 385 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 114, 3], [\"+\", 133, 3], [\"+\", 133, 3], [\"-\", 18, 3], [\"+\", 23, 3], [\"+\", 45, 2], [\"+\", 133, 2], [\"+\", 18, 2], [\"+\", 141, 2], [\"+\", 104, 1], [\"+\", 104, 1], [\"+\", 45, 1]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.03950142860412598", "solution_depth": "12", "max_successor_states": "60", "num_vars_per_state": "3", "is_feasible_args": "[[45, 141, 50, 114, 104, 19, 78, 18, 23, 133], [253, 337, 385]]", "is_correct_args": "[[45, 141, 50, 114, 104, 19, 78, 18, 23, 133], [253, 337, 385]]", "A*_args": "[\"[45, 141, 50, 114, 104, 19, 78, 18, 23, 133]\", \"[253, 337, 385]\"]"}
{"diff_sorted_id": "53", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[38, 98, 84, 33], [63, 30, 61, 93], [73, 89, 85, '_']]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[85, 61, 84, 33, 93, 85, 61, 84, 30, 89, 84, 30, 33, 93, 85, 61, 30, 33, 89, 63, 38, 98, 93, 89, 63, 84, 73, 38, 84, 73, 33, 30]", "opt_solution_cost": "32", "opt_solution_compute_t": "0.45055198669433594", "solution_depth": "32", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[38, 98, 84, 33], [63, 30, 61, 93], [73, 89, 85, \"_\"]]]", "is_correct_args": "[[[38, 98, 84, 33], [63, 30, 61, 93], [73, 89, 85, \"_\"]]]", "A*_args": "[\"[[38, 98, 84, 33], [63, 30, 61, 93], [73, 89, 85, '_']]\"]"}
{"diff_sorted_id": "53", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: limen, somers, spooky, dogtie   The initial board: [['o', 'l', 's', 'm', '_', 'n'], ['s', 'o', 'm', 'e', 'r', 'k'], ['s', 'p', 'i', 'o', 'e', 'y'], ['d', 'o', 'g', 't', 'i', 'e']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.7115309238433838", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"o\", \"l\", \"s\", \"m\", \"_\", \"n\"], [\"s\", \"o\", \"m\", \"e\", \"r\", \"k\"], [\"s\", \"p\", \"i\", \"o\", \"e\", \"y\"], [\"d\", \"o\", \"g\", \"t\", \"i\", \"e\"]]]", "is_correct_args": "[[[\"o\", \"l\", \"s\", \"m\", \"_\", \"n\"], [\"s\", \"o\", \"m\", \"e\", \"r\", \"k\"], [\"s\", \"p\", \"i\", \"o\", \"e\", \"y\"], [\"d\", \"o\", \"g\", \"t\", \"i\", \"e\"]], [\"limen\", \"somers\", \"spooky\", \"dogtie\"]]", "A*_args": "[\"[['o', 'l', 's', 'm', '_', 'n'], ['s', 'o', 'm', 'e', 'r', 'k'], ['s', 'p', 'i', 'o', 'e', 'y'], ['d', 'o', 'g', 't', 'i', 'e']]\", \"['limen', 'somers', 'spooky', 'dogtie']\"]"}
{"diff_sorted_id": "53", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'A'. Our task is to visit city D and city E excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from E and D, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  D M F X G A Q O U R N K E \nD 0 0 0 0 1 0 1 0 0 1 1 1 0 \nM 1 0 0 0 0 0 0 0 0 0 0 0 1 \nF 0 0 0 1 0 0 0 1 0 0 0 0 0 \nX 0 1 0 0 0 0 0 0 0 0 0 1 1 \nG 0 0 0 0 0 0 0 0 0 1 1 0 0 \nA 0 0 0 0 1 0 0 0 0 0 1 0 0 \nQ 0 0 1 0 1 0 0 0 0 0 0 0 0 \nO 1 1 0 1 0 1 0 0 1 0 0 0 0 \nU 1 0 1 1 1 0 0 0 0 0 0 0 0 \nR 0 0 0 0 0 0 0 0 0 0 0 0 1 \nN 0 0 0 0 0 0 0 0 1 1 0 1 0 \nK 0 1 1 0 0 0 0 0 1 0 0 0 0 \nE 1 0 0 0 0 0 0 1 1 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[\"A\", \"G\", \"R\", \"E\", \"D\", \"K\", \"M\", \"E\", \"D\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.030630111694335938", "solution_depth": "9", "max_successor_states": "13", "num_vars_per_state": "16", "is_feasible_args": "[[[0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]], [\"D\", \"M\", \"F\", \"X\", \"G\", \"A\", \"Q\", \"O\", \"U\", \"R\", \"N\", \"K\", \"E\"], \"D\", \"E\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]], [\"D\", \"M\", \"F\", \"X\", \"G\", \"A\", \"Q\", \"O\", \"U\", \"R\", \"N\", \"K\", \"E\"], \"A\", \"D\", \"E\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0]]\", \"['D', 'M', 'F', 'X', 'G', 'A', 'Q', 'O', 'U', 'R', 'N', 'K', 'E']\", \"['A']\", \"['D', 'E']\"]"}
{"diff_sorted_id": "53", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [23, 10, 22, 30, 5, 16, 2, 28, 25, 26, 30, 25, 35, 32, 10, 4, 24, 32, 34, 12, 11, 5, 5, 18, 16, 24, 3, 12, 11, 5, 2, 7, 19, 34, 7, 30, 17, 11, 16, 10, 31, 31, 34, 27, 3, 24], such that the sum of the chosen coins adds up to 359. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {24: 9, 26: 11, 17: 7, 7: 4, 12: 4, 35: 18, 5: 5, 31: 8, 2: 2, 3: 1, 27: 14, 34: 3, 30: 1, 23: 6, 4: 2, 10: 8, 18: 18, 25: 15, 28: 4, 32: 19, 11: 7, 16: 6, 19: 11, 22: 5}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "25", "opt_solution": "[34, 30, 31, 30, 28, 22, 31, 30, 35, 34, 2, 17, 23, 12]", "opt_solution_cost": "71", "opt_solution_compute_t": "0.057801008224487305", "solution_depth": "14", "max_successor_states": "46", "num_vars_per_state": "46", "is_feasible_args": "[[23, 10, 22, 30, 5, 16, 2, 28, 25, 26, 30, 25, 35, 32, 10, 4, 24, 32, 34, 12, 11, 5, 5, 18, 16, 24, 3, 12, 11, 5, 2, 7, 19, 34, 7, 30, 17, 11, 16, 10, 31, 31, 34, 27, 3, 24]]", "is_correct_args": "[[23, 10, 22, 30, 5, 16, 2, 28, 25, 26, 30, 25, 35, 32, 10, 4, 24, 32, 34, 12, 11, 5, 5, 18, 16, 24, 3, 12, 11, 5, 2, 7, 19, 34, 7, 30, 17, 11, 16, 10, 31, 31, 34, 27, 3, 24], {\"24\": 9, \"26\": 11, \"17\": 7, \"7\": 4, \"12\": 4, \"35\": 18, \"5\": 5, \"31\": 8, \"2\": 2, \"3\": 1, \"27\": 14, \"34\": 3, \"30\": 1, \"23\": 6, \"4\": 2, \"10\": 8, \"18\": 18, \"25\": 15, \"28\": 4, \"32\": 19, \"11\": 7, \"16\": 6, \"19\": 11, \"22\": 5}, 359]", "A*_args": "[\"[23, 10, 22, 30, 5, 16, 2, 28, 25, 26, 30, 25, 35, 32, 10, 4, 24, 32, 34, 12, 11, 5, 5, 18, 16, 24, 3, 12, 11, 5, 2, 7, 19, 34, 7, 30, 17, 11, 16, 10, 31, 31, 34, 27, 3, 24]\", \"{24: 9, 26: 11, 17: 7, 7: 4, 12: 4, 35: 18, 5: 5, 31: 8, 2: 2, 3: 1, 27: 14, 34: 3, 30: 1, 23: 6, 4: 2, 10: 8, 18: 18, 25: 15, 28: 4, 32: 19, 11: 7, 16: 6, 19: 11, 22: 5}\", \"359\"]"}
{"diff_sorted_id": "53", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Blue', 'Blue', 'Red', 'Green'], ['Blue', 'Green', 'Green', 'Green', 'Blue'], ['Red', 'Green', 'Blue', 'Red', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[0, 1], [2, 1], [2, 0], [2, 0], [1, 2], [1, 2], [1, 0], [1, 2], [1, 2], [1, 2], [0, 1], [0, 1], [0, 2], [0, 1], [0, 1], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [1, 2]]", "opt_solution_cost": "21", "opt_solution_compute_t": "11.96505355834961", "solution_depth": "21", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Red\", \"Green\"], [\"Blue\", \"Green\", \"Green\", \"Green\", \"Blue\"], [\"Red\", \"Green\", \"Blue\", \"Red\", \"Red\"]], 8]", "is_correct_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Red\", \"Green\"], [\"Blue\", \"Green\", \"Green\", \"Green\", \"Blue\"], [\"Red\", \"Green\", \"Blue\", \"Red\", \"Red\"]], 8]", "A*_args": "[\"[['Red', 'Blue', 'Blue', 'Red', 'Green'], ['Blue', 'Green', 'Green', 'Green', 'Blue'], ['Red', 'Green', 'Blue', 'Red', 'Red']]\", \"8\"]"}
{"diff_sorted_id": "53", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 44 to 84 (44 included in the range but 84 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['45' '55' '59' 'x']\n ['x' '67' 'x' 'x']\n ['60' 'x' '79' '80']\n ['x' 'x' 'x' '83']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "12", "opt_solution": "[[0, 3, 61], [1, 0, 46], [1, 2, 68], [1, 3, 69], [2, 1, 70], [3, 0, 62], [3, 1, 71], [3, 2, 81]]", "opt_solution_cost": "787", "opt_solution_compute_t": "0.4855637550354004", "solution_depth": "8", "max_successor_states": "40", "num_vars_per_state": "16", "is_feasible_args": "[\"[['45', '55', '59', ''], ['', '67', '', ''], ['60', '', '79', '80'], ['', '', '', '83']]\", 44, 84]", "is_correct_args": "[\"[['45', '55', '59', ''], ['', '67', '', ''], ['60', '', '79', '80'], ['', '', '', '83']]\", 44, 84]", "A*_args": "[\"[['45', '55', '59', ''], ['', '67', '', ''], ['60', '', '79', '80'], ['', '', '', '83']]\", \"44\", \"84\"]"}
{"diff_sorted_id": "53", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 9 to 40. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 116, 78, None for columns 1 to 2 respectively, and the sums of rows must be None, 94, 111, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 70. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' '22' '23']\n ['x' 'x' '15' '25']\n ['31' 'x' 'x' 'x']\n ['12' '36' 'x' '13']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 10], [0, 1, 27], [1, 0, 21], [1, 1, 33], [2, 1, 20], [2, 2, 32], [2, 3, 28], [3, 2, 9]]", "opt_solution_cost": "357", "opt_solution_compute_t": "0.4937326908111572", "solution_depth": "8", "max_successor_states": "49", "num_vars_per_state": "9", "is_feasible_args": "[\"[['', '', '22', '23'], ['', '', '15', '25'], ['31', '', '', ''], ['12', '36', '', '13']]\", 4, 9, 40]", "is_correct_args": "[\"[['', '', '22', '23'], ['', '', '15', '25'], ['31', '', '', ''], ['12', '36', '', '13']]\", 9, 40, [1, 3], [1, 3], [116, 78], [94, 111], 70]", "A*_args": "[\"[['', '', '22', '23'], ['', '', '15', '25'], ['31', '', '', ''], ['12', '36', '', '13']]\", \"9\", \"40\", \"[None, 116, 78, None]\", \"[None, 94, 111, None]\", \"70\"]"}
{"diff_sorted_id": "53", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 7, 1: 4, 2: 1, 3: 2, 4: 6, 5: 8, 6: 7, 7: 6}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Blue', 'Green', 'Red', 'Yellow', 'Blue'], ['Green', 'Blue', 'Yellow', 'Black', 'Red'], [], ['Red', 'Yellow', 'Yellow', 'Black', 'Black'], ['Green', 'Blue', 'Green', 'Black', 'Red'], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[1, 3], [1, 7], [1, 0], [1, 6], [4, 0], [4, 6], [4, 6], [2, 7], [2, 1], [2, 6], [2, 4], [5, 7], [5, 1], [5, 7], [5, 4], [3, 1], [0, 2], [0, 2], [5, 2]]", "opt_solution_cost": "95", "opt_solution_compute_t": "5.887192726135254", "solution_depth": "19", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[], [\"Blue\", \"Green\", \"Red\", \"Yellow\", \"Blue\"], [\"Green\", \"Blue\", \"Yellow\", \"Black\", \"Red\"], [], [\"Red\", \"Yellow\", \"Yellow\", \"Black\", \"Black\"], [\"Green\", \"Blue\", \"Green\", \"Black\", \"Red\"], [], []], 5, {\"0\": 7, \"1\": 4, \"2\": 1, \"3\": 2, \"4\": 6, \"5\": 8, \"6\": 7, \"7\": 6}]", "is_correct_args": "[[[], [\"Blue\", \"Green\", \"Red\", \"Yellow\", \"Blue\"], [\"Green\", \"Blue\", \"Yellow\", \"Black\", \"Red\"], [], [\"Red\", \"Yellow\", \"Yellow\", \"Black\", \"Black\"], [\"Green\", \"Blue\", \"Green\", \"Black\", \"Red\"], [], []], 5, {\"0\": 7, \"1\": 4, \"2\": 1, \"3\": 2, \"4\": 6, \"5\": 8, \"6\": 7, \"7\": 6}, 4]", "A*_args": "[\"[[], ['Blue', 'Green', 'Red', 'Yellow', 'Blue'], ['Green', 'Blue', 'Yellow', 'Black', 'Red'], [], ['Red', 'Yellow', 'Yellow', 'Black', 'Black'], ['Green', 'Blue', 'Green', 'Black', 'Red'], [], []]\", \"{0: 7, 1: 4, 2: 1, 3: 2, 4: 6, 5: 8, 6: 7, 7: 6}\", \"5\", \"4\"]"}
{"diff_sorted_id": "53", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 3) to his destination workshop at index (7, 11), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 6, and district 3 covering rows 7 to 11. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[18 x x 14 5 x x 5 18 x 3 x]\n[x x x 9 2 2 x 15 14 12 x 18]\n[x x 3 16 3 9 x 16 x 14 x 17]\n[x x x 19 7 20 x x 11 4 x 4]\n[7 x 8 11 x 1 15 5 x x 11 x]\n[x x x x x x 6 11 x x x 8]\n[x 15 2 x x 18 x 1 16 15 6 5]\n[x 4 18 8 9 x x 17 20 13 x 10]\n[x 16 x x 19 x 17 x 13 11 14 2]\n[12 x 11 x 3 x 5 3 x 13 17 6]\n[14 x x x x x x x x 11 x 16]\n[12 x x x 12 x 10 x 18 14 8 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "4", "opt_solution": "[[3, 3], [3, 4], [3, 5], [4, 5], [4, 6], [4, 7], [5, 7], [6, 7], [6, 8], [6, 9], [6, 10], [6, 11], [7, 11]]", "opt_solution_cost": "112", "opt_solution_compute_t": "0.026072263717651367", "solution_depth": "13", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"18\", \"x\", \"x\", \"14\", \"5\", \"x\", \"x\", \"5\", \"18\", \"x\", \"3\", \"x\"], [\"x\", \"x\", \"x\", \"9\", \"2\", \"2\", \"x\", \"15\", \"14\", \"12\", \"x\", \"18\"], [\"x\", \"x\", \"3\", \"16\", \"3\", \"9\", \"x\", \"16\", \"x\", \"14\", \"x\", \"17\"], [\"x\", \"x\", \"x\", \"19\", \"7\", \"20\", \"x\", \"x\", \"11\", \"4\", \"x\", \"4\"], [\"7\", \"x\", \"8\", \"11\", \"x\", \"1\", \"15\", \"5\", \"x\", \"x\", \"11\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"6\", \"11\", \"x\", \"x\", \"x\", \"8\"], [\"x\", \"15\", \"2\", \"x\", \"x\", \"18\", \"x\", \"1\", \"16\", \"15\", \"6\", \"5\"], [\"x\", \"4\", \"18\", \"8\", \"9\", \"x\", \"x\", \"17\", \"20\", \"13\", \"x\", \"10\"], [\"x\", \"16\", \"x\", \"x\", \"19\", \"x\", \"17\", \"x\", \"13\", \"11\", \"14\", \"2\"], [\"12\", \"x\", \"11\", \"x\", \"3\", \"x\", \"5\", \"3\", \"x\", \"13\", \"17\", \"6\"], [\"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"11\", \"x\", \"16\"], [\"12\", \"x\", \"x\", \"x\", \"12\", \"x\", \"10\", \"x\", \"18\", \"14\", \"8\", \"x\"]]]", "is_correct_args": "[[[\"18\", \"x\", \"x\", \"14\", \"5\", \"x\", \"x\", \"5\", \"18\", \"x\", \"3\", \"x\"], [\"x\", \"x\", \"x\", \"9\", \"2\", \"2\", \"x\", \"15\", \"14\", \"12\", \"x\", \"18\"], [\"x\", \"x\", \"3\", \"16\", \"3\", \"9\", \"x\", \"16\", \"x\", \"14\", \"x\", \"17\"], [\"x\", \"x\", \"x\", \"19\", \"7\", \"20\", \"x\", \"x\", \"11\", \"4\", \"x\", \"4\"], [\"7\", \"x\", \"8\", \"11\", \"x\", \"1\", \"15\", \"5\", \"x\", \"x\", \"11\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"6\", \"11\", \"x\", \"x\", \"x\", \"8\"], [\"x\", \"15\", \"2\", \"x\", \"x\", \"18\", \"x\", \"1\", \"16\", \"15\", \"6\", \"5\"], [\"x\", \"4\", \"18\", \"8\", \"9\", \"x\", \"x\", \"17\", \"20\", \"13\", \"x\", \"10\"], [\"x\", \"16\", \"x\", \"x\", \"19\", \"x\", \"17\", \"x\", \"13\", \"11\", \"14\", \"2\"], [\"12\", \"x\", \"11\", \"x\", \"3\", \"x\", \"5\", \"3\", \"x\", \"13\", \"17\", \"6\"], [\"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"11\", \"x\", \"16\"], [\"12\", \"x\", \"x\", \"x\", \"12\", \"x\", \"10\", \"x\", \"18\", \"14\", \"8\", \"x\"]], [3, 3], [7, 11], 3, 6]", "A*_args": "[\"[['18', 'x', 'x', '14', '5', 'x', 'x', '5', '18', 'x', '3', 'x'], ['x', 'x', 'x', '9', '2', '2', 'x', '15', '14', '12', 'x', '18'], ['x', 'x', '3', '16', '3', '9', 'x', '16', 'x', '14', 'x', '17'], ['x', 'x', 'x', '19', '7', '20', 'x', 'x', '11', '4', 'x', '4'], ['7', 'x', '8', '11', 'x', '1', '15', '5', 'x', 'x', '11', 'x'], ['x', 'x', 'x', 'x', 'x', 'x', '6', '11', 'x', 'x', 'x', '8'], ['x', '15', '2', 'x', 'x', '18', 'x', '1', '16', '15', '6', '5'], ['x', '4', '18', '8', '9', 'x', 'x', '17', '20', '13', 'x', '10'], ['x', '16', 'x', 'x', '19', 'x', '17', 'x', '13', '11', '14', '2'], ['12', 'x', '11', 'x', '3', 'x', '5', '3', 'x', '13', '17', '6'], ['14', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', '11', 'x', '16'], ['12', 'x', 'x', 'x', '12', 'x', '10', 'x', '18', '14', '8', 'x']]\", \"(3, 3)\", \"(7, 11)\", \"3\", \"6\"]"}
{"diff_sorted_id": "53", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 12x12. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (2, 11) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (8, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 1 1 1 1 1 0 0 1 1 1\n1 1 0 1 1 1 1 1 0 0 0 1\n0 0 0 1 1 0 1 0 0 0 0 0\n1 1 0 0 0 1 1 0 1 1 0 0\n0 0 0 1 0 0 0 0 0 1 0 1\n1 1 0 1 0 1 1 1 0 0 1 1\n1 0 1 1 0 0 0 0 0 1 1 1\n1 0 0 0 0 1 0 0 0 1 0 1\n0 0 0 0 1 1 0 0 1 1 1 1\n0 1 1 0 0 1 1 0 0 0 0 0\n1 0 0 1 0 0 0 1 1 1 1 0\n1 1 1 0 1 1 0 0 1 0 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[[2, 11], [2, 10], [2, 9], [2, 8], [2, 7], [3, 7], [4, 6], [4, 5], [5, 4], [6, 4], [7, 3], [7, 2], [8, 1]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.025552034378051758", "solution_depth": "13", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1], [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1], [0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1], [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1], [0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0], [1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1]]\", 4]", "is_correct_args": "[\"[[1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1], [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1], [0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1], [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1], [0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0], [1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1]]\", [2, 11], [8, 1], 4]", "A*_args": "[\"[[1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1], [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1], [0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1], [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1], [0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0], [1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1]]\", \"(2, 11)\", \"(8, 1)\", \"4\"]"}
{"diff_sorted_id": "53", "problem_statement": "Given 9 labeled water jugs with capacities 139, 143, 17, 138, 133, 19, 126, 102, 65 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 349, 415, 458 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 17, 3], [\"+\", 138, 3], [\"+\", 143, 3], [\"+\", 17, 3], [\"+\", 143, 3], [\"+\", 133, 2], [\"+\", 139, 2], [\"+\", 143, 2], [\"+\", 65, 1], [\"+\", 126, 1], [\"+\", 19, 1], [\"+\", 139, 1]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.036029815673828125", "solution_depth": "12", "max_successor_states": "54", "num_vars_per_state": "3", "is_feasible_args": "[[139, 143, 17, 138, 133, 19, 126, 102, 65], [349, 415, 458]]", "is_correct_args": "[[139, 143, 17, 138, 133, 19, 126, 102, 65], [349, 415, 458]]", "A*_args": "[\"[139, 143, 17, 138, 133, 19, 126, 102, 65]\", \"[349, 415, 458]\"]"}
{"diff_sorted_id": "54", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[100, '_', 99, 84], [59, 20, 56, 64], [74, 6, 57, 83]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[20, 56, 64, 83, 57, 6, 56, 59, 74, 56, 59, 20, 99, 84, 83, 57, 6, 59, 20, 64, 59, 6]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.07044315338134766", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[100, \"_\", 99, 84], [59, 20, 56, 64], [74, 6, 57, 83]]]", "is_correct_args": "[[[100, \"_\", 99, 84], [59, 20, 56, 64], [74, 6, 57, 83]]]", "A*_args": "[\"[[100, '_', 99, 84], [59, 20, 56, 64], [74, 6, 57, 83]]\"]"}
{"diff_sorted_id": "54", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: unfew, brolly, bright, uproot   The initial board: [['r', 'u', 'p', 'f', 'y', 'w'], ['b', 'l', 'o', 'e', 'l', 'o'], ['n', 'r', '_', 'g', 'h', 't'], ['u', 'b', 'r', 'i', 'o', 't']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "26", "opt_solution_compute_t": "1.347020149230957", "solution_depth": "26", "max_successor_states": "4", "num_vars_per_state": "24", "is_feasible_args": "[[[\"r\", \"u\", \"p\", \"f\", \"y\", \"w\"], [\"b\", \"l\", \"o\", \"e\", \"l\", \"o\"], [\"n\", \"r\", \"_\", \"g\", \"h\", \"t\"], [\"u\", \"b\", \"r\", \"i\", \"o\", \"t\"]]]", "is_correct_args": "[[[\"r\", \"u\", \"p\", \"f\", \"y\", \"w\"], [\"b\", \"l\", \"o\", \"e\", \"l\", \"o\"], [\"n\", \"r\", \"_\", \"g\", \"h\", \"t\"], [\"u\", \"b\", \"r\", \"i\", \"o\", \"t\"]], [\"unfew\", \"brolly\", \"bright\", \"uproot\"]]", "A*_args": "[\"[['r', 'u', 'p', 'f', 'y', 'w'], ['b', 'l', 'o', 'e', 'l', 'o'], ['n', 'r', '_', 'g', 'h', 't'], ['u', 'b', 'r', 'i', 'o', 't']]\", \"['unfew', 'brolly', 'bright', 'uproot']\"]"}
{"diff_sorted_id": "54", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'R'. Our task is to visit city Y and city A excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from A and Y, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  G T M U K Y D A P R E S I \nG 0 1 0 0 1 1 0 0 1 0 0 0 0 \nT 0 0 0 0 0 0 0 1 0 0 1 0 0 \nM 1 1 0 0 0 0 0 0 0 0 0 0 0 \nU 1 0 1 0 0 0 0 0 0 0 0 0 0 \nK 0 1 0 1 0 0 1 0 1 0 0 0 1 \nY 0 0 1 1 1 0 1 0 0 0 0 0 0 \nD 0 0 1 0 0 0 0 0 0 0 0 1 1 \nA 1 0 0 1 0 1 1 0 0 0 0 0 0 \nP 0 0 1 0 0 0 1 1 0 0 0 0 1 \nR 0 0 0 1 0 0 0 0 0 0 1 0 0 \nE 0 0 0 0 1 0 0 0 0 1 0 0 0 \nS 0 1 0 0 1 0 0 0 1 0 0 0 0 \nI 0 0 0 1 0 1 0 0 0 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[\"R\", \"E\", \"K\", \"P\", \"A\", \"Y\", \"M\", \"T\", \"A\", \"Y\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.03291726112365723", "solution_depth": "10", "max_successor_states": "13", "num_vars_per_state": "16", "is_feasible_args": "[[[0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [\"G\", \"T\", \"M\", \"U\", \"K\", \"Y\", \"D\", \"A\", \"P\", \"R\", \"E\", \"S\", \"I\"], \"Y\", \"A\"]", "is_correct_args": "[[[0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [\"G\", \"T\", \"M\", \"U\", \"K\", \"Y\", \"D\", \"A\", \"P\", \"R\", \"E\", \"S\", \"I\"], \"R\", \"Y\", \"A\"]", "A*_args": "[\"[[0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]]\", \"['G', 'T', 'M', 'U', 'K', 'Y', 'D', 'A', 'P', 'R', 'E', 'S', 'I']\", \"['R']\", \"['Y', 'A']\"]"}
{"diff_sorted_id": "54", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [4, 17, 14, 12, 1, 3, 12, 10, 14, 9, 30, 20, 11, 17, 11, 16, 22, 17, 30, 5, 10, 16, 19, 27, 6, 18, 20, 19, 32, 25, 30, 15, 30, 21, 19, 25, 31, 33, 19, 10, 8, 16, 8], such that the sum of the chosen coins adds up to 328. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {1: 1, 31: 13, 25: 13, 11: 3, 3: 1, 10: 8, 33: 14, 8: 4, 9: 9, 4: 1, 20: 4, 12: 8, 27: 13, 30: 14, 16: 10, 18: 9, 32: 5, 21: 20, 6: 4, 5: 5, 22: 11, 17: 11, 19: 2, 14: 10, 15: 6}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "26", "opt_solution": "[19, 19, 19, 4, 11, 33, 32, 20, 8, 11, 15, 19, 18, 31, 22, 20, 27]", "opt_solution_cost": "98", "opt_solution_compute_t": "0.053559064865112305", "solution_depth": "17", "max_successor_states": "43", "num_vars_per_state": "43", "is_feasible_args": "[[4, 17, 14, 12, 1, 3, 12, 10, 14, 9, 30, 20, 11, 17, 11, 16, 22, 17, 30, 5, 10, 16, 19, 27, 6, 18, 20, 19, 32, 25, 30, 15, 30, 21, 19, 25, 31, 33, 19, 10, 8, 16, 8]]", "is_correct_args": "[[4, 17, 14, 12, 1, 3, 12, 10, 14, 9, 30, 20, 11, 17, 11, 16, 22, 17, 30, 5, 10, 16, 19, 27, 6, 18, 20, 19, 32, 25, 30, 15, 30, 21, 19, 25, 31, 33, 19, 10, 8, 16, 8], {\"1\": 1, \"31\": 13, \"25\": 13, \"11\": 3, \"3\": 1, \"10\": 8, \"33\": 14, \"8\": 4, \"9\": 9, \"4\": 1, \"20\": 4, \"12\": 8, \"27\": 13, \"30\": 14, \"16\": 10, \"18\": 9, \"32\": 5, \"21\": 20, \"6\": 4, \"5\": 5, \"22\": 11, \"17\": 11, \"19\": 2, \"14\": 10, \"15\": 6}, 328]", "A*_args": "[\"[4, 17, 14, 12, 1, 3, 12, 10, 14, 9, 30, 20, 11, 17, 11, 16, 22, 17, 30, 5, 10, 16, 19, 27, 6, 18, 20, 19, 32, 25, 30, 15, 30, 21, 19, 25, 31, 33, 19, 10, 8, 16, 8]\", \"{1: 1, 31: 13, 25: 13, 11: 3, 3: 1, 10: 8, 33: 14, 8: 4, 9: 9, 4: 1, 20: 4, 12: 8, 27: 13, 30: 14, 16: 10, 18: 9, 32: 5, 21: 20, 6: 4, 5: 5, 22: 11, 17: 11, 19: 2, 14: 10, 15: 6}\", \"328\"]"}
{"diff_sorted_id": "54", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Blue', 'Red', 'Green'], ['Green', 'Red', 'Green', 'Red', 'Blue'], ['Blue', 'Red', 'Green', 'Blue', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[0, 2], [1, 0], [1, 2], [1, 0], [1, 2], [1, 0], [2, 1], [2, 1], [2, 1], [2, 0], [2, 1], [2, 1], [0, 2], [0, 2], [0, 1], [0, 1], [0, 1], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [2, 1]]", "opt_solution_cost": "24", "opt_solution_compute_t": "54.056875705718994", "solution_depth": "24", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Red\", \"Green\", \"Blue\", \"Red\", \"Green\"], [\"Green\", \"Red\", \"Green\", \"Red\", \"Blue\"], [\"Blue\", \"Red\", \"Green\", \"Blue\", \"Blue\"]], 8]", "is_correct_args": "[[[\"Red\", \"Green\", \"Blue\", \"Red\", \"Green\"], [\"Green\", \"Red\", \"Green\", \"Red\", \"Blue\"], [\"Blue\", \"Red\", \"Green\", \"Blue\", \"Blue\"]], 8]", "A*_args": "[\"[['Red', 'Green', 'Blue', 'Red', 'Green'], ['Green', 'Red', 'Green', 'Red', 'Blue'], ['Blue', 'Red', 'Green', 'Blue', 'Blue']]\", \"8\"]"}
{"diff_sorted_id": "54", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 13 to 53 (13 included in the range but 53 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' '25' '28']\n ['x' 'x' '28' '31']\n ['15' 'x' '34' 'x']\n ['13' '34' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "12", "opt_solution": "[[0, 0, 17], [0, 1, 18], [1, 0, 16], [1, 1, 19], [2, 1, 20], [2, 3, 35], [3, 2, 36], [3, 3, 37]]", "opt_solution_cost": "326", "opt_solution_compute_t": "138.72793531417847", "solution_depth": "8", "max_successor_states": "40", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '25', '28'], ['', '', '28', '31'], ['15', '', '34', ''], ['13', '34', '', '']]\", 13, 53]", "is_correct_args": "[\"[['', '', '25', '28'], ['', '', '28', '31'], ['15', '', '34', ''], ['13', '34', '', '']]\", 13, 53]", "A*_args": "[\"[['', '', '25', '28'], ['', '', '28', '31'], ['15', '', '34', ''], ['13', '34', '', '']]\", \"13\", \"53\"]"}
{"diff_sorted_id": "54", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 28 to 59. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 208, 157, None for columns 1 to 2 respectively, and the sums of rows must be None, 196, 162, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 166. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['30' 'x' 'x' '37']\n ['41' '56' 'x' 'x']\n ['x' 'x' '29' '55']\n ['x' 'x' 'x' '42']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 1, 48], [0, 2, 34], [1, 2, 54], [1, 3, 45], [2, 0, 31], [2, 1, 47], [3, 0, 28], [3, 1, 57], [3, 2, 40]]", "opt_solution_cost": "674", "opt_solution_compute_t": "18.105977296829224", "solution_depth": "9", "max_successor_states": "49", "num_vars_per_state": "9", "is_feasible_args": "[\"[['30', '', '', '37'], ['41', '56', '', ''], ['', '', '29', '55'], ['', '', '', '42']]\", 4, 28, 59]", "is_correct_args": "[\"[['30', '', '', '37'], ['41', '56', '', ''], ['', '', '29', '55'], ['', '', '', '42']]\", 28, 59, [1, 3], [1, 3], [208, 157], [196, 162], 166]", "A*_args": "[\"[['30', '', '', '37'], ['41', '56', '', ''], ['', '', '29', '55'], ['', '', '', '42']]\", \"28\", \"59\", \"[None, 208, 157, None]\", \"[None, 196, 162, None]\", \"166\"]"}
{"diff_sorted_id": "54", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 8, 1: 8, 2: 2, 3: 7, 4: 9, 5: 5, 6: 2, 7: 7}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Green', 'Yellow', 'Blue', 'Yellow', 'Green'], ['Black', 'Yellow', 'Blue', 'Green', 'Red'], ['Red', 'Black', 'Blue', 'Red', 'Black'], [], ['Red', 'Green', 'Yellow', 'Black', 'Blue'], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[3, 6], [5, 6], [1, 7], [5, 7], [2, 0], [2, 4], [5, 4], [5, 0], [2, 5], [2, 7], [3, 0], [3, 5], [3, 6], [3, 0], [2, 3], [1, 2], [1, 5], [1, 2], [1, 7], [3, 6], [4, 2], [4, 2]]", "opt_solution_cost": "116", "opt_solution_compute_t": "0.24997472763061523", "solution_depth": "22", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[], [\"Green\", \"Yellow\", \"Blue\", \"Yellow\", \"Green\"], [\"Black\", \"Yellow\", \"Blue\", \"Green\", \"Red\"], [\"Red\", \"Black\", \"Blue\", \"Red\", \"Black\"], [], [\"Red\", \"Green\", \"Yellow\", \"Black\", \"Blue\"], [], []], 5, {\"0\": 8, \"1\": 8, \"2\": 2, \"3\": 7, \"4\": 9, \"5\": 5, \"6\": 2, \"7\": 7}]", "is_correct_args": "[[[], [\"Green\", \"Yellow\", \"Blue\", \"Yellow\", \"Green\"], [\"Black\", \"Yellow\", \"Blue\", \"Green\", \"Red\"], [\"Red\", \"Black\", \"Blue\", \"Red\", \"Black\"], [], [\"Red\", \"Green\", \"Yellow\", \"Black\", \"Blue\"], [], []], 5, {\"0\": 8, \"1\": 8, \"2\": 2, \"3\": 7, \"4\": 9, \"5\": 5, \"6\": 2, \"7\": 7}, 4]", "A*_args": "[\"[[], ['Green', 'Yellow', 'Blue', 'Yellow', 'Green'], ['Black', 'Yellow', 'Blue', 'Green', 'Red'], ['Red', 'Black', 'Blue', 'Red', 'Black'], [], ['Red', 'Green', 'Yellow', 'Black', 'Blue'], [], []]\", \"{0: 8, 1: 8, 2: 2, 3: 7, 4: 9, 5: 5, 6: 2, 7: 7}\", \"5\", \"4\"]"}
{"diff_sorted_id": "54", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (4, 11) to his destination workshop at index (9, 2), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 8, and district 3 covering rows 9 to 11. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[19 14 16 4 15 16 15 x 9 x x x]\n[x 7 12 6 x 12 x 3 x 14 5 9]\n[1 12 x x 12 x x x x x 10 1]\n[x 1 15 14 x 2 13 x x x 10 9]\n[7 x 13 x 14 1 14 8 x x 8 5]\n[18 x 8 13 12 13 x 12 3 x 14 x]\n[x 15 x x x x x x x x 17 10]\n[x 5 x 4 x x x 3 5 6 6 11]\n[x 15 6 x 4 18 x x 14 10 2 8]\n[13 10 13 7 3 6 x x 10 17 10 15]\n[4 x x 7 19 4 13 13 12 x x 13]\n[5 x x 9 19 18 x x 16 x 2 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "4", "opt_solution": "[[4, 11], [3, 11], [4, 11], [4, 10], [5, 10], [6, 10], [7, 10], [7, 9], [7, 8], [8, 8], [9, 8], [10, 8], [10, 7], [10, 6], [10, 5], [9, 5], [9, 4], [9, 3], [9, 2]]", "opt_solution_cost": "165", "opt_solution_compute_t": "0.02228689193725586", "solution_depth": "19", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"19\", \"14\", \"16\", \"4\", \"15\", \"16\", \"15\", \"x\", \"9\", \"x\", \"x\", \"x\"], [\"x\", \"7\", \"12\", \"6\", \"x\", \"12\", \"x\", \"3\", \"x\", \"14\", \"5\", \"9\"], [\"1\", \"12\", \"x\", \"x\", \"12\", \"x\", \"x\", \"x\", \"x\", \"x\", \"10\", \"1\"], [\"x\", \"1\", \"15\", \"14\", \"x\", \"2\", \"13\", \"x\", \"x\", \"x\", \"10\", \"9\"], [\"7\", \"x\", \"13\", \"x\", \"14\", \"1\", \"14\", \"8\", \"x\", \"x\", \"8\", \"5\"], [\"18\", \"x\", \"8\", \"13\", \"12\", \"13\", \"x\", \"12\", \"3\", \"x\", \"14\", \"x\"], [\"x\", \"15\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"17\", \"10\"], [\"x\", \"5\", \"x\", \"4\", \"x\", \"x\", \"x\", \"3\", \"5\", \"6\", \"6\", \"11\"], [\"x\", \"15\", \"6\", \"x\", \"4\", \"18\", \"x\", \"x\", \"14\", \"10\", \"2\", \"8\"], [\"13\", \"10\", \"13\", \"7\", \"3\", \"6\", \"x\", \"x\", \"10\", \"17\", \"10\", \"15\"], [\"4\", \"x\", \"x\", \"7\", \"19\", \"4\", \"13\", \"13\", \"12\", \"x\", \"x\", \"13\"], [\"5\", \"x\", \"x\", \"9\", \"19\", \"18\", \"x\", \"x\", \"16\", \"x\", \"2\", \"x\"]]]", "is_correct_args": "[[[\"19\", \"14\", \"16\", \"4\", \"15\", \"16\", \"15\", \"x\", \"9\", \"x\", \"x\", \"x\"], [\"x\", \"7\", \"12\", \"6\", \"x\", \"12\", \"x\", \"3\", \"x\", \"14\", \"5\", \"9\"], [\"1\", \"12\", \"x\", \"x\", \"12\", \"x\", \"x\", \"x\", \"x\", \"x\", \"10\", \"1\"], [\"x\", \"1\", \"15\", \"14\", \"x\", \"2\", \"13\", \"x\", \"x\", \"x\", \"10\", \"9\"], [\"7\", \"x\", \"13\", \"x\", \"14\", \"1\", \"14\", \"8\", \"x\", \"x\", \"8\", \"5\"], [\"18\", \"x\", \"8\", \"13\", \"12\", \"13\", \"x\", \"12\", \"3\", \"x\", \"14\", \"x\"], [\"x\", \"15\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"17\", \"10\"], [\"x\", \"5\", \"x\", \"4\", \"x\", \"x\", \"x\", \"3\", \"5\", \"6\", \"6\", \"11\"], [\"x\", \"15\", \"6\", \"x\", \"4\", \"18\", \"x\", \"x\", \"14\", \"10\", \"2\", \"8\"], [\"13\", \"10\", \"13\", \"7\", \"3\", \"6\", \"x\", \"x\", \"10\", \"17\", \"10\", \"15\"], [\"4\", \"x\", \"x\", \"7\", \"19\", \"4\", \"13\", \"13\", \"12\", \"x\", \"x\", \"13\"], [\"5\", \"x\", \"x\", \"9\", \"19\", \"18\", \"x\", \"x\", \"16\", \"x\", \"2\", \"x\"]], [4, 11], [9, 2], 3, 8]", "A*_args": "[\"[['19', '14', '16', '4', '15', '16', '15', 'x', '9', 'x', 'x', 'x'], ['x', '7', '12', '6', 'x', '12', 'x', '3', 'x', '14', '5', '9'], ['1', '12', 'x', 'x', '12', 'x', 'x', 'x', 'x', 'x', '10', '1'], ['x', '1', '15', '14', 'x', '2', '13', 'x', 'x', 'x', '10', '9'], ['7', 'x', '13', 'x', '14', '1', '14', '8', 'x', 'x', '8', '5'], ['18', 'x', '8', '13', '12', '13', 'x', '12', '3', 'x', '14', 'x'], ['x', '15', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', '17', '10'], ['x', '5', 'x', '4', 'x', 'x', 'x', '3', '5', '6', '6', '11'], ['x', '15', '6', 'x', '4', '18', 'x', 'x', '14', '10', '2', '8'], ['13', '10', '13', '7', '3', '6', 'x', 'x', '10', '17', '10', '15'], ['4', 'x', 'x', '7', '19', '4', '13', '13', '12', 'x', 'x', '13'], ['5', 'x', 'x', '9', '19', '18', 'x', 'x', '16', 'x', '2', 'x']]\", \"(4, 11)\", \"(9, 2)\", \"3\", \"8\"]"}
{"diff_sorted_id": "54", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 12x12. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 7) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (10, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 0 1 0 0 1 0 0 1 0 0\n1 0 0 1 1 1 0 0 0 0 1 0\n0 1 1 0 1 0 0 0 1 1 0 0\n1 0 1 1 1 0 0 0 0 0 1 1\n0 0 0 0 0 0 0 0 0 1 1 0\n0 1 0 0 1 0 1 1 1 1 1 0\n0 0 0 1 1 0 0 1 0 1 1 1\n0 0 1 0 0 1 1 0 0 1 0 1\n0 0 0 1 1 1 1 1 1 0 1 0\n0 0 1 1 0 1 1 1 1 0 1 0\n0 0 0 1 1 1 0 1 1 0 1 1\n0 0 1 1 0 1 0 0 1 1 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[[1, 7], [2, 6], [3, 5], [4, 5], [5, 5], [6, 5], [7, 4], [7, 3], [8, 2], [8, 1], [9, 1], [9, 0], [10, 0]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.029400348663330078", "solution_depth": "13", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0], [0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1], [0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0], [0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1], [0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0]]\", 4]", "is_correct_args": "[\"[[1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0], [0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1], [0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0], [0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1], [0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0]]\", [1, 7], [10, 0], 4]", "A*_args": "[\"[[1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0], [0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1], [0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0], [0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1], [0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0]]\", \"(1, 7)\", \"(10, 0)\", \"4\"]"}
{"diff_sorted_id": "54", "problem_statement": "Given 9 labeled water jugs with capacities 45, 67, 134, 133, 86, 66, 107, 94, 124, 122 liters, we aim to fill 3 unlabeled buckets, numbered 1 to 3 and arranged in a line in ascending order, with 229, 303, 307 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 66, 3], [\"+\", 107, 3], [\"+\", 134, 3], [\"+\", 124, 2], [\"+\", 134, 2], [\"+\", 45, 2], [\"+\", 107, 1], [\"+\", 122, 1]]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.02436041831970215", "solution_depth": "8", "max_successor_states": "60", "num_vars_per_state": "3", "is_feasible_args": "[[45, 67, 134, 133, 86, 66, 107, 94, 124, 122], [229, 303, 307]]", "is_correct_args": "[[45, 67, 134, 133, 86, 66, 107, 94, 124, 122], [229, 303, 307]]", "A*_args": "[\"[45, 67, 134, 133, 86, 66, 107, 94, 124, 122]\", \"[229, 303, 307]\"]"}
{"diff_sorted_id": "55", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[34, 68, 46, 20], [12, 18, '_', 5], [53, 7, 65, 47]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "7", "opt_solution": "[18, 68, 46, 18, 65, 47, 5, 20, 18, 65, 47, 7, 53, 12, 34, 46, 65, 47, 20, 18, 47, 65, 68, 53, 7, 20, 53, 34, 46, 68, 65, 53, 20, 5]", "opt_solution_cost": "34", "opt_solution_compute_t": "3.4830353260040283", "solution_depth": "34", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[34, 68, 46, 20], [12, 18, \"_\", 5], [53, 7, 65, 47]]]", "is_correct_args": "[[[34, 68, 46, 20], [12, 18, \"_\", 5], [53, 7, 65, 47]]]", "A*_args": "[\"[[34, 68, 46, 20], [12, 18, '_', 5], [53, 7, 65, 47]]\"]"}
{"diff_sorted_id": "55", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: net, toss, flip, swag, bosn   The initial board: [['o', 'n', 's', 't'], ['t', 'e', 's', 'w'], ['i', 'l', 's', 'p'], ['s', 'g', 'a', 'f'], ['b', 'o', '_', 'n']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-left\"]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.19336867332458496", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"o\", \"n\", \"s\", \"t\"], [\"t\", \"e\", \"s\", \"w\"], [\"i\", \"l\", \"s\", \"p\"], [\"s\", \"g\", \"a\", \"f\"], [\"b\", \"o\", \"_\", \"n\"]]]", "is_correct_args": "[[[\"o\", \"n\", \"s\", \"t\"], [\"t\", \"e\", \"s\", \"w\"], [\"i\", \"l\", \"s\", \"p\"], [\"s\", \"g\", \"a\", \"f\"], [\"b\", \"o\", \"_\", \"n\"]], [\"net\", \"toss\", \"flip\", \"swag\", \"bosn\"]]", "A*_args": "[\"[['o', 'n', 's', 't'], ['t', 'e', 's', 'w'], ['i', 'l', 's', 'p'], ['s', 'g', 'a', 'f'], ['b', 'o', '_', 'n']]\", \"['net', 'toss', 'flip', 'swag', 'bosn']\"]"}
{"diff_sorted_id": "55", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'H'. Our task is to visit city B and city X excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from X and B, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  D Z T X L K N H U A Q B Y \nD 0 1 0 1 0 0 0 0 0 1 0 0 0 \nZ 1 0 1 1 0 0 0 1 0 0 0 0 1 \nT 1 0 0 0 0 0 0 1 1 0 0 1 0 \nX 0 0 1 0 0 0 0 0 0 0 1 0 0 \nL 1 1 0 0 0 1 0 0 0 0 0 1 0 \nK 1 0 1 1 0 0 0 0 0 1 0 0 0 \nN 1 0 0 0 0 0 0 0 0 1 0 0 1 \nH 1 0 0 0 0 0 1 0 0 0 1 0 0 \nU 0 0 0 0 0 0 1 0 0 0 0 1 0 \nA 0 0 1 0 1 0 0 1 0 0 0 0 0 \nQ 0 0 0 1 1 0 1 0 1 0 0 0 0 \nB 1 1 1 1 0 1 0 0 0 1 1 0 1 \nY 1 0 1 0 0 1 0 1 1 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[\"H\", \"Q\", \"L\", \"B\", \"X\", \"T\", \"B\", \"X\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.04383373260498047", "solution_depth": "8", "max_successor_states": "13", "num_vars_per_state": "16", "is_feasible_args": "[[[0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0], [1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1], [1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0]], [\"D\", \"Z\", \"T\", \"X\", \"L\", \"K\", \"N\", \"H\", \"U\", \"A\", \"Q\", \"B\", \"Y\"], \"B\", \"X\"]", "is_correct_args": "[[[0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0], [1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1], [1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0]], [\"D\", \"Z\", \"T\", \"X\", \"L\", \"K\", \"N\", \"H\", \"U\", \"A\", \"Q\", \"B\", \"Y\"], \"H\", \"B\", \"X\"]", "A*_args": "[\"[[0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0], [1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1], [1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0]]\", \"['D', 'Z', 'T', 'X', 'L', 'K', 'N', 'H', 'U', 'A', 'Q', 'B', 'Y']\", \"['H']\", \"['B', 'X']\"]"}
{"diff_sorted_id": "55", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [12, 26, 9, 14, 11, 25, 28, 17, 18, 18, 9, 16, 2, 11, 31, 25, 4, 23, 9, 3, 24, 22, 3, 14, 32, 30, 19, 7, 4, 22, 33, 13, 25, 15, 14, 28, 20, 3, 4, 3, 32, 10, 6, 29, 25], such that the sum of the chosen coins adds up to 325. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {29: 2, 9: 7, 17: 4, 18: 9, 26: 6, 33: 11, 16: 12, 4: 3, 31: 12, 6: 2, 11: 8, 23: 14, 7: 1, 30: 8, 12: 8, 13: 2, 20: 13, 24: 16, 14: 8, 19: 8, 10: 8, 32: 14, 3: 2, 2: 2, 25: 19, 22: 18, 15: 5, 28: 9}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "27", "opt_solution": "[30, 28, 26, 6, 13, 15, 17, 29, 33, 32, 28, 18, 19, 31]", "opt_solution_cost": "101", "opt_solution_compute_t": "0.05463528633117676", "solution_depth": "14", "max_successor_states": "45", "num_vars_per_state": "45", "is_feasible_args": "[[12, 26, 9, 14, 11, 25, 28, 17, 18, 18, 9, 16, 2, 11, 31, 25, 4, 23, 9, 3, 24, 22, 3, 14, 32, 30, 19, 7, 4, 22, 33, 13, 25, 15, 14, 28, 20, 3, 4, 3, 32, 10, 6, 29, 25]]", "is_correct_args": "[[12, 26, 9, 14, 11, 25, 28, 17, 18, 18, 9, 16, 2, 11, 31, 25, 4, 23, 9, 3, 24, 22, 3, 14, 32, 30, 19, 7, 4, 22, 33, 13, 25, 15, 14, 28, 20, 3, 4, 3, 32, 10, 6, 29, 25], {\"29\": 2, \"9\": 7, \"17\": 4, \"18\": 9, \"26\": 6, \"33\": 11, \"16\": 12, \"4\": 3, \"31\": 12, \"6\": 2, \"11\": 8, \"23\": 14, \"7\": 1, \"30\": 8, \"12\": 8, \"13\": 2, \"20\": 13, \"24\": 16, \"14\": 8, \"19\": 8, \"10\": 8, \"32\": 14, \"3\": 2, \"2\": 2, \"25\": 19, \"22\": 18, \"15\": 5, \"28\": 9}, 325]", "A*_args": "[\"[12, 26, 9, 14, 11, 25, 28, 17, 18, 18, 9, 16, 2, 11, 31, 25, 4, 23, 9, 3, 24, 22, 3, 14, 32, 30, 19, 7, 4, 22, 33, 13, 25, 15, 14, 28, 20, 3, 4, 3, 32, 10, 6, 29, 25]\", \"{29: 2, 9: 7, 17: 4, 18: 9, 26: 6, 33: 11, 16: 12, 4: 3, 31: 12, 6: 2, 11: 8, 23: 14, 7: 1, 30: 8, 12: 8, 13: 2, 20: 13, 24: 16, 14: 8, 19: 8, 10: 8, 32: 14, 3: 2, 2: 2, 25: 19, 22: 18, 15: 5, 28: 9}\", \"325\"]"}
{"diff_sorted_id": "55", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Blue', 'Blue', 'Red', 'Red'], ['Green', 'Red', 'Blue', 'Green', 'Green'], ['Red', 'Green', 'Blue', 'Blue', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[0, 2], [1, 2], [1, 0], [1, 0], [2, 1], [2, 1], [2, 0], [2, 1], [0, 1], [2, 0], [2, 0], [2, 1], [0, 2], [0, 2], [0, 2], [0, 1], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0]]", "opt_solution_cost": "21", "opt_solution_compute_t": "12.931140422821045", "solution_depth": "21", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Green\", \"Blue\", \"Blue\", \"Red\", \"Red\"], [\"Green\", \"Red\", \"Blue\", \"Green\", \"Green\"], [\"Red\", \"Green\", \"Blue\", \"Blue\", \"Red\"]], 8]", "is_correct_args": "[[[\"Green\", \"Blue\", \"Blue\", \"Red\", \"Red\"], [\"Green\", \"Red\", \"Blue\", \"Green\", \"Green\"], [\"Red\", \"Green\", \"Blue\", \"Blue\", \"Red\"]], 8]", "A*_args": "[\"[['Green', 'Blue', 'Blue', 'Red', 'Red'], ['Green', 'Red', 'Blue', 'Green', 'Green'], ['Red', 'Green', 'Blue', 'Blue', 'Red']]\", \"8\"]"}
{"diff_sorted_id": "55", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 10 to 50 (10 included in the range but 50 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '38' '19' 'x']\n ['22' 'x' 'x' 'x']\n ['x' '30' 'x' '42']\n ['x' 'x' '35' '45']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "13", "opt_solution": "[[0, 0, 39], [0, 3, 10], [1, 1, 31], [1, 2, 32], [1, 3, 33], [2, 0, 12], [2, 2, 34], [3, 0, 11], [3, 1, 13]]", "opt_solution_cost": "385", "opt_solution_compute_t": "2.9997804164886475", "solution_depth": "9", "max_successor_states": "40", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '38', '19', ''], ['22', '', '', ''], ['', '30', '', '42'], ['', '', '35', '45']]\", 10, 50]", "is_correct_args": "[\"[['', '38', '19', ''], ['22', '', '', ''], ['', '30', '', '42'], ['', '', '35', '45']]\", 10, 50]", "A*_args": "[\"[['', '38', '19', ''], ['22', '', '', ''], ['', '30', '', '42'], ['', '', '35', '45']]\", \"10\", \"50\"]"}
{"diff_sorted_id": "55", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 28 to 59. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 162, 195, None for columns 1 to 2 respectively, and the sums of rows must be None, 168, 168, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 168. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['46' 'x' '58' '45']\n ['x' 'x' '54' 'x']\n ['x' 'x' 'x' 'x']\n ['28' '53' '34' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 1, 29], [1, 0, 31], [1, 1, 39], [1, 3, 44], [2, 0, 35], [2, 1, 41], [2, 2, 49], [2, 3, 43], [3, 3, 30]]", "opt_solution_cost": "659", "opt_solution_compute_t": "0.8985345363616943", "solution_depth": "9", "max_successor_states": "49", "num_vars_per_state": "9", "is_feasible_args": "[\"[['46', '', '58', '45'], ['', '', '54', ''], ['', '', '', ''], ['28', '53', '34', '']]\", 4, 28, 59]", "is_correct_args": "[\"[['46', '', '58', '45'], ['', '', '54', ''], ['', '', '', ''], ['28', '53', '34', '']]\", 28, 59, [1, 3], [1, 3], [162, 195], [168, 168], 168]", "A*_args": "[\"[['46', '', '58', '45'], ['', '', '54', ''], ['', '', '', ''], ['28', '53', '34', '']]\", \"28\", \"59\", \"[None, 162, 195, None]\", \"[None, 168, 168, None]\", \"168\"]"}
{"diff_sorted_id": "55", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 8, 1: 2, 2: 7, 3: 6, 4: 7, 5: 1, 6: 5, 7: 3}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Red', 'Red', 'Red', 'Green', 'Yellow'], ['Black', 'Red', 'Green', 'Yellow', 'Yellow'], [], [], [], ['Black', 'Blue', 'Black', 'Yellow', 'Green'], [], ['Blue', 'Green', 'Blue', 'Black', 'Blue']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[5, 6], [5, 3], [5, 6], [5, 2], [7, 3], [7, 5], [7, 3], [7, 6], [7, 3], [1, 6], [0, 7], [0, 7], [0, 7], [1, 7], [1, 5], [2, 1], [0, 5], [0, 1]]", "opt_solution_cost": "70", "opt_solution_compute_t": "14.086882591247559", "solution_depth": "18", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[\"Red\", \"Red\", \"Red\", \"Green\", \"Yellow\"], [\"Black\", \"Red\", \"Green\", \"Yellow\", \"Yellow\"], [], [], [], [\"Black\", \"Blue\", \"Black\", \"Yellow\", \"Green\"], [], [\"Blue\", \"Green\", \"Blue\", \"Black\", \"Blue\"]], 5, {\"0\": 8, \"1\": 2, \"2\": 7, \"3\": 6, \"4\": 7, \"5\": 1, \"6\": 5, \"7\": 3}]", "is_correct_args": "[[[\"Red\", \"Red\", \"Red\", \"Green\", \"Yellow\"], [\"Black\", \"Red\", \"Green\", \"Yellow\", \"Yellow\"], [], [], [], [\"Black\", \"Blue\", \"Black\", \"Yellow\", \"Green\"], [], [\"Blue\", \"Green\", \"Blue\", \"Black\", \"Blue\"]], 5, {\"0\": 8, \"1\": 2, \"2\": 7, \"3\": 6, \"4\": 7, \"5\": 1, \"6\": 5, \"7\": 3}, 4]", "A*_args": "[\"[['Red', 'Red', 'Red', 'Green', 'Yellow'], ['Black', 'Red', 'Green', 'Yellow', 'Yellow'], [], [], [], ['Black', 'Blue', 'Black', 'Yellow', 'Green'], [], ['Blue', 'Green', 'Blue', 'Black', 'Blue']]\", \"{0: 8, 1: 2, 2: 7, 3: 6, 4: 7, 5: 1, 6: 5, 7: 3}\", \"5\", \"4\"]"}
{"diff_sorted_id": "55", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 9) to his destination workshop at index (7, 1), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 8, and district 3 covering rows 9 to 11. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[9 4 16 7 x 2 x x 14 x x x]\n[x 15 10 5 12 16 x x x 3 12 18]\n[12 x x x 9 16 3 9 x x x 7]\n[10 6 3 10 x x 1 17 x 12 12 x]\n[11 8 15 x 8 16 x x 5 15 12 7]\n[x x x x 6 x 11 19 17 17 10 20]\n[x 3 17 17 x x 18 4 x x 9 4]\n[x 1 5 17 8 15 4 17 5 6 9 11]\n[x x 4 5 17 18 3 x 9 1 11 2]\n[x x 5 3 4 14 14 1 17 3 12 12]\n[x 15 9 7 3 x x x x x 17 x]\n[x x 13 16 6 x 6 x x x x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "4", "opt_solution": "[[3, 9], [3, 10], [4, 10], [5, 10], [6, 10], [7, 10], [7, 9], [8, 9], [9, 9], [9, 8], [9, 7], [9, 6], [9, 5], [9, 4], [9, 3], [8, 3], [8, 2], [7, 2], [7, 1]]", "opt_solution_cost": "130", "opt_solution_compute_t": "0.02777552604675293", "solution_depth": "19", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"9\", \"4\", \"16\", \"7\", \"x\", \"2\", \"x\", \"x\", \"14\", \"x\", \"x\", \"x\"], [\"x\", \"15\", \"10\", \"5\", \"12\", \"16\", \"x\", \"x\", \"x\", \"3\", \"12\", \"18\"], [\"12\", \"x\", \"x\", \"x\", \"9\", \"16\", \"3\", \"9\", \"x\", \"x\", \"x\", \"7\"], [\"10\", \"6\", \"3\", \"10\", \"x\", \"x\", \"1\", \"17\", \"x\", \"12\", \"12\", \"x\"], [\"11\", \"8\", \"15\", \"x\", \"8\", \"16\", \"x\", \"x\", \"5\", \"15\", \"12\", \"7\"], [\"x\", \"x\", \"x\", \"x\", \"6\", \"x\", \"11\", \"19\", \"17\", \"17\", \"10\", \"20\"], [\"x\", \"3\", \"17\", \"17\", \"x\", \"x\", \"18\", \"4\", \"x\", \"x\", \"9\", \"4\"], [\"x\", \"1\", \"5\", \"17\", \"8\", \"15\", \"4\", \"17\", \"5\", \"6\", \"9\", \"11\"], [\"x\", \"x\", \"4\", \"5\", \"17\", \"18\", \"3\", \"x\", \"9\", \"1\", \"11\", \"2\"], [\"x\", \"x\", \"5\", \"3\", \"4\", \"14\", \"14\", \"1\", \"17\", \"3\", \"12\", \"12\"], [\"x\", \"15\", \"9\", \"7\", \"3\", \"x\", \"x\", \"x\", \"x\", \"x\", \"17\", \"x\"], [\"x\", \"x\", \"13\", \"16\", \"6\", \"x\", \"6\", \"x\", \"x\", \"x\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"9\", \"4\", \"16\", \"7\", \"x\", \"2\", \"x\", \"x\", \"14\", \"x\", \"x\", \"x\"], [\"x\", \"15\", \"10\", \"5\", \"12\", \"16\", \"x\", \"x\", \"x\", \"3\", \"12\", \"18\"], [\"12\", \"x\", \"x\", \"x\", \"9\", \"16\", \"3\", \"9\", \"x\", \"x\", \"x\", \"7\"], [\"10\", \"6\", \"3\", \"10\", \"x\", \"x\", \"1\", \"17\", \"x\", \"12\", \"12\", \"x\"], [\"11\", \"8\", \"15\", \"x\", \"8\", \"16\", \"x\", \"x\", \"5\", \"15\", \"12\", \"7\"], [\"x\", \"x\", \"x\", \"x\", \"6\", \"x\", \"11\", \"19\", \"17\", \"17\", \"10\", \"20\"], [\"x\", \"3\", \"17\", \"17\", \"x\", \"x\", \"18\", \"4\", \"x\", \"x\", \"9\", \"4\"], [\"x\", \"1\", \"5\", \"17\", \"8\", \"15\", \"4\", \"17\", \"5\", \"6\", \"9\", \"11\"], [\"x\", \"x\", \"4\", \"5\", \"17\", \"18\", \"3\", \"x\", \"9\", \"1\", \"11\", \"2\"], [\"x\", \"x\", \"5\", \"3\", \"4\", \"14\", \"14\", \"1\", \"17\", \"3\", \"12\", \"12\"], [\"x\", \"15\", \"9\", \"7\", \"3\", \"x\", \"x\", \"x\", \"x\", \"x\", \"17\", \"x\"], [\"x\", \"x\", \"13\", \"16\", \"6\", \"x\", \"6\", \"x\", \"x\", \"x\", \"x\", \"x\"]], [3, 9], [7, 1], 3, 8]", "A*_args": "[\"[['9', '4', '16', '7', 'x', '2', 'x', 'x', '14', 'x', 'x', 'x'], ['x', '15', '10', '5', '12', '16', 'x', 'x', 'x', '3', '12', '18'], ['12', 'x', 'x', 'x', '9', '16', '3', '9', 'x', 'x', 'x', '7'], ['10', '6', '3', '10', 'x', 'x', '1', '17', 'x', '12', '12', 'x'], ['11', '8', '15', 'x', '8', '16', 'x', 'x', '5', '15', '12', '7'], ['x', 'x', 'x', 'x', '6', 'x', '11', '19', '17', '17', '10', '20'], ['x', '3', '17', '17', 'x', 'x', '18', '4', 'x', 'x', '9', '4'], ['x', '1', '5', '17', '8', '15', '4', '17', '5', '6', '9', '11'], ['x', 'x', '4', '5', '17', '18', '3', 'x', '9', '1', '11', '2'], ['x', 'x', '5', '3', '4', '14', '14', '1', '17', '3', '12', '12'], ['x', '15', '9', '7', '3', 'x', 'x', 'x', 'x', 'x', '17', 'x'], ['x', 'x', '13', '16', '6', 'x', '6', 'x', 'x', 'x', 'x', 'x']]\", \"(3, 9)\", \"(7, 1)\", \"3\", \"8\"]"}
{"diff_sorted_id": "55", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 12x12. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 11) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (9, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 0 0 0 0 0 0 0 0 0 1\n0 1 1 0 0 0 1 0 1 0 0 0\n1 1 0 0 1 1 1 0 0 1 0 1\n1 1 0 1 1 1 1 1 0 1 1 1\n1 0 0 1 1 1 0 1 0 1 0 1\n0 0 0 1 0 1 1 1 1 1 0 1\n0 0 0 0 0 0 0 0 0 0 0 0\n0 1 0 0 1 1 1 1 1 1 1 1\n0 1 0 0 1 1 1 0 1 0 1 1\n0 1 1 1 1 1 1 1 0 1 0 0\n1 1 0 0 0 0 0 0 1 1 1 0\n0 0 1 1 0 1 0 1 1 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[[1, 11], [0, 10], [0, 9], [0, 8], [0, 7], [0, 6], [0, 5], [1, 5], [1, 4], [2, 3], [3, 2], [4, 2], [5, 2], [6, 2], [6, 1], [7, 0], [8, 0], [9, 0]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.029353857040405273", "solution_depth": "18", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0], [1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1], [1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1], [1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1]]\", 4]", "is_correct_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0], [1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1], [1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1], [1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1]]\", [1, 11], [9, 0], 4]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0], [1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1], [1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1], [1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1]]\", \"(1, 11)\", \"(9, 0)\", \"4\"]"}
{"diff_sorted_id": "55", "problem_statement": "Given 5 labeled water jugs with capacities 33, 87, 48, 30, 61, 60 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 170, 225, 238, 317 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 60, 4], [\"+\", 61, 4], [\"+\", 87, 4], [\"+\", 48, 4], [\"+\", 61, 4], [\"+\", 60, 3], [\"+\", 61, 3], [\"+\", 30, 3], [\"+\", 87, 3], [\"+\", 48, 2], [\"+\", 60, 2], [\"+\", 87, 2], [\"+\", 30, 2], [\"+\", 61, 1], [\"+\", 61, 1], [\"+\", 48, 1]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.039655208587646484", "solution_depth": "16", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[33, 87, 48, 30, 61, 60], [170, 225, 238, 317]]", "is_correct_args": "[[33, 87, 48, 30, 61, 60], [170, 225, 238, 317]]", "A*_args": "[\"[33, 87, 48, 30, 61, 60]\", \"[170, 225, 238, 317]\"]"}
{"diff_sorted_id": "56", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[66, 96, 24, 10], [79, 33, 84, 100], [22, 80, 15, '_']]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "7", "opt_solution": "[15, 84, 100, 10, 24, 100, 84, 80, 33, 96, 100, 84, 80, 33, 22, 79, 66, 100, 84, 80, 33, 15, 10, 24, 80, 84, 96, 66, 79, 22, 15, 10]", "opt_solution_cost": "32", "opt_solution_compute_t": "1.4827980995178223", "solution_depth": "32", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[66, 96, 24, 10], [79, 33, 84, 100], [22, 80, 15, \"_\"]]]", "is_correct_args": "[[[66, 96, 24, 10], [79, 33, 84, 100], [22, 80, 15, \"_\"]]]", "A*_args": "[\"[[66, 96, 24, 10], [79, 33, 84, 100], [22, 80, 15, '_']]\"]"}
{"diff_sorted_id": "56", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: nye, calx, hern, jaob, exam   The initial board: [['a', 'n', 'x', 'e'], ['c', 'y', 'l', 'a'], ['r', 'e', '_', 'n'], ['j', 'h', 'o', 'a'], ['e', 'x', 'b', 'm']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-left\", \"up-left\"]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.2367854118347168", "solution_depth": "12", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"a\", \"n\", \"x\", \"e\"], [\"c\", \"y\", \"l\", \"a\"], [\"r\", \"e\", \"_\", \"n\"], [\"j\", \"h\", \"o\", \"a\"], [\"e\", \"x\", \"b\", \"m\"]]]", "is_correct_args": "[[[\"a\", \"n\", \"x\", \"e\"], [\"c\", \"y\", \"l\", \"a\"], [\"r\", \"e\", \"_\", \"n\"], [\"j\", \"h\", \"o\", \"a\"], [\"e\", \"x\", \"b\", \"m\"]], [\"nye\", \"calx\", \"hern\", \"jaob\", \"exam\"]]", "A*_args": "[\"[['a', 'n', 'x', 'e'], ['c', 'y', 'l', 'a'], ['r', 'e', '_', 'n'], ['j', 'h', 'o', 'a'], ['e', 'x', 'b', 'm']]\", \"['nye', 'calx', 'hern', 'jaob', 'exam']\"]"}
{"diff_sorted_id": "56", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'C'. Our task is to visit city B and city L excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from L and B, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  K M B X N D V C I R F W L \nK 0 1 0 1 0 0 0 0 0 0 1 0 0 \nM 0 0 0 0 0 0 1 0 1 0 0 0 1 \nB 1 0 0 0 0 0 0 0 0 1 0 0 0 \nX 1 1 0 0 0 0 1 0 0 0 1 0 0 \nN 0 0 1 0 0 0 0 0 0 0 1 0 0 \nD 0 0 1 0 0 0 1 1 1 0 0 0 0 \nV 0 0 0 0 0 0 0 1 1 0 0 0 0 \nC 0 0 0 1 0 1 0 0 0 0 0 0 0 \nI 0 0 1 1 1 0 0 0 0 1 0 0 1 \nR 0 1 0 0 0 0 0 0 0 0 0 1 0 \nF 0 0 0 0 1 0 0 0 1 1 0 1 0 \nW 1 1 1 0 0 0 0 1 0 0 0 0 1 \nL 0 0 0 1 0 0 0 1 0 1 1 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[\"C\", \"D\", \"B\", \"K\", \"M\", \"L\", \"F\", \"I\", \"L\", \"W\", \"B\"]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.1076192855834961", "solution_depth": "11", "max_successor_states": "13", "num_vars_per_state": "16", "is_feasible_args": "[[[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0], [1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0]], [\"K\", \"M\", \"B\", \"X\", \"N\", \"D\", \"V\", \"C\", \"I\", \"R\", \"F\", \"W\", \"L\"], \"B\", \"L\"]", "is_correct_args": "[[[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0], [1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0]], [\"K\", \"M\", \"B\", \"X\", \"N\", \"D\", \"V\", \"C\", \"I\", \"R\", \"F\", \"W\", \"L\"], \"C\", \"B\", \"L\"]", "A*_args": "[\"[[0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0], [1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0]]\", \"['K', 'M', 'B', 'X', 'N', 'D', 'V', 'C', 'I', 'R', 'F', 'W', 'L']\", \"['C']\", \"['B', 'L']\"]"}
{"diff_sorted_id": "56", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [4, 33, 14, 32, 9, 32, 2, 35, 25, 10, 11, 6, 8, 26, 10, 25, 34, 21, 13, 15, 3, 15, 25, 3, 16, 3, 2, 25, 15, 23, 31, 35, 13, 14, 5, 7, 2, 18, 10, 8, 25, 30, 13, 35, 3, 26, 33, 2, 5, 26, 26, 28, 6], such that the sum of the chosen coins adds up to 355. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {26: 4, 34: 4, 7: 5, 28: 11, 35: 8, 18: 13, 25: 19, 14: 10, 23: 7, 6: 1, 10: 5, 21: 8, 13: 13, 2: 1, 3: 1, 30: 5, 4: 4, 31: 18, 11: 3, 9: 1, 8: 3, 5: 3, 32: 5, 15: 15, 33: 18, 16: 4}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "28", "opt_solution": "[34, 32, 26, 2, 35, 32, 30, 26, 35, 26, 35, 26, 16]", "opt_solution_cost": "64", "opt_solution_compute_t": "0.06210756301879883", "solution_depth": "13", "max_successor_states": "53", "num_vars_per_state": "53", "is_feasible_args": "[[4, 33, 14, 32, 9, 32, 2, 35, 25, 10, 11, 6, 8, 26, 10, 25, 34, 21, 13, 15, 3, 15, 25, 3, 16, 3, 2, 25, 15, 23, 31, 35, 13, 14, 5, 7, 2, 18, 10, 8, 25, 30, 13, 35, 3, 26, 33, 2, 5, 26, 26, 28, 6]]", "is_correct_args": "[[4, 33, 14, 32, 9, 32, 2, 35, 25, 10, 11, 6, 8, 26, 10, 25, 34, 21, 13, 15, 3, 15, 25, 3, 16, 3, 2, 25, 15, 23, 31, 35, 13, 14, 5, 7, 2, 18, 10, 8, 25, 30, 13, 35, 3, 26, 33, 2, 5, 26, 26, 28, 6], {\"26\": 4, \"34\": 4, \"7\": 5, \"28\": 11, \"35\": 8, \"18\": 13, \"25\": 19, \"14\": 10, \"23\": 7, \"6\": 1, \"10\": 5, \"21\": 8, \"13\": 13, \"2\": 1, \"3\": 1, \"30\": 5, \"4\": 4, \"31\": 18, \"11\": 3, \"9\": 1, \"8\": 3, \"5\": 3, \"32\": 5, \"15\": 15, \"33\": 18, \"16\": 4}, 355]", "A*_args": "[\"[4, 33, 14, 32, 9, 32, 2, 35, 25, 10, 11, 6, 8, 26, 10, 25, 34, 21, 13, 15, 3, 15, 25, 3, 16, 3, 2, 25, 15, 23, 31, 35, 13, 14, 5, 7, 2, 18, 10, 8, 25, 30, 13, 35, 3, 26, 33, 2, 5, 26, 26, 28, 6]\", \"{26: 4, 34: 4, 7: 5, 28: 11, 35: 8, 18: 13, 25: 19, 14: 10, 23: 7, 6: 1, 10: 5, 21: 8, 13: 13, 2: 1, 3: 1, 30: 5, 4: 4, 31: 18, 11: 3, 9: 1, 8: 3, 5: 3, 32: 5, 15: 15, 33: 18, 16: 4}\", \"355\"]"}
{"diff_sorted_id": "56", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Red', 'Green', 'Blue', 'Red'], ['Red', 'Green', 'Red', 'Blue', 'Blue'], ['Green', 'Blue', 'Red', 'Green', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[2, 0], [1, 2], [1, 0], [2, 1], [2, 1], [2, 1], [2, 0], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [0, 1], [0, 2], [0, 2], [1, 0], [1, 2], [1, 0], [1, 2], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1]]", "opt_solution_cost": "24", "opt_solution_compute_t": "51.796597480773926", "solution_depth": "24", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Green\", \"Red\", \"Green\", \"Blue\", \"Red\"], [\"Red\", \"Green\", \"Red\", \"Blue\", \"Blue\"], [\"Green\", \"Blue\", \"Red\", \"Green\", \"Blue\"]], 8]", "is_correct_args": "[[[\"Green\", \"Red\", \"Green\", \"Blue\", \"Red\"], [\"Red\", \"Green\", \"Red\", \"Blue\", \"Blue\"], [\"Green\", \"Blue\", \"Red\", \"Green\", \"Blue\"]], 8]", "A*_args": "[\"[['Green', 'Red', 'Green', 'Blue', 'Red'], ['Red', 'Green', 'Red', 'Blue', 'Blue'], ['Green', 'Blue', 'Red', 'Green', 'Blue']]\", \"8\"]"}
{"diff_sorted_id": "56", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 40 to 80 (40 included in the range but 80 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' '63' 'x']\n ['x' '53' '57' '73']\n ['x' 'x' '56' 'x']\n ['42' 'x' 'x' '68']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "13", "opt_solution": "[[0, 0, 45], [0, 1, 54], [0, 3, 74], [1, 0, 44], [2, 0, 43], [2, 1, 47], [2, 3, 69], [3, 1, 46], [3, 2, 48]]", "opt_solution_cost": "742", "opt_solution_compute_t": "13.670685529708862", "solution_depth": "9", "max_successor_states": "40", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '63', ''], ['', '53', '57', '73'], ['', '', '56', ''], ['42', '', '', '68']]\", 40, 80]", "is_correct_args": "[\"[['', '', '63', ''], ['', '53', '57', '73'], ['', '', '56', ''], ['42', '', '', '68']]\", 40, 80]", "A*_args": "[\"[['', '', '63', ''], ['', '53', '57', '73'], ['', '', '56', ''], ['42', '', '', '68']]\", \"40\", \"80\"]"}
{"diff_sorted_id": "56", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 28 to 59. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 134, 166, None for columns 1 to 2 respectively, and the sums of rows must be None, 185, 162, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 173. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['50' 'x' 'x' '42']\n ['x' 'x' '44' 'x']\n ['47' 'x' '49' 'x']\n ['53' 'x' 'x' '30']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 1, 28], [0, 2, 33], [1, 0, 41], [1, 1, 43], [1, 3, 57], [2, 1, 34], [2, 3, 32], [3, 1, 29], [3, 2, 40]]", "opt_solution_cost": "652", "opt_solution_compute_t": "10.336912631988525", "solution_depth": "9", "max_successor_states": "49", "num_vars_per_state": "9", "is_feasible_args": "[\"[['50', '', '', '42'], ['', '', '44', ''], ['47', '', '49', ''], ['53', '', '', '30']]\", 4, 28, 59]", "is_correct_args": "[\"[['50', '', '', '42'], ['', '', '44', ''], ['47', '', '49', ''], ['53', '', '', '30']]\", 28, 59, [1, 3], [1, 3], [134, 166], [185, 162], 173]", "A*_args": "[\"[['50', '', '', '42'], ['', '', '44', ''], ['47', '', '49', ''], ['53', '', '', '30']]\", \"28\", \"59\", \"[None, 134, 166, None]\", \"[None, 185, 162, None]\", \"173\"]"}
{"diff_sorted_id": "56", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 5, 1: 5, 2: 5, 3: 6, 4: 5, 5: 5, 6: 9, 7: 6}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Yellow', 'Red', 'Black', 'Yellow', 'Green'], [], [], ['Green', 'Red', 'Blue', 'Blue', 'Black'], ['Green', 'Blue', 'Yellow', 'Red', 'Yellow'], [], ['Blue', 'Green', 'Black', 'Red', 'Black']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[4, 0], [4, 2], [5, 0], [5, 3], [7, 3], [7, 0], [4, 3], [4, 3], [7, 4], [7, 2], [7, 4], [1, 7], [1, 2], [1, 4], [1, 7], [5, 7], [5, 2], [5, 7], [1, 0]]", "opt_solution_cost": "103", "opt_solution_compute_t": "0.03519558906555176", "solution_depth": "19", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[], [\"Yellow\", \"Red\", \"Black\", \"Yellow\", \"Green\"], [], [], [\"Green\", \"Red\", \"Blue\", \"Blue\", \"Black\"], [\"Green\", \"Blue\", \"Yellow\", \"Red\", \"Yellow\"], [], [\"Blue\", \"Green\", \"Black\", \"Red\", \"Black\"]], 5, {\"0\": 5, \"1\": 5, \"2\": 5, \"3\": 6, \"4\": 5, \"5\": 5, \"6\": 9, \"7\": 6}]", "is_correct_args": "[[[], [\"Yellow\", \"Red\", \"Black\", \"Yellow\", \"Green\"], [], [], [\"Green\", \"Red\", \"Blue\", \"Blue\", \"Black\"], [\"Green\", \"Blue\", \"Yellow\", \"Red\", \"Yellow\"], [], [\"Blue\", \"Green\", \"Black\", \"Red\", \"Black\"]], 5, {\"0\": 5, \"1\": 5, \"2\": 5, \"3\": 6, \"4\": 5, \"5\": 5, \"6\": 9, \"7\": 6}, 4]", "A*_args": "[\"[[], ['Yellow', 'Red', 'Black', 'Yellow', 'Green'], [], [], ['Green', 'Red', 'Blue', 'Blue', 'Black'], ['Green', 'Blue', 'Yellow', 'Red', 'Yellow'], [], ['Blue', 'Green', 'Black', 'Red', 'Black']]\", \"{0: 5, 1: 5, 2: 5, 3: 6, 4: 5, 5: 5, 6: 9, 7: 6}\", \"5\", \"4\"]"}
{"diff_sorted_id": "56", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (6, 9) to his destination workshop at index (3, 0), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 6, and district 3 covering rows 7 to 11. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[2 x x 14 x 19 6 x x 14 18 x]\n[x 10 1 15 x x x x 17 2 9 12]\n[13 14 x 2 x x 10 10 x x x x]\n[9 17 3 15 4 4 x 9 15 16 x 9]\n[10 7 3 8 x 7 x 16 3 7 x x]\n[16 20 16 19 18 3 x x 11 14 5 x]\n[14 13 8 14 12 19 6 3 19 10 11 x]\n[x 18 x x 4 19 6 14 15 17 7 x]\n[x 2 x x x x x 7 x 19 x x]\n[x 3 14 1 x 18 4 12 x 3 10 x]\n[2 x 16 13 x 17 x x 17 16 4 10]\n[x 4 10 x x x 7 x 19 7 x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "4", "opt_solution": "[[6, 9], [6, 8], [6, 7], [6, 6], [7, 6], [6, 6], [6, 5], [5, 5], [4, 5], [3, 5], [3, 4], [3, 3], [3, 2], [3, 1], [3, 0]]", "opt_solution_cost": "121", "opt_solution_compute_t": "0.02821516990661621", "solution_depth": "15", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"2\", \"x\", \"x\", \"14\", \"x\", \"19\", \"6\", \"x\", \"x\", \"14\", \"18\", \"x\"], [\"x\", \"10\", \"1\", \"15\", \"x\", \"x\", \"x\", \"x\", \"17\", \"2\", \"9\", \"12\"], [\"13\", \"14\", \"x\", \"2\", \"x\", \"x\", \"10\", \"10\", \"x\", \"x\", \"x\", \"x\"], [\"9\", \"17\", \"3\", \"15\", \"4\", \"4\", \"x\", \"9\", \"15\", \"16\", \"x\", \"9\"], [\"10\", \"7\", \"3\", \"8\", \"x\", \"7\", \"x\", \"16\", \"3\", \"7\", \"x\", \"x\"], [\"16\", \"20\", \"16\", \"19\", \"18\", \"3\", \"x\", \"x\", \"11\", \"14\", \"5\", \"x\"], [\"14\", \"13\", \"8\", \"14\", \"12\", \"19\", \"6\", \"3\", \"19\", \"10\", \"11\", \"x\"], [\"x\", \"18\", \"x\", \"x\", \"4\", \"19\", \"6\", \"14\", \"15\", \"17\", \"7\", \"x\"], [\"x\", \"2\", \"x\", \"x\", \"x\", \"x\", \"x\", \"7\", \"x\", \"19\", \"x\", \"x\"], [\"x\", \"3\", \"14\", \"1\", \"x\", \"18\", \"4\", \"12\", \"x\", \"3\", \"10\", \"x\"], [\"2\", \"x\", \"16\", \"13\", \"x\", \"17\", \"x\", \"x\", \"17\", \"16\", \"4\", \"10\"], [\"x\", \"4\", \"10\", \"x\", \"x\", \"x\", \"7\", \"x\", \"19\", \"7\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"2\", \"x\", \"x\", \"14\", \"x\", \"19\", \"6\", \"x\", \"x\", \"14\", \"18\", \"x\"], [\"x\", \"10\", \"1\", \"15\", \"x\", \"x\", \"x\", \"x\", \"17\", \"2\", \"9\", \"12\"], [\"13\", \"14\", \"x\", \"2\", \"x\", \"x\", \"10\", \"10\", \"x\", \"x\", \"x\", \"x\"], [\"9\", \"17\", \"3\", \"15\", \"4\", \"4\", \"x\", \"9\", \"15\", \"16\", \"x\", \"9\"], [\"10\", \"7\", \"3\", \"8\", \"x\", \"7\", \"x\", \"16\", \"3\", \"7\", \"x\", \"x\"], [\"16\", \"20\", \"16\", \"19\", \"18\", \"3\", \"x\", \"x\", \"11\", \"14\", \"5\", \"x\"], [\"14\", \"13\", \"8\", \"14\", \"12\", \"19\", \"6\", \"3\", \"19\", \"10\", \"11\", \"x\"], [\"x\", \"18\", \"x\", \"x\", \"4\", \"19\", \"6\", \"14\", \"15\", \"17\", \"7\", \"x\"], [\"x\", \"2\", \"x\", \"x\", \"x\", \"x\", \"x\", \"7\", \"x\", \"19\", \"x\", \"x\"], [\"x\", \"3\", \"14\", \"1\", \"x\", \"18\", \"4\", \"12\", \"x\", \"3\", \"10\", \"x\"], [\"2\", \"x\", \"16\", \"13\", \"x\", \"17\", \"x\", \"x\", \"17\", \"16\", \"4\", \"10\"], [\"x\", \"4\", \"10\", \"x\", \"x\", \"x\", \"7\", \"x\", \"19\", \"7\", \"x\", \"x\"]], [6, 9], [3, 0], 3, 6]", "A*_args": "[\"[['2', 'x', 'x', '14', 'x', '19', '6', 'x', 'x', '14', '18', 'x'], ['x', '10', '1', '15', 'x', 'x', 'x', 'x', '17', '2', '9', '12'], ['13', '14', 'x', '2', 'x', 'x', '10', '10', 'x', 'x', 'x', 'x'], ['9', '17', '3', '15', '4', '4', 'x', '9', '15', '16', 'x', '9'], ['10', '7', '3', '8', 'x', '7', 'x', '16', '3', '7', 'x', 'x'], ['16', '20', '16', '19', '18', '3', 'x', 'x', '11', '14', '5', 'x'], ['14', '13', '8', '14', '12', '19', '6', '3', '19', '10', '11', 'x'], ['x', '18', 'x', 'x', '4', '19', '6', '14', '15', '17', '7', 'x'], ['x', '2', 'x', 'x', 'x', 'x', 'x', '7', 'x', '19', 'x', 'x'], ['x', '3', '14', '1', 'x', '18', '4', '12', 'x', '3', '10', 'x'], ['2', 'x', '16', '13', 'x', '17', 'x', 'x', '17', '16', '4', '10'], ['x', '4', '10', 'x', 'x', 'x', '7', 'x', '19', '7', 'x', 'x']]\", \"(6, 9)\", \"(3, 0)\", \"3\", \"6\"]"}
{"diff_sorted_id": "56", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 12x12. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (11, 7) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (2, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 1 1 0 1 1 1 1 1 0 0\n1 0 1 1 0 0 0 0 1 1 1 1\n0 0 1 1 1 0 0 1 0 1 1 0\n1 0 0 1 0 1 1 1 0 0 0 0\n0 0 0 1 0 0 1 0 0 1 0 0\n0 1 1 0 1 0 0 1 0 1 1 0\n0 1 1 1 1 0 0 1 1 1 0 0\n0 0 0 0 0 1 0 1 1 0 1 0\n1 1 1 0 1 1 1 1 1 0 0 1\n0 1 1 0 0 1 0 1 0 1 1 0\n0 1 0 0 1 0 0 0 1 0 0 1\n1 1 1 0 0 0 0 0 0 1 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[[11, 7], [10, 6], [10, 5], [9, 4], [8, 3], [7, 2], [7, 1], [7, 0], [6, 0], [5, 0], [4, 0], [4, 1], [3, 1], [2, 1], [2, 0]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.029215574264526367", "solution_depth": "15", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0], [1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0], [0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0], [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1], [0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0]]\", 4]", "is_correct_args": "[\"[[0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0], [1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0], [0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0], [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1], [0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0]]\", [11, 7], [2, 0], 4]", "A*_args": "[\"[[0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0], [1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0], [0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0], [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1], [0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0]]\", \"(11, 7)\", \"(2, 0)\", \"4\"]"}
{"diff_sorted_id": "56", "problem_statement": "Given 5 labeled water jugs with capacities 12, 88, 148, 87, 143, 131 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 260, 295, 331, 394 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 87, 4], [\"+\", 148, 4], [\"+\", 148, 4], [\"-\", 88, 4], [\"+\", 87, 4], [\"+\", 12, 4], [\"+\", 88, 3], [\"+\", 88, 3], [\"+\", 12, 3], [\"+\", 143, 3], [\"+\", 131, 2], [\"-\", 12, 2], [\"+\", 88, 2], [\"+\", 88, 2], [\"+\", 12, 1], [\"+\", 88, 1], [\"+\", 148, 1], [\"+\", 12, 1]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.03827953338623047", "solution_depth": "18", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[12, 88, 148, 87, 143, 131], [260, 295, 331, 394]]", "is_correct_args": "[[12, 88, 148, 87, 143, 131], [260, 295, 331, 394]]", "A*_args": "[\"[12, 88, 148, 87, 143, 131]\", \"[260, 295, 331, 394]\"]"}
{"diff_sorted_id": "57", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[71, 42, 22, 90], [79, 78, '_', 68], [25, 58, 28, 12]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "7", "opt_solution": "[28, 12, 68, 28, 22, 90, 28, 68, 12, 22, 90, 42, 78, 90, 68, 28, 42, 78, 71, 79, 90, 68, 78, 71, 79, 90, 68, 58, 22, 12, 28, 42, 71, 78, 42, 28]", "opt_solution_cost": "36", "opt_solution_compute_t": "6.940868616104126", "solution_depth": "36", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[71, 42, 22, 90], [79, 78, \"_\", 68], [25, 58, 28, 12]]]", "is_correct_args": "[[[71, 42, 22, 90], [79, 78, \"_\", 68], [25, 58, 28, 12]]]", "A*_args": "[\"[[71, 42, 22, 90], [79, 78, '_', 68], [25, 58, 28, 12]]\"]"}
{"diff_sorted_id": "57", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: toe, kuba, meng, peso, youp   The initial board: [['u', 't', '_', 'e'], ['k', 'a', 'b', 'm'], ['n', 'e', 'o', 'g'], ['p', 'u', 's', 'o'], ['y', 'o', 'e', 'p']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.5264327526092529", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"u\", \"t\", \"_\", \"e\"], [\"k\", \"a\", \"b\", \"m\"], [\"n\", \"e\", \"o\", \"g\"], [\"p\", \"u\", \"s\", \"o\"], [\"y\", \"o\", \"e\", \"p\"]]]", "is_correct_args": "[[[\"u\", \"t\", \"_\", \"e\"], [\"k\", \"a\", \"b\", \"m\"], [\"n\", \"e\", \"o\", \"g\"], [\"p\", \"u\", \"s\", \"o\"], [\"y\", \"o\", \"e\", \"p\"]], [\"toe\", \"kuba\", \"meng\", \"peso\", \"youp\"]]", "A*_args": "[\"[['u', 't', '_', 'e'], ['k', 'a', 'b', 'm'], ['n', 'e', 'o', 'g'], ['p', 'u', 's', 'o'], ['y', 'o', 'e', 'p']]\", \"['toe', 'kuba', 'meng', 'peso', 'youp']\"]"}
{"diff_sorted_id": "57", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'T'. Our task is to visit city V and city I excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from I and V, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  V C I Y W Q X K Z T J U F \nV 0 1 0 1 1 0 0 0 0 0 0 0 0 \nC 0 0 0 1 0 0 0 0 0 0 1 0 0 \nI 1 1 0 1 0 1 0 0 0 0 0 0 0 \nY 0 0 0 0 0 0 0 0 1 0 1 0 1 \nW 0 1 0 0 0 1 1 0 0 0 0 0 0 \nQ 0 1 0 0 0 0 0 1 0 0 0 0 1 \nX 1 0 1 0 0 0 0 0 0 0 0 1 1 \nK 1 0 0 0 1 0 1 0 0 0 0 0 0 \nZ 1 1 0 1 0 1 1 1 0 0 0 0 0 \nT 0 1 0 0 1 0 1 1 0 0 0 0 1 \nJ 0 1 1 0 0 1 1 1 0 1 0 0 0 \nU 1 0 1 0 0 0 0 0 1 1 1 0 0 \nF 0 0 0 0 0 1 0 0 0 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[\"T\", \"X\", \"I\", \"V\", \"C\", \"J\", \"I\", \"V\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.030387163162231445", "solution_depth": "8", "max_successor_states": "13", "num_vars_per_state": "16", "is_feasible_args": "[[[0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1], [0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [\"V\", \"C\", \"I\", \"Y\", \"W\", \"Q\", \"X\", \"K\", \"Z\", \"T\", \"J\", \"U\", \"F\"], \"V\", \"I\"]", "is_correct_args": "[[[0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1], [0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [\"V\", \"C\", \"I\", \"Y\", \"W\", \"Q\", \"X\", \"K\", \"Z\", \"T\", \"J\", \"U\", \"F\"], \"T\", \"V\", \"I\"]", "A*_args": "[\"[[0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1], [0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]]\", \"['V', 'C', 'I', 'Y', 'W', 'Q', 'X', 'K', 'Z', 'T', 'J', 'U', 'F']\", \"['T']\", \"['V', 'I']\"]"}
{"diff_sorted_id": "57", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [25, 22, 28, 23, 5, 14, 28, 14, 20, 6, 22, 1, 25, 18, 30, 10, 19, 12, 17, 17, 6, 28, 21, 28, 21, 2, 20, 2, 19, 14, 31, 31, 14, 7, 20, 13, 7, 18, 22, 15, 6, 6, 21, 9, 18, 11, 20, 26, 15], such that the sum of the chosen coins adds up to 322. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {11: 1, 14: 4, 7: 2, 25: 4, 12: 5, 20: 19, 13: 6, 15: 11, 30: 18, 1: 1, 2: 2, 31: 6, 10: 2, 23: 1, 6: 2, 21: 18, 18: 8, 28: 15, 17: 5, 26: 6, 22: 6, 9: 1, 19: 2, 5: 4}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "29", "opt_solution": "[7, 9, 11, 19, 19, 25, 25, 31, 22, 31, 26, 22, 23, 22, 14, 10, 6]", "opt_solution_cost": "61", "opt_solution_compute_t": "0.05817842483520508", "solution_depth": "17", "max_successor_states": "49", "num_vars_per_state": "49", "is_feasible_args": "[[25, 22, 28, 23, 5, 14, 28, 14, 20, 6, 22, 1, 25, 18, 30, 10, 19, 12, 17, 17, 6, 28, 21, 28, 21, 2, 20, 2, 19, 14, 31, 31, 14, 7, 20, 13, 7, 18, 22, 15, 6, 6, 21, 9, 18, 11, 20, 26, 15]]", "is_correct_args": "[[25, 22, 28, 23, 5, 14, 28, 14, 20, 6, 22, 1, 25, 18, 30, 10, 19, 12, 17, 17, 6, 28, 21, 28, 21, 2, 20, 2, 19, 14, 31, 31, 14, 7, 20, 13, 7, 18, 22, 15, 6, 6, 21, 9, 18, 11, 20, 26, 15], {\"11\": 1, \"14\": 4, \"7\": 2, \"25\": 4, \"12\": 5, \"20\": 19, \"13\": 6, \"15\": 11, \"30\": 18, \"1\": 1, \"2\": 2, \"31\": 6, \"10\": 2, \"23\": 1, \"6\": 2, \"21\": 18, \"18\": 8, \"28\": 15, \"17\": 5, \"26\": 6, \"22\": 6, \"9\": 1, \"19\": 2, \"5\": 4}, 322]", "A*_args": "[\"[25, 22, 28, 23, 5, 14, 28, 14, 20, 6, 22, 1, 25, 18, 30, 10, 19, 12, 17, 17, 6, 28, 21, 28, 21, 2, 20, 2, 19, 14, 31, 31, 14, 7, 20, 13, 7, 18, 22, 15, 6, 6, 21, 9, 18, 11, 20, 26, 15]\", \"{11: 1, 14: 4, 7: 2, 25: 4, 12: 5, 20: 19, 13: 6, 15: 11, 30: 18, 1: 1, 2: 2, 31: 6, 10: 2, 23: 1, 6: 2, 21: 18, 18: 8, 28: 15, 17: 5, 26: 6, 22: 6, 9: 1, 19: 2, 5: 4}\", \"322\"]"}
{"diff_sorted_id": "57", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Blue', 'Green', 'Green'], ['Green', 'Red', 'Blue', 'Blue', 'Blue'], ['Red', 'Red', 'Blue', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[0, 2], [0, 1], [0, 2], [1, 0], [1, 0], [1, 0], [2, 1], [2, 0], [2, 0], [2, 0], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0]]", "opt_solution_cost": "17", "opt_solution_compute_t": "1.3616485595703125", "solution_depth": "17", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Red\", \"Green\", \"Blue\", \"Green\", \"Green\"], [\"Green\", \"Red\", \"Blue\", \"Blue\", \"Blue\"], [\"Red\", \"Red\", \"Blue\", \"Green\", \"Red\"]], 8]", "is_correct_args": "[[[\"Red\", \"Green\", \"Blue\", \"Green\", \"Green\"], [\"Green\", \"Red\", \"Blue\", \"Blue\", \"Blue\"], [\"Red\", \"Red\", \"Blue\", \"Green\", \"Red\"]], 8]", "A*_args": "[\"[['Red', 'Green', 'Blue', 'Green', 'Green'], ['Green', 'Red', 'Blue', 'Blue', 'Blue'], ['Red', 'Red', 'Blue', 'Green', 'Red']]\", \"8\"]"}
{"diff_sorted_id": "57", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 7 to 47 (7 included in the range but 47 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['11' '14' 'x' 'x']\n ['12' 'x' 'x' '38']\n ['x' 'x' 'x' '36']\n ['25' 'x' 'x' '34']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "13", "opt_solution": "[[0, 2, 15], [0, 3, 39], [1, 1, 16], [1, 2, 17], [2, 0, 13], [2, 1, 18], [2, 2, 19], [3, 1, 26], [3, 2, 27]]", "opt_solution_cost": "306", "opt_solution_compute_t": "88.0573205947876", "solution_depth": "9", "max_successor_states": "40", "num_vars_per_state": "16", "is_feasible_args": "[\"[['11', '14', '', ''], ['12', '', '', '38'], ['', '', '', '36'], ['25', '', '', '34']]\", 7, 47]", "is_correct_args": "[\"[['11', '14', '', ''], ['12', '', '', '38'], ['', '', '', '36'], ['25', '', '', '34']]\", 7, 47]", "A*_args": "[\"[['11', '14', '', ''], ['12', '', '', '38'], ['', '', '', '36'], ['25', '', '', '34']]\", \"7\", \"47\"]"}
{"diff_sorted_id": "57", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 28 to 59. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 170, 162, None for columns 1 to 2 respectively, and the sums of rows must be None, 191, 157, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 171. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['42' 'x' '41' 'x']\n ['x' '48' 'x' 'x']\n ['x' '39' '30' '52']\n ['x' 'x' '40' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 1, 29], [0, 3, 31], [1, 0, 34], [1, 2, 51], [1, 3, 58], [2, 0, 36], [3, 0, 50], [3, 1, 54], [3, 3, 28]]", "opt_solution_cost": "663", "opt_solution_compute_t": "3.644191026687622", "solution_depth": "9", "max_successor_states": "26", "num_vars_per_state": "16", "is_feasible_args": "[\"[['42', '', '41', ''], ['', '48', '', ''], ['', '39', '30', '52'], ['', '', '40', '']]\", 4, 28, 59]", "is_correct_args": "[\"[['42', '', '41', ''], ['', '48', '', ''], ['', '39', '30', '52'], ['', '', '40', '']]\", 28, 59, [1, 3], [1, 3], [170, 162], [191, 157], 171]", "A*_args": "[\"[['42', '', '41', ''], ['', '48', '', ''], ['', '39', '30', '52'], ['', '', '40', '']]\", \"28\", \"59\", \"[None, 170, 162, None]\", \"[None, 191, 157, None]\", \"171\"]"}
{"diff_sorted_id": "57", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 2, 1: 3, 2: 9, 3: 8, 4: 3, 5: 7, 6: 9, 7: 5}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], ['Green', 'Red', 'Black', 'Blue', 'Blue'], ['Yellow', 'Blue', 'Blue', 'Green', 'Black'], ['Yellow', 'Yellow', 'Yellow', 'Red', 'Black'], [], [], ['Red', 'Green', 'Green', 'Red', 'Black']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[2, 0], [2, 1], [7, 1], [7, 0], [7, 0], [7, 1], [2, 7], [3, 5], [4, 5], [4, 5], [4, 5], [4, 1], [4, 7], [3, 4], [3, 4], [3, 0], [3, 7], [2, 4], [2, 4]]", "opt_solution_cost": "75", "opt_solution_compute_t": "0.13939952850341797", "solution_depth": "19", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[], [], [\"Green\", \"Red\", \"Black\", \"Blue\", \"Blue\"], [\"Yellow\", \"Blue\", \"Blue\", \"Green\", \"Black\"], [\"Yellow\", \"Yellow\", \"Yellow\", \"Red\", \"Black\"], [], [], [\"Red\", \"Green\", \"Green\", \"Red\", \"Black\"]], 5, {\"0\": 2, \"1\": 3, \"2\": 9, \"3\": 8, \"4\": 3, \"5\": 7, \"6\": 9, \"7\": 5}]", "is_correct_args": "[[[], [], [\"Green\", \"Red\", \"Black\", \"Blue\", \"Blue\"], [\"Yellow\", \"Blue\", \"Blue\", \"Green\", \"Black\"], [\"Yellow\", \"Yellow\", \"Yellow\", \"Red\", \"Black\"], [], [], [\"Red\", \"Green\", \"Green\", \"Red\", \"Black\"]], 5, {\"0\": 2, \"1\": 3, \"2\": 9, \"3\": 8, \"4\": 3, \"5\": 7, \"6\": 9, \"7\": 5}, 4]", "A*_args": "[\"[[], [], ['Green', 'Red', 'Black', 'Blue', 'Blue'], ['Yellow', 'Blue', 'Blue', 'Green', 'Black'], ['Yellow', 'Yellow', 'Yellow', 'Red', 'Black'], [], [], ['Red', 'Green', 'Green', 'Red', 'Black']]\", \"{0: 2, 1: 3, 2: 9, 3: 8, 4: 3, 5: 7, 6: 9, 7: 5}\", \"5\", \"4\"]"}
{"diff_sorted_id": "57", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (7, 0) to his destination workshop at index (3, 8), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 6, and district 3 covering rows 7 to 11. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[17 9 11 5 19 4 18 x 5 8 x x]\n[6 13 x 9 2 20 11 20 7 x x 3]\n[4 17 x 18 2 10 x 16 x 18 x x]\n[12 10 9 14 x x 12 6 1 2 x x]\n[5 x x 3 x 4 9 14 8 x 10 12]\n[1 x 6 3 18 18 17 17 10 x x 10]\n[13 x x x x x 14 x 1 19 x 7]\n[11 x x 5 9 x 18 19 13 13 x 10]\n[x x 11 x 17 x x x 14 17 x 13]\n[19 x x x x 19 12 7 3 14 x 9]\n[x 12 7 15 1 x 16 11 9 17 x x]\n[x x x 10 x 1 7 x x x 6 12]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "4", "opt_solution": "[[7, 0], [6, 0], [5, 0], [4, 0], [3, 0], [3, 1], [3, 2], [3, 3], [4, 3], [5, 3], [5, 4], [5, 5], [4, 5], [4, 6], [3, 6], [3, 7], [3, 8]]", "opt_solution_cost": "138", "opt_solution_compute_t": "0.02782440185546875", "solution_depth": "17", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"17\", \"9\", \"11\", \"5\", \"19\", \"4\", \"18\", \"x\", \"5\", \"8\", \"x\", \"x\"], [\"6\", \"13\", \"x\", \"9\", \"2\", \"20\", \"11\", \"20\", \"7\", \"x\", \"x\", \"3\"], [\"4\", \"17\", \"x\", \"18\", \"2\", \"10\", \"x\", \"16\", \"x\", \"18\", \"x\", \"x\"], [\"12\", \"10\", \"9\", \"14\", \"x\", \"x\", \"12\", \"6\", \"1\", \"2\", \"x\", \"x\"], [\"5\", \"x\", \"x\", \"3\", \"x\", \"4\", \"9\", \"14\", \"8\", \"x\", \"10\", \"12\"], [\"1\", \"x\", \"6\", \"3\", \"18\", \"18\", \"17\", \"17\", \"10\", \"x\", \"x\", \"10\"], [\"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"14\", \"x\", \"1\", \"19\", \"x\", \"7\"], [\"11\", \"x\", \"x\", \"5\", \"9\", \"x\", \"18\", \"19\", \"13\", \"13\", \"x\", \"10\"], [\"x\", \"x\", \"11\", \"x\", \"17\", \"x\", \"x\", \"x\", \"14\", \"17\", \"x\", \"13\"], [\"19\", \"x\", \"x\", \"x\", \"x\", \"19\", \"12\", \"7\", \"3\", \"14\", \"x\", \"9\"], [\"x\", \"12\", \"7\", \"15\", \"1\", \"x\", \"16\", \"11\", \"9\", \"17\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"10\", \"x\", \"1\", \"7\", \"x\", \"x\", \"x\", \"6\", \"12\"]]]", "is_correct_args": "[[[\"17\", \"9\", \"11\", \"5\", \"19\", \"4\", \"18\", \"x\", \"5\", \"8\", \"x\", \"x\"], [\"6\", \"13\", \"x\", \"9\", \"2\", \"20\", \"11\", \"20\", \"7\", \"x\", \"x\", \"3\"], [\"4\", \"17\", \"x\", \"18\", \"2\", \"10\", \"x\", \"16\", \"x\", \"18\", \"x\", \"x\"], [\"12\", \"10\", \"9\", \"14\", \"x\", \"x\", \"12\", \"6\", \"1\", \"2\", \"x\", \"x\"], [\"5\", \"x\", \"x\", \"3\", \"x\", \"4\", \"9\", \"14\", \"8\", \"x\", \"10\", \"12\"], [\"1\", \"x\", \"6\", \"3\", \"18\", \"18\", \"17\", \"17\", \"10\", \"x\", \"x\", \"10\"], [\"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"14\", \"x\", \"1\", \"19\", \"x\", \"7\"], [\"11\", \"x\", \"x\", \"5\", \"9\", \"x\", \"18\", \"19\", \"13\", \"13\", \"x\", \"10\"], [\"x\", \"x\", \"11\", \"x\", \"17\", \"x\", \"x\", \"x\", \"14\", \"17\", \"x\", \"13\"], [\"19\", \"x\", \"x\", \"x\", \"x\", \"19\", \"12\", \"7\", \"3\", \"14\", \"x\", \"9\"], [\"x\", \"12\", \"7\", \"15\", \"1\", \"x\", \"16\", \"11\", \"9\", \"17\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"10\", \"x\", \"1\", \"7\", \"x\", \"x\", \"x\", \"6\", \"12\"]], [7, 0], [3, 8], 3, 6]", "A*_args": "[\"[['17', '9', '11', '5', '19', '4', '18', 'x', '5', '8', 'x', 'x'], ['6', '13', 'x', '9', '2', '20', '11', '20', '7', 'x', 'x', '3'], ['4', '17', 'x', '18', '2', '10', 'x', '16', 'x', '18', 'x', 'x'], ['12', '10', '9', '14', 'x', 'x', '12', '6', '1', '2', 'x', 'x'], ['5', 'x', 'x', '3', 'x', '4', '9', '14', '8', 'x', '10', '12'], ['1', 'x', '6', '3', '18', '18', '17', '17', '10', 'x', 'x', '10'], ['13', 'x', 'x', 'x', 'x', 'x', '14', 'x', '1', '19', 'x', '7'], ['11', 'x', 'x', '5', '9', 'x', '18', '19', '13', '13', 'x', '10'], ['x', 'x', '11', 'x', '17', 'x', 'x', 'x', '14', '17', 'x', '13'], ['19', 'x', 'x', 'x', 'x', '19', '12', '7', '3', '14', 'x', '9'], ['x', '12', '7', '15', '1', 'x', '16', '11', '9', '17', 'x', 'x'], ['x', 'x', 'x', '10', 'x', '1', '7', 'x', 'x', 'x', '6', '12']]\", \"(7, 0)\", \"(3, 8)\", \"3\", \"6\"]"}
{"diff_sorted_id": "57", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 12x12. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (11, 2) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (3, 10). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 0 0 0 1 0 1 1 0 0 1\n1 1 1 1 0 1 1 1 0 1 1 1\n1 0 0 0 0 1 0 0 0 1 0 1\n1 0 0 1 1 0 1 0 1 1 0 1\n1 1 1 1 1 1 0 0 1 1 0 0\n0 0 1 1 0 1 0 0 0 1 0 0\n0 0 0 0 1 0 1 0 0 0 1 0\n0 0 0 0 1 0 1 0 0 0 0 0\n1 0 1 1 0 0 1 1 0 1 0 0\n0 1 0 1 0 0 1 0 0 1 0 0\n1 1 0 0 0 1 0 0 1 1 1 1\n1 1 0 1 1 1 0 1 1 0 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[[11, 2], [10, 2], [10, 3], [9, 4], [8, 4], [8, 5], [7, 5], [6, 5], [5, 6], [5, 7], [5, 8], [6, 9], [5, 10], [4, 10], [3, 10]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.03331708908081055", "solution_depth": "15", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1], [1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1], [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1], [1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0]]\", 4]", "is_correct_args": "[\"[[1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1], [1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1], [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1], [1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0]]\", [11, 2], [3, 10], 4]", "A*_args": "[\"[[1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1], [1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1], [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1], [1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0]]\", \"(11, 2)\", \"(3, 10)\", \"4\"]"}
{"diff_sorted_id": "57", "problem_statement": "Given 5 labeled water jugs with capacities 15, 20, 141, 104, 67, 14 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 230, 267, 278, 318 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 67, 4], [\"+\", 104, 4], [\"+\", 141, 4], [\"-\", 14, 4], [\"+\", 20, 4], [\"+\", 67, 3], [\"+\", 67, 3], [\"+\", 104, 3], [\"+\", 20, 3], [\"+\", 20, 3], [\"+\", 141, 2], [\"-\", 15, 2], [\"+\", 141, 2], [\"+\", 104, 1], [\"-\", 15, 1], [\"+\", 141, 1]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.03609800338745117", "solution_depth": "16", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[15, 20, 141, 104, 67, 14], [230, 267, 278, 318]]", "is_correct_args": "[[15, 20, 141, 104, 67, 14], [230, 267, 278, 318]]", "A*_args": "[\"[15, 20, 141, 104, 67, 14]\", \"[230, 267, 278, 318]\"]"}
{"diff_sorted_id": "58", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[94, 91, 92, 46], [6, 86, '_', 10], [12, 58, 73, 75]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "7", "opt_solution": "[86, 91, 92, 86, 91, 58, 73, 75, 10, 46, 86, 91, 58, 6, 12, 73, 75, 10, 46, 58, 6, 75, 73, 12, 75, 73, 10, 6, 58, 46]", "opt_solution_cost": "30", "opt_solution_compute_t": "1.039477825164795", "solution_depth": "30", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[94, 91, 92, 46], [6, 86, \"_\", 10], [12, 58, 73, 75]]]", "is_correct_args": "[[[94, 91, 92, 46], [6, 86, \"_\", 10], [12, 58, 73, 75]]]", "A*_args": "[\"[[94, 91, 92, 46], [6, 86, '_', 10], [12, 58, 73, 75]]\"]"}
{"diff_sorted_id": "58", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: eld, vint, edea, poco, pirl   The initial board: [['i', 'e', 'e', 'd'], ['v', 't', 'n', 'l'], ['o', 'd', '_', 'a'], ['p', 'r', 'c', 'e'], ['p', 'i', 'o', 'l']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.1858220100402832", "solution_depth": "10", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"i\", \"e\", \"e\", \"d\"], [\"v\", \"t\", \"n\", \"l\"], [\"o\", \"d\", \"_\", \"a\"], [\"p\", \"r\", \"c\", \"e\"], [\"p\", \"i\", \"o\", \"l\"]]]", "is_correct_args": "[[[\"i\", \"e\", \"e\", \"d\"], [\"v\", \"t\", \"n\", \"l\"], [\"o\", \"d\", \"_\", \"a\"], [\"p\", \"r\", \"c\", \"e\"], [\"p\", \"i\", \"o\", \"l\"]], [\"eld\", \"vint\", \"edea\", \"poco\", \"pirl\"]]", "A*_args": "[\"[['i', 'e', 'e', 'd'], ['v', 't', 'n', 'l'], ['o', 'd', '_', 'a'], ['p', 'r', 'c', 'e'], ['p', 'i', 'o', 'l']]\", \"['eld', 'vint', 'edea', 'poco', 'pirl']\"]"}
{"diff_sorted_id": "58", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'S'. Our task is to visit city B and city V excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from V and B, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  B K S X T P Q M R G J V E \nB 0 1 0 0 0 1 0 1 1 0 1 0 0 \nK 0 0 0 1 0 1 0 0 0 0 0 0 0 \nS 0 1 0 0 0 1 0 0 0 0 0 0 0 \nX 0 1 0 0 0 0 0 0 0 0 1 1 0 \nT 0 1 1 0 0 0 1 0 0 0 1 1 0 \nP 0 0 0 0 1 0 0 0 0 1 0 0 0 \nQ 1 0 0 0 0 1 0 0 0 1 1 0 0 \nM 0 1 1 0 1 0 0 0 0 0 0 0 0 \nR 1 1 0 1 0 0 1 0 0 1 0 0 0 \nG 0 0 1 0 0 0 1 0 0 0 1 0 0 \nJ 0 1 0 0 1 0 0 1 0 0 0 0 0 \nV 1 0 0 0 0 0 0 0 1 0 0 0 1 \nE 1 1 0 0 1 1 1 0 1 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[\"S\", \"K\", \"X\", \"V\", \"B\", \"J\", \"T\", \"V\", \"B\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.03627133369445801", "solution_depth": "9", "max_successor_states": "13", "num_vars_per_state": "16", "is_feasible_args": "[[[0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0]], [\"B\", \"K\", \"S\", \"X\", \"T\", \"P\", \"Q\", \"M\", \"R\", \"G\", \"J\", \"V\", \"E\"], \"B\", \"V\"]", "is_correct_args": "[[[0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0]], [\"B\", \"K\", \"S\", \"X\", \"T\", \"P\", \"Q\", \"M\", \"R\", \"G\", \"J\", \"V\", \"E\"], \"S\", \"B\", \"V\"]", "A*_args": "[\"[[0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0]]\", \"['B', 'K', 'S', 'X', 'T', 'P', 'Q', 'M', 'R', 'G', 'J', 'V', 'E']\", \"['S']\", \"['B', 'V']\"]"}
{"diff_sorted_id": "58", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [10, 16, 2, 18, 10, 16, 17, 32, 18, 33, 23, 20, 21, 25, 32, 24, 10, 27, 13, 27, 30, 13, 19, 20, 4, 5, 15, 8, 8, 34, 21, 14, 3, 20, 10, 18, 3, 14, 28, 6, 4, 8, 15, 4, 30, 30, 12, 20, 14, 10], such that the sum of the chosen coins adds up to 357. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {30: 12, 20: 19, 16: 7, 24: 14, 12: 3, 13: 4, 8: 2, 2: 1, 21: 2, 23: 12, 34: 13, 27: 16, 3: 3, 28: 3, 14: 13, 6: 4, 33: 17, 10: 8, 5: 3, 15: 12, 4: 2, 18: 2, 19: 5, 17: 1, 32: 2, 25: 12}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "30", "opt_solution": "[32, 28, 8, 17, 21, 18, 21, 18, 12, 8, 19, 18, 8, 4, 13, 4, 13, 33, 32, 30]", "opt_solution_cost": "73", "opt_solution_compute_t": "0.05944538116455078", "solution_depth": "20", "max_successor_states": "50", "num_vars_per_state": "50", "is_feasible_args": "[[10, 16, 2, 18, 10, 16, 17, 32, 18, 33, 23, 20, 21, 25, 32, 24, 10, 27, 13, 27, 30, 13, 19, 20, 4, 5, 15, 8, 8, 34, 21, 14, 3, 20, 10, 18, 3, 14, 28, 6, 4, 8, 15, 4, 30, 30, 12, 20, 14, 10]]", "is_correct_args": "[[10, 16, 2, 18, 10, 16, 17, 32, 18, 33, 23, 20, 21, 25, 32, 24, 10, 27, 13, 27, 30, 13, 19, 20, 4, 5, 15, 8, 8, 34, 21, 14, 3, 20, 10, 18, 3, 14, 28, 6, 4, 8, 15, 4, 30, 30, 12, 20, 14, 10], {\"30\": 12, \"20\": 19, \"16\": 7, \"24\": 14, \"12\": 3, \"13\": 4, \"8\": 2, \"2\": 1, \"21\": 2, \"23\": 12, \"34\": 13, \"27\": 16, \"3\": 3, \"28\": 3, \"14\": 13, \"6\": 4, \"33\": 17, \"10\": 8, \"5\": 3, \"15\": 12, \"4\": 2, \"18\": 2, \"19\": 5, \"17\": 1, \"32\": 2, \"25\": 12}, 357]", "A*_args": "[\"[10, 16, 2, 18, 10, 16, 17, 32, 18, 33, 23, 20, 21, 25, 32, 24, 10, 27, 13, 27, 30, 13, 19, 20, 4, 5, 15, 8, 8, 34, 21, 14, 3, 20, 10, 18, 3, 14, 28, 6, 4, 8, 15, 4, 30, 30, 12, 20, 14, 10]\", \"{30: 12, 20: 19, 16: 7, 24: 14, 12: 3, 13: 4, 8: 2, 2: 1, 21: 2, 23: 12, 34: 13, 27: 16, 3: 3, 28: 3, 14: 13, 6: 4, 33: 17, 10: 8, 5: 3, 15: 12, 4: 2, 18: 2, 19: 5, 17: 1, 32: 2, 25: 12}\", \"357\"]"}
{"diff_sorted_id": "58", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Blue', 'Green', 'Blue', 'Blue'], ['Green', 'Red', 'Green', 'Red', 'Blue'], ['Blue', 'Green', 'Red', 'Red', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[0, 1], [0, 2], [0, 1], [2, 0], [2, 0], [2, 1], [2, 0], [2, 0], [1, 2], [1, 2], [1, 0], [1, 2], [1, 0], [1, 2], [1, 2], [1, 2], [0, 1], [0, 1], [0, 1], [0, 1], [2, 0], [2, 1]]", "opt_solution_cost": "22", "opt_solution_compute_t": "19.447868585586548", "solution_depth": "22", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Red\", \"Blue\", \"Green\", \"Blue\", \"Blue\"], [\"Green\", \"Red\", \"Green\", \"Red\", \"Blue\"], [\"Blue\", \"Green\", \"Red\", \"Red\", \"Green\"]], 8]", "is_correct_args": "[[[\"Red\", \"Blue\", \"Green\", \"Blue\", \"Blue\"], [\"Green\", \"Red\", \"Green\", \"Red\", \"Blue\"], [\"Blue\", \"Green\", \"Red\", \"Red\", \"Green\"]], 8]", "A*_args": "[\"[['Red', 'Blue', 'Green', 'Blue', 'Blue'], ['Green', 'Red', 'Green', 'Red', 'Blue'], ['Blue', 'Green', 'Red', 'Red', 'Green']]\", \"8\"]"}
{"diff_sorted_id": "58", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 42 to 82 (42 included in the range but 82 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['79' 'x' 'x' 'x']\n ['x' 'x' '65' 'x']\n ['56' '60' 'x' 'x']\n ['48' '54' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "14", "opt_solution": "[[0, 0, 23], [0, 1, 31], [0, 3, 39], [1, 0, 21], [1, 2, 40], [1, 3, 41], [2, 1, 24], [2, 3, 45], [3, 0, 19], [3, 2, 46]]", "opt_solution_cost": "467", "opt_solution_compute_t": "127.71580004692078", "solution_depth": "10", "max_successor_states": "40", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '38', ''], ['', '30', '', ''], ['20', '', '44', ''], ['', '22', '', '57']]\", 19, 59]", "is_correct_args": "[\"[['', '', '38', ''], ['', '30', '', ''], ['20', '', '44', ''], ['', '22', '', '57']]\", 19, 59]", "A*_args": "[\"[['', '', '38', ''], ['', '30', '', ''], ['20', '', '44', ''], ['', '22', '', '57']]\", \"19\", \"59\"]"}
{"diff_sorted_id": "58", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 22 to 53. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 137, 162, None for columns 1 to 2 respectively, and the sums of rows must be None, 141, 135, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 151. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x' '40']\n ['34' '37' 'x' 'x']\n ['x' '43' 'x' '22']\n ['x' 'x' 'x' '47']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 23], [0, 1, 27], [0, 2, 31], [1, 2, 44], [1, 3, 26], [2, 0, 25], [2, 2, 45], [3, 0, 24], [3, 1, 30], [3, 2, 42]]", "opt_solution_cost": "540", "opt_solution_compute_t": "180.21373414993286", "solution_depth": "10", "max_successor_states": "26", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '', '40'], ['34', '37', '', ''], ['', '43', '', '22'], ['', '', '', '47']]\", 4, 22, 53]", "is_correct_args": "[\"[['', '', '', '40'], ['34', '37', '', ''], ['', '43', '', '22'], ['', '', '', '47']]\", 22, 53, [1, 3], [1, 3], [137, 162], [141, 135], 151]", "A*_args": "[\"[['', '', '', '40'], ['34', '37', '', ''], ['', '43', '', '22'], ['', '', '', '47']]\", \"22\", \"53\", \"[None, 137, 162, None]\", \"[None, 141, 135, None]\", \"151\"]"}
{"diff_sorted_id": "58", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 4, 1: 8, 2: 9, 3: 9, 4: 5, 5: 7, 6: 9, 7: 6}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Green', 'Yellow', 'Red', 'Red', 'Red'], [], ['Green', 'Yellow', 'Green', 'Blue', 'Black'], ['Red', 'Yellow', 'Black', 'Blue', 'Black'], [], [], ['Green', 'Black', 'Yellow', 'Blue', 'Blue']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[1, 0], [7, 0], [1, 5], [4, 1], [4, 5], [3, 0], [3, 5], [3, 0], [3, 2], [7, 3], [7, 5], [4, 3], [4, 7], [2, 7], [3, 4], [3, 4], [3, 4]]", "opt_solution_cost": "106", "opt_solution_compute_t": "0.03409838676452637", "solution_depth": "17", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[], [\"Green\", \"Yellow\", \"Red\", \"Red\", \"Red\"], [], [\"Green\", \"Yellow\", \"Green\", \"Blue\", \"Black\"], [\"Red\", \"Yellow\", \"Black\", \"Blue\", \"Black\"], [], [], [\"Green\", \"Black\", \"Yellow\", \"Blue\", \"Blue\"]], 5, {\"0\": 4, \"1\": 8, \"2\": 9, \"3\": 9, \"4\": 5, \"5\": 7, \"6\": 9, \"7\": 6}]", "is_correct_args": "[[[], [\"Green\", \"Yellow\", \"Red\", \"Red\", \"Red\"], [], [\"Green\", \"Yellow\", \"Green\", \"Blue\", \"Black\"], [\"Red\", \"Yellow\", \"Black\", \"Blue\", \"Black\"], [], [], [\"Green\", \"Black\", \"Yellow\", \"Blue\", \"Blue\"]], 5, {\"0\": 4, \"1\": 8, \"2\": 9, \"3\": 9, \"4\": 5, \"5\": 7, \"6\": 9, \"7\": 6}, 4]", "A*_args": "[\"[[], ['Green', 'Yellow', 'Red', 'Red', 'Red'], [], ['Green', 'Yellow', 'Green', 'Blue', 'Black'], ['Red', 'Yellow', 'Black', 'Blue', 'Black'], [], [], ['Green', 'Black', 'Yellow', 'Blue', 'Blue']]\", \"{0: 4, 1: 8, 2: 9, 3: 9, 4: 5, 5: 7, 6: 9, 7: 6}\", \"5\", \"4\"]"}
{"diff_sorted_id": "58", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (1, 3) to his destination workshop at index (6, 10), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 5, and district 3 covering rows 6 to 11. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x x 6 9 x x 10 14 7 3 12]\n[x 11 x 3 14 16 17 1 4 14 8 16]\n[3 x x x 6 1 18 16 x 6 3 11]\n[x x 11 4 8 x x 1 3 9 8 7]\n[x x 3 x x x 8 14 18 x x 18]\n[4 1 x x x 14 x x x 3 4 20]\n[1 x x x 14 19 15 x x 3 16 15]\n[x x 6 18 x x 16 1 x 3 x 11]\n[x 3 x 15 x 19 10 x x x x x]\n[x 9 x x x x 17 17 x 16 x 13]\n[x x 8 x x 1 x x x 19 19 1]\n[x 3 9 x x x x 1 x 10 11 8]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "4", "opt_solution": "[[1, 3], [1, 4], [2, 4], [2, 5], [2, 6], [2, 7], [3, 7], [3, 8], [3, 9], [3, 10], [3, 11], [4, 11], [5, 11], [5, 10], [6, 10]]", "opt_solution_cost": "141", "opt_solution_compute_t": "0.027864456176757812", "solution_depth": "15", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"x\", \"6\", \"9\", \"x\", \"x\", \"10\", \"14\", \"7\", \"3\", \"12\"], [\"x\", \"11\", \"x\", \"3\", \"14\", \"16\", \"17\", \"1\", \"4\", \"14\", \"8\", \"16\"], [\"3\", \"x\", \"x\", \"x\", \"6\", \"1\", \"18\", \"16\", \"x\", \"6\", \"3\", \"11\"], [\"x\", \"x\", \"11\", \"4\", \"8\", \"x\", \"x\", \"1\", \"3\", \"9\", \"8\", \"7\"], [\"x\", \"x\", \"3\", \"x\", \"x\", \"x\", \"8\", \"14\", \"18\", \"x\", \"x\", \"18\"], [\"4\", \"1\", \"x\", \"x\", \"x\", \"14\", \"x\", \"x\", \"x\", \"3\", \"4\", \"20\"], [\"1\", \"x\", \"x\", \"x\", \"14\", \"19\", \"15\", \"x\", \"x\", \"3\", \"16\", \"15\"], [\"x\", \"x\", \"6\", \"18\", \"x\", \"x\", \"16\", \"1\", \"x\", \"3\", \"x\", \"11\"], [\"x\", \"3\", \"x\", \"15\", \"x\", \"19\", \"10\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"9\", \"x\", \"x\", \"x\", \"x\", \"17\", \"17\", \"x\", \"16\", \"x\", \"13\"], [\"x\", \"x\", \"8\", \"x\", \"x\", \"1\", \"x\", \"x\", \"x\", \"19\", \"19\", \"1\"], [\"x\", \"3\", \"9\", \"x\", \"x\", \"x\", \"x\", \"1\", \"x\", \"10\", \"11\", \"8\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"x\", \"6\", \"9\", \"x\", \"x\", \"10\", \"14\", \"7\", \"3\", \"12\"], [\"x\", \"11\", \"x\", \"3\", \"14\", \"16\", \"17\", \"1\", \"4\", \"14\", \"8\", \"16\"], [\"3\", \"x\", \"x\", \"x\", \"6\", \"1\", \"18\", \"16\", \"x\", \"6\", \"3\", \"11\"], [\"x\", \"x\", \"11\", \"4\", \"8\", \"x\", \"x\", \"1\", \"3\", \"9\", \"8\", \"7\"], [\"x\", \"x\", \"3\", \"x\", \"x\", \"x\", \"8\", \"14\", \"18\", \"x\", \"x\", \"18\"], [\"4\", \"1\", \"x\", \"x\", \"x\", \"14\", \"x\", \"x\", \"x\", \"3\", \"4\", \"20\"], [\"1\", \"x\", \"x\", \"x\", \"14\", \"19\", \"15\", \"x\", \"x\", \"3\", \"16\", \"15\"], [\"x\", \"x\", \"6\", \"18\", \"x\", \"x\", \"16\", \"1\", \"x\", \"3\", \"x\", \"11\"], [\"x\", \"3\", \"x\", \"15\", \"x\", \"19\", \"10\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"9\", \"x\", \"x\", \"x\", \"x\", \"17\", \"17\", \"x\", \"16\", \"x\", \"13\"], [\"x\", \"x\", \"8\", \"x\", \"x\", \"1\", \"x\", \"x\", \"x\", \"19\", \"19\", \"1\"], [\"x\", \"3\", \"9\", \"x\", \"x\", \"x\", \"x\", \"1\", \"x\", \"10\", \"11\", \"8\"]], [1, 3], [6, 10], 1, 5]", "A*_args": "[\"[['x', 'x', 'x', '6', '9', 'x', 'x', '10', '14', '7', '3', '12'], ['x', '11', 'x', '3', '14', '16', '17', '1', '4', '14', '8', '16'], ['3', 'x', 'x', 'x', '6', '1', '18', '16', 'x', '6', '3', '11'], ['x', 'x', '11', '4', '8', 'x', 'x', '1', '3', '9', '8', '7'], ['x', 'x', '3', 'x', 'x', 'x', '8', '14', '18', 'x', 'x', '18'], ['4', '1', 'x', 'x', 'x', '14', 'x', 'x', 'x', '3', '4', '20'], ['1', 'x', 'x', 'x', '14', '19', '15', 'x', 'x', '3', '16', '15'], ['x', 'x', '6', '18', 'x', 'x', '16', '1', 'x', '3', 'x', '11'], ['x', '3', 'x', '15', 'x', '19', '10', 'x', 'x', 'x', 'x', 'x'], ['x', '9', 'x', 'x', 'x', 'x', '17', '17', 'x', '16', 'x', '13'], ['x', 'x', '8', 'x', 'x', '1', 'x', 'x', 'x', '19', '19', '1'], ['x', '3', '9', 'x', 'x', 'x', 'x', '1', 'x', '10', '11', '8']]\", \"(1, 3)\", \"(6, 10)\", \"1\", \"5\"]"}
{"diff_sorted_id": "58", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 12x12. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 1) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (10, 8). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 0 1 1 1 1 1 1 1 1 1\n0 0 1 0 0 1 1 1 0 1 1 1\n0 0 1 1 0 1 0 1 0 0 0 0\n0 0 0 0 0 0 1 1 0 0 0 1\n0 1 0 0 0 0 1 0 0 1 1 0\n1 0 1 0 0 0 0 0 1 1 1 1\n1 0 1 0 1 1 1 0 1 1 0 0\n1 1 0 1 0 1 0 0 0 1 1 0\n1 1 0 0 0 1 0 0 0 1 0 1\n1 1 0 1 0 0 0 1 0 0 1 1\n0 1 0 1 0 1 0 1 0 0 0 1\n0 1 1 0 1 1 1 1 1 0 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[[1, 1], [2, 1], [3, 1], [4, 2], [5, 3], [5, 4], [5, 5], [5, 6], [6, 7], [7, 7], [8, 7], [9, 8], [10, 8]]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.0319523811340332", "solution_depth": "13", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1], [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0], [1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1], [0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0]]\", 4]", "is_correct_args": "[\"[[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1], [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0], [1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1], [0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0]]\", [1, 1], [10, 8], 4]", "A*_args": "[\"[[0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1], [0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0], [1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1], [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1], [0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0]]\", \"(1, 1)\", \"(10, 8)\", \"4\"]"}
{"diff_sorted_id": "58", "problem_statement": "Given 5 labeled water jugs with capacities 59, 20, 21, 62, 61, 60 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 149, 156, 173, 186 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 62, 4], [\"+\", 62, 4], [\"+\", 62, 4], [\"+\", 59, 3], [\"+\", 59, 3], [\"-\", 21, 3], [\"+\", 59, 3], [\"-\", 62, 3], [\"+\", 20, 3], [\"+\", 59, 3], [\"+\", 59, 2], [\"+\", 59, 2], [\"-\", 21, 2], [\"+\", 59, 2], [\"+\", 20, 1], [\"+\", 61, 1], [\"+\", 62, 1], [\"-\", 59, 1], [\"+\", 62, 1], [\"-\", 59, 1], [\"+\", 62, 1]]", "opt_solution_cost": "21", "opt_solution_compute_t": "0.03367137908935547", "solution_depth": "21", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[59, 20, 21, 62, 61, 60], [149, 156, 173, 186]]", "is_correct_args": "[[59, 20, 21, 62, 61, 60], [149, 156, 173, 186]]", "A*_args": "[\"[59, 20, 21, 62, 61, 60]\", \"[149, 156, 173, 186]\"]"}
{"diff_sorted_id": "59", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[10, 96, 60, '_'], [98, 73, 14, 58], [53, 3, 21, 67]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "7", "opt_solution": "[58, 67, 21, 3, 53, 98, 10, 96, 73, 14, 60, 58, 67, 21, 3, 53, 14, 10, 98, 14, 10, 60, 58, 73, 96, 98, 60, 58, 53, 3]", "opt_solution_cost": "30", "opt_solution_compute_t": "0.15825581550598145", "solution_depth": "30", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[10, 96, 60, \"_\"], [98, 73, 14, 58], [53, 3, 21, 67]]]", "is_correct_args": "[[[10, 96, 60, \"_\"], [98, 73, 14, 58], [53, 3, 21, 67]]]", "A*_args": "[\"[[10, 96, 60, '_'], [98, 73, 14, 58], [53, 3, 21, 67]]\"]"}
{"diff_sorted_id": "59", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: fae, trah, feat, fine, daff   The initial board: [['r', 'f', '_', 'e'], ['t', 'a', 'a', 'f'], ['a', 'e', 'f', 't'], ['f', 'i', 'n', 'h'], ['d', 'a', 'e', 'f']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.20941829681396484", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"r\", \"f\", \"_\", \"e\"], [\"t\", \"a\", \"a\", \"f\"], [\"a\", \"e\", \"f\", \"t\"], [\"f\", \"i\", \"n\", \"h\"], [\"d\", \"a\", \"e\", \"f\"]]]", "is_correct_args": "[[[\"r\", \"f\", \"_\", \"e\"], [\"t\", \"a\", \"a\", \"f\"], [\"a\", \"e\", \"f\", \"t\"], [\"f\", \"i\", \"n\", \"h\"], [\"d\", \"a\", \"e\", \"f\"]], [\"fae\", \"trah\", \"feat\", \"fine\", \"daff\"]]", "A*_args": "[\"[['r', 'f', '_', 'e'], ['t', 'a', 'a', 'f'], ['a', 'e', 'f', 't'], ['f', 'i', 'n', 'h'], ['d', 'a', 'e', 'f']]\", \"['fae', 'trah', 'feat', 'fine', 'daff']\"]"}
{"diff_sorted_id": "59", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'K'. Our task is to visit city L and city D excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from D and L, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  D Y F M W H Q B K S V I L \nD 0 0 1 0 0 0 0 0 0 1 0 1 0 \nY 1 0 0 1 0 0 1 1 0 0 0 0 0 \nF 0 0 0 1 0 0 0 0 1 0 0 1 0 \nM 0 0 0 0 0 0 0 0 1 1 0 1 1 \nW 0 0 1 0 0 0 0 0 0 0 0 0 1 \nH 0 0 1 0 1 0 0 1 0 0 0 0 1 \nQ 1 0 0 1 0 1 0 1 0 0 1 0 0 \nB 0 0 1 0 1 1 0 0 0 0 0 0 0 \nK 0 0 0 0 0 1 0 1 0 0 1 0 0 \nS 0 1 1 0 1 0 0 1 0 0 0 0 0 \nV 0 0 0 0 0 0 0 1 0 1 0 1 0 \nI 0 1 0 0 1 1 1 0 0 0 0 0 0 \nL 0 0 1 0 0 0 0 0 1 1 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[\"K\", \"H\", \"L\", \"F\", \"M\", \"L\", \"S\", \"Y\", \"D\", \"I\", \"Q\", \"D\"]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.11734938621520996", "solution_depth": "12", "max_successor_states": "13", "num_vars_per_state": "16", "is_feasible_args": "[[[0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0]], [\"D\", \"Y\", \"F\", \"M\", \"W\", \"H\", \"Q\", \"B\", \"K\", \"S\", \"V\", \"I\", \"L\"], \"L\", \"D\"]", "is_correct_args": "[[[0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0]], [\"D\", \"Y\", \"F\", \"M\", \"W\", \"H\", \"Q\", \"B\", \"K\", \"S\", \"V\", \"I\", \"L\"], \"K\", \"L\", \"D\"]", "A*_args": "[\"[[0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0]]\", \"['D', 'Y', 'F', 'M', 'W', 'H', 'Q', 'B', 'K', 'S', 'V', 'I', 'L']\", \"['K']\", \"['L', 'D']\"]"}
{"diff_sorted_id": "59", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [23, 27, 20, 21, 8, 2, 2, 3, 21, 26, 16, 33, 22, 3, 25, 17, 5, 31, 3, 9, 12, 30, 11, 10, 7, 13, 2, 21, 8, 16, 5, 18, 32, 27, 7, 32, 7, 10, 11, 33, 18, 30, 7, 24, 21, 4, 25, 4, 23, 21, 23, 15, 26, 10], such that the sum of the chosen coins adds up to 334. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {16: 1, 18: 1, 9: 1, 11: 5, 5: 3, 2: 1, 21: 1, 33: 3, 7: 1, 4: 1, 30: 8, 23: 10, 17: 8, 15: 7, 13: 6, 20: 8, 32: 4, 10: 6, 3: 1, 12: 7, 27: 6, 31: 5, 22: 1, 26: 20, 24: 5, 8: 4, 25: 9}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "31", "opt_solution": "[9, 21, 21, 21, 21, 18, 21, 18, 16, 33, 32, 22, 33, 32, 16]", "opt_solution_cost": "25", "opt_solution_compute_t": "0.05468130111694336", "solution_depth": "15", "max_successor_states": "54", "num_vars_per_state": "54", "is_feasible_args": "[[23, 27, 20, 21, 8, 2, 2, 3, 21, 26, 16, 33, 22, 3, 25, 17, 5, 31, 3, 9, 12, 30, 11, 10, 7, 13, 2, 21, 8, 16, 5, 18, 32, 27, 7, 32, 7, 10, 11, 33, 18, 30, 7, 24, 21, 4, 25, 4, 23, 21, 23, 15, 26, 10]]", "is_correct_args": "[[23, 27, 20, 21, 8, 2, 2, 3, 21, 26, 16, 33, 22, 3, 25, 17, 5, 31, 3, 9, 12, 30, 11, 10, 7, 13, 2, 21, 8, 16, 5, 18, 32, 27, 7, 32, 7, 10, 11, 33, 18, 30, 7, 24, 21, 4, 25, 4, 23, 21, 23, 15, 26, 10], {\"16\": 1, \"18\": 1, \"9\": 1, \"11\": 5, \"5\": 3, \"2\": 1, \"21\": 1, \"33\": 3, \"7\": 1, \"4\": 1, \"30\": 8, \"23\": 10, \"17\": 8, \"15\": 7, \"13\": 6, \"20\": 8, \"32\": 4, \"10\": 6, \"3\": 1, \"12\": 7, \"27\": 6, \"31\": 5, \"22\": 1, \"26\": 20, \"24\": 5, \"8\": 4, \"25\": 9}, 334]", "A*_args": "[\"[23, 27, 20, 21, 8, 2, 2, 3, 21, 26, 16, 33, 22, 3, 25, 17, 5, 31, 3, 9, 12, 30, 11, 10, 7, 13, 2, 21, 8, 16, 5, 18, 32, 27, 7, 32, 7, 10, 11, 33, 18, 30, 7, 24, 21, 4, 25, 4, 23, 21, 23, 15, 26, 10]\", \"{16: 1, 18: 1, 9: 1, 11: 5, 5: 3, 2: 1, 21: 1, 33: 3, 7: 1, 4: 1, 30: 8, 23: 10, 17: 8, 15: 7, 13: 6, 20: 8, 32: 4, 10: 6, 3: 1, 12: 7, 27: 6, 31: 5, 22: 1, 26: 20, 24: 5, 8: 4, 25: 9}\", \"334\"]"}
{"diff_sorted_id": "59", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Red', 'Red', 'Blue', 'Red'], ['Green', 'Blue', 'Blue', 'Red', 'Green'], ['Blue', 'Green', 'Red', 'Green', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[0, 1], [2, 1], [0, 2], [0, 2], [0, 1], [0, 2], [1, 0], [1, 0], [1, 0], [1, 2], [1, 0], [1, 0], [2, 0], [1, 2], [1, 0], [2, 1], [2, 1], [2, 1], [2, 1], [2, 0], [2, 1], [0, 2], [0, 2], [0, 2]]", "opt_solution_cost": "24", "opt_solution_compute_t": "45.59880995750427", "solution_depth": "24", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Blue\", \"Red\", \"Red\", \"Blue\", \"Red\"], [\"Green\", \"Blue\", \"Blue\", \"Red\", \"Green\"], [\"Blue\", \"Green\", \"Red\", \"Green\", \"Green\"]], 8]", "is_correct_args": "[[[\"Blue\", \"Red\", \"Red\", \"Blue\", \"Red\"], [\"Green\", \"Blue\", \"Blue\", \"Red\", \"Green\"], [\"Blue\", \"Green\", \"Red\", \"Green\", \"Green\"]], 8]", "A*_args": "[\"[['Blue', 'Red', 'Red', 'Blue', 'Red'], ['Green', 'Blue', 'Blue', 'Red', 'Green'], ['Blue', 'Green', 'Red', 'Green', 'Green']]\", \"8\"]"}
{"diff_sorted_id": "59", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 19 to 59 (19 included in the range but 59 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' '38' 'x']\n ['x' '30' 'x' 'x']\n ['20' 'x' '44' 'x']\n ['x' '22' 'x' '57']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "14", "opt_solution": "[[0, 0, 24], [0, 1, 25], [0, 2, 26], [0, 3, 27], [1, 1, 38], [1, 3, 52], [2, 0, 39], [2, 2, 50], [2, 3, 53], [3, 1, 45]]", "opt_solution_cost": "468", "opt_solution_compute_t": "132.53104043006897", "solution_depth": "10", "max_successor_states": "40", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '', ''], ['37', '', '49', ''], ['', '44', '', ''], ['42', '', '51', '61']]\", 24, 64]", "is_correct_args": "[\"[['', '', '', ''], ['37', '', '49', ''], ['', '44', '', ''], ['42', '', '51', '61']]\", 24, 64]", "A*_args": "[\"[['', '', '', ''], ['37', '', '49', ''], ['', '44', '', ''], ['42', '', '51', '61']]\", \"24\", \"64\"]"}
{"diff_sorted_id": "59", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 22 to 53. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 148, 157, None for columns 1 to 2 respectively, and the sums of rows must be None, 138, 149, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 133. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['35' 'x' '51' 'x']\n ['x' 'x' 'x' '23']\n ['x' '32' '31' '52']\n ['x' 'x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 1, 28], [0, 3, 25], [1, 0, 24], [1, 1, 42], [1, 2, 49], [2, 0, 34], [3, 0, 27], [3, 1, 46], [3, 2, 26], [3, 3, 22]]", "opt_solution_cost": "547", "opt_solution_compute_t": "42.003302574157715", "solution_depth": "10", "max_successor_states": "26", "num_vars_per_state": "16", "is_feasible_args": "[\"[['35', '', '51', ''], ['', '', '', '23'], ['', '32', '31', '52'], ['', '', '', '']]\", 4, 22, 53]", "is_correct_args": "[\"[['35', '', '51', ''], ['', '', '', '23'], ['', '32', '31', '52'], ['', '', '', '']]\", 22, 53, [1, 3], [1, 3], [148, 157], [138, 149], 133]", "A*_args": "[\"[['35', '', '51', ''], ['', '', '', '23'], ['', '32', '31', '52'], ['', '', '', '']]\", \"22\", \"53\", \"[None, 148, 157, None]\", \"[None, 138, 149, None]\", \"133\"]"}
{"diff_sorted_id": "59", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 1, 1: 5, 2: 5, 3: 4, 4: 8, 5: 6, 6: 8, 7: 9}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Green', 'Blue', 'Green', 'Yellow', 'Yellow'], [], ['Red', 'Red', 'Green', 'Black', 'Black'], [], ['Blue', 'Yellow', 'Black', 'Yellow', 'Blue'], [], [], ['Black', 'Blue', 'Red', 'Red', 'Green']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[0, 5], [0, 3], [0, 5], [2, 1], [2, 1], [2, 5], [7, 2], [7, 3], [7, 1], [7, 1], [7, 5], [4, 3], [4, 0], [4, 2], [4, 0], [4, 3]]", "opt_solution_cost": "72", "opt_solution_compute_t": "6.510378360748291", "solution_depth": "16", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[\"Green\", \"Blue\", \"Green\", \"Yellow\", \"Yellow\"], [], [\"Red\", \"Red\", \"Green\", \"Black\", \"Black\"], [], [\"Blue\", \"Yellow\", \"Black\", \"Yellow\", \"Blue\"], [], [], [\"Black\", \"Blue\", \"Red\", \"Red\", \"Green\"]], 5, {\"0\": 1, \"1\": 5, \"2\": 5, \"3\": 4, \"4\": 8, \"5\": 6, \"6\": 8, \"7\": 9}]", "is_correct_args": "[[[\"Green\", \"Blue\", \"Green\", \"Yellow\", \"Yellow\"], [], [\"Red\", \"Red\", \"Green\", \"Black\", \"Black\"], [], [\"Blue\", \"Yellow\", \"Black\", \"Yellow\", \"Blue\"], [], [], [\"Black\", \"Blue\", \"Red\", \"Red\", \"Green\"]], 5, {\"0\": 1, \"1\": 5, \"2\": 5, \"3\": 4, \"4\": 8, \"5\": 6, \"6\": 8, \"7\": 9}, 4]", "A*_args": "[\"[['Green', 'Blue', 'Green', 'Yellow', 'Yellow'], [], ['Red', 'Red', 'Green', 'Black', 'Black'], [], ['Blue', 'Yellow', 'Black', 'Yellow', 'Blue'], [], [], ['Black', 'Blue', 'Red', 'Red', 'Green']]\", \"{0: 1, 1: 5, 2: 5, 3: 4, 4: 8, 5: 6, 6: 8, 7: 9}\", \"5\", \"4\"]"}
{"diff_sorted_id": "59", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (2, 0) to his destination workshop at index (7, 8), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 6, and district 3 covering rows 7 to 11. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[4 1 20 15 9 x 8 6 x x 14 x]\n[5 11 9 12 10 4 15 18 7 x x 13]\n[15 9 1 x 18 3 1 19 x x 17 17]\n[x 17 11 10 x 19 8 x x x x 7]\n[5 x 1 x 14 13 4 8 5 x 13 14]\n[16 6 x x x 17 x 15 4 x x 15]\n[x x x 15 x 19 10 x 16 18 11 1]\n[6 8 x 3 x 5 5 x 3 8 9 14]\n[10 14 x x x x x x 6 2 x x]\n[12 x x 6 11 4 x x 12 x 4 16]\n[4 x x x 11 x x x 18 16 x 10]\n[x 6 x x 11 x 5 13 8 1 17 9]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "4", "opt_solution": "[[2, 0], [2, 1], [2, 2], [1, 2], [1, 3], [1, 4], [1, 5], [2, 5], [2, 6], [3, 6], [4, 6], [4, 7], [4, 8], [5, 8], [6, 8], [7, 8]]", "opt_solution_cost": "97", "opt_solution_compute_t": "0.027582406997680664", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"4\", \"1\", \"20\", \"15\", \"9\", \"x\", \"8\", \"6\", \"x\", \"x\", \"14\", \"x\"], [\"5\", \"11\", \"9\", \"12\", \"10\", \"4\", \"15\", \"18\", \"7\", \"x\", \"x\", \"13\"], [\"15\", \"9\", \"1\", \"x\", \"18\", \"3\", \"1\", \"19\", \"x\", \"x\", \"17\", \"17\"], [\"x\", \"17\", \"11\", \"10\", \"x\", \"19\", \"8\", \"x\", \"x\", \"x\", \"x\", \"7\"], [\"5\", \"x\", \"1\", \"x\", \"14\", \"13\", \"4\", \"8\", \"5\", \"x\", \"13\", \"14\"], [\"16\", \"6\", \"x\", \"x\", \"x\", \"17\", \"x\", \"15\", \"4\", \"x\", \"x\", \"15\"], [\"x\", \"x\", \"x\", \"15\", \"x\", \"19\", \"10\", \"x\", \"16\", \"18\", \"11\", \"1\"], [\"6\", \"8\", \"x\", \"3\", \"x\", \"5\", \"5\", \"x\", \"3\", \"8\", \"9\", \"14\"], [\"10\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"6\", \"2\", \"x\", \"x\"], [\"12\", \"x\", \"x\", \"6\", \"11\", \"4\", \"x\", \"x\", \"12\", \"x\", \"4\", \"16\"], [\"4\", \"x\", \"x\", \"x\", \"11\", \"x\", \"x\", \"x\", \"18\", \"16\", \"x\", \"10\"], [\"x\", \"6\", \"x\", \"x\", \"11\", \"x\", \"5\", \"13\", \"8\", \"1\", \"17\", \"9\"]]]", "is_correct_args": "[[[\"4\", \"1\", \"20\", \"15\", \"9\", \"x\", \"8\", \"6\", \"x\", \"x\", \"14\", \"x\"], [\"5\", \"11\", \"9\", \"12\", \"10\", \"4\", \"15\", \"18\", \"7\", \"x\", \"x\", \"13\"], [\"15\", \"9\", \"1\", \"x\", \"18\", \"3\", \"1\", \"19\", \"x\", \"x\", \"17\", \"17\"], [\"x\", \"17\", \"11\", \"10\", \"x\", \"19\", \"8\", \"x\", \"x\", \"x\", \"x\", \"7\"], [\"5\", \"x\", \"1\", \"x\", \"14\", \"13\", \"4\", \"8\", \"5\", \"x\", \"13\", \"14\"], [\"16\", \"6\", \"x\", \"x\", \"x\", \"17\", \"x\", \"15\", \"4\", \"x\", \"x\", \"15\"], [\"x\", \"x\", \"x\", \"15\", \"x\", \"19\", \"10\", \"x\", \"16\", \"18\", \"11\", \"1\"], [\"6\", \"8\", \"x\", \"3\", \"x\", \"5\", \"5\", \"x\", \"3\", \"8\", \"9\", \"14\"], [\"10\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"6\", \"2\", \"x\", \"x\"], [\"12\", \"x\", \"x\", \"6\", \"11\", \"4\", \"x\", \"x\", \"12\", \"x\", \"4\", \"16\"], [\"4\", \"x\", \"x\", \"x\", \"11\", \"x\", \"x\", \"x\", \"18\", \"16\", \"x\", \"10\"], [\"x\", \"6\", \"x\", \"x\", \"11\", \"x\", \"5\", \"13\", \"8\", \"1\", \"17\", \"9\"]], [2, 0], [7, 8], 1, 6]", "A*_args": "[\"[['4', '1', '20', '15', '9', 'x', '8', '6', 'x', 'x', '14', 'x'], ['5', '11', '9', '12', '10', '4', '15', '18', '7', 'x', 'x', '13'], ['15', '9', '1', 'x', '18', '3', '1', '19', 'x', 'x', '17', '17'], ['x', '17', '11', '10', 'x', '19', '8', 'x', 'x', 'x', 'x', '7'], ['5', 'x', '1', 'x', '14', '13', '4', '8', '5', 'x', '13', '14'], ['16', '6', 'x', 'x', 'x', '17', 'x', '15', '4', 'x', 'x', '15'], ['x', 'x', 'x', '15', 'x', '19', '10', 'x', '16', '18', '11', '1'], ['6', '8', 'x', '3', 'x', '5', '5', 'x', '3', '8', '9', '14'], ['10', '14', 'x', 'x', 'x', 'x', 'x', 'x', '6', '2', 'x', 'x'], ['12', 'x', 'x', '6', '11', '4', 'x', 'x', '12', 'x', '4', '16'], ['4', 'x', 'x', 'x', '11', 'x', 'x', 'x', '18', '16', 'x', '10'], ['x', '6', 'x', 'x', '11', 'x', '5', '13', '8', '1', '17', '9']]\", \"(2, 0)\", \"(7, 8)\", \"1\", \"6\"]"}
{"diff_sorted_id": "59", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 12x12. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 9) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (11, 2). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 0 0 1 0 0 0 0 1 1\n1 1 1 0 0 0 0 0 0 0 1 1\n1 0 1 0 1 1 0 1 1 0 1 1\n1 1 0 0 1 0 0 1 1 1 0 0\n1 1 0 0 0 1 1 0 1 1 0 1\n0 0 0 1 1 1 1 0 1 0 1 0\n0 1 0 1 1 1 1 1 1 1 1 1\n0 1 0 0 0 0 0 1 1 0 1 0\n0 1 1 1 1 1 1 1 1 0 0 0\n0 1 1 1 1 1 1 1 1 0 1 0\n0 0 0 1 1 1 0 1 1 1 0 1\n0 0 0 0 1 1 1 1 1 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[[0, 9], [1, 8], [1, 7], [1, 6], [2, 6], [3, 6], [3, 5], [4, 4], [4, 3], [4, 2], [5, 2], [5, 1], [5, 0], [6, 0], [7, 0], [8, 0], [9, 0], [10, 1], [11, 2]]", "opt_solution_cost": "19", "opt_solution_compute_t": "0.03089118003845215", "solution_depth": "19", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1], [1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0], [1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1], [0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]]\", 4]", "is_correct_args": "[\"[[1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1], [1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0], [1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1], [0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]]\", [0, 9], [11, 2], 4]", "A*_args": "[\"[[1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1], [1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0], [1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1], [0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]]\", \"(0, 9)\", \"(11, 2)\", \"4\"]"}
{"diff_sorted_id": "59", "problem_statement": "Given 5 labeled water jugs with capacities 128, 67, 44, 31, 127, 15 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 258, 261, 415, 430 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 31, 4], [\"+\", 128, 4], [\"+\", 128, 4], [\"+\", 128, 4], [\"+\", 15, 4], [\"+\", 31, 3], [\"+\", 128, 3], [\"+\", 128, 3], [\"+\", 128, 3], [\"+\", 67, 2], [\"+\", 67, 2], [\"+\", 127, 2], [\"+\", 128, 1], [\"+\", 128, 1], [\"-\", 44, 1], [\"+\", 15, 1], [\"+\", 31, 1]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.06383585929870605", "solution_depth": "17", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[128, 67, 44, 31, 127, 15], [258, 261, 415, 430]]", "is_correct_args": "[[128, 67, 44, 31, 127, 15], [258, 261, 415, 430]]", "A*_args": "[\"[128, 67, 44, 31, 127, 15]\", \"[258, 261, 415, 430]\"]"}
{"diff_sorted_id": "60", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[31, 92, 67, 69], [87, 35, 42, 72], [53, '_', 28, 19]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "7", "opt_solution": "[28, 42, 72, 69, 67, 72, 35, 87, 31, 92, 72, 67, 69, 35, 67, 72, 87, 67, 42, 28, 53, 31, 67, 53, 28, 19]", "opt_solution_cost": "26", "opt_solution_compute_t": "0.2203352451324463", "solution_depth": "26", "max_successor_states": "4", "num_vars_per_state": "12", "is_feasible_args": "[[[31, 92, 67, 69], [87, 35, 42, 72], [53, \"_\", 28, 19]]]", "is_correct_args": "[[[31, 92, 67, 69], [87, 35, 42, 72], [53, \"_\", 28, 19]]]", "A*_args": "[\"[[31, 92, 67, 69], [87, 35, 42, 72], [53, '_', 28, 19]]\"]"}
{"diff_sorted_id": "60", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: ban, zeed, dazy, mote, maun   The initial board: [['e', 'b', 'a', 'n'], ['z', 'e', 'e', 'd'], ['o', 'a', 'd', 'y'], ['m', 'u', 't', 'z'], ['m', 'a', '_', 'n']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"up-left\", \"up-left\", \"up-right\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.18634486198425293", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"e\", \"b\", \"a\", \"n\"], [\"z\", \"e\", \"e\", \"d\"], [\"o\", \"a\", \"d\", \"y\"], [\"m\", \"u\", \"t\", \"z\"], [\"m\", \"a\", \"_\", \"n\"]]]", "is_correct_args": "[[[\"e\", \"b\", \"a\", \"n\"], [\"z\", \"e\", \"e\", \"d\"], [\"o\", \"a\", \"d\", \"y\"], [\"m\", \"u\", \"t\", \"z\"], [\"m\", \"a\", \"_\", \"n\"]], [\"ban\", \"zeed\", \"dazy\", \"mote\", \"maun\"]]", "A*_args": "[\"[['e', 'b', 'a', 'n'], ['z', 'e', 'e', 'd'], ['o', 'a', 'd', 'y'], ['m', 'u', 't', 'z'], ['m', 'a', '_', 'n']]\", \"['ban', 'zeed', 'dazy', 'mote', 'maun']\"]"}
{"diff_sorted_id": "60", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'I'. Our task is to visit city F and city U excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from U and F, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  H T R F L U Q G N E Y I X \nH 0 0 0 0 0 0 1 0 1 1 0 0 0 \nT 0 0 0 0 1 0 0 0 1 0 0 0 0 \nR 1 0 0 0 1 0 0 1 0 0 0 0 1 \nF 0 1 1 0 0 0 1 0 0 0 0 0 0 \nL 0 0 0 1 0 0 0 0 0 0 1 0 1 \nU 0 0 0 0 0 0 0 1 0 0 1 0 1 \nQ 0 0 0 1 0 0 0 0 0 1 1 0 0 \nG 1 1 0 1 1 0 0 0 0 1 0 0 0 \nN 0 1 0 0 1 1 0 1 0 0 0 0 0 \nE 0 0 1 1 0 0 0 1 0 0 0 0 0 \nY 0 0 1 0 0 0 1 1 0 0 0 0 0 \nI 1 0 0 0 0 0 0 0 0 0 0 0 0 \nX 0 0 0 0 1 1 1 0 0 0 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[\"I\", \"H\", \"N\", \"U\", \"X\", \"U\", \"G\", \"F\", \"Q\", \"F\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.046558380126953125", "solution_depth": "10", "max_successor_states": "13", "num_vars_per_state": "16", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0]], [\"H\", \"T\", \"R\", \"F\", \"L\", \"U\", \"Q\", \"G\", \"N\", \"E\", \"Y\", \"I\", \"X\"], \"F\", \"U\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0]], [\"H\", \"T\", \"R\", \"F\", \"L\", \"U\", \"Q\", \"G\", \"N\", \"E\", \"Y\", \"I\", \"X\"], \"I\", \"F\", \"U\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0]]\", \"['H', 'T', 'R', 'F', 'L', 'U', 'Q', 'G', 'N', 'E', 'Y', 'I', 'X']\", \"['I']\", \"['F', 'U']\"]"}
{"diff_sorted_id": "60", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [28, 2, 4, 7, 11, 26, 14, 8, 23, 29, 18, 13, 26, 21, 10, 26, 8, 33, 9, 15, 4, 21, 19, 3, 7, 10, 4, 7, 16, 16, 11, 33, 12, 23, 5, 3, 26, 7, 17, 30, 22, 22, 6, 16, 18, 25, 26, 11, 13, 23, 17, 11, 20, 12], such that the sum of the chosen coins adds up to 339. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {10: 6, 18: 17, 33: 15, 16: 16, 3: 2, 30: 18, 13: 3, 21: 17, 23: 4, 12: 1, 7: 6, 17: 7, 4: 2, 6: 5, 2: 2, 11: 5, 14: 14, 29: 1, 20: 7, 8: 3, 15: 7, 28: 3, 26: 8, 19: 11, 9: 9, 22: 4, 5: 5, 25: 5}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "32", "opt_solution": "[28, 12, 23, 12, 13, 23, 22, 8, 23, 22, 25, 29, 26, 20, 8, 13, 15, 17]", "opt_solution_cost": "72", "opt_solution_compute_t": "0.06408143043518066", "solution_depth": "18", "max_successor_states": "54", "num_vars_per_state": "54", "is_feasible_args": "[[28, 2, 4, 7, 11, 26, 14, 8, 23, 29, 18, 13, 26, 21, 10, 26, 8, 33, 9, 15, 4, 21, 19, 3, 7, 10, 4, 7, 16, 16, 11, 33, 12, 23, 5, 3, 26, 7, 17, 30, 22, 22, 6, 16, 18, 25, 26, 11, 13, 23, 17, 11, 20, 12]]", "is_correct_args": "[[28, 2, 4, 7, 11, 26, 14, 8, 23, 29, 18, 13, 26, 21, 10, 26, 8, 33, 9, 15, 4, 21, 19, 3, 7, 10, 4, 7, 16, 16, 11, 33, 12, 23, 5, 3, 26, 7, 17, 30, 22, 22, 6, 16, 18, 25, 26, 11, 13, 23, 17, 11, 20, 12], {\"10\": 6, \"18\": 17, \"33\": 15, \"16\": 16, \"3\": 2, \"30\": 18, \"13\": 3, \"21\": 17, \"23\": 4, \"12\": 1, \"7\": 6, \"17\": 7, \"4\": 2, \"6\": 5, \"2\": 2, \"11\": 5, \"14\": 14, \"29\": 1, \"20\": 7, \"8\": 3, \"15\": 7, \"28\": 3, \"26\": 8, \"19\": 11, \"9\": 9, \"22\": 4, \"5\": 5, \"25\": 5}, 339]", "A*_args": "[\"[28, 2, 4, 7, 11, 26, 14, 8, 23, 29, 18, 13, 26, 21, 10, 26, 8, 33, 9, 15, 4, 21, 19, 3, 7, 10, 4, 7, 16, 16, 11, 33, 12, 23, 5, 3, 26, 7, 17, 30, 22, 22, 6, 16, 18, 25, 26, 11, 13, 23, 17, 11, 20, 12]\", \"{10: 6, 18: 17, 33: 15, 16: 16, 3: 2, 30: 18, 13: 3, 21: 17, 23: 4, 12: 1, 7: 6, 17: 7, 4: 2, 6: 5, 2: 2, 11: 5, 14: 14, 29: 1, 20: 7, 8: 3, 15: 7, 28: 3, 26: 8, 19: 11, 9: 9, 22: 4, 5: 5, 25: 5}\", \"339\"]"}
{"diff_sorted_id": "60", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Red', 'Blue', 'Blue', 'Green'], ['Red', 'Green', 'Blue', 'Red', 'Green'], ['Blue', 'Red', 'Blue', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[1, 0], [2, 1], [2, 0], [2, 1], [2, 1], [0, 2], [0, 2], [0, 1], [0, 2], [1, 2], [1, 2], [0, 1], [0, 1], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 2], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [2, 1], [0, 2]]", "opt_solution_cost": "26", "opt_solution_compute_t": "132.6773865222931", "solution_depth": "26", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Green\", \"Red\", \"Blue\", \"Blue\", \"Green\"], [\"Red\", \"Green\", \"Blue\", \"Red\", \"Green\"], [\"Blue\", \"Red\", \"Blue\", \"Green\", \"Red\"]], 8]", "is_correct_args": "[[[\"Green\", \"Red\", \"Blue\", \"Blue\", \"Green\"], [\"Red\", \"Green\", \"Blue\", \"Red\", \"Green\"], [\"Blue\", \"Red\", \"Blue\", \"Green\", \"Red\"]], 8]", "A*_args": "[\"[['Green', 'Red', 'Blue', 'Blue', 'Green'], ['Red', 'Green', 'Blue', 'Red', 'Green'], ['Blue', 'Red', 'Blue', 'Green', 'Red']]\", \"8\"]"}
{"diff_sorted_id": "60", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 24 to 64 (24 included in the range but 64 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' 'x' 'x']\n ['37' 'x' '49' 'x']\n ['x' '44' 'x' 'x']\n ['42' 'x' '51' '61']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "14", "opt_solution": "[[0, 0, 36], [0, 1, 37], [0, 3, 47], [1, 0, 38], [2, 1, 58], [3, 2, 76]]", "opt_solution_cost": "678", "opt_solution_compute_t": "0.18999671936035156", "solution_depth": "6", "max_successor_states": "40", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '46', ''], ['', '57', '59', '70'], ['56', '', '69', '73'], ['57', '75', '', '80']]\", 36, 81]", "is_correct_args": "[\"[['', '', '46', ''], ['', '57', '59', '70'], ['56', '', '69', '73'], ['57', '75', '', '80']]\", 36, 81]", "A*_args": "[\"[['', '', '46', ''], ['', '57', '59', '70'], ['56', '', '69', '73'], ['57', '75', '', '80']]\", \"36\", \"81\"]"}
{"diff_sorted_id": "60", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 23 to 54. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 173, 166, None for columns 1 to 2 respectively, and the sums of rows must be None, 166, 165, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 131. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['45' '53' 'x' 'x']\n ['x' 'x' 'x' 'x']\n ['47' 'x' 'x' 'x']\n ['35' 'x' '52' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 2, 26], [0, 3, 23], [1, 0, 30], [1, 1, 50], [1, 2, 37], [1, 3, 49], [2, 1, 36], [2, 2, 51], [2, 3, 31], [3, 1, 34], [3, 3, 24]]", "opt_solution_cost": "623", "opt_solution_compute_t": "225.59702444076538", "solution_depth": "11", "max_successor_states": "26", "num_vars_per_state": "16", "is_feasible_args": "[\"[['45', '53', '', ''], ['', '', '', ''], ['47', '', '', ''], ['35', '', '52', '']]\", 4, 23, 54]", "is_correct_args": "[\"[['45', '53', '', ''], ['', '', '', ''], ['47', '', '', ''], ['35', '', '52', '']]\", 23, 54, [1, 3], [1, 3], [173, 166], [166, 165], 131]", "A*_args": "[\"[['45', '53', '', ''], ['', '', '', ''], ['47', '', '', ''], ['35', '', '52', '']]\", \"23\", \"54\", \"[None, 173, 166, None]\", \"[None, 166, 165, None]\", \"131\"]"}
{"diff_sorted_id": "60", "problem_statement": "In 'Restricted Sorting', there are 8 stacks each with a capacity of 5 blocks, with 4 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 4 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 6, 1: 1, 2: 8, 3: 8, 4: 1, 5: 6, 6: 4, 7: 1}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Yellow', 'Green', 'Green', 'Black', 'Black'], [], ['Yellow', 'Green', 'Black', 'Green', 'Red'], ['Red', 'Black', 'Blue', 'Blue', 'Yellow'], [], [], ['Red', 'Blue', 'Yellow', 'Blue', 'Red'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "2", "opt_solution": "[[0, 1], [0, 5], [0, 5], [2, 1], [2, 5], [2, 0], [2, 5], [3, 4], [3, 0], [3, 7], [3, 7], [6, 4], [6, 7], [6, 1], [6, 7], [2, 4], [3, 1], [6, 4]]", "opt_solution_cost": "48", "opt_solution_compute_t": "7.157405853271484", "solution_depth": "18", "max_successor_states": "56", "num_vars_per_state": "20", "is_feasible_args": "[[[\"Yellow\", \"Green\", \"Green\", \"Black\", \"Black\"], [], [\"Yellow\", \"Green\", \"Black\", \"Green\", \"Red\"], [\"Red\", \"Black\", \"Blue\", \"Blue\", \"Yellow\"], [], [], [\"Red\", \"Blue\", \"Yellow\", \"Blue\", \"Red\"], []], 5, {\"0\": 6, \"1\": 1, \"2\": 8, \"3\": 8, \"4\": 1, \"5\": 6, \"6\": 4, \"7\": 1}]", "is_correct_args": "[[[\"Yellow\", \"Green\", \"Green\", \"Black\", \"Black\"], [], [\"Yellow\", \"Green\", \"Black\", \"Green\", \"Red\"], [\"Red\", \"Black\", \"Blue\", \"Blue\", \"Yellow\"], [], [], [\"Red\", \"Blue\", \"Yellow\", \"Blue\", \"Red\"], []], 5, {\"0\": 6, \"1\": 1, \"2\": 8, \"3\": 8, \"4\": 1, \"5\": 6, \"6\": 4, \"7\": 1}, 4]", "A*_args": "[\"[['Yellow', 'Green', 'Green', 'Black', 'Black'], [], ['Yellow', 'Green', 'Black', 'Green', 'Red'], ['Red', 'Black', 'Blue', 'Blue', 'Yellow'], [], [], ['Red', 'Blue', 'Yellow', 'Blue', 'Red'], []]\", \"{0: 6, 1: 1, 2: 8, 3: 8, 4: 1, 5: 6, 6: 4, 7: 1}\", \"5\", \"4\"]"}
{"diff_sorted_id": "60", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 0) to his destination workshop at index (9, 7), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 8, and district 3 covering rows 9 to 11. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[16 x 5 6 x 14 12 x x x 6 x]\n[17 x x x 5 x 5 7 x x 8 x]\n[3 19 x x x x 18 x 13 7 x x]\n[13 x 4 x x 8 7 4 x 15 x x]\n[5 17 18 12 3 x 14 2 4 18 x 1]\n[4 10 1 19 10 x x 17 x 17 16 4]\n[7 x 16 x x 1 3 x 13 13 x x]\n[x x 9 1 7 18 16 3 x 4 x x]\n[2 x 13 10 x 4 x x x x x 12]\n[x x x 18 8 4 x 11 x 14 18 x]\n[x 19 2 x 2 6 5 18 x 5 x x]\n[x 2 x 7 x x 8 7 x 11 16 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "4", "opt_solution": "[[3, 0], [4, 0], [5, 0], [5, 1], [5, 2], [6, 2], [7, 2], [7, 3], [7, 4], [7, 5], [8, 5], [9, 5], [10, 5], [10, 6], [10, 7], [9, 7]]", "opt_solution_cost": "119", "opt_solution_compute_t": "0.021150827407836914", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"16\", \"x\", \"5\", \"6\", \"x\", \"14\", \"12\", \"x\", \"x\", \"x\", \"6\", \"x\"], [\"17\", \"x\", \"x\", \"x\", \"5\", \"x\", \"5\", \"7\", \"x\", \"x\", \"8\", \"x\"], [\"3\", \"19\", \"x\", \"x\", \"x\", \"x\", \"18\", \"x\", \"13\", \"7\", \"x\", \"x\"], [\"13\", \"x\", \"4\", \"x\", \"x\", \"8\", \"7\", \"4\", \"x\", \"15\", \"x\", \"x\"], [\"5\", \"17\", \"18\", \"12\", \"3\", \"x\", \"14\", \"2\", \"4\", \"18\", \"x\", \"1\"], [\"4\", \"10\", \"1\", \"19\", \"10\", \"x\", \"x\", \"17\", \"x\", \"17\", \"16\", \"4\"], [\"7\", \"x\", \"16\", \"x\", \"x\", \"1\", \"3\", \"x\", \"13\", \"13\", \"x\", \"x\"], [\"x\", \"x\", \"9\", \"1\", \"7\", \"18\", \"16\", \"3\", \"x\", \"4\", \"x\", \"x\"], [\"2\", \"x\", \"13\", \"10\", \"x\", \"4\", \"x\", \"x\", \"x\", \"x\", \"x\", \"12\"], [\"x\", \"x\", \"x\", \"18\", \"8\", \"4\", \"x\", \"11\", \"x\", \"14\", \"18\", \"x\"], [\"x\", \"19\", \"2\", \"x\", \"2\", \"6\", \"5\", \"18\", \"x\", \"5\", \"x\", \"x\"], [\"x\", \"2\", \"x\", \"7\", \"x\", \"x\", \"8\", \"7\", \"x\", \"11\", \"16\", \"x\"]]]", "is_correct_args": "[[[\"16\", \"x\", \"5\", \"6\", \"x\", \"14\", \"12\", \"x\", \"x\", \"x\", \"6\", \"x\"], [\"17\", \"x\", \"x\", \"x\", \"5\", \"x\", \"5\", \"7\", \"x\", \"x\", \"8\", \"x\"], [\"3\", \"19\", \"x\", \"x\", \"x\", \"x\", \"18\", \"x\", \"13\", \"7\", \"x\", \"x\"], [\"13\", \"x\", \"4\", \"x\", \"x\", \"8\", \"7\", \"4\", \"x\", \"15\", \"x\", \"x\"], [\"5\", \"17\", \"18\", \"12\", \"3\", \"x\", \"14\", \"2\", \"4\", \"18\", \"x\", \"1\"], [\"4\", \"10\", \"1\", \"19\", \"10\", \"x\", \"x\", \"17\", \"x\", \"17\", \"16\", \"4\"], [\"7\", \"x\", \"16\", \"x\", \"x\", \"1\", \"3\", \"x\", \"13\", \"13\", \"x\", \"x\"], [\"x\", \"x\", \"9\", \"1\", \"7\", \"18\", \"16\", \"3\", \"x\", \"4\", \"x\", \"x\"], [\"2\", \"x\", \"13\", \"10\", \"x\", \"4\", \"x\", \"x\", \"x\", \"x\", \"x\", \"12\"], [\"x\", \"x\", \"x\", \"18\", \"8\", \"4\", \"x\", \"11\", \"x\", \"14\", \"18\", \"x\"], [\"x\", \"19\", \"2\", \"x\", \"2\", \"6\", \"5\", \"18\", \"x\", \"5\", \"x\", \"x\"], [\"x\", \"2\", \"x\", \"7\", \"x\", \"x\", \"8\", \"7\", \"x\", \"11\", \"16\", \"x\"]], [3, 0], [9, 7], 3, 8]", "A*_args": "[\"[['16', 'x', '5', '6', 'x', '14', '12', 'x', 'x', 'x', '6', 'x'], ['17', 'x', 'x', 'x', '5', 'x', '5', '7', 'x', 'x', '8', 'x'], ['3', '19', 'x', 'x', 'x', 'x', '18', 'x', '13', '7', 'x', 'x'], ['13', 'x', '4', 'x', 'x', '8', '7', '4', 'x', '15', 'x', 'x'], ['5', '17', '18', '12', '3', 'x', '14', '2', '4', '18', 'x', '1'], ['4', '10', '1', '19', '10', 'x', 'x', '17', 'x', '17', '16', '4'], ['7', 'x', '16', 'x', 'x', '1', '3', 'x', '13', '13', 'x', 'x'], ['x', 'x', '9', '1', '7', '18', '16', '3', 'x', '4', 'x', 'x'], ['2', 'x', '13', '10', 'x', '4', 'x', 'x', 'x', 'x', 'x', '12'], ['x', 'x', 'x', '18', '8', '4', 'x', '11', 'x', '14', '18', 'x'], ['x', '19', '2', 'x', '2', '6', '5', '18', 'x', '5', 'x', 'x'], ['x', '2', 'x', '7', 'x', 'x', '8', '7', 'x', '11', '16', 'x']]\", \"(3, 0)\", \"(9, 7)\", \"3\", \"8\"]"}
{"diff_sorted_id": "60", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 12x12. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (11, 7). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 1 1 0 1 1 1 0 1 1 0\n0 1 1 1 1 1 0 1 0 0 1 0\n1 0 1 1 0 0 1 1 1 1 0 0\n1 0 0 1 0 1 1 1 0 1 0 1\n0 1 0 1 1 0 0 0 0 1 0 1\n0 0 0 1 1 1 0 1 1 1 0 0\n1 1 0 0 1 1 0 1 0 0 1 1\n0 1 0 0 0 1 0 1 1 1 1 1\n1 0 0 0 0 1 0 0 1 1 1 0\n0 0 1 0 0 0 0 1 0 1 1 1\n0 1 0 0 1 1 0 0 1 1 1 0\n1 0 1 1 0 0 0 0 1 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "12", "opt_solution": "[[1, 0], [2, 1], [3, 1], [3, 2], [4, 2], [5, 2], [6, 2], [6, 3], [7, 3], [7, 4], [8, 4], [9, 5], [10, 6], [11, 7]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.02705216407775879", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0], [0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1], [0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0], [1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1], [0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1], [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]]\", 4]", "is_correct_args": "[\"[[0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0], [0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1], [0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0], [1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1], [0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1], [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]]\", [1, 0], [11, 7], 4]", "A*_args": "[\"[[0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0], [0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1], [0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0], [1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1], [0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1], [0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1]]\", \"(1, 0)\", \"(11, 7)\", \"4\"]"}
{"diff_sorted_id": "60", "problem_statement": "Given 5 labeled water jugs with capacities 78, 68, 49, 82, 77, 88 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 176, 189, 251, 285 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 77, 4], [\"+\", 77, 4], [\"+\", 49, 4], [\"+\", 82, 4], [\"+\", 68, 3], [\"+\", 68, 3], [\"+\", 82, 3], [\"-\", 49, 3], [\"+\", 82, 3], [\"+\", 68, 2], [\"+\", 82, 2], [\"-\", 49, 2], [\"+\", 88, 2], [\"+\", 88, 1], [\"+\", 88, 1]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.06066584587097168", "solution_depth": "15", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[78, 68, 49, 82, 77, 88], [176, 189, 251, 285]]", "is_correct_args": "[[78, 68, 49, 82, 77, 88], [176, 189, 251, 285]]", "A*_args": "[\"[78, 68, 49, 82, 77, 88]\", \"[176, 189, 251, 285]\"]"}
{"diff_sorted_id": "61", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[93, 83, 50, 21, 67], [59, '_', 60, 19, 8], [14, 12, 92, 54, 9]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[12, 92, 54, 9, 8, 19, 60, 12, 92, 54, 12, 50, 83, 92, 54, 12, 9, 8, 19, 60, 21, 67, 60, 19]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.06862807273864746", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[93, 83, 50, 21, 67], [59, \"_\", 60, 19, 8], [14, 12, 92, 54, 9]]]", "is_correct_args": "[[[93, 83, 50, 21, 67], [59, \"_\", 60, 19, 8], [14, 12, 92, 54, 9]]]", "A*_args": "[\"[[93, 83, 50, 21, 67], [59, '_', 60, 19, 8], [14, 12, 92, 54, 9]]\"]"}
{"diff_sorted_id": "61", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: aer, hume, mimp, viva, fiji   The initial board: [['u', 'a', '_', 'r'], ['h', 'e', 'm', 'e'], ['m', 'i', 'i', 'p'], ['v', 'a', 'v', 'j'], ['f', 'i', 'm', 'i']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"down-right\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-left\"]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.19978690147399902", "solution_depth": "12", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"u\", \"a\", \"_\", \"r\"], [\"h\", \"e\", \"m\", \"e\"], [\"m\", \"i\", \"i\", \"p\"], [\"v\", \"a\", \"v\", \"j\"], [\"f\", \"i\", \"m\", \"i\"]]]", "is_correct_args": "[[[\"u\", \"a\", \"_\", \"r\"], [\"h\", \"e\", \"m\", \"e\"], [\"m\", \"i\", \"i\", \"p\"], [\"v\", \"a\", \"v\", \"j\"], [\"f\", \"i\", \"m\", \"i\"]], [\"aer\", \"hume\", \"mimp\", \"viva\", \"fiji\"]]", "A*_args": "[\"[['u', 'a', '_', 'r'], ['h', 'e', 'm', 'e'], ['m', 'i', 'i', 'p'], ['v', 'a', 'v', 'j'], ['f', 'i', 'm', 'i']]\", \"['aer', 'hume', 'mimp', 'viva', 'fiji']\"]"}
{"diff_sorted_id": "61", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'J'. Our task is to visit city Z and city M excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from M and Z, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  J U X R L Z O F Q C N V M \nJ 0 0 0 0 0 0 0 0 0 0 1 0 0 \nU 0 0 0 1 1 1 0 0 0 0 0 0 1 \nX 1 1 0 0 0 0 0 0 0 0 1 1 1 \nR 0 0 0 0 0 0 0 0 1 1 0 0 0 \nL 0 0 0 1 0 1 1 0 0 0 0 0 0 \nZ 0 0 0 0 0 0 1 1 0 0 0 0 1 \nO 0 0 1 0 0 1 0 0 0 0 0 0 0 \nF 0 1 0 0 0 0 0 0 1 0 0 1 0 \nQ 0 1 1 0 1 0 1 0 0 0 0 1 0 \nC 0 0 0 0 0 1 0 1 1 0 0 0 1 \nN 0 1 0 1 1 1 1 0 0 0 0 1 0 \nV 1 1 0 0 1 1 0 0 1 0 0 0 1 \nM 0 0 0 1 0 0 0 1 0 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[\"J\", \"N\", \"Z\", \"M\", \"F\", \"U\", \"Z\", \"M\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.040180206298828125", "solution_depth": "8", "max_successor_states": "13", "num_vars_per_state": "16", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]], [\"J\", \"U\", \"X\", \"R\", \"L\", \"Z\", \"O\", \"F\", \"Q\", \"C\", \"N\", \"V\", \"M\"], \"Z\", \"M\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]], [\"J\", \"U\", \"X\", \"R\", \"L\", \"Z\", \"O\", \"F\", \"Q\", \"C\", \"N\", \"V\", \"M\"], \"J\", \"Z\", \"M\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]]\", \"['J', 'U', 'X', 'R', 'L', 'Z', 'O', 'F', 'Q', 'C', 'N', 'V', 'M']\", \"['J']\", \"['Z', 'M']\"]"}
{"diff_sorted_id": "61", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [30, 4, 10, 25, 2, 20, 23, 22, 29, 13, 21, 23, 23, 24, 3, 26, 29, 27, 15, 18, 28, 10, 22, 24, 2, 22, 13, 32, 8, 28, 31, 13, 27, 6, 35, 2, 20, 25, 24, 2, 16, 31, 3, 5, 23, 32, 24, 20, 13, 7, 11, 12], such that the sum of the chosen coins adds up to 351. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {10: 8, 32: 8, 25: 5, 7: 2, 30: 9, 18: 3, 5: 2, 35: 14, 2: 1, 15: 10, 12: 6, 29: 14, 23: 12, 31: 14, 11: 3, 8: 7, 21: 5, 13: 3, 28: 3, 6: 1, 3: 2, 4: 2, 22: 5, 16: 9, 24: 4, 27: 16, 26: 6, 20: 20}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "33", "opt_solution": "[28, 24, 18, 21, 25, 24, 25, 24, 6, 13, 13, 13, 35, 28, 26, 24, 4]", "opt_solution_cost": "72", "opt_solution_compute_t": "0.058156728744506836", "solution_depth": "17", "max_successor_states": "52", "num_vars_per_state": "52", "is_feasible_args": "[[30, 4, 10, 25, 2, 20, 23, 22, 29, 13, 21, 23, 23, 24, 3, 26, 29, 27, 15, 18, 28, 10, 22, 24, 2, 22, 13, 32, 8, 28, 31, 13, 27, 6, 35, 2, 20, 25, 24, 2, 16, 31, 3, 5, 23, 32, 24, 20, 13, 7, 11, 12]]", "is_correct_args": "[[30, 4, 10, 25, 2, 20, 23, 22, 29, 13, 21, 23, 23, 24, 3, 26, 29, 27, 15, 18, 28, 10, 22, 24, 2, 22, 13, 32, 8, 28, 31, 13, 27, 6, 35, 2, 20, 25, 24, 2, 16, 31, 3, 5, 23, 32, 24, 20, 13, 7, 11, 12], {\"10\": 8, \"32\": 8, \"25\": 5, \"7\": 2, \"30\": 9, \"18\": 3, \"5\": 2, \"35\": 14, \"2\": 1, \"15\": 10, \"12\": 6, \"29\": 14, \"23\": 12, \"31\": 14, \"11\": 3, \"8\": 7, \"21\": 5, \"13\": 3, \"28\": 3, \"6\": 1, \"3\": 2, \"4\": 2, \"22\": 5, \"16\": 9, \"24\": 4, \"27\": 16, \"26\": 6, \"20\": 20}, 351]", "A*_args": "[\"[30, 4, 10, 25, 2, 20, 23, 22, 29, 13, 21, 23, 23, 24, 3, 26, 29, 27, 15, 18, 28, 10, 22, 24, 2, 22, 13, 32, 8, 28, 31, 13, 27, 6, 35, 2, 20, 25, 24, 2, 16, 31, 3, 5, 23, 32, 24, 20, 13, 7, 11, 12]\", \"{10: 8, 32: 8, 25: 5, 7: 2, 30: 9, 18: 3, 5: 2, 35: 14, 2: 1, 15: 10, 12: 6, 29: 14, 23: 12, 31: 14, 11: 3, 8: 7, 21: 5, 13: 3, 28: 3, 6: 1, 3: 2, 4: 2, 22: 5, 16: 9, 24: 4, 27: 16, 26: 6, 20: 20}\", \"351\"]"}
{"diff_sorted_id": "61", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Green', 'Red', 'Blue'], ['Red', 'Blue', 'Green', 'Red', 'Green'], ['Green', 'Blue', 'Blue', 'Blue', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[1, 0], [1, 0], [1, 2], [1, 0], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [0, 2], [0, 1], [0, 2], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [2, 0], [2, 1], [2, 1], [0, 2]]", "opt_solution_cost": "24", "opt_solution_compute_t": "50.06358861923218", "solution_depth": "24", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Red\", \"Green\", \"Green\", \"Red\", \"Blue\"], [\"Red\", \"Blue\", \"Green\", \"Red\", \"Green\"], [\"Green\", \"Blue\", \"Blue\", \"Blue\", \"Red\"]], 8]", "is_correct_args": "[[[\"Red\", \"Green\", \"Green\", \"Red\", \"Blue\"], [\"Red\", \"Blue\", \"Green\", \"Red\", \"Green\"], [\"Green\", \"Blue\", \"Blue\", \"Blue\", \"Red\"]], 8]", "A*_args": "[\"[['Red', 'Green', 'Green', 'Red', 'Blue'], ['Red', 'Blue', 'Green', 'Red', 'Green'], ['Green', 'Blue', 'Blue', 'Blue', 'Red']]\", \"8\"]"}
{"diff_sorted_id": "61", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 36 to 81 (36 included in the range but 81 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' '46' 'x']\n ['x' '57' '59' '70']\n ['56' 'x' '69' '73']\n ['57' '75' 'x' '80']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "11", "opt_solution": "[[0, 2, 71], [0, 3, 76], [1, 2, 68], [2, 2, 65], [2, 3, 67], [3, 1, 49]]", "opt_solution_cost": "796", "opt_solution_compute_t": "0.5532352924346924", "solution_depth": "6", "max_successor_states": "45", "num_vars_per_state": "16", "is_feasible_args": "[\"[['69', '70', '', ''], ['64', '66', '', '75'], ['62', '64', '', ''], ['60', '', '48', '46']]\", 41, 86]", "is_correct_args": "[\"[['69', '70', '', ''], ['64', '66', '', '75'], ['62', '64', '', ''], ['60', '', '48', '46']]\", 41, 86]", "A*_args": "[\"[['69', '70', '', ''], ['64', '66', '', '75'], ['62', '64', '', ''], ['60', '', '48', '46']]\", \"41\", \"86\"]"}
{"diff_sorted_id": "61", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 23 to 54. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 135, 149, None for columns 1 to 2 respectively, and the sums of rows must be None, 156, 156, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 149. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '31' 'x' 'x']\n ['x' 'x' 'x' 'x']\n ['x' 'x' '42' 'x']\n ['x' '49' '30' '27']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 25], [0, 2, 24], [0, 3, 26], [1, 0, 28], [1, 1, 23], [1, 2, 53], [1, 3, 52], [2, 0, 34], [2, 1, 32], [2, 3, 48], [3, 0, 38]]", "opt_solution_cost": "562", "opt_solution_compute_t": "323.3269555568695", "solution_depth": "11", "max_successor_states": "26", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '31', '', ''], ['', '', '', ''], ['', '', '42', ''], ['', '49', '30', '27']]\", 4, 23, 54]", "is_correct_args": "[\"[['', '31', '', ''], ['', '', '', ''], ['', '', '42', ''], ['', '49', '30', '27']]\", 23, 54, [1, 3], [1, 3], [135, 149], [156, 156], 149]", "A*_args": "[\"[['', '31', '', ''], ['', '', '', ''], ['', '', '42', ''], ['', '49', '30', '27']]\", \"23\", \"54\", \"[None, 135, 149, None]\", \"[None, 156, 156, None]\", \"149\"]"}
{"diff_sorted_id": "61", "problem_statement": "In 'Restricted Sorting', there are 10 stacks each with a capacity of 6 blocks, with 5 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 5 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 7, 1: 11, 2: 8, 3: 10, 4: 5, 5: 6, 6: 10, 7: 10, 8: 4, 9: 11}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], ['Green', 'Red', 'White', 'Green', 'Black', 'White'], [], ['Red', 'Red', 'Yellow', 'White', 'Blue', 'Black'], ['Blue', 'Yellow', 'Red', 'Blue', 'Blue', 'Green'], [], [], ['Black', 'White', 'Black', 'White', 'Yellow', 'Blue'], ['Yellow', 'Black', 'Green', 'Red', 'Green', 'Yellow']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "3", "opt_solution": "[[2, 0], [2, 3], [8, 6], [9, 7], [9, 6], [9, 0], [9, 3], [9, 0], [4, 3], [4, 3], [4, 7], [4, 1], [9, 7], [4, 9], [4, 6], [2, 4], [2, 0], [2, 6], [2, 4], [8, 4], [8, 2], [8, 4], [8, 7], [5, 8], [5, 7], [5, 3], [5, 8], [5, 8], [2, 6], [5, 0], [1, 4], [9, 8]]", "opt_solution_cost": "256", "opt_solution_compute_t": "0.2655496597290039", "solution_depth": "32", "max_successor_states": "90", "num_vars_per_state": "30", "is_feasible_args": "[[[], [], [\"Green\", \"Red\", \"White\", \"Green\", \"Black\", \"White\"], [], [\"Red\", \"Red\", \"Yellow\", \"White\", \"Blue\", \"Black\"], [\"Blue\", \"Yellow\", \"Red\", \"Blue\", \"Blue\", \"Green\"], [], [], [\"Black\", \"White\", \"Black\", \"White\", \"Yellow\", \"Blue\"], [\"Yellow\", \"Black\", \"Green\", \"Red\", \"Green\", \"Yellow\"]], 6, {\"0\": 7, \"1\": 11, \"2\": 8, \"3\": 10, \"4\": 5, \"5\": 6, \"6\": 10, \"7\": 10, \"8\": 4, \"9\": 11}]", "is_correct_args": "[[[], [], [\"Green\", \"Red\", \"White\", \"Green\", \"Black\", \"White\"], [], [\"Red\", \"Red\", \"Yellow\", \"White\", \"Blue\", \"Black\"], [\"Blue\", \"Yellow\", \"Red\", \"Blue\", \"Blue\", \"Green\"], [], [], [\"Black\", \"White\", \"Black\", \"White\", \"Yellow\", \"Blue\"], [\"Yellow\", \"Black\", \"Green\", \"Red\", \"Green\", \"Yellow\"]], 6, {\"0\": 7, \"1\": 11, \"2\": 8, \"3\": 10, \"4\": 5, \"5\": 6, \"6\": 10, \"7\": 10, \"8\": 4, \"9\": 11}, 5]", "A*_args": "[\"[[], [], ['Green', 'Red', 'White', 'Green', 'Black', 'White'], [], ['Red', 'Red', 'Yellow', 'White', 'Blue', 'Black'], ['Blue', 'Yellow', 'Red', 'Blue', 'Blue', 'Green'], [], [], ['Black', 'White', 'Black', 'White', 'Yellow', 'Blue'], ['Yellow', 'Black', 'Green', 'Red', 'Green', 'Yellow']]\", \"{0: 7, 1: 11, 2: 8, 3: 10, 4: 5, 5: 6, 6: 10, 7: 10, 8: 4, 9: 11}\", \"6\", \"5\"]"}
{"diff_sorted_id": "61", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 12) to his destination workshop at index (6, 2), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 5, and district 3 covering rows 6 to 12. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[13 13 16 8 x 19 1 18 13 8 x 7 x]\n[x 13 x 15 x 12 20 1 13 19 4 17 x]\n[x 12 9 11 13 12 2 12 19 5 19 16 8]\n[x 12 18 19 x 7 x 12 3 2 x 16 11]\n[x 7 x x 8 13 15 3 1 x 15 15 x]\n[11 9 x 16 2 10 1 2 16 1 x 10 12]\n[x x 9 9 7 x 6 x x 10 7 2 x]\n[x 13 10 8 1 11 x x x x x x x]\n[11 14 x x x x 4 8 x x 18 x x]\n[13 14 x 10 x x 16 x x x x x x]\n[x x 16 x 10 x 17 x 12 x 10 x 5]\n[9 x 10 x 19 16 x 14 16 12 15 7 x]\n[1 x 8 10 14 x 6 9 x x 8 11 11]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "5", "opt_solution": "[[3, 12], [2, 12], [2, 11], [1, 11], [1, 10], [1, 9], [2, 9], [3, 9], [3, 8], [4, 8], [4, 7], [5, 7], [5, 6], [5, 5], [5, 4], [6, 4], [6, 3], [6, 2]]", "opt_solution_cost": "118", "opt_solution_compute_t": "0.02977895736694336", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"13\", \"13\", \"16\", \"8\", \"x\", \"19\", \"1\", \"18\", \"13\", \"8\", \"x\", \"7\", \"x\"], [\"x\", \"13\", \"x\", \"15\", \"x\", \"12\", \"20\", \"1\", \"13\", \"19\", \"4\", \"17\", \"x\"], [\"x\", \"12\", \"9\", \"11\", \"13\", \"12\", \"2\", \"12\", \"19\", \"5\", \"19\", \"16\", \"8\"], [\"x\", \"12\", \"18\", \"19\", \"x\", \"7\", \"x\", \"12\", \"3\", \"2\", \"x\", \"16\", \"11\"], [\"x\", \"7\", \"x\", \"x\", \"8\", \"13\", \"15\", \"3\", \"1\", \"x\", \"15\", \"15\", \"x\"], [\"11\", \"9\", \"x\", \"16\", \"2\", \"10\", \"1\", \"2\", \"16\", \"1\", \"x\", \"10\", \"12\"], [\"x\", \"x\", \"9\", \"9\", \"7\", \"x\", \"6\", \"x\", \"x\", \"10\", \"7\", \"2\", \"x\"], [\"x\", \"13\", \"10\", \"8\", \"1\", \"11\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"11\", \"14\", \"x\", \"x\", \"x\", \"x\", \"4\", \"8\", \"x\", \"x\", \"18\", \"x\", \"x\"], [\"13\", \"14\", \"x\", \"10\", \"x\", \"x\", \"16\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"16\", \"x\", \"10\", \"x\", \"17\", \"x\", \"12\", \"x\", \"10\", \"x\", \"5\"], [\"9\", \"x\", \"10\", \"x\", \"19\", \"16\", \"x\", \"14\", \"16\", \"12\", \"15\", \"7\", \"x\"], [\"1\", \"x\", \"8\", \"10\", \"14\", \"x\", \"6\", \"9\", \"x\", \"x\", \"8\", \"11\", \"11\"]]]", "is_correct_args": "[[[\"13\", \"13\", \"16\", \"8\", \"x\", \"19\", \"1\", \"18\", \"13\", \"8\", \"x\", \"7\", \"x\"], [\"x\", \"13\", \"x\", \"15\", \"x\", \"12\", \"20\", \"1\", \"13\", \"19\", \"4\", \"17\", \"x\"], [\"x\", \"12\", \"9\", \"11\", \"13\", \"12\", \"2\", \"12\", \"19\", \"5\", \"19\", \"16\", \"8\"], [\"x\", \"12\", \"18\", \"19\", \"x\", \"7\", \"x\", \"12\", \"3\", \"2\", \"x\", \"16\", \"11\"], [\"x\", \"7\", \"x\", \"x\", \"8\", \"13\", \"15\", \"3\", \"1\", \"x\", \"15\", \"15\", \"x\"], [\"11\", \"9\", \"x\", \"16\", \"2\", \"10\", \"1\", \"2\", \"16\", \"1\", \"x\", \"10\", \"12\"], [\"x\", \"x\", \"9\", \"9\", \"7\", \"x\", \"6\", \"x\", \"x\", \"10\", \"7\", \"2\", \"x\"], [\"x\", \"13\", \"10\", \"8\", \"1\", \"11\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"11\", \"14\", \"x\", \"x\", \"x\", \"x\", \"4\", \"8\", \"x\", \"x\", \"18\", \"x\", \"x\"], [\"13\", \"14\", \"x\", \"10\", \"x\", \"x\", \"16\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"16\", \"x\", \"10\", \"x\", \"17\", \"x\", \"12\", \"x\", \"10\", \"x\", \"5\"], [\"9\", \"x\", \"10\", \"x\", \"19\", \"16\", \"x\", \"14\", \"16\", \"12\", \"15\", \"7\", \"x\"], [\"1\", \"x\", \"8\", \"10\", \"14\", \"x\", \"6\", \"9\", \"x\", \"x\", \"8\", \"11\", \"11\"]], [3, 12], [6, 2], 1, 5]", "A*_args": "[\"[['13', '13', '16', '8', 'x', '19', '1', '18', '13', '8', 'x', '7', 'x'], ['x', '13', 'x', '15', 'x', '12', '20', '1', '13', '19', '4', '17', 'x'], ['x', '12', '9', '11', '13', '12', '2', '12', '19', '5', '19', '16', '8'], ['x', '12', '18', '19', 'x', '7', 'x', '12', '3', '2', 'x', '16', '11'], ['x', '7', 'x', 'x', '8', '13', '15', '3', '1', 'x', '15', '15', 'x'], ['11', '9', 'x', '16', '2', '10', '1', '2', '16', '1', 'x', '10', '12'], ['x', 'x', '9', '9', '7', 'x', '6', 'x', 'x', '10', '7', '2', 'x'], ['x', '13', '10', '8', '1', '11', 'x', 'x', 'x', 'x', 'x', 'x', 'x'], ['11', '14', 'x', 'x', 'x', 'x', '4', '8', 'x', 'x', '18', 'x', 'x'], ['13', '14', 'x', '10', 'x', 'x', '16', 'x', 'x', 'x', 'x', 'x', 'x'], ['x', 'x', '16', 'x', '10', 'x', '17', 'x', '12', 'x', '10', 'x', '5'], ['9', 'x', '10', 'x', '19', '16', 'x', '14', '16', '12', '15', '7', 'x'], ['1', 'x', '8', '10', '14', 'x', '6', '9', 'x', 'x', '8', '11', '11']]\", \"(3, 12)\", \"(6, 2)\", \"1\", \"5\"]"}
{"diff_sorted_id": "61", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 13x13. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 11) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (7, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 1 0 1 0 0 1 0 0 0 0\n0 1 1 0 1 0 1 1 1 1 0 0 1\n1 1 1 1 1 1 1 0 1 0 0 1 1\n0 1 0 0 0 1 0 1 1 0 0 0 1\n1 1 0 1 0 0 0 0 0 1 1 1 0\n1 0 1 0 1 0 0 0 0 0 1 0 1\n1 0 0 0 1 1 1 0 1 0 1 0 1\n0 0 0 0 0 0 1 0 0 1 0 1 1\n0 1 0 0 0 0 0 0 1 0 0 0 0\n0 0 0 0 1 0 1 0 0 1 0 0 0\n0 0 1 1 0 1 0 0 0 1 1 0 1\n1 0 1 1 0 1 1 1 1 0 0 1 1\n0 0 1 0 1 1 1 1 1 0 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[[0, 11], [0, 10], [1, 10], [2, 9], [3, 9], [4, 8], [4, 7], [4, 6], [4, 5], [4, 4], [5, 3], [6, 2], [6, 1], [7, 1]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.03135824203491211", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1], [0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0], [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1], [0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]]\", 4]", "is_correct_args": "[\"[[1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1], [0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0], [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1], [0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]]\", [0, 11], [7, 1], 4]", "A*_args": "[\"[[1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1], [0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0], [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1], [0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1]]\", \"(0, 11)\", \"(7, 1)\", \"4\"]"}
{"diff_sorted_id": "61", "problem_statement": "Given 5 labeled water jugs with capacities 56, 92, 66, 85, 65, 136 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 209, 293, 326, 379 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 66, 4], [\"+\", 85, 4], [\"+\", 92, 4], [\"+\", 136, 4], [\"+\", 85, 3], [\"+\", 85, 3], [\"+\", 136, 3], [\"-\", 65, 3], [\"+\", 85, 3], [\"+\", 65, 2], [\"+\", 92, 2], [\"+\", 136, 2], [\"+\", 66, 1], [\"+\", 92, 1], [\"-\", 85, 1], [\"+\", 136, 1]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.05174422264099121", "solution_depth": "16", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[56, 92, 66, 85, 65, 136], [209, 293, 326, 379]]", "is_correct_args": "[[56, 92, 66, 85, 65, 136], [209, 293, 326, 379]]", "A*_args": "[\"[56, 92, 66, 85, 65, 136]\", \"[209, 293, 326, 379]\"]"}
{"diff_sorted_id": "62", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[87, 49, 79, 68, '_'], [56, 19, 64, 37, 7], [27, 15, 41, 35, 78]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[68, 37, 7, 78, 35, 7, 78, 68, 37, 78, 64, 41, 15, 19, 49, 79, 78, 37, 68, 64, 37, 68, 64, 35]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.16290855407714844", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[87, 49, 79, 68, \"_\"], [56, 19, 64, 37, 7], [27, 15, 41, 35, 78]]]", "is_correct_args": "[[[87, 49, 79, 68, \"_\"], [56, 19, 64, 37, 7], [27, 15, 41, 35, 78]]]", "A*_args": "[\"[[87, 49, 79, 68, '_'], [56, 19, 64, 37, 7], [27, 15, 41, 35, 78]]\"]"}
{"diff_sorted_id": "62", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: man, cute, dazy, down, oryx   The initial board: [['u', 'm', 'a', 'n'], ['c', 'd', 't', 'e'], ['o', 'a', '_', 'y'], ['d', 'n', 'w', 'y'], ['o', 'r', 'z', 'x']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.20729756355285645", "solution_depth": "8", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"u\", \"m\", \"a\", \"n\"], [\"c\", \"d\", \"t\", \"e\"], [\"o\", \"a\", \"_\", \"y\"], [\"d\", \"n\", \"w\", \"y\"], [\"o\", \"r\", \"z\", \"x\"]]]", "is_correct_args": "[[[\"u\", \"m\", \"a\", \"n\"], [\"c\", \"d\", \"t\", \"e\"], [\"o\", \"a\", \"_\", \"y\"], [\"d\", \"n\", \"w\", \"y\"], [\"o\", \"r\", \"z\", \"x\"]], [\"man\", \"cute\", \"dazy\", \"down\", \"oryx\"]]", "A*_args": "[\"[['u', 'm', 'a', 'n'], ['c', 'd', 't', 'e'], ['o', 'a', '_', 'y'], ['d', 'n', 'w', 'y'], ['o', 'r', 'z', 'x']]\", \"['man', 'cute', 'dazy', 'down', 'oryx']\"]"}
{"diff_sorted_id": "62", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'K'. Our task is to visit city U and city Y excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from Y and U, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  Z C M X N A B L U K G Y O \nZ 0 0 0 1 1 0 1 1 1 1 0 0 0 \nC 1 0 1 1 0 1 0 0 0 0 0 1 1 \nM 0 0 0 0 1 1 1 0 0 0 0 1 0 \nX 0 0 1 0 0 0 0 1 0 0 1 0 1 \nN 1 1 0 0 0 0 1 0 0 0 0 0 0 \nA 1 0 1 0 0 0 1 0 0 0 0 0 0 \nB 0 1 0 0 0 0 0 1 0 1 0 1 0 \nL 0 0 0 0 0 0 0 0 1 0 1 0 0 \nU 1 0 1 0 0 0 0 0 0 1 0 0 1 \nK 0 0 0 1 1 1 0 0 0 0 0 0 0 \nG 1 0 0 1 1 1 1 1 0 0 0 1 0 \nY 0 0 0 0 1 0 1 0 0 0 0 0 0 \nO 1 1 0 0 0 0 1 0 1 0 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[\"K\", \"A\", \"Z\", \"U\", \"O\", \"U\", \"M\", \"Y\", \"B\", \"Y\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.049027204513549805", "solution_depth": "10", "max_successor_states": "13", "num_vars_per_state": "16", "is_feasible_args": "[[[0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0], [1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0]], [\"Z\", \"C\", \"M\", \"X\", \"N\", \"A\", \"B\", \"L\", \"U\", \"K\", \"G\", \"Y\", \"O\"], \"U\", \"Y\"]", "is_correct_args": "[[[0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0], [1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0]], [\"Z\", \"C\", \"M\", \"X\", \"N\", \"A\", \"B\", \"L\", \"U\", \"K\", \"G\", \"Y\", \"O\"], \"K\", \"U\", \"Y\"]", "A*_args": "[\"[[0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0], [1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0]]\", \"['Z', 'C', 'M', 'X', 'N', 'A', 'B', 'L', 'U', 'K', 'G', 'Y', 'O']\", \"['K']\", \"['U', 'Y']\"]"}
{"diff_sorted_id": "62", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [35, 14, 9, 23, 25, 24, 21, 20, 12, 17, 12, 5, 2, 17, 25, 25, 26, 31, 7, 21, 10, 2, 27, 19, 32, 29, 11, 33, 3, 27, 17, 3, 18, 14, 2, 32, 14, 21, 12, 8, 3, 34, 13, 12, 2, 23, 13, 3, 3, 31, 23, 23, 6, 30, 30, 11, 21], such that the sum of the chosen coins adds up to 356. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {3: 1, 32: 16, 6: 5, 20: 13, 13: 5, 31: 9, 23: 10, 35: 14, 24: 17, 11: 11, 9: 1, 12: 10, 5: 3, 8: 5, 34: 11, 17: 16, 25: 9, 26: 6, 30: 17, 27: 17, 7: 2, 18: 17, 33: 5, 14: 2, 29: 14, 10: 3, 2: 2, 21: 12, 19: 9}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "34", "opt_solution": "[7, 9, 33, 14, 31, 26, 14, 31, 14, 25, 25, 25, 35, 34, 10, 23]", "opt_solution_cost": "103", "opt_solution_compute_t": "0.07300186157226562", "solution_depth": "16", "max_successor_states": "57", "num_vars_per_state": "57", "is_feasible_args": "[[35, 14, 9, 23, 25, 24, 21, 20, 12, 17, 12, 5, 2, 17, 25, 25, 26, 31, 7, 21, 10, 2, 27, 19, 32, 29, 11, 33, 3, 27, 17, 3, 18, 14, 2, 32, 14, 21, 12, 8, 3, 34, 13, 12, 2, 23, 13, 3, 3, 31, 23, 23, 6, 30, 30, 11, 21]]", "is_correct_args": "[[35, 14, 9, 23, 25, 24, 21, 20, 12, 17, 12, 5, 2, 17, 25, 25, 26, 31, 7, 21, 10, 2, 27, 19, 32, 29, 11, 33, 3, 27, 17, 3, 18, 14, 2, 32, 14, 21, 12, 8, 3, 34, 13, 12, 2, 23, 13, 3, 3, 31, 23, 23, 6, 30, 30, 11, 21], {\"3\": 1, \"32\": 16, \"6\": 5, \"20\": 13, \"13\": 5, \"31\": 9, \"23\": 10, \"35\": 14, \"24\": 17, \"11\": 11, \"9\": 1, \"12\": 10, \"5\": 3, \"8\": 5, \"34\": 11, \"17\": 16, \"25\": 9, \"26\": 6, \"30\": 17, \"27\": 17, \"7\": 2, \"18\": 17, \"33\": 5, \"14\": 2, \"29\": 14, \"10\": 3, \"2\": 2, \"21\": 12, \"19\": 9}, 356]", "A*_args": "[\"[35, 14, 9, 23, 25, 24, 21, 20, 12, 17, 12, 5, 2, 17, 25, 25, 26, 31, 7, 21, 10, 2, 27, 19, 32, 29, 11, 33, 3, 27, 17, 3, 18, 14, 2, 32, 14, 21, 12, 8, 3, 34, 13, 12, 2, 23, 13, 3, 3, 31, 23, 23, 6, 30, 30, 11, 21]\", \"{3: 1, 32: 16, 6: 5, 20: 13, 13: 5, 31: 9, 23: 10, 35: 14, 24: 17, 11: 11, 9: 1, 12: 10, 5: 3, 8: 5, 34: 11, 17: 16, 25: 9, 26: 6, 30: 17, 27: 17, 7: 2, 18: 17, 33: 5, 14: 2, 29: 14, 10: 3, 2: 2, 21: 12, 19: 9}\", \"356\"]"}
{"diff_sorted_id": "62", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Green', 'Blue', 'Green'], ['Red', 'Blue', 'Green', 'Blue', 'Green'], ['Red', 'Blue', 'Red', 'Red', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[2, 1], [2, 0], [1, 2], [1, 2], [1, 0], [1, 2], [1, 0], [1, 2], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 2], [1, 0], [1, 0], [2, 1], [2, 0], [2, 0]]", "opt_solution_cost": "20", "opt_solution_compute_t": "7.412998199462891", "solution_depth": "20", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Green\", \"Blue\", \"Green\"], [\"Red\", \"Blue\", \"Green\", \"Blue\", \"Green\"], [\"Red\", \"Blue\", \"Red\", \"Red\", \"Red\"]], 8]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Green\", \"Blue\", \"Green\"], [\"Red\", \"Blue\", \"Green\", \"Blue\", \"Green\"], [\"Red\", \"Blue\", \"Red\", \"Red\", \"Red\"]], 8]", "A*_args": "[\"[['Blue', 'Green', 'Green', 'Blue', 'Green'], ['Red', 'Blue', 'Green', 'Blue', 'Green'], ['Red', 'Blue', 'Red', 'Red', 'Red']]\", \"8\"]"}
{"diff_sorted_id": "62", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 41 to 86 (41 included in the range but 86 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['69' '70' 'x' 'x']\n ['64' '66' 'x' '75']\n ['62' '64' 'x' 'x']\n ['60' 'x' '48' '46']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "11", "opt_solution": "[[0, 2, 38], [1, 2, 53], [2, 0, 45], [3, 0, 46], [3, 1, 54], [3, 3, 66]]", "opt_solution_cost": "629", "opt_solution_compute_t": "24.031245946884155", "solution_depth": "6", "max_successor_states": "45", "num_vars_per_state": "16", "is_feasible_args": "[\"[['33', '37', '', '58'], ['44', '51', '', '63'], ['', '52', '62', '64'], ['', '', '65', '']]\", 33, 78]", "is_correct_args": "[\"[['33', '37', '', '58'], ['44', '51', '', '63'], ['', '52', '62', '64'], ['', '', '65', '']]\", 33, 78]", "A*_args": "[\"[['33', '37', '', '58'], ['44', '51', '', '63'], ['', '52', '62', '64'], ['', '', '65', '']]\", \"33\", \"78\"]"}
{"diff_sorted_id": "62", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 30 to 66. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 199, 194, None for columns 1 to 2 respectively, and the sums of rows must be None, 164, 210, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 197. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x' 'x']\n ['40' '39' '32' '53']\n ['46' 'x' '58' 'x']\n ['x' 'x' '43' '51']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 30], [0, 1, 31], [0, 2, 61], [0, 3, 37], [2, 1, 65], [2, 3, 41], [3, 0, 63], [3, 1, 64]]", "opt_solution_cost": "754", "opt_solution_compute_t": "73.30463027954102", "solution_depth": "8", "max_successor_states": "26", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '', ''], ['40', '39', '32', '53'], ['46', '', '58', ''], ['', '', '43', '51']]\", 4, 30, 66]", "is_correct_args": "[\"[['', '', '', ''], ['40', '39', '32', '53'], ['46', '', '58', ''], ['', '', '43', '51']]\", 30, 66, [1, 3], [1, 3], [199, 194], [164, 210], 197]", "A*_args": "[\"[['', '', '', ''], ['40', '39', '32', '53'], ['46', '', '58', ''], ['', '', '43', '51']]\", \"30\", \"66\", \"[None, 199, 194, None]\", \"[None, 164, 210, None]\", \"197\"]"}
{"diff_sorted_id": "62", "problem_statement": "In 'Restricted Sorting', there are 10 stacks each with a capacity of 6 blocks, with 5 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 5 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 6, 1: 10, 2: 8, 3: 3, 4: 5, 5: 7, 6: 10, 7: 6, 8: 3, 9: 8}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], ['Blue', 'Yellow', 'Red', 'Black', 'White', 'Blue'], ['Blue', 'Green', 'Yellow', 'Red', 'Red', 'White'], [], ['Red', 'Black', 'White', 'Yellow', 'White', 'Green'], [], ['Black', 'Yellow', 'Green', 'Black', 'Black', 'Blue'], [], ['Red', 'Green', 'Green', 'Blue', 'Yellow', 'White']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "3", "opt_solution": "[[5, 8], [9, 8], [3, 4], [3, 0], [9, 0], [9, 0], [9, 4], [3, 1], [3, 8], [3, 8], [5, 6], [9, 1], [2, 4], [9, 3], [2, 9], [2, 8], [5, 3], [5, 9], [5, 3], [5, 0], [2, 5], [2, 3], [7, 5], [7, 9], [7, 0], [7, 5], [7, 5], [1, 9], [1, 9], [6, 5], [2, 4], [7, 4]]", "opt_solution_cost": "187", "opt_solution_compute_t": "0.27761077880859375", "solution_depth": "32", "max_successor_states": "90", "num_vars_per_state": "30", "is_feasible_args": "[[[], [], [\"Blue\", \"Yellow\", \"Red\", \"Black\", \"White\", \"Blue\"], [\"Blue\", \"Green\", \"Yellow\", \"Red\", \"Red\", \"White\"], [], [\"Red\", \"Black\", \"White\", \"Yellow\", \"White\", \"Green\"], [], [\"Black\", \"Yellow\", \"Green\", \"Black\", \"Black\", \"Blue\"], [], [\"Red\", \"Green\", \"Green\", \"Blue\", \"Yellow\", \"White\"]], 6, {\"0\": 6, \"1\": 10, \"2\": 8, \"3\": 3, \"4\": 5, \"5\": 7, \"6\": 10, \"7\": 6, \"8\": 3, \"9\": 8}]", "is_correct_args": "[[[], [], [\"Blue\", \"Yellow\", \"Red\", \"Black\", \"White\", \"Blue\"], [\"Blue\", \"Green\", \"Yellow\", \"Red\", \"Red\", \"White\"], [], [\"Red\", \"Black\", \"White\", \"Yellow\", \"White\", \"Green\"], [], [\"Black\", \"Yellow\", \"Green\", \"Black\", \"Black\", \"Blue\"], [], [\"Red\", \"Green\", \"Green\", \"Blue\", \"Yellow\", \"White\"]], 6, {\"0\": 6, \"1\": 10, \"2\": 8, \"3\": 3, \"4\": 5, \"5\": 7, \"6\": 10, \"7\": 6, \"8\": 3, \"9\": 8}, 5]", "A*_args": "[\"[[], [], ['Blue', 'Yellow', 'Red', 'Black', 'White', 'Blue'], ['Blue', 'Green', 'Yellow', 'Red', 'Red', 'White'], [], ['Red', 'Black', 'White', 'Yellow', 'White', 'Green'], [], ['Black', 'Yellow', 'Green', 'Black', 'Black', 'Blue'], [], ['Red', 'Green', 'Green', 'Blue', 'Yellow', 'White']]\", \"{0: 6, 1: 10, 2: 8, 3: 3, 4: 5, 5: 7, 6: 10, 7: 6, 8: 3, 9: 8}\", \"6\", \"5\"]"}
{"diff_sorted_id": "62", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (8, 2) to his destination workshop at index (2, 9), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 7, and district 3 covering rows 8 to 12. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[5 15 15 5 6 19 x 9 2 x 16 x 15]\n[16 x x 7 5 x x x 5 2 19 x 3]\n[x 11 2 19 17 5 11 6 3 18 15 16 x]\n[2 x 12 x 20 11 7 19 2 x 4 14 x]\n[3 x 19 x 11 19 x 14 x 12 x 18 7]\n[6 x 5 8 3 12 12 11 5 14 x 6 x]\n[x x 13 2 x 20 x x x 18 18 x 3]\n[x x 13 1 10 18 x x x x 10 x 15]\n[10 x 9 2 17 19 16 8 x 18 10 x 13]\n[x x 2 8 2 7 x 17 x 1 x 9 x]\n[x 13 x 19 15 3 15 13 1 12 4 7 x]\n[14 x x x x x x 16 x 15 x x x]\n[3 15 x 6 x 9 x x 9 1 6 x 5]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "5", "opt_solution": "[[8, 2], [8, 3], [7, 3], [6, 3], [5, 3], [5, 4], [4, 4], [4, 5], [3, 5], [2, 5], [2, 6], [2, 7], [2, 8], [2, 9]]", "opt_solution_cost": "100", "opt_solution_compute_t": "0.019217967987060547", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"5\", \"15\", \"15\", \"5\", \"6\", \"19\", \"x\", \"9\", \"2\", \"x\", \"16\", \"x\", \"15\"], [\"16\", \"x\", \"x\", \"7\", \"5\", \"x\", \"x\", \"x\", \"5\", \"2\", \"19\", \"x\", \"3\"], [\"x\", \"11\", \"2\", \"19\", \"17\", \"5\", \"11\", \"6\", \"3\", \"18\", \"15\", \"16\", \"x\"], [\"2\", \"x\", \"12\", \"x\", \"20\", \"11\", \"7\", \"19\", \"2\", \"x\", \"4\", \"14\", \"x\"], [\"3\", \"x\", \"19\", \"x\", \"11\", \"19\", \"x\", \"14\", \"x\", \"12\", \"x\", \"18\", \"7\"], [\"6\", \"x\", \"5\", \"8\", \"3\", \"12\", \"12\", \"11\", \"5\", \"14\", \"x\", \"6\", \"x\"], [\"x\", \"x\", \"13\", \"2\", \"x\", \"20\", \"x\", \"x\", \"x\", \"18\", \"18\", \"x\", \"3\"], [\"x\", \"x\", \"13\", \"1\", \"10\", \"18\", \"x\", \"x\", \"x\", \"x\", \"10\", \"x\", \"15\"], [\"10\", \"x\", \"9\", \"2\", \"17\", \"19\", \"16\", \"8\", \"x\", \"18\", \"10\", \"x\", \"13\"], [\"x\", \"x\", \"2\", \"8\", \"2\", \"7\", \"x\", \"17\", \"x\", \"1\", \"x\", \"9\", \"x\"], [\"x\", \"13\", \"x\", \"19\", \"15\", \"3\", \"15\", \"13\", \"1\", \"12\", \"4\", \"7\", \"x\"], [\"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"16\", \"x\", \"15\", \"x\", \"x\", \"x\"], [\"3\", \"15\", \"x\", \"6\", \"x\", \"9\", \"x\", \"x\", \"9\", \"1\", \"6\", \"x\", \"5\"]]]", "is_correct_args": "[[[\"5\", \"15\", \"15\", \"5\", \"6\", \"19\", \"x\", \"9\", \"2\", \"x\", \"16\", \"x\", \"15\"], [\"16\", \"x\", \"x\", \"7\", \"5\", \"x\", \"x\", \"x\", \"5\", \"2\", \"19\", \"x\", \"3\"], [\"x\", \"11\", \"2\", \"19\", \"17\", \"5\", \"11\", \"6\", \"3\", \"18\", \"15\", \"16\", \"x\"], [\"2\", \"x\", \"12\", \"x\", \"20\", \"11\", \"7\", \"19\", \"2\", \"x\", \"4\", \"14\", \"x\"], [\"3\", \"x\", \"19\", \"x\", \"11\", \"19\", \"x\", \"14\", \"x\", \"12\", \"x\", \"18\", \"7\"], [\"6\", \"x\", \"5\", \"8\", \"3\", \"12\", \"12\", \"11\", \"5\", \"14\", \"x\", \"6\", \"x\"], [\"x\", \"x\", \"13\", \"2\", \"x\", \"20\", \"x\", \"x\", \"x\", \"18\", \"18\", \"x\", \"3\"], [\"x\", \"x\", \"13\", \"1\", \"10\", \"18\", \"x\", \"x\", \"x\", \"x\", \"10\", \"x\", \"15\"], [\"10\", \"x\", \"9\", \"2\", \"17\", \"19\", \"16\", \"8\", \"x\", \"18\", \"10\", \"x\", \"13\"], [\"x\", \"x\", \"2\", \"8\", \"2\", \"7\", \"x\", \"17\", \"x\", \"1\", \"x\", \"9\", \"x\"], [\"x\", \"13\", \"x\", \"19\", \"15\", \"3\", \"15\", \"13\", \"1\", \"12\", \"4\", \"7\", \"x\"], [\"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"16\", \"x\", \"15\", \"x\", \"x\", \"x\"], [\"3\", \"15\", \"x\", \"6\", \"x\", \"9\", \"x\", \"x\", \"9\", \"1\", \"6\", \"x\", \"5\"]], [8, 2], [2, 9], 2, 7]", "A*_args": "[\"[['5', '15', '15', '5', '6', '19', 'x', '9', '2', 'x', '16', 'x', '15'], ['16', 'x', 'x', '7', '5', 'x', 'x', 'x', '5', '2', '19', 'x', '3'], ['x', '11', '2', '19', '17', '5', '11', '6', '3', '18', '15', '16', 'x'], ['2', 'x', '12', 'x', '20', '11', '7', '19', '2', 'x', '4', '14', 'x'], ['3', 'x', '19', 'x', '11', '19', 'x', '14', 'x', '12', 'x', '18', '7'], ['6', 'x', '5', '8', '3', '12', '12', '11', '5', '14', 'x', '6', 'x'], ['x', 'x', '13', '2', 'x', '20', 'x', 'x', 'x', '18', '18', 'x', '3'], ['x', 'x', '13', '1', '10', '18', 'x', 'x', 'x', 'x', '10', 'x', '15'], ['10', 'x', '9', '2', '17', '19', '16', '8', 'x', '18', '10', 'x', '13'], ['x', 'x', '2', '8', '2', '7', 'x', '17', 'x', '1', 'x', '9', 'x'], ['x', '13', 'x', '19', '15', '3', '15', '13', '1', '12', '4', '7', 'x'], ['14', 'x', 'x', 'x', 'x', 'x', 'x', '16', 'x', '15', 'x', 'x', 'x'], ['3', '15', 'x', '6', 'x', '9', 'x', 'x', '9', '1', '6', 'x', '5']]\", \"(8, 2)\", \"(2, 9)\", \"2\", \"7\"]"}
{"diff_sorted_id": "62", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 13x13. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (11, 8) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (1, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 0 0 0 1 0 1 1 0 1 0 0\n0 0 0 0 1 1 1 1 1 1 0 1 1\n1 0 1 0 1 1 1 0 0 0 0 0 0\n0 0 0 0 1 1 1 1 1 0 0 0 1\n1 0 0 1 0 0 1 1 1 1 1 0 1\n1 0 0 0 0 1 1 0 0 0 1 1 1\n1 1 1 0 0 1 1 0 1 1 0 0 0\n1 0 1 1 1 0 0 1 0 1 1 1 1\n0 1 1 1 0 1 1 1 0 1 0 1 1\n0 0 1 0 0 0 0 0 1 1 0 1 0\n1 0 1 0 1 1 0 1 0 1 0 1 0\n1 1 1 0 0 1 1 0 0 1 1 0 1\n0 1 1 0 0 0 1 0 1 0 0 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[[11, 8], [10, 8], [9, 7], [9, 6], [9, 5], [8, 4], [7, 5], [6, 4], [5, 4], [5, 3], [5, 2], [4, 2], [3, 2], [3, 1], [2, 1], [1, 1], [1, 0]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.032764434814453125", "solution_depth": "17", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1], [1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1], [0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1], [0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1], [0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0]]\", 4]", "is_correct_args": "[\"[[1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1], [1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1], [0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1], [0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1], [0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0]]\", [11, 8], [1, 0], 4]", "A*_args": "[\"[[1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1], [1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1], [0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1], [0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1], [0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0]]\", \"(11, 8)\", \"(1, 0)\", \"4\"]"}
{"diff_sorted_id": "62", "problem_statement": "Given 5 labeled water jugs with capacities 54, 89, 26, 70, 71, 128 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 240, 242, 246, 329 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 54, 4], [\"+\", 128, 4], [\"+\", 128, 4], [\"-\", 70, 4], [\"+\", 89, 4], [\"+\", 70, 3], [\"+\", 70, 3], [\"+\", 89, 3], [\"-\", 54, 3], [\"+\", 71, 3], [\"+\", 70, 2], [\"+\", 70, 2], [\"-\", 26, 2], [\"+\", 128, 2], [\"+\", 54, 1], [\"+\", 71, 1], [\"+\", 89, 1], [\"+\", 26, 1]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.041527748107910156", "solution_depth": "18", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[54, 89, 26, 70, 71, 128], [240, 242, 246, 329]]", "is_correct_args": "[[54, 89, 26, 70, 71, 128], [240, 242, 246, 329]]", "A*_args": "[\"[54, 89, 26, 70, 71, 128]\", \"[240, 242, 246, 329]\"]"}
{"diff_sorted_id": "63", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[98, 80, 41, 91, 88], [75, 93, 24, '_', 12], [38, 37, 49, 65, 43]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[65, 49, 24, 65, 91, 41, 80, 93, 65, 91, 49, 43, 12, 88, 41, 80, 91, 49, 88, 41, 80, 88, 43, 12]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.1251230239868164", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[98, 80, 41, 91, 88], [75, 93, 24, \"_\", 12], [38, 37, 49, 65, 43]]]", "is_correct_args": "[[[98, 80, 41, 91, 88], [75, 93, 24, \"_\", 12], [38, 37, 49, 65, 43]]]", "A*_args": "[\"[[98, 80, 41, 91, 88], [75, 93, 24, '_', 12], [38, 37, 49, 65, 43]]\"]"}
{"diff_sorted_id": "63", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: liz, coos, enos, coze, gast   The initial board: [['o', 'l', '_', 'z'], ['c', 'i', 'o', 's'], ['e', 'n', 'o', 's'], ['c', 'e', 'z', 'o'], ['g', 'a', 's', 't']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"down-left\", \"down-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.22672724723815918", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"o\", \"l\", \"_\", \"z\"], [\"c\", \"i\", \"o\", \"s\"], [\"e\", \"n\", \"o\", \"s\"], [\"c\", \"e\", \"z\", \"o\"], [\"g\", \"a\", \"s\", \"t\"]]]", "is_correct_args": "[[[\"o\", \"l\", \"_\", \"z\"], [\"c\", \"i\", \"o\", \"s\"], [\"e\", \"n\", \"o\", \"s\"], [\"c\", \"e\", \"z\", \"o\"], [\"g\", \"a\", \"s\", \"t\"]], [\"liz\", \"coos\", \"enos\", \"coze\", \"gast\"]]", "A*_args": "[\"[['o', 'l', '_', 'z'], ['c', 'i', 'o', 's'], ['e', 'n', 'o', 's'], ['c', 'e', 'z', 'o'], ['g', 'a', 's', 't']]\", \"['liz', 'coos', 'enos', 'coze', 'gast']\"]"}
{"diff_sorted_id": "63", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'F'. Our task is to visit city N and city J excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from J and N, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  Z N R F O U P L J I S Q G \nZ 0 0 1 0 0 1 0 1 0 1 0 0 0 \nN 1 0 0 0 1 0 1 1 0 0 0 1 1 \nR 0 1 0 0 0 0 0 1 0 1 0 0 0 \nF 0 0 0 0 0 0 0 1 0 0 0 0 0 \nO 0 0 1 1 0 0 0 0 1 1 0 1 0 \nU 0 0 0 1 0 0 0 1 1 0 0 0 0 \nP 0 0 0 0 0 1 0 0 0 1 0 0 0 \nL 1 0 0 0 1 0 0 0 0 0 0 0 0 \nJ 0 0 0 0 0 1 0 0 0 1 0 0 0 \nI 0 0 0 0 0 1 0 0 0 0 1 0 0 \nS 0 1 0 0 1 1 0 1 1 0 0 0 0 \nQ 0 0 0 0 0 1 1 0 0 0 0 0 1 \nG 0 0 0 0 1 0 0 1 0 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[\"F\", \"L\", \"O\", \"J\", \"U\", \"J\", \"I\", \"S\", \"N\", \"Z\", \"R\", \"N\"]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.05983471870422363", "solution_depth": "12", "max_successor_states": "13", "num_vars_per_state": "16", "is_feasible_args": "[[[0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]], [\"Z\", \"N\", \"R\", \"F\", \"O\", \"U\", \"P\", \"L\", \"J\", \"I\", \"S\", \"Q\", \"G\"], \"N\", \"J\"]", "is_correct_args": "[[[0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]], [\"Z\", \"N\", \"R\", \"F\", \"O\", \"U\", \"P\", \"L\", \"J\", \"I\", \"S\", \"Q\", \"G\"], \"F\", \"N\", \"J\"]", "A*_args": "[\"[[0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1], [0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0]]\", \"['Z', 'N', 'R', 'F', 'O', 'U', 'P', 'L', 'J', 'I', 'S', 'Q', 'G']\", \"['F']\", \"['N', 'J']\"]"}
{"diff_sorted_id": "63", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [12, 12, 5, 32, 25, 3, 23, 49, 31, 6, 12, 23, 20, 14, 34, 17, 16, 16, 21, 18, 7, 30, 7, 27, 29, 14, 5, 9, 48, 33, 5, 18, 15, 29, 2, 28, 29, 25, 26, 6, 4, 4, 6, 8, 16, 5, 4, 4, 20, 25, 10, 6, 3, 24, 19], such that the sum of the chosen coins adds up to 348. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {20: 18, 16: 6, 19: 2, 27: 12, 25: 2, 6: 2, 26: 16, 23: 9, 28: 12, 49: 16, 33: 13, 30: 12, 8: 6, 21: 18, 31: 16, 48: 5, 15: 5, 10: 2, 3: 1, 29: 14, 32: 15, 5: 3, 4: 4, 34: 3, 17: 14, 12: 11, 7: 3, 9: 9, 14: 7, 24: 14, 18: 15, 2: 1}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "35", "opt_solution": "[48, 34, 2, 25, 25, 6, 25, 6, 49, 6, 15, 19, 16, 6, 23, 10, 33]", "opt_solution_cost": "76", "opt_solution_compute_t": "0.07342052459716797", "solution_depth": "17", "max_successor_states": "55", "num_vars_per_state": "55", "is_feasible_args": "[[12, 12, 5, 32, 25, 3, 23, 49, 31, 6, 12, 23, 20, 14, 34, 17, 16, 16, 21, 18, 7, 30, 7, 27, 29, 14, 5, 9, 48, 33, 5, 18, 15, 29, 2, 28, 29, 25, 26, 6, 4, 4, 6, 8, 16, 5, 4, 4, 20, 25, 10, 6, 3, 24, 19]]", "is_correct_args": "[[12, 12, 5, 32, 25, 3, 23, 49, 31, 6, 12, 23, 20, 14, 34, 17, 16, 16, 21, 18, 7, 30, 7, 27, 29, 14, 5, 9, 48, 33, 5, 18, 15, 29, 2, 28, 29, 25, 26, 6, 4, 4, 6, 8, 16, 5, 4, 4, 20, 25, 10, 6, 3, 24, 19], {\"20\": 18, \"16\": 6, \"19\": 2, \"27\": 12, \"25\": 2, \"6\": 2, \"26\": 16, \"23\": 9, \"28\": 12, \"49\": 16, \"33\": 13, \"30\": 12, \"8\": 6, \"21\": 18, \"31\": 16, \"48\": 5, \"15\": 5, \"10\": 2, \"3\": 1, \"29\": 14, \"32\": 15, \"5\": 3, \"4\": 4, \"34\": 3, \"17\": 14, \"12\": 11, \"7\": 3, \"9\": 9, \"14\": 7, \"24\": 14, \"18\": 15, \"2\": 1}, 348]", "A*_args": "[\"[12, 12, 5, 32, 25, 3, 23, 49, 31, 6, 12, 23, 20, 14, 34, 17, 16, 16, 21, 18, 7, 30, 7, 27, 29, 14, 5, 9, 48, 33, 5, 18, 15, 29, 2, 28, 29, 25, 26, 6, 4, 4, 6, 8, 16, 5, 4, 4, 20, 25, 10, 6, 3, 24, 19]\", \"{20: 18, 16: 6, 19: 2, 27: 12, 25: 2, 6: 2, 26: 16, 23: 9, 28: 12, 49: 16, 33: 13, 30: 12, 8: 6, 21: 18, 31: 16, 48: 5, 15: 5, 10: 2, 3: 1, 29: 14, 32: 15, 5: 3, 4: 4, 34: 3, 17: 14, 12: 11, 7: 3, 9: 9, 14: 7, 24: 14, 18: 15, 2: 1}\", \"348\"]"}
{"diff_sorted_id": "63", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Blue', 'Red', 'Green'], ['Blue', 'Green', 'Green', 'Red', 'Blue'], ['Red', 'Blue', 'Red', 'Red', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[1, 0], [2, 1], [2, 0], [2, 1], [2, 1], [2, 0], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [0, 2], [0, 1], [0, 1], [0, 1], [0, 2], [0, 1], [0, 1], [2, 0], [2, 0], [2, 1], [2, 0], [2, 0], [1, 2], [1, 2]]", "opt_solution_cost": "26", "opt_solution_compute_t": "131.11853456497192", "solution_depth": "26", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Blue\", \"Red\", \"Green\"], [\"Blue\", \"Green\", \"Green\", \"Red\", \"Blue\"], [\"Red\", \"Blue\", \"Red\", \"Red\", \"Green\"]], 8]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Blue\", \"Red\", \"Green\"], [\"Blue\", \"Green\", \"Green\", \"Red\", \"Blue\"], [\"Red\", \"Blue\", \"Red\", \"Red\", \"Green\"]], 8]", "A*_args": "[\"[['Blue', 'Green', 'Blue', 'Red', 'Green'], ['Blue', 'Green', 'Green', 'Red', 'Blue'], ['Red', 'Blue', 'Red', 'Red', 'Green']]\", \"8\"]"}
{"diff_sorted_id": "63", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 33 to 78 (33 included in the range but 78 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['33' '37' 'x' '58']\n ['44' '51' 'x' '63']\n ['x' '52' '62' '64']\n ['x' 'x' '65' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "11", "opt_solution": "[[0, 0, 48], [0, 3, 75], [1, 1, 49], [2, 0, 42], [2, 2, 51], [2, 3, 55], [3, 2, 50]]", "opt_solution_cost": "728", "opt_solution_compute_t": "4.985894441604614", "solution_depth": "7", "max_successor_states": "45", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '73', '74', ''], ['46', '', '63', '72'], ['', '47', '', ''], ['41', '45', '', '54']]\", 35, 80]", "is_correct_args": "[\"[['', '73', '74', ''], ['46', '', '63', '72'], ['', '47', '', ''], ['41', '45', '', '54']]\", 35, 80]", "A*_args": "[\"[['', '73', '74', ''], ['46', '', '63', '72'], ['', '47', '', ''], ['41', '45', '', '54']]\", \"35\", \"80\"]"}
{"diff_sorted_id": "63", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 30 to 66. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 207, 208, None for columns 1 to 2 respectively, and the sums of rows must be None, 173, 208, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 201. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' '63' 'x']\n ['x' '44' 'x' '36']\n ['50' 'x' 'x' '60']\n ['x' '52' '38' '64']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 30], [0, 1, 58], [0, 3, 32], [1, 0, 31], [1, 2, 62], [2, 1, 53], [2, 2, 45], [3, 0, 54]]", "opt_solution_cost": "772", "opt_solution_compute_t": "65.37240958213806", "solution_depth": "8", "max_successor_states": "26", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '63', ''], ['', '44', '', '36'], ['50', '', '', '60'], ['', '52', '38', '64']]\", 4, 30, 66]", "is_correct_args": "[\"[['', '', '63', ''], ['', '44', '', '36'], ['50', '', '', '60'], ['', '52', '38', '64']]\", 30, 66, [1, 3], [1, 3], [207, 208], [173, 208], 201]", "A*_args": "[\"[['', '', '63', ''], ['', '44', '', '36'], ['50', '', '', '60'], ['', '52', '38', '64']]\", \"30\", \"66\", \"[None, 207, 208, None]\", \"[None, 173, 208, None]\", \"201\"]"}
{"diff_sorted_id": "63", "problem_statement": "In 'Restricted Sorting', there are 10 stacks each with a capacity of 6 blocks, with 5 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 5 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 7, 1: 7, 2: 8, 3: 5, 4: 8, 5: 10, 6: 5, 7: 5, 8: 4, 9: 8}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], ['Blue', 'Yellow', 'Yellow', 'Yellow', 'Yellow', 'Black'], ['Red', 'Red', 'Blue', 'White', 'Blue', 'Black'], ['White', 'Green', 'Red', 'Black', 'Blue', 'Yellow'], [], ['White', 'Green', 'Green', 'White', 'Green', 'Green'], ['Black', 'Red', 'Red', 'Blue', 'White', 'Black'], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "3", "opt_solution": "[[3, 8], [3, 8], [2, 0], [4, 1], [6, 1], [4, 9], [4, 8], [4, 5], [4, 0], [7, 5], [7, 8], [7, 8], [7, 0], [7, 1], [3, 0], [3, 1], [3, 0], [6, 9], [6, 9], [6, 1], [2, 4], [2, 4], [3, 7], [2, 3], [2, 4], [3, 4], [6, 9], [6, 9], [2, 7], [5, 7], [5, 7]]", "opt_solution_cost": "207", "opt_solution_compute_t": "13.576901912689209", "solution_depth": "31", "max_successor_states": "90", "num_vars_per_state": "30", "is_feasible_args": "[[[], [], [\"Blue\", \"Yellow\", \"Yellow\", \"Yellow\", \"Yellow\", \"Black\"], [\"Red\", \"Red\", \"Blue\", \"White\", \"Blue\", \"Black\"], [\"White\", \"Green\", \"Red\", \"Black\", \"Blue\", \"Yellow\"], [], [\"White\", \"Green\", \"Green\", \"White\", \"Green\", \"Green\"], [\"Black\", \"Red\", \"Red\", \"Blue\", \"White\", \"Black\"], [], []], 6, {\"0\": 7, \"1\": 7, \"2\": 8, \"3\": 5, \"4\": 8, \"5\": 10, \"6\": 5, \"7\": 5, \"8\": 4, \"9\": 8}]", "is_correct_args": "[[[], [], [\"Blue\", \"Yellow\", \"Yellow\", \"Yellow\", \"Yellow\", \"Black\"], [\"Red\", \"Red\", \"Blue\", \"White\", \"Blue\", \"Black\"], [\"White\", \"Green\", \"Red\", \"Black\", \"Blue\", \"Yellow\"], [], [\"White\", \"Green\", \"Green\", \"White\", \"Green\", \"Green\"], [\"Black\", \"Red\", \"Red\", \"Blue\", \"White\", \"Black\"], [], []], 6, {\"0\": 7, \"1\": 7, \"2\": 8, \"3\": 5, \"4\": 8, \"5\": 10, \"6\": 5, \"7\": 5, \"8\": 4, \"9\": 8}, 5]", "A*_args": "[\"[[], [], ['Blue', 'Yellow', 'Yellow', 'Yellow', 'Yellow', 'Black'], ['Red', 'Red', 'Blue', 'White', 'Blue', 'Black'], ['White', 'Green', 'Red', 'Black', 'Blue', 'Yellow'], [], ['White', 'Green', 'Green', 'White', 'Green', 'Green'], ['Black', 'Red', 'Red', 'Blue', 'White', 'Black'], [], []]\", \"{0: 7, 1: 7, 2: 8, 3: 5, 4: 8, 5: 10, 6: 5, 7: 5, 8: 4, 9: 8}\", \"6\", \"5\"]"}
{"diff_sorted_id": "63", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 0) to his destination workshop at index (8, 9), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 8, and district 3 covering rows 9 to 12. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[16 9 19 14 16 19 6 x x x 16 18 x]\n[19 x x 9 9 x 17 16 3 x x 14 x]\n[x x 11 x 5 x 15 15 17 10 x 13 5]\n[2 12 9 18 7 x x x 4 x 10 x 3]\n[8 9 19 1 x 4 8 x 17 6 x 18 x]\n[x 6 7 9 1 x x x x x x x x]\n[x 5 4 12 13 13 x x x 11 x 5 9]\n[x x 2 20 6 11 2 x x x 10 18 x]\n[x x 1 18 1 17 2 3 10 12 11 x 19]\n[x 16 3 x x 16 3 10 19 x x 9 x]\n[10 x x x x 1 10 13 x x 13 x x]\n[x x x x 13 x 1 14 x 10 x x 8]\n[x x x x x 9 2 18 19 14 10 x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "5", "opt_solution": "[[3, 0], [4, 0], [4, 1], [5, 1], [6, 1], [6, 2], [7, 2], [8, 2], [9, 2], [8, 2], [8, 3], [8, 4], [8, 5], [8, 6], [8, 7], [8, 8], [8, 9]]", "opt_solution_cost": "102", "opt_solution_compute_t": "0.01901412010192871", "solution_depth": "17", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"16\", \"9\", \"19\", \"14\", \"16\", \"19\", \"6\", \"x\", \"x\", \"x\", \"16\", \"18\", \"x\"], [\"19\", \"x\", \"x\", \"9\", \"9\", \"x\", \"17\", \"16\", \"3\", \"x\", \"x\", \"14\", \"x\"], [\"x\", \"x\", \"11\", \"x\", \"5\", \"x\", \"15\", \"15\", \"17\", \"10\", \"x\", \"13\", \"5\"], [\"2\", \"12\", \"9\", \"18\", \"7\", \"x\", \"x\", \"x\", \"4\", \"x\", \"10\", \"x\", \"3\"], [\"8\", \"9\", \"19\", \"1\", \"x\", \"4\", \"8\", \"x\", \"17\", \"6\", \"x\", \"18\", \"x\"], [\"x\", \"6\", \"7\", \"9\", \"1\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"5\", \"4\", \"12\", \"13\", \"13\", \"x\", \"x\", \"x\", \"11\", \"x\", \"5\", \"9\"], [\"x\", \"x\", \"2\", \"20\", \"6\", \"11\", \"2\", \"x\", \"x\", \"x\", \"10\", \"18\", \"x\"], [\"x\", \"x\", \"1\", \"18\", \"1\", \"17\", \"2\", \"3\", \"10\", \"12\", \"11\", \"x\", \"19\"], [\"x\", \"16\", \"3\", \"x\", \"x\", \"16\", \"3\", \"10\", \"19\", \"x\", \"x\", \"9\", \"x\"], [\"10\", \"x\", \"x\", \"x\", \"x\", \"1\", \"10\", \"13\", \"x\", \"x\", \"13\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"13\", \"x\", \"1\", \"14\", \"x\", \"10\", \"x\", \"x\", \"8\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"9\", \"2\", \"18\", \"19\", \"14\", \"10\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"16\", \"9\", \"19\", \"14\", \"16\", \"19\", \"6\", \"x\", \"x\", \"x\", \"16\", \"18\", \"x\"], [\"19\", \"x\", \"x\", \"9\", \"9\", \"x\", \"17\", \"16\", \"3\", \"x\", \"x\", \"14\", \"x\"], [\"x\", \"x\", \"11\", \"x\", \"5\", \"x\", \"15\", \"15\", \"17\", \"10\", \"x\", \"13\", \"5\"], [\"2\", \"12\", \"9\", \"18\", \"7\", \"x\", \"x\", \"x\", \"4\", \"x\", \"10\", \"x\", \"3\"], [\"8\", \"9\", \"19\", \"1\", \"x\", \"4\", \"8\", \"x\", \"17\", \"6\", \"x\", \"18\", \"x\"], [\"x\", \"6\", \"7\", \"9\", \"1\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"5\", \"4\", \"12\", \"13\", \"13\", \"x\", \"x\", \"x\", \"11\", \"x\", \"5\", \"9\"], [\"x\", \"x\", \"2\", \"20\", \"6\", \"11\", \"2\", \"x\", \"x\", \"x\", \"10\", \"18\", \"x\"], [\"x\", \"x\", \"1\", \"18\", \"1\", \"17\", \"2\", \"3\", \"10\", \"12\", \"11\", \"x\", \"19\"], [\"x\", \"16\", \"3\", \"x\", \"x\", \"16\", \"3\", \"10\", \"19\", \"x\", \"x\", \"9\", \"x\"], [\"10\", \"x\", \"x\", \"x\", \"x\", \"1\", \"10\", \"13\", \"x\", \"x\", \"13\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"13\", \"x\", \"1\", \"14\", \"x\", \"10\", \"x\", \"x\", \"8\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"9\", \"2\", \"18\", \"19\", \"14\", \"10\", \"x\", \"x\"]], [3, 0], [8, 9], 3, 8]", "A*_args": "[\"[['16', '9', '19', '14', '16', '19', '6', 'x', 'x', 'x', '16', '18', 'x'], ['19', 'x', 'x', '9', '9', 'x', '17', '16', '3', 'x', 'x', '14', 'x'], ['x', 'x', '11', 'x', '5', 'x', '15', '15', '17', '10', 'x', '13', '5'], ['2', '12', '9', '18', '7', 'x', 'x', 'x', '4', 'x', '10', 'x', '3'], ['8', '9', '19', '1', 'x', '4', '8', 'x', '17', '6', 'x', '18', 'x'], ['x', '6', '7', '9', '1', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x'], ['x', '5', '4', '12', '13', '13', 'x', 'x', 'x', '11', 'x', '5', '9'], ['x', 'x', '2', '20', '6', '11', '2', 'x', 'x', 'x', '10', '18', 'x'], ['x', 'x', '1', '18', '1', '17', '2', '3', '10', '12', '11', 'x', '19'], ['x', '16', '3', 'x', 'x', '16', '3', '10', '19', 'x', 'x', '9', 'x'], ['10', 'x', 'x', 'x', 'x', '1', '10', '13', 'x', 'x', '13', 'x', 'x'], ['x', 'x', 'x', 'x', '13', 'x', '1', '14', 'x', '10', 'x', 'x', '8'], ['x', 'x', 'x', 'x', 'x', '9', '2', '18', '19', '14', '10', 'x', 'x']]\", \"(3, 0)\", \"(8, 9)\", \"3\", \"8\"]"}
{"diff_sorted_id": "63", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 13x13. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (4, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (12, 12). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 1 0 0 0 0 0 1 1 1 1 0\n1 0 0 1 1 0 1 1 1 0 0 0 0\n0 1 1 1 1 1 1 0 0 0 1 1 1\n1 0 1 1 0 0 1 1 1 1 1 0 1\n0 0 0 1 1 0 1 0 1 0 0 0 1\n0 0 1 0 0 0 0 1 1 1 1 0 1\n0 1 0 0 0 1 0 1 0 0 0 0 1\n0 1 1 1 1 1 0 0 1 0 1 1 1\n1 1 0 0 1 1 0 0 0 0 0 0 1\n0 0 1 1 0 0 0 0 1 0 1 1 0\n0 1 1 1 1 0 1 0 1 0 0 0 0\n0 1 1 0 1 0 0 0 1 0 0 0 1\n1 0 0 1 0 0 0 0 0 0 0 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[[4, 0], [4, 1], [4, 2], [5, 3], [5, 4], [5, 5], [5, 6], [6, 6], [7, 6], [7, 7], [8, 7], [8, 8], [8, 9], [9, 9], [10, 10], [11, 11], [12, 12]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.03172564506530762", "solution_depth": "17", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0], [1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1], [1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1], [0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1], [0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1], [0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1], [1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0], [0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\", 4]", "is_correct_args": "[\"[[1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0], [1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1], [1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1], [0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1], [0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1], [0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1], [1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0], [0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\", [4, 0], [12, 12], 4]", "A*_args": "[\"[[1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0], [1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1], [1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1], [0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1], [0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1], [0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1], [1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0], [0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\", \"(4, 0)\", \"(12, 12)\", \"4\"]"}
{"diff_sorted_id": "63", "problem_statement": "Given 5 labeled water jugs with capacities 123, 124, 133, 85, 74 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 276, 277, 355, 425 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 85, 4], [\"+\", 133, 4], [\"+\", 74, 4], [\"+\", 133, 4], [\"+\", 74, 3], [\"+\", 74, 3], [\"+\", 74, 3], [\"+\", 133, 3], [\"+\", 85, 2], [\"+\", 133, 2], [\"-\", 74, 2], [\"+\", 133, 2], [\"+\", 133, 1], [\"+\", 133, 1], [\"-\", 123, 1], [\"+\", 133, 1]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.024725675582885742", "solution_depth": "16", "max_successor_states": "40", "num_vars_per_state": "3", "is_feasible_args": "[[123, 124, 133, 85, 74], [276, 277, 355, 425]]", "is_correct_args": "[[123, 124, 133, 85, 74], [276, 277, 355, 425]]", "A*_args": "[\"[123, 124, 133, 85, 74]\", \"[276, 277, 355, 425]\"]"}
{"diff_sorted_id": "64", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[54, 100, 91, 80, 56], [19, '_', 38, 74, 29], [14, 36, 44, 13, 10]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[36, 44, 38, 36, 44, 14, 19, 54, 100, 91, 80, 74, 36, 38, 13, 10]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.03679513931274414", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[54, 100, 91, 80, 56], [19, \"_\", 38, 74, 29], [14, 36, 44, 13, 10]]]", "is_correct_args": "[[[54, 100, 91, 80, 56], [19, \"_\", 38, 74, 29], [14, 36, 44, 13, 10]]]", "A*_args": "[\"[[54, 100, 91, 80, 56], [19, '_', 38, 74, 29], [14, 36, 44, 13, 10]]\"]"}
{"diff_sorted_id": "64", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: tue, judy, zein, bord, wiry   The initial board: [['u', 't', '_', 'e'], ['j', 'd', 'd', 'u'], ['o', 'e', 'z', 'n'], ['b', 'i', 'r', 'y'], ['w', 'i', 'r', 'y']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.3210330009460449", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"u\", \"t\", \"_\", \"e\"], [\"j\", \"d\", \"d\", \"u\"], [\"o\", \"e\", \"z\", \"n\"], [\"b\", \"i\", \"r\", \"y\"], [\"w\", \"i\", \"r\", \"y\"]]]", "is_correct_args": "[[[\"u\", \"t\", \"_\", \"e\"], [\"j\", \"d\", \"d\", \"u\"], [\"o\", \"e\", \"z\", \"n\"], [\"b\", \"i\", \"r\", \"y\"], [\"w\", \"i\", \"r\", \"y\"]], [\"tue\", \"judy\", \"zein\", \"bord\", \"wiry\"]]", "A*_args": "[\"[['u', 't', '_', 'e'], ['j', 'd', 'd', 'u'], ['o', 'e', 'z', 'n'], ['b', 'i', 'r', 'y'], ['w', 'i', 'r', 'y']]\", \"['tue', 'judy', 'zein', 'bord', 'wiry']\"]"}
{"diff_sorted_id": "64", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'Y'. Our task is to visit city D and city R excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from R and D, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  Z J T D W L P Y V H R I A \nZ 0 0 0 0 0 0 0 0 0 1 1 1 0 \nJ 0 0 0 0 0 0 0 0 1 1 1 0 0 \nT 1 0 0 1 0 0 0 0 0 0 0 0 0 \nD 1 0 1 0 0 1 1 0 0 1 0 0 1 \nW 1 1 1 0 0 0 0 0 0 1 0 0 1 \nL 0 1 1 0 1 0 0 0 1 1 1 0 1 \nP 1 1 1 0 1 1 0 0 1 0 0 0 0 \nY 0 0 1 0 0 0 0 0 0 1 0 0 0 \nV 0 0 1 1 0 0 0 0 0 0 1 0 1 \nH 0 0 1 0 0 0 0 0 0 0 0 1 0 \nR 1 0 1 0 0 1 0 0 0 1 0 0 0 \nI 0 0 1 1 0 0 0 0 0 0 1 0 0 \nA 0 1 0 1 1 0 1 1 0 1 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[\"Y\", \"T\", \"D\", \"A\", \"D\", \"L\", \"R\", \"Z\", \"R\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.04733538627624512", "solution_depth": "9", "max_successor_states": "13", "num_vars_per_state": "16", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0], [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1], [1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0]], [\"Z\", \"J\", \"T\", \"D\", \"W\", \"L\", \"P\", \"Y\", \"V\", \"H\", \"R\", \"I\", \"A\"], \"D\", \"R\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0], [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1], [1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0]], [\"Z\", \"J\", \"T\", \"D\", \"W\", \"L\", \"P\", \"Y\", \"V\", \"H\", \"R\", \"I\", \"A\"], \"Y\", \"D\", \"R\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0], [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1], [1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0]]\", \"['Z', 'J', 'T', 'D', 'W', 'L', 'P', 'Y', 'V', 'H', 'R', 'I', 'A']\", \"['Y']\", \"['D', 'R']\"]"}
{"diff_sorted_id": "64", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [14, 8, 11, 30, 3, 3, 27, 16, 19, 4, 6, 14, 7, 2, 39, 103, 15, 100, 27, 36, 7, 36, 13, 7, 18, 39, 14, 3, 28], such that the sum of the chosen coins adds up to 410. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {13: 11, 18: 8, 36: 15, 11: 4, 6: 1, 16: 8, 100: 12, 39: 10, 28: 9, 27: 20, 103: 6, 19: 5, 30: 14, 2: 1, 4: 3, 3: 3, 15: 10, 8: 5, 7: 2, 14: 14}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "15", "opt_solution": "[7, 7, 19, 39, 103, 100, 28, 39, 36, 6, 7, 11, 8]", "opt_solution_cost": "83", "opt_solution_compute_t": "0.03669548034667969", "solution_depth": "13", "max_successor_states": "29", "num_vars_per_state": "29", "is_feasible_args": "[[14, 8, 11, 30, 3, 3, 27, 16, 19, 4, 6, 14, 7, 2, 39, 103, 15, 100, 27, 36, 7, 36, 13, 7, 18, 39, 14, 3, 28]]", "is_correct_args": "[[14, 8, 11, 30, 3, 3, 27, 16, 19, 4, 6, 14, 7, 2, 39, 103, 15, 100, 27, 36, 7, 36, 13, 7, 18, 39, 14, 3, 28], {\"13\": 11, \"18\": 8, \"36\": 15, \"11\": 4, \"6\": 1, \"16\": 8, \"100\": 12, \"39\": 10, \"28\": 9, \"27\": 20, \"103\": 6, \"19\": 5, \"30\": 14, \"2\": 1, \"4\": 3, \"3\": 3, \"15\": 10, \"8\": 5, \"7\": 2, \"14\": 14}, 410]", "A*_args": "[\"[14, 8, 11, 30, 3, 3, 27, 16, 19, 4, 6, 14, 7, 2, 39, 103, 15, 100, 27, 36, 7, 36, 13, 7, 18, 39, 14, 3, 28]\", \"{13: 11, 18: 8, 36: 15, 11: 4, 6: 1, 16: 8, 100: 12, 39: 10, 28: 9, 27: 20, 103: 6, 19: 5, 30: 14, 2: 1, 4: 3, 3: 3, 15: 10, 8: 5, 7: 2, 14: 14}\", \"410\"]"}
{"diff_sorted_id": "64", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Blue', 'Red', 'Red', 'Red'], ['Blue', 'Blue', 'Blue', 'Green', 'Green'], ['Red', 'Green', 'Green', 'Green', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[0, 2], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [1, 2], [1, 2], [1, 2], [1, 2], [0, 1], [0, 1], [0, 1]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.2936434745788574", "solution_depth": "14", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Red\", \"Blue\", \"Red\", \"Red\", \"Red\"], [\"Blue\", \"Blue\", \"Blue\", \"Green\", \"Green\"], [\"Red\", \"Green\", \"Green\", \"Green\", \"Blue\"]], 8]", "is_correct_args": "[[[\"Red\", \"Blue\", \"Red\", \"Red\", \"Red\"], [\"Blue\", \"Blue\", \"Blue\", \"Green\", \"Green\"], [\"Red\", \"Green\", \"Green\", \"Green\", \"Blue\"]], 8]", "A*_args": "[\"[['Red', 'Blue', 'Red', 'Red', 'Red'], ['Blue', 'Blue', 'Blue', 'Green', 'Green'], ['Red', 'Green', 'Green', 'Green', 'Blue']]\", \"8\"]"}
{"diff_sorted_id": "64", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 35 to 80 (35 included in the range but 80 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '73' '74' 'x']\n ['46' 'x' '63' '72']\n ['x' '47' 'x' 'x']\n ['41' '45' 'x' '54']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "12", "opt_solution": "[[0, 0, 31], [0, 3, 72], [1, 0, 32], [1, 1, 47], [1, 3, 63], [2, 1, 46], [2, 3, 59]]", "opt_solution_cost": "685", "opt_solution_compute_t": "41.66590666770935", "solution_depth": "7", "max_successor_states": "45", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '68', '71', ''], ['', '', '62', ''], ['43', '', '55', ''], ['44', '45', '52', '58']]\", 31, 76]", "is_correct_args": "[\"[['', '68', '71', ''], ['', '', '62', ''], ['43', '', '55', ''], ['44', '45', '52', '58']]\", 31, 76]", "A*_args": "[\"[['', '68', '71', ''], ['', '', '62', ''], ['43', '', '55', ''], ['44', '45', '52', '58']]\", \"31\", \"76\"]"}
{"diff_sorted_id": "64", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 30 to 66. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 154, 157, None for columns 1 to 2 respectively, and the sums of rows must be None, 173, 194, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 208. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['46' '30' 'x' '49']\n ['43' 'x' 'x' '53']\n ['x' 'x' '37' 'x']\n ['x' '34' '33' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 2, 42], [1, 1, 32], [1, 2, 45], [2, 0, 35], [2, 1, 58], [2, 3, 64], [3, 0, 56], [3, 3, 31]]", "opt_solution_cost": "688", "opt_solution_compute_t": "0.30200624465942383", "solution_depth": "8", "max_successor_states": "26", "num_vars_per_state": "16", "is_feasible_args": "[\"[['46', '30', '', '49'], ['43', '', '', '53'], ['', '', '37', ''], ['', '34', '33', '']]\", 4, 30, 66]", "is_correct_args": "[\"[['46', '30', '', '49'], ['43', '', '', '53'], ['', '', '37', ''], ['', '34', '33', '']]\", 30, 66, [1, 3], [1, 3], [154, 157], [173, 194], 208]", "A*_args": "[\"[['46', '30', '', '49'], ['43', '', '', '53'], ['', '', '37', ''], ['', '34', '33', '']]\", \"30\", \"66\", \"[None, 154, 157, None]\", \"[None, 173, 194, None]\", \"208\"]"}
{"diff_sorted_id": "64", "problem_statement": "In 'Restricted Sorting', there are 10 stacks each with a capacity of 6 blocks, with 5 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 5 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 6, 1: 7, 2: 11, 3: 10, 4: 7, 5: 2, 6: 3, 7: 3, 8: 11, 9: 8}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['White', 'White', 'Yellow', 'White', 'White', 'Black'], [], ['Red', 'Red', 'Green', 'Green', 'Green', 'Red'], ['Black', 'Yellow', 'Black', 'Yellow', 'Blue', 'Green'], ['Yellow', 'Blue', 'Black', 'Green', 'Blue', 'Red'], [], ['Red', 'Black', 'Blue', 'Yellow', 'Blue', 'White'], [], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "3", "opt_solution": "[[2, 5], [2, 5], [6, 5], [4, 7], [3, 1], [6, 1], [3, 7], [3, 1], [3, 7], [3, 9], [6, 9], [6, 7], [6, 9], [4, 9], [4, 1], [4, 3], [4, 9], [4, 5], [0, 4], [0, 4], [0, 7], [0, 4], [0, 4], [0, 1], [6, 4], [2, 6], [2, 6], [2, 6], [3, 6], [3, 6], [2, 5]]", "opt_solution_cost": "160", "opt_solution_compute_t": "1.107576847076416", "solution_depth": "31", "max_successor_states": "90", "num_vars_per_state": "30", "is_feasible_args": "[[[\"White\", \"White\", \"Yellow\", \"White\", \"White\", \"Black\"], [], [\"Red\", \"Red\", \"Green\", \"Green\", \"Green\", \"Red\"], [\"Black\", \"Yellow\", \"Black\", \"Yellow\", \"Blue\", \"Green\"], [\"Yellow\", \"Blue\", \"Black\", \"Green\", \"Blue\", \"Red\"], [], [\"Red\", \"Black\", \"Blue\", \"Yellow\", \"Blue\", \"White\"], [], [], []], 6, {\"0\": 6, \"1\": 7, \"2\": 11, \"3\": 10, \"4\": 7, \"5\": 2, \"6\": 3, \"7\": 3, \"8\": 11, \"9\": 8}]", "is_correct_args": "[[[\"White\", \"White\", \"Yellow\", \"White\", \"White\", \"Black\"], [], [\"Red\", \"Red\", \"Green\", \"Green\", \"Green\", \"Red\"], [\"Black\", \"Yellow\", \"Black\", \"Yellow\", \"Blue\", \"Green\"], [\"Yellow\", \"Blue\", \"Black\", \"Green\", \"Blue\", \"Red\"], [], [\"Red\", \"Black\", \"Blue\", \"Yellow\", \"Blue\", \"White\"], [], [], []], 6, {\"0\": 6, \"1\": 7, \"2\": 11, \"3\": 10, \"4\": 7, \"5\": 2, \"6\": 3, \"7\": 3, \"8\": 11, \"9\": 8}, 5]", "A*_args": "[\"[['White', 'White', 'Yellow', 'White', 'White', 'Black'], [], ['Red', 'Red', 'Green', 'Green', 'Green', 'Red'], ['Black', 'Yellow', 'Black', 'Yellow', 'Blue', 'Green'], ['Yellow', 'Blue', 'Black', 'Green', 'Blue', 'Red'], [], ['Red', 'Black', 'Blue', 'Yellow', 'Blue', 'White'], [], [], []]\", \"{0: 6, 1: 7, 2: 11, 3: 10, 4: 7, 5: 2, 6: 3, 7: 3, 8: 11, 9: 8}\", \"6\", \"5\"]"}
{"diff_sorted_id": "64", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 0) to his destination workshop at index (6, 12), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 5, and district 3 covering rows 6 to 12. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[8 x 12 x 16 x x x 7 x x x x]\n[x x x x 16 x 7 8 x 17 x 19 x]\n[7 x 13 x 19 x 6 x 14 x 18 x 19]\n[9 20 2 x 10 6 x 18 x x x 18 x]\n[x x 8 12 7 14 13 9 8 6 14 11 7]\n[x 14 x x x 19 13 15 3 12 16 16 3]\n[x x x 13 x 9 13 10 x 14 x 4 18]\n[6 12 10 x x 18 7 20 18 x 13 1 x]\n[x 5 x 18 12 x x 3 12 14 19 16 x]\n[10 x 19 x x x x 11 14 16 12 x 8]\n[8 x x x x x x 9 16 15 x x 8]\n[x x 2 x 1 x x 16 x x 3 x x]\n[9 x 5 x x 15 x x x 7 15 9 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "5", "opt_solution": "[[3, 0], [3, 1], [3, 2], [4, 2], [4, 3], [4, 4], [4, 5], [4, 6], [4, 7], [4, 8], [4, 9], [4, 10], [4, 11], [4, 12], [5, 12], [6, 12]]", "opt_solution_cost": "152", "opt_solution_compute_t": "0.018406391143798828", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"8\", \"x\", \"12\", \"x\", \"16\", \"x\", \"x\", \"x\", \"7\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"16\", \"x\", \"7\", \"8\", \"x\", \"17\", \"x\", \"19\", \"x\"], [\"7\", \"x\", \"13\", \"x\", \"19\", \"x\", \"6\", \"x\", \"14\", \"x\", \"18\", \"x\", \"19\"], [\"9\", \"20\", \"2\", \"x\", \"10\", \"6\", \"x\", \"18\", \"x\", \"x\", \"x\", \"18\", \"x\"], [\"x\", \"x\", \"8\", \"12\", \"7\", \"14\", \"13\", \"9\", \"8\", \"6\", \"14\", \"11\", \"7\"], [\"x\", \"14\", \"x\", \"x\", \"x\", \"19\", \"13\", \"15\", \"3\", \"12\", \"16\", \"16\", \"3\"], [\"x\", \"x\", \"x\", \"13\", \"x\", \"9\", \"13\", \"10\", \"x\", \"14\", \"x\", \"4\", \"18\"], [\"6\", \"12\", \"10\", \"x\", \"x\", \"18\", \"7\", \"20\", \"18\", \"x\", \"13\", \"1\", \"x\"], [\"x\", \"5\", \"x\", \"18\", \"12\", \"x\", \"x\", \"3\", \"12\", \"14\", \"19\", \"16\", \"x\"], [\"10\", \"x\", \"19\", \"x\", \"x\", \"x\", \"x\", \"11\", \"14\", \"16\", \"12\", \"x\", \"8\"], [\"8\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"9\", \"16\", \"15\", \"x\", \"x\", \"8\"], [\"x\", \"x\", \"2\", \"x\", \"1\", \"x\", \"x\", \"16\", \"x\", \"x\", \"3\", \"x\", \"x\"], [\"9\", \"x\", \"5\", \"x\", \"x\", \"15\", \"x\", \"x\", \"x\", \"7\", \"15\", \"9\", \"x\"]]]", "is_correct_args": "[[[\"8\", \"x\", \"12\", \"x\", \"16\", \"x\", \"x\", \"x\", \"7\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"16\", \"x\", \"7\", \"8\", \"x\", \"17\", \"x\", \"19\", \"x\"], [\"7\", \"x\", \"13\", \"x\", \"19\", \"x\", \"6\", \"x\", \"14\", \"x\", \"18\", \"x\", \"19\"], [\"9\", \"20\", \"2\", \"x\", \"10\", \"6\", \"x\", \"18\", \"x\", \"x\", \"x\", \"18\", \"x\"], [\"x\", \"x\", \"8\", \"12\", \"7\", \"14\", \"13\", \"9\", \"8\", \"6\", \"14\", \"11\", \"7\"], [\"x\", \"14\", \"x\", \"x\", \"x\", \"19\", \"13\", \"15\", \"3\", \"12\", \"16\", \"16\", \"3\"], [\"x\", \"x\", \"x\", \"13\", \"x\", \"9\", \"13\", \"10\", \"x\", \"14\", \"x\", \"4\", \"18\"], [\"6\", \"12\", \"10\", \"x\", \"x\", \"18\", \"7\", \"20\", \"18\", \"x\", \"13\", \"1\", \"x\"], [\"x\", \"5\", \"x\", \"18\", \"12\", \"x\", \"x\", \"3\", \"12\", \"14\", \"19\", \"16\", \"x\"], [\"10\", \"x\", \"19\", \"x\", \"x\", \"x\", \"x\", \"11\", \"14\", \"16\", \"12\", \"x\", \"8\"], [\"8\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"9\", \"16\", \"15\", \"x\", \"x\", \"8\"], [\"x\", \"x\", \"2\", \"x\", \"1\", \"x\", \"x\", \"16\", \"x\", \"x\", \"3\", \"x\", \"x\"], [\"9\", \"x\", \"5\", \"x\", \"x\", \"15\", \"x\", \"x\", \"x\", \"7\", \"15\", \"9\", \"x\"]], [3, 0], [6, 12], 3, 5]", "A*_args": "[\"[['8', 'x', '12', 'x', '16', 'x', 'x', 'x', '7', 'x', 'x', 'x', 'x'], ['x', 'x', 'x', 'x', '16', 'x', '7', '8', 'x', '17', 'x', '19', 'x'], ['7', 'x', '13', 'x', '19', 'x', '6', 'x', '14', 'x', '18', 'x', '19'], ['9', '20', '2', 'x', '10', '6', 'x', '18', 'x', 'x', 'x', '18', 'x'], ['x', 'x', '8', '12', '7', '14', '13', '9', '8', '6', '14', '11', '7'], ['x', '14', 'x', 'x', 'x', '19', '13', '15', '3', '12', '16', '16', '3'], ['x', 'x', 'x', '13', 'x', '9', '13', '10', 'x', '14', 'x', '4', '18'], ['6', '12', '10', 'x', 'x', '18', '7', '20', '18', 'x', '13', '1', 'x'], ['x', '5', 'x', '18', '12', 'x', 'x', '3', '12', '14', '19', '16', 'x'], ['10', 'x', '19', 'x', 'x', 'x', 'x', '11', '14', '16', '12', 'x', '8'], ['8', 'x', 'x', 'x', 'x', 'x', 'x', '9', '16', '15', 'x', 'x', '8'], ['x', 'x', '2', 'x', '1', 'x', 'x', '16', 'x', 'x', '3', 'x', 'x'], ['9', 'x', '5', 'x', 'x', '15', 'x', 'x', 'x', '7', '15', '9', 'x']]\", \"(3, 0)\", \"(6, 12)\", \"3\", \"5\"]"}
{"diff_sorted_id": "64", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 13x13. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 7) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (12, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 0 1 1 1 0 0 1 0 1 1 1\n1 1 1 1 1 1 0 0 1 1 1 0 1\n0 0 1 1 0 0 0 0 1 1 1 0 1\n1 1 1 1 1 0 0 0 1 0 0 0 0\n1 0 1 1 1 0 0 0 0 1 1 0 1\n0 0 0 0 0 0 1 1 0 1 0 0 0\n0 0 0 1 1 1 0 0 0 1 0 1 1\n0 1 1 1 1 1 0 0 0 1 1 0 1\n0 1 1 0 0 1 1 0 0 0 0 1 1\n0 0 1 1 1 1 0 1 0 1 0 0 1\n0 0 1 1 0 0 1 1 1 1 1 1 1\n0 0 1 1 1 0 1 0 0 1 0 1 1\n1 0 0 1 0 1 0 0 0 0 1 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[[0, 7], [1, 6], [2, 5], [3, 5], [4, 5], [5, 4], [5, 3], [5, 2], [6, 2], [6, 1], [6, 0], [7, 0], [8, 0], [9, 0], [10, 0], [11, 0], [12, 1]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.031978607177734375", "solution_depth": "17", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1], [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1], [0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1], [0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1], [0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1], [0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1], [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]]\", 4]", "is_correct_args": "[\"[[1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1], [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1], [0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1], [0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1], [0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1], [0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1], [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]]\", [0, 7], [12, 1], 4]", "A*_args": "[\"[[1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1], [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1], [0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1], [0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1], [0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1], [0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1], [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0]]\", \"(0, 7)\", \"(12, 1)\", \"4\"]"}
{"diff_sorted_id": "64", "problem_statement": "Given 5 labeled water jugs with capacities 14, 42, 113, 131, 41, 147 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 240, 257, 350, 369 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 41, 4], [\"+\", 42, 4], [\"+\", 113, 4], [\"+\", 131, 4], [\"+\", 42, 4], [\"+\", 42, 3], [\"+\", 147, 3], [\"+\", 14, 3], [\"+\", 147, 3], [\"+\", 42, 2], [\"+\", 42, 2], [\"+\", 42, 2], [\"+\", 131, 2], [\"+\", 113, 1], [\"+\", 113, 1], [\"+\", 14, 1]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.02796316146850586", "solution_depth": "16", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[14, 42, 113, 131, 41, 147], [240, 257, 350, 369]]", "is_correct_args": "[[14, 42, 113, 131, 41, 147], [240, 257, 350, 369]]", "A*_args": "[\"[14, 42, 113, 131, 41, 147]\", \"[240, 257, 350, 369]\"]"}
{"diff_sorted_id": "65", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[94, 93, 84, 27, 6], [55, 18, 91, 82, 8], [19, 32, 37, 30, '_']]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[8, 6, 27, 82, 30, 8, 6, 27, 82, 84, 91, 37, 32, 18, 37, 32, 8, 6]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.03599905967712402", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[94, 93, 84, 27, 6], [55, 18, 91, 82, 8], [19, 32, 37, 30, \"_\"]]]", "is_correct_args": "[[[94, 93, 84, 27, 6], [55, 18, 91, 82, 8], [19, 32, 37, 30, \"_\"]]]", "A*_args": "[\"[[94, 93, 84, 27, 6], [55, 18, 91, 82, 8], [19, 32, 37, 30, '_']]\"]"}
{"diff_sorted_id": "65", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: ned, wham, royt, hell, miek   The initial board: [['h', 'n', '_', 'd'], ['w', 'r', 'a', 'e'], ['e', 'o', 'y', 't'], ['h', 'e', 'l', 'm'], ['m', 'i', 'l', 'k']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.29477596282958984", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"h\", \"n\", \"_\", \"d\"], [\"w\", \"r\", \"a\", \"e\"], [\"e\", \"o\", \"y\", \"t\"], [\"h\", \"e\", \"l\", \"m\"], [\"m\", \"i\", \"l\", \"k\"]]]", "is_correct_args": "[[[\"h\", \"n\", \"_\", \"d\"], [\"w\", \"r\", \"a\", \"e\"], [\"e\", \"o\", \"y\", \"t\"], [\"h\", \"e\", \"l\", \"m\"], [\"m\", \"i\", \"l\", \"k\"]], [\"ned\", \"wham\", \"royt\", \"hell\", \"miek\"]]", "A*_args": "[\"[['h', 'n', '_', 'd'], ['w', 'r', 'a', 'e'], ['e', 'o', 'y', 't'], ['h', 'e', 'l', 'm'], ['m', 'i', 'l', 'k']]\", \"['ned', 'wham', 'royt', 'hell', 'miek']\"]"}
{"diff_sorted_id": "65", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'Q'. Our task is to visit city F and city N excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from N and F, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  F D E Z G Y N I X P S Q C \nF 0 0 0 1 0 0 0 1 0 1 0 0 0 \nD 1 0 1 0 0 0 0 1 0 0 0 0 0 \nE 0 0 0 0 1 0 0 0 0 0 1 0 1 \nZ 0 0 1 0 0 1 0 0 1 0 1 0 1 \nG 1 0 0 0 0 0 0 1 0 1 0 0 0 \nY 0 0 0 0 1 0 0 1 0 0 0 0 0 \nN 0 0 0 0 0 1 0 0 0 0 0 0 0 \nI 0 0 1 1 0 0 0 0 1 0 0 0 0 \nX 0 0 1 0 1 0 0 0 0 1 0 0 0 \nP 0 1 0 1 0 0 0 0 0 0 0 1 0 \nS 1 1 0 0 0 0 1 0 1 0 0 0 1 \nQ 0 1 0 0 0 0 0 0 1 0 0 0 0 \nC 0 0 0 0 1 0 1 1 1 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[\"Q\", \"D\", \"F\", \"I\", \"E\", \"C\", \"N\", \"Y\", \"G\", \"F\", \"Z\", \"S\", \"N\"]", "opt_solution_cost": "13", "opt_solution_compute_t": "0.07228732109069824", "solution_depth": "13", "max_successor_states": "13", "num_vars_per_state": "16", "is_feasible_args": "[[[0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0]], [\"F\", \"D\", \"E\", \"Z\", \"G\", \"Y\", \"N\", \"I\", \"X\", \"P\", \"S\", \"Q\", \"C\"], \"F\", \"N\"]", "is_correct_args": "[[[0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0]], [\"F\", \"D\", \"E\", \"Z\", \"G\", \"Y\", \"N\", \"I\", \"X\", \"P\", \"S\", \"Q\", \"C\"], \"Q\", \"F\", \"N\"]", "A*_args": "[\"[[0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0]]\", \"['F', 'D', 'E', 'Z', 'G', 'Y', 'N', 'I', 'X', 'P', 'S', 'Q', 'C']\", \"['Q']\", \"['F', 'N']\"]"}
{"diff_sorted_id": "65", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [9, 30, 18, 32, 31, 20, 34, 9, 12, 18, 14, 16, 29, 37, 37, 6, 24, 10, 10, 35, 23, 4, 30, 121, 31, 16, 35], such that the sum of the chosen coins adds up to 406. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {35: 20, 4: 2, 18: 11, 24: 10, 10: 7, 14: 3, 37: 1, 16: 14, 12: 7, 6: 2, 29: 18, 34: 19, 121: 10, 31: 7, 30: 12, 32: 12, 23: 8, 20: 8, 9: 9}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "16", "opt_solution": "[31, 37, 121, 6, 31, 30, 24, 37, 32, 20, 14, 23]", "opt_solution_cost": "81", "opt_solution_compute_t": "0.04330945014953613", "solution_depth": "12", "max_successor_states": "27", "num_vars_per_state": "27", "is_feasible_args": "[[9, 30, 18, 32, 31, 20, 34, 9, 12, 18, 14, 16, 29, 37, 37, 6, 24, 10, 10, 35, 23, 4, 30, 121, 31, 16, 35]]", "is_correct_args": "[[9, 30, 18, 32, 31, 20, 34, 9, 12, 18, 14, 16, 29, 37, 37, 6, 24, 10, 10, 35, 23, 4, 30, 121, 31, 16, 35], {\"35\": 20, \"4\": 2, \"18\": 11, \"24\": 10, \"10\": 7, \"14\": 3, \"37\": 1, \"16\": 14, \"12\": 7, \"6\": 2, \"29\": 18, \"34\": 19, \"121\": 10, \"31\": 7, \"30\": 12, \"32\": 12, \"23\": 8, \"20\": 8, \"9\": 9}, 406]", "A*_args": "[\"[9, 30, 18, 32, 31, 20, 34, 9, 12, 18, 14, 16, 29, 37, 37, 6, 24, 10, 10, 35, 23, 4, 30, 121, 31, 16, 35]\", \"{35: 20, 4: 2, 18: 11, 24: 10, 10: 7, 14: 3, 37: 1, 16: 14, 12: 7, 6: 2, 29: 18, 34: 19, 121: 10, 31: 7, 30: 12, 32: 12, 23: 8, 20: 8, 9: 9}\", \"406\"]"}
{"diff_sorted_id": "65", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Blue', 'Red', 'Red'], ['Red', 'Red', 'Blue', 'Green', 'Blue'], ['Green', 'Green', 'Red', 'Blue', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[0, 1], [2, 0], [2, 0], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [1, 2], [1, 0], [1, 2], [1, 0], [1, 0], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [0, 2], [0, 1]]", "opt_solution_cost": "21", "opt_solution_compute_t": "12.990425109863281", "solution_depth": "21", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Blue\", \"Red\", \"Red\"], [\"Red\", \"Red\", \"Blue\", \"Green\", \"Blue\"], [\"Green\", \"Green\", \"Red\", \"Blue\", \"Green\"]], 8]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Blue\", \"Red\", \"Red\"], [\"Red\", \"Red\", \"Blue\", \"Green\", \"Blue\"], [\"Green\", \"Green\", \"Red\", \"Blue\", \"Green\"]], 8]", "A*_args": "[\"[['Blue', 'Green', 'Blue', 'Red', 'Red'], ['Red', 'Red', 'Blue', 'Green', 'Blue'], ['Green', 'Green', 'Red', 'Blue', 'Green']]\", \"8\"]"}
{"diff_sorted_id": "65", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 31 to 76 (31 included in the range but 76 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '68' '71' 'x']\n ['x' 'x' '62' 'x']\n ['43' 'x' '55' 'x']\n ['44' '45' '52' '58']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "12", "opt_solution": "[[1, 0, 11], [1, 3, 47], [2, 2, 44], [2, 3, 48], [3, 0, 22], [3, 1, 41], [3, 2, 45]]", "opt_solution_cost": "444", "opt_solution_compute_t": "0.25410008430480957", "solution_depth": "7", "max_successor_states": "45", "num_vars_per_state": "16", "is_feasible_args": "[\"[['10', '26', '30', '46'], ['', '33', '43', ''], ['21', '40', '', ''], ['', '', '', '52']]\", 9, 54]", "is_correct_args": "[\"[['10', '26', '30', '46'], ['', '33', '43', ''], ['21', '40', '', ''], ['', '', '', '52']]\", 9, 54]", "A*_args": "[\"[['10', '26', '30', '46'], ['', '33', '43', ''], ['21', '40', '', ''], ['', '', '', '52']]\", \"9\", \"54\"]"}
{"diff_sorted_id": "65", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 30 to 66. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 191, 190, None for columns 1 to 2 respectively, and the sums of rows must be None, 192, 173, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 180. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '65' '49' '35']\n ['40' 'x' '52' 'x']\n ['x' 'x' '34' 'x']\n ['x' 'x' '55' '61']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 0, 31], [1, 1, 36], [1, 3, 64], [2, 0, 32], [2, 1, 60], [2, 3, 47], [3, 0, 33], [3, 1, 30]]", "opt_solution_cost": "724", "opt_solution_compute_t": "7.544063568115234", "solution_depth": "8", "max_successor_states": "26", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '65', '49', '35'], ['40', '', '52', ''], ['', '', '34', ''], ['', '', '55', '61']]\", 4, 30, 66]", "is_correct_args": "[\"[['', '65', '49', '35'], ['40', '', '52', ''], ['', '', '34', ''], ['', '', '55', '61']]\", 30, 66, [1, 3], [1, 3], [191, 190], [192, 173], 180]", "A*_args": "[\"[['', '65', '49', '35'], ['40', '', '52', ''], ['', '', '34', ''], ['', '', '55', '61']]\", \"30\", \"66\", \"[None, 191, 190, None]\", \"[None, 192, 173, None]\", \"180\"]"}
{"diff_sorted_id": "65", "problem_statement": "In 'Restricted Sorting', there are 10 stacks each with a capacity of 6 blocks, with 5 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 5 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 3, 1: 6, 2: 3, 3: 6, 4: 9, 5: 6, 6: 6, 7: 10, 8: 2, 9: 5}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Yellow', 'White', 'Blue', 'Yellow', 'Red', 'White'], [], [], ['Blue', 'Blue', 'Green', 'Black', 'Black', 'Red'], ['Black', 'Green', 'Yellow', 'Yellow', 'Blue', 'Black'], [], ['White', 'Blue', 'Green', 'White', 'Yellow', 'Red'], [], ['Green', 'White', 'Black', 'Red', 'Green', 'Red']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "3", "opt_solution": "[[4, 8], [4, 8], [4, 0], [9, 0], [9, 2], [7, 2], [7, 8], [7, 0], [7, 2], [1, 3], [5, 6], [5, 0], [7, 3], [9, 6], [1, 2], [1, 8], [1, 3], [5, 3], [5, 3], [5, 8], [4, 6], [4, 6], [5, 6], [9, 5], [9, 0], [1, 9], [4, 9], [5, 9], [7, 9], [1, 2]]", "opt_solution_cost": "126", "opt_solution_compute_t": "0.4554884433746338", "solution_depth": "30", "max_successor_states": "90", "num_vars_per_state": "30", "is_feasible_args": "[[[], [\"Yellow\", \"White\", \"Blue\", \"Yellow\", \"Red\", \"White\"], [], [], [\"Blue\", \"Blue\", \"Green\", \"Black\", \"Black\", \"Red\"], [\"Black\", \"Green\", \"Yellow\", \"Yellow\", \"Blue\", \"Black\"], [], [\"White\", \"Blue\", \"Green\", \"White\", \"Yellow\", \"Red\"], [], [\"Green\", \"White\", \"Black\", \"Red\", \"Green\", \"Red\"]], 6, {\"0\": 3, \"1\": 6, \"2\": 3, \"3\": 6, \"4\": 9, \"5\": 6, \"6\": 6, \"7\": 10, \"8\": 2, \"9\": 5}]", "is_correct_args": "[[[], [\"Yellow\", \"White\", \"Blue\", \"Yellow\", \"Red\", \"White\"], [], [], [\"Blue\", \"Blue\", \"Green\", \"Black\", \"Black\", \"Red\"], [\"Black\", \"Green\", \"Yellow\", \"Yellow\", \"Blue\", \"Black\"], [], [\"White\", \"Blue\", \"Green\", \"White\", \"Yellow\", \"Red\"], [], [\"Green\", \"White\", \"Black\", \"Red\", \"Green\", \"Red\"]], 6, {\"0\": 3, \"1\": 6, \"2\": 3, \"3\": 6, \"4\": 9, \"5\": 6, \"6\": 6, \"7\": 10, \"8\": 2, \"9\": 5}, 5]", "A*_args": "[\"[[], ['Yellow', 'White', 'Blue', 'Yellow', 'Red', 'White'], [], [], ['Blue', 'Blue', 'Green', 'Black', 'Black', 'Red'], ['Black', 'Green', 'Yellow', 'Yellow', 'Blue', 'Black'], [], ['White', 'Blue', 'Green', 'White', 'Yellow', 'Red'], [], ['Green', 'White', 'Black', 'Red', 'Green', 'Red']]\", \"{0: 3, 1: 6, 2: 3, 3: 6, 4: 9, 5: 6, 6: 6, 7: 10, 8: 2, 9: 5}\", \"6\", \"5\"]"}
{"diff_sorted_id": "65", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (8, 11) to his destination workshop at index (2, 3), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 7, and district 3 covering rows 8 to 12. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[11 x x x 15 5 18 4 1 17 14 x 9]\n[x 10 10 7 12 12 6 x x 8 4 19 11]\n[17 x x 12 8 x x x 14 19 x 18 16]\n[17 x 16 x x 17 4 x 15 x x x 17]\n[17 x x 6 x x 12 6 10 3 11 x 19]\n[10 x 9 15 17 4 x x x x 14 17 18]\n[4 x x x x 13 18 13 x 17 12 x 19]\n[x 2 11 7 6 14 9 x 12 17 9 13 14]\n[x 18 16 x x x 11 6 12 x x 10 x]\n[5 3 x x x 5 x 14 x x x x x]\n[18 x x x x 14 x x 13 1 3 x x]\n[1 16 10 x x 14 13 x 10 x 1 x 18]\n[8 x x 10 2 10 x x x x x 13 5]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "5", "opt_solution": "[[8, 11], [7, 11], [7, 10], [6, 10], [5, 10], [4, 10], [4, 9], [4, 8], [3, 8], [2, 8], [2, 9], [1, 9], [0, 9], [0, 8], [0, 7], [0, 6], [0, 5], [1, 5], [1, 4], [1, 3], [2, 3]]", "opt_solution_cost": "216", "opt_solution_compute_t": "0.018636226654052734", "solution_depth": "21", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"11\", \"x\", \"x\", \"x\", \"15\", \"5\", \"18\", \"4\", \"1\", \"17\", \"14\", \"x\", \"9\"], [\"x\", \"10\", \"10\", \"7\", \"12\", \"12\", \"6\", \"x\", \"x\", \"8\", \"4\", \"19\", \"11\"], [\"17\", \"x\", \"x\", \"12\", \"8\", \"x\", \"x\", \"x\", \"14\", \"19\", \"x\", \"18\", \"16\"], [\"17\", \"x\", \"16\", \"x\", \"x\", \"17\", \"4\", \"x\", \"15\", \"x\", \"x\", \"x\", \"17\"], [\"17\", \"x\", \"x\", \"6\", \"x\", \"x\", \"12\", \"6\", \"10\", \"3\", \"11\", \"x\", \"19\"], [\"10\", \"x\", \"9\", \"15\", \"17\", \"4\", \"x\", \"x\", \"x\", \"x\", \"14\", \"17\", \"18\"], [\"4\", \"x\", \"x\", \"x\", \"x\", \"13\", \"18\", \"13\", \"x\", \"17\", \"12\", \"x\", \"19\"], [\"x\", \"2\", \"11\", \"7\", \"6\", \"14\", \"9\", \"x\", \"12\", \"17\", \"9\", \"13\", \"14\"], [\"x\", \"18\", \"16\", \"x\", \"x\", \"x\", \"11\", \"6\", \"12\", \"x\", \"x\", \"10\", \"x\"], [\"5\", \"3\", \"x\", \"x\", \"x\", \"5\", \"x\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"18\", \"x\", \"x\", \"x\", \"x\", \"14\", \"x\", \"x\", \"13\", \"1\", \"3\", \"x\", \"x\"], [\"1\", \"16\", \"10\", \"x\", \"x\", \"14\", \"13\", \"x\", \"10\", \"x\", \"1\", \"x\", \"18\"], [\"8\", \"x\", \"x\", \"10\", \"2\", \"10\", \"x\", \"x\", \"x\", \"x\", \"x\", \"13\", \"5\"]]]", "is_correct_args": "[[[\"11\", \"x\", \"x\", \"x\", \"15\", \"5\", \"18\", \"4\", \"1\", \"17\", \"14\", \"x\", \"9\"], [\"x\", \"10\", \"10\", \"7\", \"12\", \"12\", \"6\", \"x\", \"x\", \"8\", \"4\", \"19\", \"11\"], [\"17\", \"x\", \"x\", \"12\", \"8\", \"x\", \"x\", \"x\", \"14\", \"19\", \"x\", \"18\", \"16\"], [\"17\", \"x\", \"16\", \"x\", \"x\", \"17\", \"4\", \"x\", \"15\", \"x\", \"x\", \"x\", \"17\"], [\"17\", \"x\", \"x\", \"6\", \"x\", \"x\", \"12\", \"6\", \"10\", \"3\", \"11\", \"x\", \"19\"], [\"10\", \"x\", \"9\", \"15\", \"17\", \"4\", \"x\", \"x\", \"x\", \"x\", \"14\", \"17\", \"18\"], [\"4\", \"x\", \"x\", \"x\", \"x\", \"13\", \"18\", \"13\", \"x\", \"17\", \"12\", \"x\", \"19\"], [\"x\", \"2\", \"11\", \"7\", \"6\", \"14\", \"9\", \"x\", \"12\", \"17\", \"9\", \"13\", \"14\"], [\"x\", \"18\", \"16\", \"x\", \"x\", \"x\", \"11\", \"6\", \"12\", \"x\", \"x\", \"10\", \"x\"], [\"5\", \"3\", \"x\", \"x\", \"x\", \"5\", \"x\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"18\", \"x\", \"x\", \"x\", \"x\", \"14\", \"x\", \"x\", \"13\", \"1\", \"3\", \"x\", \"x\"], [\"1\", \"16\", \"10\", \"x\", \"x\", \"14\", \"13\", \"x\", \"10\", \"x\", \"1\", \"x\", \"18\"], [\"8\", \"x\", \"x\", \"10\", \"2\", \"10\", \"x\", \"x\", \"x\", \"x\", \"x\", \"13\", \"5\"]], [8, 11], [2, 3], 2, 7]", "A*_args": "[\"[['11', 'x', 'x', 'x', '15', '5', '18', '4', '1', '17', '14', 'x', '9'], ['x', '10', '10', '7', '12', '12', '6', 'x', 'x', '8', '4', '19', '11'], ['17', 'x', 'x', '12', '8', 'x', 'x', 'x', '14', '19', 'x', '18', '16'], ['17', 'x', '16', 'x', 'x', '17', '4', 'x', '15', 'x', 'x', 'x', '17'], ['17', 'x', 'x', '6', 'x', 'x', '12', '6', '10', '3', '11', 'x', '19'], ['10', 'x', '9', '15', '17', '4', 'x', 'x', 'x', 'x', '14', '17', '18'], ['4', 'x', 'x', 'x', 'x', '13', '18', '13', 'x', '17', '12', 'x', '19'], ['x', '2', '11', '7', '6', '14', '9', 'x', '12', '17', '9', '13', '14'], ['x', '18', '16', 'x', 'x', 'x', '11', '6', '12', 'x', 'x', '10', 'x'], ['5', '3', 'x', 'x', 'x', '5', 'x', '14', 'x', 'x', 'x', 'x', 'x'], ['18', 'x', 'x', 'x', 'x', '14', 'x', 'x', '13', '1', '3', 'x', 'x'], ['1', '16', '10', 'x', 'x', '14', '13', 'x', '10', 'x', '1', 'x', '18'], ['8', 'x', 'x', '10', '2', '10', 'x', 'x', 'x', 'x', 'x', '13', '5']]\", \"(8, 11)\", \"(2, 3)\", \"2\", \"7\"]"}
{"diff_sorted_id": "65", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 13x13. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (8, 9). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 1 1 1 0 0 0 0 0 0 0 0\n1 0 0 0 0 0 0 1 0 0 0 0 1\n1 0 1 0 1 0 0 1 0 0 1 1 1\n1 0 0 1 1 1 0 1 0 0 0 0 0\n1 1 1 0 1 0 1 0 0 1 1 0 0\n1 0 1 0 0 1 1 1 0 0 1 0 1\n1 1 1 0 0 0 0 1 1 1 1 0 0\n1 0 0 1 1 0 0 1 0 1 0 0 1\n1 1 0 0 1 0 1 1 0 0 0 0 1\n1 1 0 1 1 0 0 0 0 1 1 0 0\n0 0 1 1 0 0 1 1 1 0 0 1 0\n0 1 1 0 0 0 0 0 1 0 0 0 0\n0 1 1 0 1 1 1 1 1 1 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[[0, 0], [0, 1], [1, 1], [2, 1], [3, 1], [3, 2], [4, 3], [5, 3], [5, 4], [6, 5], [7, 5], [8, 5], [9, 6], [9, 7], [9, 8], [8, 9]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.03348350524902344", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1], [1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0], [1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1], [1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1], [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1], [1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0], [0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]]\", 4]", "is_correct_args": "[\"[[0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1], [1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0], [1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1], [1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1], [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1], [1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0], [0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]]\", [0, 0], [8, 9], 4]", "A*_args": "[\"[[0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1], [1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0], [1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1], [1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1], [1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1], [1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0], [0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1]]\", \"(0, 0)\", \"(8, 9)\", \"4\"]"}
{"diff_sorted_id": "65", "problem_statement": "Given 5 labeled water jugs with capacities 141, 116, 66, 83, 142 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 397, 401, 419, 425 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 141, 4], [\"+\", 142, 4], [\"+\", 142, 4], [\"+\", 142, 3], [\"+\", 142, 3], [\"-\", 66, 3], [\"+\", 142, 3], [\"-\", 83, 3], [\"+\", 142, 3], [\"+\", 116, 2], [\"+\", 142, 2], [\"+\", 142, 2], [\"-\", 141, 2], [\"+\", 142, 2], [\"+\", 66, 1], [\"+\", 66, 1], [\"+\", 66, 1], [\"+\", 116, 1], [\"+\", 83, 1]]", "opt_solution_cost": "19", "opt_solution_compute_t": "0.0269773006439209", "solution_depth": "19", "max_successor_states": "40", "num_vars_per_state": "3", "is_feasible_args": "[[141, 116, 66, 83, 142], [397, 401, 419, 425]]", "is_correct_args": "[[141, 116, 66, 83, 142], [397, 401, 419, 425]]", "A*_args": "[\"[141, 116, 66, 83, 142]\", \"[397, 401, 419, 425]\"]"}
{"diff_sorted_id": "66", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[94, 91, 33, 29, 78], [97, 20, 14, 54, 25], [38, 22, 32, 17, '_']]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[25, 54, 14, 33, 91, 94, 97, 38, 22, 20, 33, 32, 17, 14, 29, 78, 54, 25]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.03129744529724121", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[94, 91, 33, 29, 78], [97, 20, 14, 54, 25], [38, 22, 32, 17, \"_\"]]]", "is_correct_args": "[[[94, 91, 33, 29, 78], [97, 20, 14, 54, 25], [38, 22, 32, 17, \"_\"]]]", "A*_args": "[\"[[94, 91, 33, 29, 78], [97, 20, 14, 54, 25], [38, 22, 32, 17, '_']]\"]"}
{"diff_sorted_id": "66", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: jay, eppy, home, roon, ward   The initial board: [['p', 'j', 'm', 'y'], ['e', 'h', 'p', 'o'], ['y', 'o', '_', 'e'], ['r', 'a', 'o', 'n'], ['w', 'a', 'r', 'd']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.16893219947814941", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"p\", \"j\", \"m\", \"y\"], [\"e\", \"h\", \"p\", \"o\"], [\"y\", \"o\", \"_\", \"e\"], [\"r\", \"a\", \"o\", \"n\"], [\"w\", \"a\", \"r\", \"d\"]]]", "is_correct_args": "[[[\"p\", \"j\", \"m\", \"y\"], [\"e\", \"h\", \"p\", \"o\"], [\"y\", \"o\", \"_\", \"e\"], [\"r\", \"a\", \"o\", \"n\"], [\"w\", \"a\", \"r\", \"d\"]], [\"jay\", \"eppy\", \"home\", \"roon\", \"ward\"]]", "A*_args": "[\"[['p', 'j', 'm', 'y'], ['e', 'h', 'p', 'o'], ['y', 'o', '_', 'e'], ['r', 'a', 'o', 'n'], ['w', 'a', 'r', 'd']]\", \"['jay', 'eppy', 'home', 'roon', 'ward']\"]"}
{"diff_sorted_id": "66", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'L'. Our task is to visit city K and city J excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from J and K, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  L A J U E P Q Y H R K M F \nL 0 0 0 0 0 0 0 0 0 0 0 0 1 \nA 1 0 0 1 0 1 0 0 0 0 0 0 0 \nJ 0 1 0 0 0 0 0 1 0 0 0 1 0 \nU 0 0 0 0 1 0 0 0 0 1 1 1 0 \nE 0 0 0 0 0 0 1 0 0 0 0 1 0 \nP 0 0 0 0 0 0 1 0 0 0 1 1 0 \nQ 0 0 1 1 0 0 0 0 0 1 1 0 1 \nY 1 1 0 1 0 0 0 0 0 1 0 0 0 \nH 1 0 1 1 0 1 0 1 0 1 0 0 1 \nR 0 0 0 0 1 0 0 0 0 0 1 0 0 \nK 0 1 0 0 1 1 0 0 0 1 0 0 0 \nM 0 0 0 0 0 1 1 0 1 0 0 0 0 \nF 0 1 0 0 1 1 0 1 0 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[\"L\", \"F\", \"K\", \"P\", \"K\", \"E\", \"Q\", \"J\", \"M\", \"H\", \"J\"]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.05126047134399414", "solution_depth": "11", "max_successor_states": "13", "num_vars_per_state": "16", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0]], [\"L\", \"A\", \"J\", \"U\", \"E\", \"P\", \"Q\", \"Y\", \"H\", \"R\", \"K\", \"M\", \"F\"], \"K\", \"J\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0]], [\"L\", \"A\", \"J\", \"U\", \"E\", \"P\", \"Q\", \"Y\", \"H\", \"R\", \"K\", \"M\", \"F\"], \"L\", \"K\", \"J\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0]]\", \"['L', 'A', 'J', 'U', 'E', 'P', 'Q', 'Y', 'H', 'R', 'K', 'M', 'F']\", \"['L']\", \"['K', 'J']\"]"}
{"diff_sorted_id": "66", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [3, 35, 33, 20, 31, 29, 12, 31, 8, 10, 3, 17, 2, 28, 6, 25, 10, 13, 31, 25, 37, 35, 9, 15, 113, 26, 18, 34, 30], such that the sum of the chosen coins adds up to 384. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {31: 11, 15: 6, 13: 13, 28: 1, 9: 6, 20: 1, 34: 15, 6: 5, 113: 20, 12: 6, 2: 1, 29: 10, 37: 2, 25: 11, 26: 10, 3: 3, 33: 19, 8: 7, 18: 6, 17: 7, 10: 8, 35: 11, 30: 16}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "17", "opt_solution": "[37, 28, 18, 35, 113, 26, 29, 31, 35, 20, 12]", "opt_solution_cost": "89", "opt_solution_compute_t": "0.043546199798583984", "solution_depth": "11", "max_successor_states": "29", "num_vars_per_state": "29", "is_feasible_args": "[[3, 35, 33, 20, 31, 29, 12, 31, 8, 10, 3, 17, 2, 28, 6, 25, 10, 13, 31, 25, 37, 35, 9, 15, 113, 26, 18, 34, 30]]", "is_correct_args": "[[3, 35, 33, 20, 31, 29, 12, 31, 8, 10, 3, 17, 2, 28, 6, 25, 10, 13, 31, 25, 37, 35, 9, 15, 113, 26, 18, 34, 30], {\"31\": 11, \"15\": 6, \"13\": 13, \"28\": 1, \"9\": 6, \"20\": 1, \"34\": 15, \"6\": 5, \"113\": 20, \"12\": 6, \"2\": 1, \"29\": 10, \"37\": 2, \"25\": 11, \"26\": 10, \"3\": 3, \"33\": 19, \"8\": 7, \"18\": 6, \"17\": 7, \"10\": 8, \"35\": 11, \"30\": 16}, 384]", "A*_args": "[\"[3, 35, 33, 20, 31, 29, 12, 31, 8, 10, 3, 17, 2, 28, 6, 25, 10, 13, 31, 25, 37, 35, 9, 15, 113, 26, 18, 34, 30]\", \"{31: 11, 15: 6, 13: 13, 28: 1, 9: 6, 20: 1, 34: 15, 6: 5, 113: 20, 12: 6, 2: 1, 29: 10, 37: 2, 25: 11, 26: 10, 3: 3, 33: 19, 8: 7, 18: 6, 17: 7, 10: 8, 35: 11, 30: 16}\", \"384\"]"}
{"diff_sorted_id": "66", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Blue', 'Green', 'Red'], ['Red', 'Blue', 'Blue', 'Green', 'Red'], ['Red', 'Blue', 'Green', 'Green', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[0, 2], [1, 2], [0, 1], [0, 1], [0, 1], [2, 0], [2, 0], [2, 0], [1, 0], [2, 1], [2, 0], [2, 0], [1, 2], [1, 2], [1, 0], [1, 2], [1, 2], [1, 2], [1, 2], [0, 1], [0, 1], [0, 1], [0, 1], [2, 0], [2, 1]]", "opt_solution_cost": "25", "opt_solution_compute_t": "84.72133731842041", "solution_depth": "25", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Red\", \"Green\", \"Blue\", \"Green\", \"Red\"], [\"Red\", \"Blue\", \"Blue\", \"Green\", \"Red\"], [\"Red\", \"Blue\", \"Green\", \"Green\", \"Blue\"]], 8]", "is_correct_args": "[[[\"Red\", \"Green\", \"Blue\", \"Green\", \"Red\"], [\"Red\", \"Blue\", \"Blue\", \"Green\", \"Red\"], [\"Red\", \"Blue\", \"Green\", \"Green\", \"Blue\"]], 8]", "A*_args": "[\"[['Red', 'Green', 'Blue', 'Green', 'Red'], ['Red', 'Blue', 'Blue', 'Green', 'Red'], ['Red', 'Blue', 'Green', 'Green', 'Blue']]\", \"8\"]"}
{"diff_sorted_id": "66", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 9 to 54 (9 included in the range but 54 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['10' '26' '30' '46']\n ['x' '33' '43' 'x']\n ['21' '40' 'x' 'x']\n ['x' 'x' 'x' '52']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "12", "opt_solution": "[[0, 0, 17], [0, 2, 41], [0, 3, 46], [1, 0, 16], [1, 3, 45], [2, 1, 21], [2, 2, 39], [3, 3, 38]]", "opt_solution_cost": "443", "opt_solution_compute_t": "425.06947112083435", "solution_depth": "8", "max_successor_states": "45", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '37', '', ''], ['', '35', '40', ''], ['15', '', '', '44'], ['11', '20', '36', '']]\", 9, 54]", "is_correct_args": "[\"[['', '37', '', ''], ['', '35', '40', ''], ['15', '', '', '44'], ['11', '20', '36', '']]\", 9, 54]", "A*_args": "[\"[['', '37', '', ''], ['', '35', '40', ''], ['15', '', '', '44'], ['11', '20', '36', '']]\", \"9\", \"54\"]"}
{"diff_sorted_id": "66", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 31 to 67. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 217, 193, None for columns 1 to 2 respectively, and the sums of rows must be None, 156, 208, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 166. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' '64' 'x']\n ['34' '54' 'x' 'x']\n ['x' '56' '53' 'x']\n ['36' 'x' 'x' '49']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 0, 31], [0, 1, 42], [0, 3, 39], [1, 2, 35], [1, 3, 33], [2, 0, 37], [2, 3, 62], [3, 1, 65], [3, 2, 41]]", "opt_solution_cost": "731", "opt_solution_compute_t": "11.399878740310669", "solution_depth": "9", "max_successor_states": "26", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '64', ''], ['34', '54', '', ''], ['', '56', '53', ''], ['36', '', '', '49']]\", 4, 31, 67]", "is_correct_args": "[\"[['', '', '64', ''], ['34', '54', '', ''], ['', '56', '53', ''], ['36', '', '', '49']]\", 31, 67, [1, 3], [1, 3], [217, 193], [156, 208], 166]", "A*_args": "[\"[['', '', '64', ''], ['34', '54', '', ''], ['', '56', '53', ''], ['36', '', '', '49']]\", \"31\", \"67\", \"[None, 217, 193, None]\", \"[None, 156, 208, None]\", \"166\"]"}
{"diff_sorted_id": "66", "problem_statement": "In 'Restricted Sorting', there are 10 stacks each with a capacity of 6 blocks, with 5 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 5 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 4, 1: 5, 2: 2, 3: 10, 4: 6, 5: 8, 6: 2, 7: 11, 8: 2, 9: 8}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], ['White', 'Black', 'Green', 'White', 'Green', 'Blue'], ['Red', 'Green', 'Black', 'Red', 'White', 'Yellow'], [], ['Yellow', 'Black', 'Yellow', 'Red', 'Green', 'White'], [], ['White', 'Blue', 'Red', 'Red', 'Blue', 'Black'], [], ['Yellow', 'Blue', 'Yellow', 'Blue', 'Green', 'Black']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "3", "opt_solution": "[[2, 6], [7, 6], [7, 8], [9, 0], [2, 1], [9, 8], [9, 0], [9, 8], [9, 4], [5, 0], [5, 1], [5, 0], [2, 4], [2, 6], [2, 4], [2, 8], [5, 2], [7, 2], [7, 2], [7, 8], [5, 4], [3, 2], [3, 4], [3, 1], [3, 2], [3, 6], [7, 1], [9, 1], [3, 0], [5, 6]]", "opt_solution_cost": "105", "opt_solution_compute_t": "0.0666203498840332", "solution_depth": "30", "max_successor_states": "90", "num_vars_per_state": "30", "is_feasible_args": "[[[], [], [\"White\", \"Black\", \"Green\", \"White\", \"Green\", \"Blue\"], [\"Red\", \"Green\", \"Black\", \"Red\", \"White\", \"Yellow\"], [], [\"Yellow\", \"Black\", \"Yellow\", \"Red\", \"Green\", \"White\"], [], [\"White\", \"Blue\", \"Red\", \"Red\", \"Blue\", \"Black\"], [], [\"Yellow\", \"Blue\", \"Yellow\", \"Blue\", \"Green\", \"Black\"]], 6, {\"0\": 4, \"1\": 5, \"2\": 2, \"3\": 10, \"4\": 6, \"5\": 8, \"6\": 2, \"7\": 11, \"8\": 2, \"9\": 8}]", "is_correct_args": "[[[], [], [\"White\", \"Black\", \"Green\", \"White\", \"Green\", \"Blue\"], [\"Red\", \"Green\", \"Black\", \"Red\", \"White\", \"Yellow\"], [], [\"Yellow\", \"Black\", \"Yellow\", \"Red\", \"Green\", \"White\"], [], [\"White\", \"Blue\", \"Red\", \"Red\", \"Blue\", \"Black\"], [], [\"Yellow\", \"Blue\", \"Yellow\", \"Blue\", \"Green\", \"Black\"]], 6, {\"0\": 4, \"1\": 5, \"2\": 2, \"3\": 10, \"4\": 6, \"5\": 8, \"6\": 2, \"7\": 11, \"8\": 2, \"9\": 8}, 5]", "A*_args": "[\"[[], [], ['White', 'Black', 'Green', 'White', 'Green', 'Blue'], ['Red', 'Green', 'Black', 'Red', 'White', 'Yellow'], [], ['Yellow', 'Black', 'Yellow', 'Red', 'Green', 'White'], [], ['White', 'Blue', 'Red', 'Red', 'Blue', 'Black'], [], ['Yellow', 'Blue', 'Yellow', 'Blue', 'Green', 'Black']]\", \"{0: 4, 1: 5, 2: 2, 3: 10, 4: 6, 5: 8, 6: 2, 7: 11, 8: 2, 9: 8}\", \"6\", \"5\"]"}
{"diff_sorted_id": "66", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 10) to his destination workshop at index (9, 2), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 8, and district 3 covering rows 9 to 12. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 17 14 18 x x 8 18 10 5 5 x x]\n[x x x x 17 18 17 17 6 12 x 7 16]\n[17 x 17 6 18 x 10 13 10 19 15 4 13]\n[15 5 15 3 17 3 x x 18 15 19 3 2]\n[x x x x 2 10 x x x 18 14 5 12]\n[x 16 x 12 4 7 x x 9 x x x x]\n[x 7 x x 16 2 9 1 3 x x 4 x]\n[15 16 x 10 1 16 x x 2 18 1 x x]\n[x x 8 3 x 19 x x x 5 9 x x]\n[x 8 12 14 x x x 16 x 8 x 3 2]\n[8 1 x x x x 13 x x x 9 x 12]\n[x x 3 3 11 x x 16 x x 5 x x]\n[x 11 17 x x x x 9 x x 2 15 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "5", "opt_solution": "[[3, 10], [3, 9], [3, 8], [2, 8], [1, 8], [1, 7], [1, 6], [1, 5], [1, 4], [2, 4], [3, 4], [4, 4], [5, 4], [6, 4], [7, 4], [7, 3], [8, 3], [8, 2], [9, 2]]", "opt_solution_cost": "209", "opt_solution_compute_t": "0.019596099853515625", "solution_depth": "19", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"17\", \"14\", \"18\", \"x\", \"x\", \"8\", \"18\", \"10\", \"5\", \"5\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"17\", \"18\", \"17\", \"17\", \"6\", \"12\", \"x\", \"7\", \"16\"], [\"17\", \"x\", \"17\", \"6\", \"18\", \"x\", \"10\", \"13\", \"10\", \"19\", \"15\", \"4\", \"13\"], [\"15\", \"5\", \"15\", \"3\", \"17\", \"3\", \"x\", \"x\", \"18\", \"15\", \"19\", \"3\", \"2\"], [\"x\", \"x\", \"x\", \"x\", \"2\", \"10\", \"x\", \"x\", \"x\", \"18\", \"14\", \"5\", \"12\"], [\"x\", \"16\", \"x\", \"12\", \"4\", \"7\", \"x\", \"x\", \"9\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"7\", \"x\", \"x\", \"16\", \"2\", \"9\", \"1\", \"3\", \"x\", \"x\", \"4\", \"x\"], [\"15\", \"16\", \"x\", \"10\", \"1\", \"16\", \"x\", \"x\", \"2\", \"18\", \"1\", \"x\", \"x\"], [\"x\", \"x\", \"8\", \"3\", \"x\", \"19\", \"x\", \"x\", \"x\", \"5\", \"9\", \"x\", \"x\"], [\"x\", \"8\", \"12\", \"14\", \"x\", \"x\", \"x\", \"16\", \"x\", \"8\", \"x\", \"3\", \"2\"], [\"8\", \"1\", \"x\", \"x\", \"x\", \"x\", \"13\", \"x\", \"x\", \"x\", \"9\", \"x\", \"12\"], [\"x\", \"x\", \"3\", \"3\", \"11\", \"x\", \"x\", \"16\", \"x\", \"x\", \"5\", \"x\", \"x\"], [\"x\", \"11\", \"17\", \"x\", \"x\", \"x\", \"x\", \"9\", \"x\", \"x\", \"2\", \"15\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"17\", \"14\", \"18\", \"x\", \"x\", \"8\", \"18\", \"10\", \"5\", \"5\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"17\", \"18\", \"17\", \"17\", \"6\", \"12\", \"x\", \"7\", \"16\"], [\"17\", \"x\", \"17\", \"6\", \"18\", \"x\", \"10\", \"13\", \"10\", \"19\", \"15\", \"4\", \"13\"], [\"15\", \"5\", \"15\", \"3\", \"17\", \"3\", \"x\", \"x\", \"18\", \"15\", \"19\", \"3\", \"2\"], [\"x\", \"x\", \"x\", \"x\", \"2\", \"10\", \"x\", \"x\", \"x\", \"18\", \"14\", \"5\", \"12\"], [\"x\", \"16\", \"x\", \"12\", \"4\", \"7\", \"x\", \"x\", \"9\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"7\", \"x\", \"x\", \"16\", \"2\", \"9\", \"1\", \"3\", \"x\", \"x\", \"4\", \"x\"], [\"15\", \"16\", \"x\", \"10\", \"1\", \"16\", \"x\", \"x\", \"2\", \"18\", \"1\", \"x\", \"x\"], [\"x\", \"x\", \"8\", \"3\", \"x\", \"19\", \"x\", \"x\", \"x\", \"5\", \"9\", \"x\", \"x\"], [\"x\", \"8\", \"12\", \"14\", \"x\", \"x\", \"x\", \"16\", \"x\", \"8\", \"x\", \"3\", \"2\"], [\"8\", \"1\", \"x\", \"x\", \"x\", \"x\", \"13\", \"x\", \"x\", \"x\", \"9\", \"x\", \"12\"], [\"x\", \"x\", \"3\", \"3\", \"11\", \"x\", \"x\", \"16\", \"x\", \"x\", \"5\", \"x\", \"x\"], [\"x\", \"11\", \"17\", \"x\", \"x\", \"x\", \"x\", \"9\", \"x\", \"x\", \"2\", \"15\", \"x\"]], [3, 10], [9, 2], 3, 8]", "A*_args": "[\"[['x', '17', '14', '18', 'x', 'x', '8', '18', '10', '5', '5', 'x', 'x'], ['x', 'x', 'x', 'x', '17', '18', '17', '17', '6', '12', 'x', '7', '16'], ['17', 'x', '17', '6', '18', 'x', '10', '13', '10', '19', '15', '4', '13'], ['15', '5', '15', '3', '17', '3', 'x', 'x', '18', '15', '19', '3', '2'], ['x', 'x', 'x', 'x', '2', '10', 'x', 'x', 'x', '18', '14', '5', '12'], ['x', '16', 'x', '12', '4', '7', 'x', 'x', '9', 'x', 'x', 'x', 'x'], ['x', '7', 'x', 'x', '16', '2', '9', '1', '3', 'x', 'x', '4', 'x'], ['15', '16', 'x', '10', '1', '16', 'x', 'x', '2', '18', '1', 'x', 'x'], ['x', 'x', '8', '3', 'x', '19', 'x', 'x', 'x', '5', '9', 'x', 'x'], ['x', '8', '12', '14', 'x', 'x', 'x', '16', 'x', '8', 'x', '3', '2'], ['8', '1', 'x', 'x', 'x', 'x', '13', 'x', 'x', 'x', '9', 'x', '12'], ['x', 'x', '3', '3', '11', 'x', 'x', '16', 'x', 'x', '5', 'x', 'x'], ['x', '11', '17', 'x', 'x', 'x', 'x', '9', 'x', 'x', '2', '15', 'x']]\", \"(3, 10)\", \"(9, 2)\", \"3\", \"8\"]"}
{"diff_sorted_id": "66", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 13x13. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (12, 9) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (3, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 1 1 1 0 1 0 0 1 1 0 0\n0 1 0 1 1 1 0 1 1 0 0 1 0\n1 1 0 1 1 1 1 1 0 0 1 1 0\n1 0 1 0 0 0 0 0 1 0 1 1 1\n1 0 1 0 1 1 1 0 0 0 1 1 0\n1 0 1 0 1 1 1 1 0 1 1 1 1\n1 0 0 0 1 1 1 1 1 1 1 0 1\n1 1 1 0 1 0 0 0 0 1 1 0 1\n1 1 1 0 0 0 1 0 1 1 0 1 1\n1 0 1 0 0 0 1 0 1 1 1 1 1\n1 1 1 0 1 0 0 1 0 1 1 0 1\n1 0 1 1 0 1 0 0 0 1 1 0 1\n1 1 1 0 0 1 1 0 0 0 1 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[[12, 9], [11, 8], [11, 7], [10, 6], [9, 5], [8, 4], [8, 3], [7, 3], [6, 3], [6, 2], [6, 1], [5, 1], [4, 1], [3, 1]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.03254389762878418", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0], [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1], [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1], [1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1], [1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1], [1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1], [1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1]]\", 4]", "is_correct_args": "[\"[[0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0], [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1], [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1], [1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1], [1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1], [1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1], [1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1]]\", [12, 9], [3, 1], 4]", "A*_args": "[\"[[0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0], [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1], [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1], [1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1], [1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1], [1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1], [1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1]]\", \"(12, 9)\", \"(3, 1)\", \"4\"]"}
{"diff_sorted_id": "66", "problem_statement": "Given 5 labeled water jugs with capacities 122, 121, 124, 28, 89, 73 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 270, 311, 372, 389 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 121, 4], [\"+\", 122, 4], [\"+\", 73, 4], [\"+\", 73, 4], [\"+\", 124, 3], [\"+\", 124, 3], [\"+\", 124, 3], [\"+\", 73, 2], [\"+\", 89, 2], [\"+\", 28, 2], [\"+\", 121, 2], [\"+\", 121, 1], [\"+\", 121, 1], [\"+\", 28, 1]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.027414321899414062", "solution_depth": "14", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[122, 121, 124, 28, 89, 73], [270, 311, 372, 389]]", "is_correct_args": "[[122, 121, 124, 28, 89, 73], [270, 311, 372, 389]]", "A*_args": "[\"[122, 121, 124, 28, 89, 73]\", \"[270, 311, 372, 389]\"]"}
{"diff_sorted_id": "67", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[58, 51, 56, 43, 33], [91, 71, 21, 14, 24], [46, 45, '_', 17, 13]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[21, 56, 51, 58, 91, 71, 45, 21, 17, 14, 43, 51, 56, 45, 71, 46, 21, 17, 14, 13, 24, 33, 51, 56, 58, 71, 45, 43, 33, 24]", "opt_solution_cost": "30", "opt_solution_compute_t": "0.723954439163208", "solution_depth": "30", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[58, 51, 56, 43, 33], [91, 71, 21, 14, 24], [46, 45, \"_\", 17, 13]]]", "is_correct_args": "[[[58, 51, 56, 43, 33], [91, 71, 21, 14, 24], [46, 45, \"_\", 17, 13]]]", "A*_args": "[\"[[58, 51, 56, 43, 33], [91, 71, 21, 14, 24], [46, 45, '_', 17, 13]]\"]"}
{"diff_sorted_id": "67", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: lew, keck, flea, susu, herb   The initial board: [['e', 'l', 'u', 'w'], ['k', 'k', 'c', 'e'], ['f', 'l', '_', 'a'], ['s', 'r', 's', 'e'], ['h', 'e', 'u', 'b']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.2113971710205078", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"e\", \"l\", \"u\", \"w\"], [\"k\", \"k\", \"c\", \"e\"], [\"f\", \"l\", \"_\", \"a\"], [\"s\", \"r\", \"s\", \"e\"], [\"h\", \"e\", \"u\", \"b\"]]]", "is_correct_args": "[[[\"e\", \"l\", \"u\", \"w\"], [\"k\", \"k\", \"c\", \"e\"], [\"f\", \"l\", \"_\", \"a\"], [\"s\", \"r\", \"s\", \"e\"], [\"h\", \"e\", \"u\", \"b\"]], [\"lew\", \"keck\", \"flea\", \"susu\", \"herb\"]]", "A*_args": "[\"[['e', 'l', 'u', 'w'], ['k', 'k', 'c', 'e'], ['f', 'l', '_', 'a'], ['s', 'r', 's', 'e'], ['h', 'e', 'u', 'b']]\", \"['lew', 'keck', 'flea', 'susu', 'herb']\"]"}
{"diff_sorted_id": "67", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'S'. Our task is to visit city N and city R excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from R and N, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  A K G U Q D N X S V Y R Z \nA 0 0 0 0 1 0 1 0 0 0 0 0 0 \nK 0 0 0 0 0 1 0 1 0 0 0 0 0 \nG 0 1 0 0 0 0 0 0 0 0 0 0 1 \nU 0 0 0 0 0 0 0 0 0 0 0 1 0 \nQ 0 0 0 0 0 0 0 0 0 0 1 1 0 \nD 1 1 0 0 1 0 0 0 0 1 1 0 0 \nN 0 0 1 0 1 0 0 0 0 0 1 0 0 \nX 1 0 0 1 0 0 1 0 0 0 0 0 0 \nS 1 1 0 0 1 0 0 1 0 0 1 0 0 \nV 0 0 1 0 0 0 1 1 1 0 0 0 0 \nY 1 0 0 0 1 0 0 0 0 0 0 0 0 \nR 0 1 0 0 0 0 1 1 0 0 1 0 0 \nZ 1 1 0 1 0 0 0 1 1 1 1 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[\"S\", \"Q\", \"R\", \"N\", \"G\", \"Z\", \"R\", \"N\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.03870034217834473", "solution_depth": "8", "max_successor_states": "13", "num_vars_per_state": "16", "is_feasible_args": "[[[0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0]], [\"A\", \"K\", \"G\", \"U\", \"Q\", \"D\", \"N\", \"X\", \"S\", \"V\", \"Y\", \"R\", \"Z\"], \"N\", \"R\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0]], [\"A\", \"K\", \"G\", \"U\", \"Q\", \"D\", \"N\", \"X\", \"S\", \"V\", \"Y\", \"R\", \"Z\"], \"S\", \"N\", \"R\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0]]\", \"['A', 'K', 'G', 'U', 'Q', 'D', 'N', 'X', 'S', 'V', 'Y', 'R', 'Z']\", \"['S']\", \"['N', 'R']\"]"}
{"diff_sorted_id": "67", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [8, 13, 16, 4, 35, 2, 19, 2, 21, 26, 28, 12, 58, 28, 12, 35, 33, 4, 19, 27, 61, 30, 17, 20, 27, 25, 30, 31, 9, 15, 4, 13, 11, 29], such that the sum of the chosen coins adds up to 384. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {13: 1, 4: 1, 61: 2, 30: 19, 12: 4, 20: 16, 29: 10, 2: 2, 35: 17, 31: 17, 19: 15, 25: 11, 21: 8, 27: 16, 17: 17, 11: 7, 58: 12, 26: 4, 15: 14, 28: 10, 8: 5, 16: 5, 9: 8, 33: 13}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "18", "opt_solution": "[4, 13, 12, 4, 61, 58, 28, 26, 16, 12, 13, 29, 28, 8, 33, 4, 35]", "opt_solution_cost": "101", "opt_solution_compute_t": "0.04987359046936035", "solution_depth": "17", "max_successor_states": "34", "num_vars_per_state": "34", "is_feasible_args": "[[8, 13, 16, 4, 35, 2, 19, 2, 21, 26, 28, 12, 58, 28, 12, 35, 33, 4, 19, 27, 61, 30, 17, 20, 27, 25, 30, 31, 9, 15, 4, 13, 11, 29]]", "is_correct_args": "[[8, 13, 16, 4, 35, 2, 19, 2, 21, 26, 28, 12, 58, 28, 12, 35, 33, 4, 19, 27, 61, 30, 17, 20, 27, 25, 30, 31, 9, 15, 4, 13, 11, 29], {\"13\": 1, \"4\": 1, \"61\": 2, \"30\": 19, \"12\": 4, \"20\": 16, \"29\": 10, \"2\": 2, \"35\": 17, \"31\": 17, \"19\": 15, \"25\": 11, \"21\": 8, \"27\": 16, \"17\": 17, \"11\": 7, \"58\": 12, \"26\": 4, \"15\": 14, \"28\": 10, \"8\": 5, \"16\": 5, \"9\": 8, \"33\": 13}, 384]", "A*_args": "[\"[8, 13, 16, 4, 35, 2, 19, 2, 21, 26, 28, 12, 58, 28, 12, 35, 33, 4, 19, 27, 61, 30, 17, 20, 27, 25, 30, 31, 9, 15, 4, 13, 11, 29]\", \"{13: 1, 4: 1, 61: 2, 30: 19, 12: 4, 20: 16, 29: 10, 2: 2, 35: 17, 31: 17, 19: 15, 25: 11, 21: 8, 27: 16, 17: 17, 11: 7, 58: 12, 26: 4, 15: 14, 28: 10, 8: 5, 16: 5, 9: 8, 33: 13}\", \"384\"]"}
{"diff_sorted_id": "67", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Blue', 'Green', 'Red', 'Red'], ['Green', 'Blue', 'Green', 'Blue', 'Blue'], ['Red', 'Green', 'Red', 'Red', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[0, 2], [0, 2], [1, 0], [1, 2], [1, 0], [2, 1], [2, 1], [2, 1], [2, 1], [2, 0], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0]]", "opt_solution_cost": "19", "opt_solution_compute_t": "4.2806196212768555", "solution_depth": "19", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Blue\", \"Blue\", \"Green\", \"Red\", \"Red\"], [\"Green\", \"Blue\", \"Green\", \"Blue\", \"Blue\"], [\"Red\", \"Green\", \"Red\", \"Red\", \"Green\"]], 8]", "is_correct_args": "[[[\"Blue\", \"Blue\", \"Green\", \"Red\", \"Red\"], [\"Green\", \"Blue\", \"Green\", \"Blue\", \"Blue\"], [\"Red\", \"Green\", \"Red\", \"Red\", \"Green\"]], 8]", "A*_args": "[\"[['Blue', 'Blue', 'Green', 'Red', 'Red'], ['Green', 'Blue', 'Green', 'Blue', 'Blue'], ['Red', 'Green', 'Red', 'Red', 'Green']]\", \"8\"]"}
{"diff_sorted_id": "67", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 9 to 54 (9 included in the range but 54 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '37' 'x' 'x']\n ['x' '35' '40' 'x']\n ['15' 'x' 'x' '44']\n ['11' '20' '36' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "13", "opt_solution": "[[0, 0, 30], [0, 2, 48], [1, 2, 36], [1, 3, 37], [2, 1, 31], [2, 2, 32], [3, 0, 12], [3, 2, 27], [3, 3, 28]]", "opt_solution_cost": "459", "opt_solution_compute_t": "351.63161611557007", "solution_depth": "9", "max_successor_states": "45", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '47', '', '55'], ['29', '34', '', ''], ['16', '', '', '35'], ['', '26', '', '']]\", 12, 57]", "is_correct_args": "[\"[['', '47', '', '55'], ['29', '34', '', ''], ['16', '', '', '35'], ['', '26', '', '']]\", 12, 57]", "A*_args": "[\"[['', '47', '', '55'], ['29', '34', '', ''], ['16', '', '', '35'], ['', '26', '', '']]\", \"12\", \"57\"]"}
{"diff_sorted_id": "67", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 31 to 67. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 204, 206, None for columns 1 to 2 respectively, and the sums of rows must be None, 187, 203, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 199. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '59' '52' '54']\n ['x' 'x' 'x' '62']\n ['x' '58' 'x' 'x']\n ['x' 'x' '63' '42']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 0, 31], [1, 0, 32], [1, 1, 40], [1, 2, 53], [2, 0, 41], [2, 2, 38], [2, 3, 66], [3, 0, 34], [3, 1, 47]]", "opt_solution_cost": "772", "opt_solution_compute_t": "36.59412097930908", "solution_depth": "9", "max_successor_states": "26", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '59', '52', '54'], ['', '', '', '62'], ['', '58', '', ''], ['', '', '63', '42']]\", 4, 31, 67]", "is_correct_args": "[\"[['', '59', '52', '54'], ['', '', '', '62'], ['', '58', '', ''], ['', '', '63', '42']]\", 31, 67, [1, 3], [1, 3], [204, 206], [187, 203], 199]", "A*_args": "[\"[['', '59', '52', '54'], ['', '', '', '62'], ['', '58', '', ''], ['', '', '63', '42']]\", \"31\", \"67\", \"[None, 204, 206, None]\", \"[None, 187, 203, None]\", \"199\"]"}
{"diff_sorted_id": "67", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (2, 3) to his destination workshop at index (8, 10), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 7, and district 3 covering rows 8 to 12. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x 10 x x x 3 x x x x x x]\n[6 19 x x x 12 x x 3 x x x x]\n[5 3 7 7 x 7 9 x 18 x x x x]\n[1 4 19 19 16 6 x 2 10 x 1 7 x]\n[14 10 x x 2 3 5 3 13 7 x 8 x]\n[x 8 11 14 18 x x 16 15 8 x 10 x]\n[x 17 x x 15 x x 1 17 9 7 x 10]\n[18 6 14 4 12 12 x 12 5 x x 5 18]\n[x x x x x x x 7 17 4 16 x x]\n[x 6 17 x x x x x 15 x x 12 x]\n[14 x x 12 3 11 x x x x x x 17]\n[x 16 x x x 3 5 19 x 16 14 x 19]\n[13 x 11 x 3 16 x 1 x x 1 x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "5", "opt_solution": "[[2, 3], [3, 3], [3, 4], [4, 4], [4, 5], [4, 6], [4, 7], [5, 7], [6, 7], [7, 7], [7, 8], [8, 8], [8, 9], [8, 10]]", "opt_solution_cost": "119", "opt_solution_compute_t": "0.020412206649780273", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"10\", \"x\", \"x\", \"x\", \"3\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"6\", \"19\", \"x\", \"x\", \"x\", \"12\", \"x\", \"x\", \"3\", \"x\", \"x\", \"x\", \"x\"], [\"5\", \"3\", \"7\", \"7\", \"x\", \"7\", \"9\", \"x\", \"18\", \"x\", \"x\", \"x\", \"x\"], [\"1\", \"4\", \"19\", \"19\", \"16\", \"6\", \"x\", \"2\", \"10\", \"x\", \"1\", \"7\", \"x\"], [\"14\", \"10\", \"x\", \"x\", \"2\", \"3\", \"5\", \"3\", \"13\", \"7\", \"x\", \"8\", \"x\"], [\"x\", \"8\", \"11\", \"14\", \"18\", \"x\", \"x\", \"16\", \"15\", \"8\", \"x\", \"10\", \"x\"], [\"x\", \"17\", \"x\", \"x\", \"15\", \"x\", \"x\", \"1\", \"17\", \"9\", \"7\", \"x\", \"10\"], [\"18\", \"6\", \"14\", \"4\", \"12\", \"12\", \"x\", \"12\", \"5\", \"x\", \"x\", \"5\", \"18\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"7\", \"17\", \"4\", \"16\", \"x\", \"x\"], [\"x\", \"6\", \"17\", \"x\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\", \"x\", \"12\", \"x\"], [\"14\", \"x\", \"x\", \"12\", \"3\", \"11\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"17\"], [\"x\", \"16\", \"x\", \"x\", \"x\", \"3\", \"5\", \"19\", \"x\", \"16\", \"14\", \"x\", \"19\"], [\"13\", \"x\", \"11\", \"x\", \"3\", \"16\", \"x\", \"1\", \"x\", \"x\", \"1\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"10\", \"x\", \"x\", \"x\", \"3\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"6\", \"19\", \"x\", \"x\", \"x\", \"12\", \"x\", \"x\", \"3\", \"x\", \"x\", \"x\", \"x\"], [\"5\", \"3\", \"7\", \"7\", \"x\", \"7\", \"9\", \"x\", \"18\", \"x\", \"x\", \"x\", \"x\"], [\"1\", \"4\", \"19\", \"19\", \"16\", \"6\", \"x\", \"2\", \"10\", \"x\", \"1\", \"7\", \"x\"], [\"14\", \"10\", \"x\", \"x\", \"2\", \"3\", \"5\", \"3\", \"13\", \"7\", \"x\", \"8\", \"x\"], [\"x\", \"8\", \"11\", \"14\", \"18\", \"x\", \"x\", \"16\", \"15\", \"8\", \"x\", \"10\", \"x\"], [\"x\", \"17\", \"x\", \"x\", \"15\", \"x\", \"x\", \"1\", \"17\", \"9\", \"7\", \"x\", \"10\"], [\"18\", \"6\", \"14\", \"4\", \"12\", \"12\", \"x\", \"12\", \"5\", \"x\", \"x\", \"5\", \"18\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"7\", \"17\", \"4\", \"16\", \"x\", \"x\"], [\"x\", \"6\", \"17\", \"x\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\", \"x\", \"12\", \"x\"], [\"14\", \"x\", \"x\", \"12\", \"3\", \"11\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"17\"], [\"x\", \"16\", \"x\", \"x\", \"x\", \"3\", \"5\", \"19\", \"x\", \"16\", \"14\", \"x\", \"19\"], [\"13\", \"x\", \"11\", \"x\", \"3\", \"16\", \"x\", \"1\", \"x\", \"x\", \"1\", \"x\", \"x\"]], [2, 3], [8, 10], 2, 7]", "A*_args": "[\"[['x', 'x', '10', 'x', 'x', 'x', '3', 'x', 'x', 'x', 'x', 'x', 'x'], ['6', '19', 'x', 'x', 'x', '12', 'x', 'x', '3', 'x', 'x', 'x', 'x'], ['5', '3', '7', '7', 'x', '7', '9', 'x', '18', 'x', 'x', 'x', 'x'], ['1', '4', '19', '19', '16', '6', 'x', '2', '10', 'x', '1', '7', 'x'], ['14', '10', 'x', 'x', '2', '3', '5', '3', '13', '7', 'x', '8', 'x'], ['x', '8', '11', '14', '18', 'x', 'x', '16', '15', '8', 'x', '10', 'x'], ['x', '17', 'x', 'x', '15', 'x', 'x', '1', '17', '9', '7', 'x', '10'], ['18', '6', '14', '4', '12', '12', 'x', '12', '5', 'x', 'x', '5', '18'], ['x', 'x', 'x', 'x', 'x', 'x', 'x', '7', '17', '4', '16', 'x', 'x'], ['x', '6', '17', 'x', 'x', 'x', 'x', 'x', '15', 'x', 'x', '12', 'x'], ['14', 'x', 'x', '12', '3', '11', 'x', 'x', 'x', 'x', 'x', 'x', '17'], ['x', '16', 'x', 'x', 'x', '3', '5', '19', 'x', '16', '14', 'x', '19'], ['13', 'x', '11', 'x', '3', '16', 'x', '1', 'x', 'x', '1', 'x', 'x']]\", \"(2, 3)\", \"(8, 10)\", \"2\", \"7\"]"}
{"diff_sorted_id": "67", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 13x13. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (3, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (9, 11). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 0 1 1 1 1 0 1 0 1 1\n1 0 1 1 1 1 0 0 1 0 1 0 0\n0 0 0 0 1 0 1 1 1 0 1 0 0\n0 0 0 1 0 1 1 0 1 1 1 1 1\n0 0 0 0 0 0 0 1 1 1 1 1 0\n0 0 1 0 1 0 0 0 0 1 1 1 0\n0 0 0 1 1 0 0 1 1 1 1 0 1\n1 0 1 0 0 0 0 0 1 0 0 1 1\n0 0 0 0 0 1 1 0 0 0 0 0 1\n0 0 0 0 0 0 0 1 0 1 0 0 0\n1 1 0 0 0 0 0 0 1 0 0 0 0\n0 1 1 1 1 1 0 1 0 0 1 1 1\n0 0 1 0 1 1 1 0 1 0 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[[3, 0], [3, 1], [3, 2], [4, 3], [4, 4], [4, 5], [4, 6], [5, 6], [6, 6], [7, 7], [8, 8], [8, 9], [8, 10], [9, 11]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.07725334167480469", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1], [0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1]]\", 4]", "is_correct_args": "[\"[[1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1], [0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1]]\", [3, 0], [9, 11], 4]", "A*_args": "[\"[[1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1], [0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1]]\", \"(3, 0)\", \"(9, 11)\", \"4\"]"}
{"diff_sorted_id": "67", "problem_statement": "Given 5 labeled water jugs with capacities 116, 115, 29, 129, 39, 114 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 353, 368, 396, 403 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 116, 4], [\"+\", 129, 4], [\"+\", 29, 4], [\"+\", 129, 4], [\"+\", 114, 3], [\"+\", 129, 3], [\"+\", 39, 3], [\"+\", 114, 3], [\"+\", 114, 2], [\"+\", 115, 2], [\"+\", 129, 2], [\"-\", 29, 2], [\"+\", 39, 2], [\"+\", 114, 1], [\"+\", 114, 1], [\"+\", 115, 1], [\"-\", 29, 1], [\"+\", 39, 1]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.03425145149230957", "solution_depth": "18", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[116, 115, 29, 129, 39, 114], [353, 368, 396, 403]]", "is_correct_args": "[[116, 115, 29, 129, 39, 114], [353, 368, 396, 403]]", "A*_args": "[\"[116, 115, 29, 129, 39, 114]\", \"[353, 368, 396, 403]\"]"}
{"diff_sorted_id": "68", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[72, 92, '_', 78, 74], [70, 67, 85, 75, 66], [48, 42, 32, 26, 50]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[85, 67, 70, 72, 92, 85, 78, 75, 66, 50]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.019316434860229492", "solution_depth": "10", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[72, 92, \"_\", 78, 74], [70, 67, 85, 75, 66], [48, 42, 32, 26, 50]]]", "is_correct_args": "[[[72, 92, \"_\", 78, 74], [70, 67, 85, 75, 66], [48, 42, 32, 26, 50]]]", "A*_args": "[\"[[72, 92, '_', 78, 74], [70, 67, 85, 75, 66], [48, 42, 32, 26, 50]]\"]"}
{"diff_sorted_id": "68", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: sat, leep, mack, pogo, drew   The initial board: [['e', 's', '_', 't'], ['l', 'o', 'e', 'm'], ['c', 'a', 'o', 'k'], ['p', 'p', 'g', 'e'], ['d', 'r', 'a', 'w']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.2691648006439209", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"e\", \"s\", \"_\", \"t\"], [\"l\", \"o\", \"e\", \"m\"], [\"c\", \"a\", \"o\", \"k\"], [\"p\", \"p\", \"g\", \"e\"], [\"d\", \"r\", \"a\", \"w\"]]]", "is_correct_args": "[[[\"e\", \"s\", \"_\", \"t\"], [\"l\", \"o\", \"e\", \"m\"], [\"c\", \"a\", \"o\", \"k\"], [\"p\", \"p\", \"g\", \"e\"], [\"d\", \"r\", \"a\", \"w\"]], [\"sat\", \"leep\", \"mack\", \"pogo\", \"drew\"]]", "A*_args": "[\"[['e', 's', '_', 't'], ['l', 'o', 'e', 'm'], ['c', 'a', 'o', 'k'], ['p', 'p', 'g', 'e'], ['d', 'r', 'a', 'w']]\", \"['sat', 'leep', 'mack', 'pogo', 'drew']\"]"}
{"diff_sorted_id": "68", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'P'. Our task is to visit city J and city G excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from G and J, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  P G W V L M B S J H D N R \nP 0 0 0 0 0 0 0 0 0 1 0 0 1 \nG 0 0 0 1 0 1 0 0 0 0 0 0 0 \nW 0 0 0 0 1 0 1 1 0 0 1 0 0 \nV 0 0 0 0 1 0 0 1 0 0 0 1 0 \nL 0 1 0 0 0 1 1 1 0 0 0 1 0 \nM 0 0 1 1 0 0 0 0 1 0 1 0 0 \nB 1 1 0 0 1 0 0 0 0 0 1 0 0 \nS 0 1 0 0 0 0 0 0 0 0 0 1 0 \nJ 0 0 1 1 1 0 1 0 0 0 0 0 0 \nH 1 0 1 0 0 1 1 1 0 0 0 0 1 \nD 0 1 0 1 0 0 0 0 1 0 0 0 1 \nN 0 0 0 0 0 0 0 0 1 1 1 0 0 \nR 0 1 0 1 0 1 0 0 0 1 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[\"P\", \"R\", \"G\", \"M\", \"J\", \"B\", \"D\", \"J\", \"L\", \"G\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.06922531127929688", "solution_depth": "10", "max_successor_states": "13", "num_vars_per_state": "16", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]], [\"P\", \"G\", \"W\", \"V\", \"L\", \"M\", \"B\", \"S\", \"J\", \"H\", \"D\", \"N\", \"R\"], \"J\", \"G\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]], [\"P\", \"G\", \"W\", \"V\", \"L\", \"M\", \"B\", \"S\", \"J\", \"H\", \"D\", \"N\", \"R\"], \"P\", \"J\", \"G\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0]]\", \"['P', 'G', 'W', 'V', 'L', 'M', 'B', 'S', 'J', 'H', 'D', 'N', 'R']\", \"['P']\", \"['J', 'G']\"]"}
{"diff_sorted_id": "68", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [5, 29, 12, 96, 4, 13, 8, 23, 14, 25, 18, 23, 36, 32, 17, 37, 34, 7, 9, 32, 29, 37, 30, 40, 99, 9, 2, 40, 35, 14], such that the sum of the chosen coins adds up to 427. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {14: 4, 4: 2, 18: 12, 23: 12, 36: 15, 5: 1, 12: 3, 13: 13, 9: 7, 32: 8, 99: 16, 8: 7, 96: 17, 35: 13, 29: 19, 30: 19, 7: 1, 34: 16, 37: 15, 2: 2, 17: 3, 40: 18, 25: 9}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "19", "opt_solution": "[5, 7, 17, 99, 96, 32, 14, 35, 32, 14, 25, 12, 37, 2]", "opt_solution_cost": "104", "opt_solution_compute_t": "0.04604029655456543", "solution_depth": "14", "max_successor_states": "30", "num_vars_per_state": "30", "is_feasible_args": "[[5, 29, 12, 96, 4, 13, 8, 23, 14, 25, 18, 23, 36, 32, 17, 37, 34, 7, 9, 32, 29, 37, 30, 40, 99, 9, 2, 40, 35, 14]]", "is_correct_args": "[[5, 29, 12, 96, 4, 13, 8, 23, 14, 25, 18, 23, 36, 32, 17, 37, 34, 7, 9, 32, 29, 37, 30, 40, 99, 9, 2, 40, 35, 14], {\"14\": 4, \"4\": 2, \"18\": 12, \"23\": 12, \"36\": 15, \"5\": 1, \"12\": 3, \"13\": 13, \"9\": 7, \"32\": 8, \"99\": 16, \"8\": 7, \"96\": 17, \"35\": 13, \"29\": 19, \"30\": 19, \"7\": 1, \"34\": 16, \"37\": 15, \"2\": 2, \"17\": 3, \"40\": 18, \"25\": 9}, 427]", "A*_args": "[\"[5, 29, 12, 96, 4, 13, 8, 23, 14, 25, 18, 23, 36, 32, 17, 37, 34, 7, 9, 32, 29, 37, 30, 40, 99, 9, 2, 40, 35, 14]\", \"{14: 4, 4: 2, 18: 12, 23: 12, 36: 15, 5: 1, 12: 3, 13: 13, 9: 7, 32: 8, 99: 16, 8: 7, 96: 17, 35: 13, 29: 19, 30: 19, 7: 1, 34: 16, 37: 15, 2: 2, 17: 3, 40: 18, 25: 9}\", \"427\"]"}
{"diff_sorted_id": "68", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Blue', 'Blue', 'Blue'], ['Blue', 'Green', 'Red', 'Red', 'Green'], ['Green', 'Red', 'Red', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[0, 1], [0, 2], [1, 0], [1, 0], [1, 2], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [2, 0], [1, 2], [1, 2], [0, 1], [0, 2], [0, 2]]", "opt_solution_cost": "18", "opt_solution_compute_t": "2.5658318996429443", "solution_depth": "18", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Blue\", \"Blue\", \"Blue\"], [\"Blue\", \"Green\", \"Red\", \"Red\", \"Green\"], [\"Green\", \"Red\", \"Red\", \"Green\", \"Red\"]], 8]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Blue\", \"Blue\", \"Blue\"], [\"Blue\", \"Green\", \"Red\", \"Red\", \"Green\"], [\"Green\", \"Red\", \"Red\", \"Green\", \"Red\"]], 8]", "A*_args": "[\"[['Blue', 'Green', 'Blue', 'Blue', 'Blue'], ['Blue', 'Green', 'Red', 'Red', 'Green'], ['Green', 'Red', 'Red', 'Green', 'Red']]\", \"8\"]"}
{"diff_sorted_id": "68", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 34 to 79 (34 included in the range but 79 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['35' 'x' '47' 'x']\n ['40' '49' 'x' '63']\n ['41' 'x' 'x' '65']\n ['x' 'x' '70' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "13", "opt_solution": "[[0, 0, 25], [0, 2, 41], [1, 1, 42], [1, 3, 64], [2, 0, 35], [2, 1, 43], [2, 2, 54], [3, 0, 36], [3, 2, 57]]", "opt_solution_cost": "608", "opt_solution_compute_t": "48.17496109008789", "solution_depth": "9", "max_successor_states": "45", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '40', '', '65'], ['34', '', '53', ''], ['', '', '', '63'], ['', '56', '', '62']]\", 25, 70]", "is_correct_args": "[\"[['', '40', '', '65'], ['34', '', '53', ''], ['', '', '', '63'], ['', '56', '', '62']]\", 25, 70]", "A*_args": "[\"[['', '40', '', '65'], ['34', '', '53', ''], ['', '', '', '63'], ['', '56', '', '62']]\", \"25\", \"70\"]"}
{"diff_sorted_id": "68", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 31 to 67. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 224, 226, None for columns 1 to 2 respectively, and the sums of rows must be None, 220, 216, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 211. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '40' 'x' 'x']\n ['x' '58' 'x' '37']\n ['47' 'x' 'x' '44']\n ['45' 'x' 'x' '42']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 0, 31], [0, 2, 36], [0, 3, 35], [1, 0, 59], [1, 2, 66], [2, 1, 65], [2, 2, 60], [3, 1, 61], [3, 2, 64]]", "opt_solution_cost": "790", "opt_solution_compute_t": "85.8753867149353", "solution_depth": "9", "max_successor_states": "26", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '40', '', ''], ['', '58', '', '37'], ['47', '', '', '44'], ['45', '', '', '42']]\", 4, 31, 67]", "is_correct_args": "[\"[['', '40', '', ''], ['', '58', '', '37'], ['47', '', '', '44'], ['45', '', '', '42']]\", 31, 67, [1, 3], [1, 3], [224, 226], [220, 216], 211]", "A*_args": "[\"[['', '40', '', ''], ['', '58', '', '37'], ['47', '', '', '44'], ['45', '', '', '42']]\", \"31\", \"67\", \"[None, 224, 226, None]\", \"[None, 220, 216, None]\", \"211\"]"}
{"diff_sorted_id": "68", "problem_statement": "In 'Restricted Sorting', there are 10 stacks each with a capacity of 6 blocks, with 5 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 5 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 9, 1: 11, 2: 2, 3: 10, 4: 8, 5: 6, 6: 4, 7: 4, 8: 7, 9: 3}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Black', 'Black', 'White', 'Blue', 'Yellow', 'White'], ['Black', 'Blue', 'Red', 'Blue', 'Red', 'Green'], [], ['Black', 'White', 'Red', 'Green', 'White', 'Blue'], ['Yellow', 'Blue', 'Red', 'Green', 'Green', 'Yellow'], [], ['Green', 'Black', 'Red', 'White', 'Yellow', 'Yellow'], [], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "3", "opt_solution": "[[0, 2], [0, 2], [1, 2], [3, 2], [1, 9], [4, 7], [4, 9], [6, 5], [6, 2], [4, 8], [6, 8], [1, 8], [1, 9], [1, 8], [4, 5], [4, 5], [4, 7], [6, 4], [6, 7], [6, 7], [0, 6], [0, 9], [0, 7], [3, 6], [3, 8], [3, 5], [3, 6], [1, 5], [0, 6], [4, 6], [3, 9]]", "opt_solution_cost": "138", "opt_solution_compute_t": "0.08098411560058594", "solution_depth": "31", "max_successor_states": "90", "num_vars_per_state": "30", "is_feasible_args": "[[[\"Black\", \"Black\", \"White\", \"Blue\", \"Yellow\", \"White\"], [\"Black\", \"Blue\", \"Red\", \"Blue\", \"Red\", \"Green\"], [], [\"Black\", \"White\", \"Red\", \"Green\", \"White\", \"Blue\"], [\"Yellow\", \"Blue\", \"Red\", \"Green\", \"Green\", \"Yellow\"], [], [\"Green\", \"Black\", \"Red\", \"White\", \"Yellow\", \"Yellow\"], [], [], []], 6, {\"0\": 9, \"1\": 11, \"2\": 2, \"3\": 10, \"4\": 8, \"5\": 6, \"6\": 4, \"7\": 4, \"8\": 7, \"9\": 3}]", "is_correct_args": "[[[\"Black\", \"Black\", \"White\", \"Blue\", \"Yellow\", \"White\"], [\"Black\", \"Blue\", \"Red\", \"Blue\", \"Red\", \"Green\"], [], [\"Black\", \"White\", \"Red\", \"Green\", \"White\", \"Blue\"], [\"Yellow\", \"Blue\", \"Red\", \"Green\", \"Green\", \"Yellow\"], [], [\"Green\", \"Black\", \"Red\", \"White\", \"Yellow\", \"Yellow\"], [], [], []], 6, {\"0\": 9, \"1\": 11, \"2\": 2, \"3\": 10, \"4\": 8, \"5\": 6, \"6\": 4, \"7\": 4, \"8\": 7, \"9\": 3}, 5]", "A*_args": "[\"[['Black', 'Black', 'White', 'Blue', 'Yellow', 'White'], ['Black', 'Blue', 'Red', 'Blue', 'Red', 'Green'], [], ['Black', 'White', 'Red', 'Green', 'White', 'Blue'], ['Yellow', 'Blue', 'Red', 'Green', 'Green', 'Yellow'], [], ['Green', 'Black', 'Red', 'White', 'Yellow', 'Yellow'], [], [], []]\", \"{0: 9, 1: 11, 2: 2, 3: 10, 4: 8, 5: 6, 6: 4, 7: 4, 8: 7, 9: 3}\", \"6\", \"5\"]"}
{"diff_sorted_id": "68", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (5, 12) to his destination workshop at index (1, 2), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 5, and district 3 covering rows 6 to 12. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[18 x x x 19 x x 8 6 3 x x x]\n[x x 8 1 11 x x x x x 4 6 4]\n[1 4 15 13 17 11 x 15 x 13 1 x x]\n[3 x 6 1 15 2 x 13 13 x 10 x x]\n[17 12 13 11 6 1 3 x x 19 6 6 x]\n[x 17 7 12 1 15 17 20 3 x x 18 10]\n[16 14 15 x x 11 x 17 20 15 7 10 x]\n[5 11 x 7 19 x 6 18 15 x 8 x 1]\n[10 x 1 x x 6 x 11 x 13 x x x]\n[x x x x 4 x 8 x 12 x 12 13 x]\n[x x 18 14 x x 5 x x 13 1 x x]\n[x x 1 17 8 18 x 7 x x 16 8 x]\n[x x x 16 1 x 19 x x x x 14 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "5", "opt_solution": "[[5, 12], [5, 11], [6, 11], [6, 10], [6, 9], [6, 8], [5, 8], [5, 7], [5, 6], [4, 6], [4, 5], [3, 5], [3, 4], [3, 3], [2, 3], [1, 3], [1, 2]]", "opt_solution_cost": "154", "opt_solution_compute_t": "0.0203857421875", "solution_depth": "17", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"18\", \"x\", \"x\", \"x\", \"19\", \"x\", \"x\", \"8\", \"6\", \"3\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"8\", \"1\", \"11\", \"x\", \"x\", \"x\", \"x\", \"x\", \"4\", \"6\", \"4\"], [\"1\", \"4\", \"15\", \"13\", \"17\", \"11\", \"x\", \"15\", \"x\", \"13\", \"1\", \"x\", \"x\"], [\"3\", \"x\", \"6\", \"1\", \"15\", \"2\", \"x\", \"13\", \"13\", \"x\", \"10\", \"x\", \"x\"], [\"17\", \"12\", \"13\", \"11\", \"6\", \"1\", \"3\", \"x\", \"x\", \"19\", \"6\", \"6\", \"x\"], [\"x\", \"17\", \"7\", \"12\", \"1\", \"15\", \"17\", \"20\", \"3\", \"x\", \"x\", \"18\", \"10\"], [\"16\", \"14\", \"15\", \"x\", \"x\", \"11\", \"x\", \"17\", \"20\", \"15\", \"7\", \"10\", \"x\"], [\"5\", \"11\", \"x\", \"7\", \"19\", \"x\", \"6\", \"18\", \"15\", \"x\", \"8\", \"x\", \"1\"], [\"10\", \"x\", \"1\", \"x\", \"x\", \"6\", \"x\", \"11\", \"x\", \"13\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"4\", \"x\", \"8\", \"x\", \"12\", \"x\", \"12\", \"13\", \"x\"], [\"x\", \"x\", \"18\", \"14\", \"x\", \"x\", \"5\", \"x\", \"x\", \"13\", \"1\", \"x\", \"x\"], [\"x\", \"x\", \"1\", \"17\", \"8\", \"18\", \"x\", \"7\", \"x\", \"x\", \"16\", \"8\", \"x\"], [\"x\", \"x\", \"x\", \"16\", \"1\", \"x\", \"19\", \"x\", \"x\", \"x\", \"x\", \"14\", \"x\"]]]", "is_correct_args": "[[[\"18\", \"x\", \"x\", \"x\", \"19\", \"x\", \"x\", \"8\", \"6\", \"3\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"8\", \"1\", \"11\", \"x\", \"x\", \"x\", \"x\", \"x\", \"4\", \"6\", \"4\"], [\"1\", \"4\", \"15\", \"13\", \"17\", \"11\", \"x\", \"15\", \"x\", \"13\", \"1\", \"x\", \"x\"], [\"3\", \"x\", \"6\", \"1\", \"15\", \"2\", \"x\", \"13\", \"13\", \"x\", \"10\", \"x\", \"x\"], [\"17\", \"12\", \"13\", \"11\", \"6\", \"1\", \"3\", \"x\", \"x\", \"19\", \"6\", \"6\", \"x\"], [\"x\", \"17\", \"7\", \"12\", \"1\", \"15\", \"17\", \"20\", \"3\", \"x\", \"x\", \"18\", \"10\"], [\"16\", \"14\", \"15\", \"x\", \"x\", \"11\", \"x\", \"17\", \"20\", \"15\", \"7\", \"10\", \"x\"], [\"5\", \"11\", \"x\", \"7\", \"19\", \"x\", \"6\", \"18\", \"15\", \"x\", \"8\", \"x\", \"1\"], [\"10\", \"x\", \"1\", \"x\", \"x\", \"6\", \"x\", \"11\", \"x\", \"13\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"4\", \"x\", \"8\", \"x\", \"12\", \"x\", \"12\", \"13\", \"x\"], [\"x\", \"x\", \"18\", \"14\", \"x\", \"x\", \"5\", \"x\", \"x\", \"13\", \"1\", \"x\", \"x\"], [\"x\", \"x\", \"1\", \"17\", \"8\", \"18\", \"x\", \"7\", \"x\", \"x\", \"16\", \"8\", \"x\"], [\"x\", \"x\", \"x\", \"16\", \"1\", \"x\", \"19\", \"x\", \"x\", \"x\", \"x\", \"14\", \"x\"]], [5, 12], [1, 2], 1, 5]", "A*_args": "[\"[['18', 'x', 'x', 'x', '19', 'x', 'x', '8', '6', '3', 'x', 'x', 'x'], ['x', 'x', '8', '1', '11', 'x', 'x', 'x', 'x', 'x', '4', '6', '4'], ['1', '4', '15', '13', '17', '11', 'x', '15', 'x', '13', '1', 'x', 'x'], ['3', 'x', '6', '1', '15', '2', 'x', '13', '13', 'x', '10', 'x', 'x'], ['17', '12', '13', '11', '6', '1', '3', 'x', 'x', '19', '6', '6', 'x'], ['x', '17', '7', '12', '1', '15', '17', '20', '3', 'x', 'x', '18', '10'], ['16', '14', '15', 'x', 'x', '11', 'x', '17', '20', '15', '7', '10', 'x'], ['5', '11', 'x', '7', '19', 'x', '6', '18', '15', 'x', '8', 'x', '1'], ['10', 'x', '1', 'x', 'x', '6', 'x', '11', 'x', '13', 'x', 'x', 'x'], ['x', 'x', 'x', 'x', '4', 'x', '8', 'x', '12', 'x', '12', '13', 'x'], ['x', 'x', '18', '14', 'x', 'x', '5', 'x', 'x', '13', '1', 'x', 'x'], ['x', 'x', '1', '17', '8', '18', 'x', '7', 'x', 'x', '16', '8', 'x'], ['x', 'x', 'x', '16', '1', 'x', '19', 'x', 'x', 'x', 'x', '14', 'x']]\", \"(5, 12)\", \"(1, 2)\", \"1\", \"5\"]"}
{"diff_sorted_id": "68", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 13x13. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (11, 5) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (0, 12). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 1 1 1 0 1 0 0 0 0 0 0\n1 1 1 1 1 0 1 0 0 0 0 0 0\n1 0 0 0 0 1 0 0 1 0 0 1 1\n1 1 1 1 0 1 1 0 1 1 0 0 1\n0 1 0 0 0 1 0 0 1 1 0 1 1\n1 0 1 0 0 1 0 0 0 1 1 1 1\n0 1 0 0 1 0 0 0 1 0 1 1 0\n1 1 0 1 0 0 0 1 1 1 0 1 0\n1 1 0 1 0 0 0 1 1 0 0 0 1\n1 0 1 0 0 0 0 1 1 1 0 0 0\n1 1 1 0 0 0 1 1 0 1 1 1 0\n1 0 0 0 0 0 1 0 0 1 0 1 1\n1 0 1 1 1 1 1 1 0 1 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[[11, 5], [10, 5], [9, 5], [8, 5], [7, 5], [6, 6], [5, 7], [4, 7], [3, 7], [2, 7], [1, 8], [0, 9], [0, 10], [0, 11], [0, 12]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.03449535369873047", "solution_depth": "15", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1], [1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1], [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0], [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0], [1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1], [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1]]\", 4]", "is_correct_args": "[\"[[1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1], [1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1], [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0], [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0], [1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1], [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1]]\", [11, 5], [0, 12], 4]", "A*_args": "[\"[[1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1], [1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1], [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0], [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0], [1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1], [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1]]\", \"(11, 5)\", \"(0, 12)\", \"4\"]"}
{"diff_sorted_id": "68", "problem_statement": "Given 5 labeled water jugs with capacities 73, 129, 120, 38, 72, 138 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 278, 295, 323, 383 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 72, 4], [\"+\", 138, 4], [\"+\", 138, 4], [\"-\", 38, 4], [\"+\", 73, 4], [\"+\", 120, 3], [\"+\", 138, 3], [\"-\", 73, 3], [\"+\", 138, 3], [\"+\", 72, 2], [\"+\", 138, 2], [\"+\", 38, 2], [\"-\", 73, 2], [\"+\", 120, 2], [\"+\", 120, 1], [\"+\", 120, 1], [\"+\", 38, 1]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.030396461486816406", "solution_depth": "17", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[73, 129, 120, 38, 72, 138], [278, 295, 323, 383]]", "is_correct_args": "[[73, 129, 120, 38, 72, 138], [278, 295, 323, 383]]", "A*_args": "[\"[73, 129, 120, 38, 72, 138]\", \"[278, 295, 323, 383]\"]"}
{"diff_sorted_id": "69", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [['_', 83, 11, 57, 59], [89, 61, 99, 76, 63], [42, 35, 25, 48, 54]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[83, 11, 57, 59, 63, 54, 48, 25, 35, 61, 99, 57, 11, 83, 89, 99, 61, 35, 57, 11, 59, 76, 11, 59, 83, 89, 99, 61, 59, 57, 25, 11, 54, 48]", "opt_solution_cost": "34", "opt_solution_compute_t": "3.8137171268463135", "solution_depth": "34", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[\"_\", 83, 11, 57, 59], [89, 61, 99, 76, 63], [42, 35, 25, 48, 54]]]", "is_correct_args": "[[[\"_\", 83, 11, 57, 59], [89, 61, 99, 76, 63], [42, 35, 25, 48, 54]]]", "A*_args": "[\"[['_', 83, 11, 57, 59], [89, 61, 99, 76, 63], [42, 35, 25, 48, 54]]\"]"}
{"diff_sorted_id": "69", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: orc, icho, dear, four, peai   The initial board: [['c', 'o', 'a', 'c'], ['i', 'o', 'h', 'r'], ['d', 'e', 'r', 'r'], ['f', 'o', 'u', 'a'], ['p', 'e', '_', 'i']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"up-right\", \"up-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.19328975677490234", "solution_depth": "8", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"c\", \"o\", \"a\", \"c\"], [\"i\", \"o\", \"h\", \"r\"], [\"d\", \"e\", \"r\", \"r\"], [\"f\", \"o\", \"u\", \"a\"], [\"p\", \"e\", \"_\", \"i\"]]]", "is_correct_args": "[[[\"c\", \"o\", \"a\", \"c\"], [\"i\", \"o\", \"h\", \"r\"], [\"d\", \"e\", \"r\", \"r\"], [\"f\", \"o\", \"u\", \"a\"], [\"p\", \"e\", \"_\", \"i\"]], [\"orc\", \"icho\", \"dear\", \"four\", \"peai\"]]", "A*_args": "[\"[['c', 'o', 'a', 'c'], ['i', 'o', 'h', 'r'], ['d', 'e', 'r', 'r'], ['f', 'o', 'u', 'a'], ['p', 'e', '_', 'i']]\", \"['orc', 'icho', 'dear', 'four', 'peai']\"]"}
{"diff_sorted_id": "69", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'P'. Our task is to visit city N and city R excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from R and N, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  N Y P L Q H C G U K J B R T \nN 0 1 0 0 0 1 0 1 0 0 0 0 0 1 \nY 1 0 0 0 0 0 0 0 1 0 0 0 0 1 \nP 0 0 0 0 1 0 0 0 1 0 0 0 0 1 \nL 1 1 0 0 1 0 0 0 1 0 0 0 0 1 \nQ 0 0 0 0 0 0 0 0 0 0 0 0 1 0 \nH 0 0 0 1 0 0 0 0 0 1 0 1 0 0 \nC 1 1 1 1 1 1 0 1 0 0 0 0 1 0 \nG 0 1 1 1 1 0 0 0 0 0 0 0 0 0 \nU 0 0 0 0 1 0 1 1 0 0 0 0 0 0 \nK 1 1 0 1 0 0 0 0 0 0 0 0 1 0 \nJ 1 1 1 1 0 0 1 0 0 0 0 0 1 0 \nB 1 0 0 0 0 0 1 1 0 1 1 0 0 1 \nR 0 1 1 1 1 0 0 0 1 0 1 0 0 0 \nT 0 1 0 0 1 0 1 0 0 1 1 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[\"P\", \"Q\", \"R\", \"J\", \"R\", \"L\", \"N\", \"Y\", \"N\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.05361437797546387", "solution_depth": "9", "max_successor_states": "14", "num_vars_per_state": "17", "is_feasible_args": "[[[0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1], [0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0]], [\"N\", \"Y\", \"P\", \"L\", \"Q\", \"H\", \"C\", \"G\", \"U\", \"K\", \"J\", \"B\", \"R\", \"T\"], \"N\", \"R\"]", "is_correct_args": "[[[0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1], [0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0]], [\"N\", \"Y\", \"P\", \"L\", \"Q\", \"H\", \"C\", \"G\", \"U\", \"K\", \"J\", \"B\", \"R\", \"T\"], \"P\", \"N\", \"R\"]", "A*_args": "[\"[[0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1], [0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0]]\", \"['N', 'Y', 'P', 'L', 'Q', 'H', 'C', 'G', 'U', 'K', 'J', 'B', 'R', 'T']\", \"['P']\", \"['N', 'R']\"]"}
{"diff_sorted_id": "69", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [28, 11, 40, 15, 21, 6, 20, 6, 12, 22, 8, 18, 34, 24, 22, 30, 35, 41, 6, 39, 5, 15, 19, 8, 26, 38, 11, 29, 31, 14, 37, 28, 8, 11, 28, 27, 38], such that the sum of the chosen coins adds up to 423. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {40: 1, 41: 13, 8: 5, 28: 2, 21: 18, 15: 7, 5: 4, 14: 13, 37: 12, 22: 12, 29: 3, 30: 15, 35: 4, 26: 19, 39: 7, 31: 14, 11: 7, 20: 3, 6: 2, 12: 8, 27: 13, 19: 19, 34: 5, 18: 9, 38: 16, 24: 17}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "20", "opt_solution": "[40, 28, 6, 35, 6, 29, 28, 6, 39, 34, 20, 37, 41, 38, 28, 8]", "opt_solution_cost": "81", "opt_solution_compute_t": "0.05535292625427246", "solution_depth": "16", "max_successor_states": "37", "num_vars_per_state": "37", "is_feasible_args": "[[28, 11, 40, 15, 21, 6, 20, 6, 12, 22, 8, 18, 34, 24, 22, 30, 35, 41, 6, 39, 5, 15, 19, 8, 26, 38, 11, 29, 31, 14, 37, 28, 8, 11, 28, 27, 38]]", "is_correct_args": "[[28, 11, 40, 15, 21, 6, 20, 6, 12, 22, 8, 18, 34, 24, 22, 30, 35, 41, 6, 39, 5, 15, 19, 8, 26, 38, 11, 29, 31, 14, 37, 28, 8, 11, 28, 27, 38], {\"40\": 1, \"41\": 13, \"8\": 5, \"28\": 2, \"21\": 18, \"15\": 7, \"5\": 4, \"14\": 13, \"37\": 12, \"22\": 12, \"29\": 3, \"30\": 15, \"35\": 4, \"26\": 19, \"39\": 7, \"31\": 14, \"11\": 7, \"20\": 3, \"6\": 2, \"12\": 8, \"27\": 13, \"19\": 19, \"34\": 5, \"18\": 9, \"38\": 16, \"24\": 17}, 423]", "A*_args": "[\"[28, 11, 40, 15, 21, 6, 20, 6, 12, 22, 8, 18, 34, 24, 22, 30, 35, 41, 6, 39, 5, 15, 19, 8, 26, 38, 11, 29, 31, 14, 37, 28, 8, 11, 28, 27, 38]\", \"{40: 1, 41: 13, 8: 5, 28: 2, 21: 18, 15: 7, 5: 4, 14: 13, 37: 12, 22: 12, 29: 3, 30: 15, 35: 4, 26: 19, 39: 7, 31: 14, 11: 7, 20: 3, 6: 2, 12: 8, 27: 13, 19: 19, 34: 5, 18: 9, 38: 16, 24: 17}\", \"423\"]"}
{"diff_sorted_id": "69", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Blue', 'Blue', 'Green', 'Blue'], ['Blue', 'Red', 'Red', 'Blue', 'Red'], ['Red', 'Red', 'Green', 'Green', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[0, 2], [0, 1], [0, 1], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 2], [0, 1], [0, 1], [2, 0], [2, 0], [2, 0], [2, 1], [2, 1], [0, 2], [0, 2]]", "opt_solution_cost": "19", "opt_solution_compute_t": "4.277469635009766", "solution_depth": "19", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Green\", \"Blue\", \"Blue\", \"Green\", \"Blue\"], [\"Blue\", \"Red\", \"Red\", \"Blue\", \"Red\"], [\"Red\", \"Red\", \"Green\", \"Green\", \"Green\"]], 8]", "is_correct_args": "[[[\"Green\", \"Blue\", \"Blue\", \"Green\", \"Blue\"], [\"Blue\", \"Red\", \"Red\", \"Blue\", \"Red\"], [\"Red\", \"Red\", \"Green\", \"Green\", \"Green\"]], 8]", "A*_args": "[\"[['Green', 'Blue', 'Blue', 'Green', 'Blue'], ['Blue', 'Red', 'Red', 'Blue', 'Red'], ['Red', 'Red', 'Green', 'Green', 'Green']]\", \"8\"]"}
{"diff_sorted_id": "69", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 48 to 93 (48 included in the range but 93 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['48' '52' '56' 'x']\n ['55' 'x' 'x' '71']\n ['59' 'x' '74' '82']\n ['x' 'x' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "13", "opt_solution": "[[0, 1, 32], [0, 2, 35], [1, 2, 34], [1, 3, 36], [2, 3, 33], [3, 0, 27], [3, 1, 11], [3, 2, 10], [3, 3, 9]]", "opt_solution_cost": "370", "opt_solution_compute_t": "7.134505748748779", "solution_depth": "9", "max_successor_states": "45", "num_vars_per_state": "16", "is_feasible_args": "[\"[['24', '', '', '53'], ['25', '31', '', ''], ['26', '29', '31', ''], ['', '', '', '']]\", 9, 54]", "is_correct_args": "[\"[['24', '', '', '53'], ['25', '31', '', ''], ['26', '29', '31', ''], ['', '', '', '']]\", 9, 54]", "A*_args": "[\"[['24', '', '', '53'], ['25', '31', '', ''], ['26', '29', '31', ''], ['', '', '', '']]\", \"9\", \"54\"]"}
{"diff_sorted_id": "69", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 31 to 67. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 205, 218, None for columns 1 to 2 respectively, and the sums of rows must be None, 219, 220, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 182. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['43' '65' 'x' 'x']\n ['42' 'x' '59' 'x']\n ['54' '45' 'x' 'x']\n ['x' 'x' 'x' '35']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 2, 32], [0, 3, 31], [1, 1, 62], [1, 3, 56], [2, 2, 66], [2, 3, 55], [3, 0, 47], [3, 1, 33], [3, 2, 61]]", "opt_solution_cost": "786", "opt_solution_compute_t": "41.5692081451416", "solution_depth": "9", "max_successor_states": "26", "num_vars_per_state": "16", "is_feasible_args": "[\"[['43', '65', '', ''], ['42', '', '59', ''], ['54', '45', '', ''], ['', '', '', '35']]\", 4, 31, 67]", "is_correct_args": "[\"[['43', '65', '', ''], ['42', '', '59', ''], ['54', '45', '', ''], ['', '', '', '35']]\", 31, 67, [1, 3], [1, 3], [205, 218], [219, 220], 182]", "A*_args": "[\"[['43', '65', '', ''], ['42', '', '59', ''], ['54', '45', '', ''], ['', '', '', '35']]\", \"31\", \"67\", \"[None, 205, 218, None]\", \"[None, 219, 220, None]\", \"182\"]"}
{"diff_sorted_id": "69", "problem_statement": "In 'Restricted Sorting', there are 10 stacks each with a capacity of 6 blocks, with 5 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 5 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 5, 1: 4, 2: 7, 3: 7, 4: 11, 5: 11, 6: 8, 7: 3, 8: 7, 9: 9}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Blue', 'Black', 'Black', 'Yellow', 'White', 'Green'], ['Green', 'Black', 'Red', 'Green', 'Yellow', 'Blue'], [], ['Green', 'Red', 'Blue', 'Yellow', 'Green', 'Blue'], ['Black', 'White', 'White', 'Red', 'White', 'Black'], [], ['White', 'Red', 'Blue', 'Yellow', 'Yellow', 'Red'], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "3", "opt_solution": "[[1, 0], [4, 3], [4, 8], [5, 6], [7, 9], [7, 8], [7, 0], [2, 3], [2, 6], [2, 8], [2, 3], [1, 6], [1, 6], [5, 9], [5, 9], [5, 8], [5, 9], [5, 6], [1, 5], [1, 9], [1, 3], [2, 1], [7, 1], [7, 1], [4, 0], [4, 1], [4, 3], [7, 8], [2, 0], [4, 0], [5, 1]]", "opt_solution_cost": "211", "opt_solution_compute_t": "0.1563878059387207", "solution_depth": "31", "max_successor_states": "90", "num_vars_per_state": "30", "is_feasible_args": "[[[], [\"Blue\", \"Black\", \"Black\", \"Yellow\", \"White\", \"Green\"], [\"Green\", \"Black\", \"Red\", \"Green\", \"Yellow\", \"Blue\"], [], [\"Green\", \"Red\", \"Blue\", \"Yellow\", \"Green\", \"Blue\"], [\"Black\", \"White\", \"White\", \"Red\", \"White\", \"Black\"], [], [\"White\", \"Red\", \"Blue\", \"Yellow\", \"Yellow\", \"Red\"], [], []], 6, {\"0\": 5, \"1\": 4, \"2\": 7, \"3\": 7, \"4\": 11, \"5\": 11, \"6\": 8, \"7\": 3, \"8\": 7, \"9\": 9}]", "is_correct_args": "[[[], [\"Blue\", \"Black\", \"Black\", \"Yellow\", \"White\", \"Green\"], [\"Green\", \"Black\", \"Red\", \"Green\", \"Yellow\", \"Blue\"], [], [\"Green\", \"Red\", \"Blue\", \"Yellow\", \"Green\", \"Blue\"], [\"Black\", \"White\", \"White\", \"Red\", \"White\", \"Black\"], [], [\"White\", \"Red\", \"Blue\", \"Yellow\", \"Yellow\", \"Red\"], [], []], 6, {\"0\": 5, \"1\": 4, \"2\": 7, \"3\": 7, \"4\": 11, \"5\": 11, \"6\": 8, \"7\": 3, \"8\": 7, \"9\": 9}, 5]", "A*_args": "[\"[[], ['Blue', 'Black', 'Black', 'Yellow', 'White', 'Green'], ['Green', 'Black', 'Red', 'Green', 'Yellow', 'Blue'], [], ['Green', 'Red', 'Blue', 'Yellow', 'Green', 'Blue'], ['Black', 'White', 'White', 'Red', 'White', 'Black'], [], ['White', 'Red', 'Blue', 'Yellow', 'Yellow', 'Red'], [], []]\", \"{0: 5, 1: 4, 2: 7, 3: 7, 4: 11, 5: 11, 6: 8, 7: 3, 8: 7, 9: 9}\", \"6\", \"5\"]"}
{"diff_sorted_id": "69", "problem_statement": "In 'Restricted Sorting', there are 10 stacks each with a capacity of 6 blocks, with 5 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 5 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 5, 1: 4, 2: 7, 3: 7, 4: 11, 5: 11, 6: 8, 7: 3, 8: 7, 9: 9}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Blue', 'Black', 'Black', 'Yellow', 'White', 'Green'], ['Green', 'Black', 'Red', 'Green', 'Yellow', 'Blue'], [], ['Green', 'Red', 'Blue', 'Yellow', 'Green', 'Blue'], ['Black', 'White', 'White', 'Red', 'White', 'Black'], [], ['White', 'Red', 'Blue', 'Yellow', 'Yellow', 'Red'], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "3", "opt_solution": "[[1, 0], [4, 3], [4, 8], [5, 6], [7, 9], [7, 8], [7, 0], [2, 3], [2, 6], [2, 8], [2, 3], [1, 6], [1, 6], [5, 9], [5, 9], [5, 8], [5, 9], [5, 6], [1, 5], [1, 9], [1, 3], [2, 1], [7, 1], [7, 1], [4, 0], [4, 1], [4, 3], [7, 8], [2, 0], [4, 0], [5, 1]]", "opt_solution_cost": "211", "opt_solution_compute_t": "0.1563878059387207", "solution_depth": "31", "max_successor_states": "90", "num_vars_per_state": "30", "is_feasible_args": "[[[], [\"Blue\", \"Black\", \"Black\", \"Yellow\", \"White\", \"Green\"], [\"Green\", \"Black\", \"Red\", \"Green\", \"Yellow\", \"Blue\"], [], [\"Green\", \"Red\", \"Blue\", \"Yellow\", \"Green\", \"Blue\"], [\"Black\", \"White\", \"White\", \"Red\", \"White\", \"Black\"], [], [\"White\", \"Red\", \"Blue\", \"Yellow\", \"Yellow\", \"Red\"], [], []], 6, {\"0\": 5, \"1\": 4, \"2\": 7, \"3\": 7, \"4\": 11, \"5\": 11, \"6\": 8, \"7\": 3, \"8\": 7, \"9\": 9}]", "is_correct_args": "[[[], [\"Blue\", \"Black\", \"Black\", \"Yellow\", \"White\", \"Green\"], [\"Green\", \"Black\", \"Red\", \"Green\", \"Yellow\", \"Blue\"], [], [\"Green\", \"Red\", \"Blue\", \"Yellow\", \"Green\", \"Blue\"], [\"Black\", \"White\", \"White\", \"Red\", \"White\", \"Black\"], [], [\"White\", \"Red\", \"Blue\", \"Yellow\", \"Yellow\", \"Red\"], [], []], 6, {\"0\": 5, \"1\": 4, \"2\": 7, \"3\": 7, \"4\": 11, \"5\": 11, \"6\": 8, \"7\": 3, \"8\": 7, \"9\": 9}, 5]", "A*_args": "[\"[[], ['Blue', 'Black', 'Black', 'Yellow', 'White', 'Green'], ['Green', 'Black', 'Red', 'Green', 'Yellow', 'Blue'], [], ['Green', 'Red', 'Blue', 'Yellow', 'Green', 'Blue'], ['Black', 'White', 'White', 'Red', 'White', 'Black'], [], ['White', 'Red', 'Blue', 'Yellow', 'Yellow', 'Red'], [], []]\", \"{0: 5, 1: 4, 2: 7, 3: 7, 4: 11, 5: 11, 6: 8, 7: 3, 8: 7, 9: 9}\", \"6\", \"5\"]"}
{"diff_sorted_id": "69", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (1, 12) to his destination workshop at index (6, 3), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 5, and district 3 covering rows 6 to 12. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[17 x x x 5 x x 12 16 x x 5 16]\n[x x x x x x x x x x 12 4 6]\n[9 x x x x x 19 x x 13 6 11 19]\n[1 x x x 13 x x x 3 2 7 4 3]\n[x x x 14 19 20 10 13 14 2 x 9 3]\n[15 x 11 7 x 11 6 16 x x x 8 19]\n[19 16 4 8 5 5 5 11 10 17 9 x 5]\n[x 3 17 x x 6 17 19 x x 14 x x]\n[x x x x x 14 x 10 14 13 x 13 x]\n[15 5 4 x x x x 2 12 6 x 16 14]\n[10 x x x 9 x x x x x 13 2 x]\n[x x 17 x x x x 7 x x 16 x x]\n[12 10 x 15 16 x x 7 11 7 x 17 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "5", "opt_solution": "[[1, 12], [1, 11], [2, 11], [3, 11], [3, 10], [3, 9], [4, 9], [4, 8], [4, 7], [4, 6], [5, 6], [6, 6], [6, 5], [6, 4], [6, 3]]", "opt_solution_cost": "96", "opt_solution_compute_t": "0.021815061569213867", "solution_depth": "15", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"17\", \"x\", \"x\", \"x\", \"5\", \"x\", \"x\", \"12\", \"16\", \"x\", \"x\", \"5\", \"16\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"12\", \"4\", \"6\"], [\"9\", \"x\", \"x\", \"x\", \"x\", \"x\", \"19\", \"x\", \"x\", \"13\", \"6\", \"11\", \"19\"], [\"1\", \"x\", \"x\", \"x\", \"13\", \"x\", \"x\", \"x\", \"3\", \"2\", \"7\", \"4\", \"3\"], [\"x\", \"x\", \"x\", \"14\", \"19\", \"20\", \"10\", \"13\", \"14\", \"2\", \"x\", \"9\", \"3\"], [\"15\", \"x\", \"11\", \"7\", \"x\", \"11\", \"6\", \"16\", \"x\", \"x\", \"x\", \"8\", \"19\"], [\"19\", \"16\", \"4\", \"8\", \"5\", \"5\", \"5\", \"11\", \"10\", \"17\", \"9\", \"x\", \"5\"], [\"x\", \"3\", \"17\", \"x\", \"x\", \"6\", \"17\", \"19\", \"x\", \"x\", \"14\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"14\", \"x\", \"10\", \"14\", \"13\", \"x\", \"13\", \"x\"], [\"15\", \"5\", \"4\", \"x\", \"x\", \"x\", \"x\", \"2\", \"12\", \"6\", \"x\", \"16\", \"14\"], [\"10\", \"x\", \"x\", \"x\", \"9\", \"x\", \"x\", \"x\", \"x\", \"x\", \"13\", \"2\", \"x\"], [\"x\", \"x\", \"17\", \"x\", \"x\", \"x\", \"x\", \"7\", \"x\", \"x\", \"16\", \"x\", \"x\"], [\"12\", \"10\", \"x\", \"15\", \"16\", \"x\", \"x\", \"7\", \"11\", \"7\", \"x\", \"17\", \"x\"]]]", "is_correct_args": "[[[\"17\", \"x\", \"x\", \"x\", \"5\", \"x\", \"x\", \"12\", \"16\", \"x\", \"x\", \"5\", \"16\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"12\", \"4\", \"6\"], [\"9\", \"x\", \"x\", \"x\", \"x\", \"x\", \"19\", \"x\", \"x\", \"13\", \"6\", \"11\", \"19\"], [\"1\", \"x\", \"x\", \"x\", \"13\", \"x\", \"x\", \"x\", \"3\", \"2\", \"7\", \"4\", \"3\"], [\"x\", \"x\", \"x\", \"14\", \"19\", \"20\", \"10\", \"13\", \"14\", \"2\", \"x\", \"9\", \"3\"], [\"15\", \"x\", \"11\", \"7\", \"x\", \"11\", \"6\", \"16\", \"x\", \"x\", \"x\", \"8\", \"19\"], [\"19\", \"16\", \"4\", \"8\", \"5\", \"5\", \"5\", \"11\", \"10\", \"17\", \"9\", \"x\", \"5\"], [\"x\", \"3\", \"17\", \"x\", \"x\", \"6\", \"17\", \"19\", \"x\", \"x\", \"14\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"14\", \"x\", \"10\", \"14\", \"13\", \"x\", \"13\", \"x\"], [\"15\", \"5\", \"4\", \"x\", \"x\", \"x\", \"x\", \"2\", \"12\", \"6\", \"x\", \"16\", \"14\"], [\"10\", \"x\", \"x\", \"x\", \"9\", \"x\", \"x\", \"x\", \"x\", \"x\", \"13\", \"2\", \"x\"], [\"x\", \"x\", \"17\", \"x\", \"x\", \"x\", \"x\", \"7\", \"x\", \"x\", \"16\", \"x\", \"x\"], [\"12\", \"10\", \"x\", \"15\", \"16\", \"x\", \"x\", \"7\", \"11\", \"7\", \"x\", \"17\", \"x\"]], [1, 12], [6, 3], 1, 5]", "A*_args": "[\"[['17', 'x', 'x', 'x', '5', 'x', 'x', '12', '16', 'x', 'x', '5', '16'], ['x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', '12', '4', '6'], ['9', 'x', 'x', 'x', 'x', 'x', '19', 'x', 'x', '13', '6', '11', '19'], ['1', 'x', 'x', 'x', '13', 'x', 'x', 'x', '3', '2', '7', '4', '3'], ['x', 'x', 'x', '14', '19', '20', '10', '13', '14', '2', 'x', '9', '3'], ['15', 'x', '11', '7', 'x', '11', '6', '16', 'x', 'x', 'x', '8', '19'], ['19', '16', '4', '8', '5', '5', '5', '11', '10', '17', '9', 'x', '5'], ['x', '3', '17', 'x', 'x', '6', '17', '19', 'x', 'x', '14', 'x', 'x'], ['x', 'x', 'x', 'x', 'x', '14', 'x', '10', '14', '13', 'x', '13', 'x'], ['15', '5', '4', 'x', 'x', 'x', 'x', '2', '12', '6', 'x', '16', '14'], ['10', 'x', 'x', 'x', '9', 'x', 'x', 'x', 'x', 'x', '13', '2', 'x'], ['x', 'x', '17', 'x', 'x', 'x', 'x', '7', 'x', 'x', '16', 'x', 'x'], ['12', '10', 'x', '15', '16', 'x', 'x', '7', '11', '7', 'x', '17', 'x']]\", \"(1, 12)\", \"(6, 3)\", \"1\", \"5\"]"}
{"diff_sorted_id": "69", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 13x13. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (12, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (3, 8). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 1 1 1 0 1 1 1 1 1 1 0\n1 1 1 0 1 1 0 0 0 0 1 1 1\n1 1 0 0 0 0 0 1 1 0 1 1 1\n1 0 1 1 0 0 0 0 0 1 1 0 1\n0 0 1 0 1 0 0 0 0 0 1 0 1\n0 1 1 1 0 0 0 1 1 1 1 0 1\n0 1 0 1 0 1 0 0 0 0 1 0 1\n1 1 0 1 1 0 0 0 1 1 0 1 1\n0 1 1 0 1 0 0 1 1 0 0 1 1\n0 0 1 1 0 0 0 0 0 1 1 0 0\n1 1 1 0 0 0 0 1 1 1 0 0 0\n0 0 0 1 0 1 0 0 0 0 0 0 1\n0 0 1 0 1 1 0 1 1 1 0 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[[12, 0], [11, 0], [11, 1], [11, 2], [10, 3], [9, 4], [8, 5], [7, 5], [6, 6], [5, 6], [4, 6], [4, 7], [3, 7], [3, 8]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.03328585624694824", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], [1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1], [1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1], [1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1], [0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], [1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1]]\", 4]", "is_correct_args": "[\"[[0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], [1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1], [1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1], [1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1], [0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], [1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1]]\", [12, 0], [3, 8], 4]", "A*_args": "[\"[[0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], [1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1], [1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1], [1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1], [0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], [1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1]]\", \"(12, 0)\", \"(3, 8)\", \"4\"]"}
{"diff_sorted_id": "69", "problem_statement": "Given 5 labeled water jugs with capacities 34, 98, 27, 19, 52, 53 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 257, 260, 269, 291 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 27, 4], [\"+\", 98, 4], [\"+\", 98, 4], [\"+\", 34, 4], [\"+\", 34, 4], [\"+\", 19, 3], [\"+\", 98, 3], [\"+\", 98, 3], [\"+\", 27, 3], [\"+\", 27, 3], [\"+\", 98, 2], [\"+\", 98, 2], [\"-\", 34, 2], [\"+\", 98, 2], [\"+\", 98, 1], [\"+\", 98, 1], [\"+\", 27, 1], [\"+\", 34, 1]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.034804582595825195", "solution_depth": "18", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[34, 98, 27, 19, 52, 53], [257, 260, 269, 291]]", "is_correct_args": "[[34, 98, 27, 19, 52, 53], [257, 260, 269, 291]]", "A*_args": "[\"[34, 98, 27, 19, 52, 53]\", \"[257, 260, 269, 291]\"]"}
{"diff_sorted_id": "70", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[86, 100, 92, 37, 95], [88, '_', 97, 10, 67], [32, 82, 19, 53, 4]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[88, 86, 100, 88, 97, 10, 67, 95, 37, 92, 88, 97, 82, 19, 10, 67, 92, 88, 67, 92, 95, 37, 88, 95, 92, 67, 95, 92, 53, 4]", "opt_solution_cost": "30", "opt_solution_compute_t": "0.4556577205657959", "solution_depth": "30", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[86, 100, 92, 37, 95], [88, \"_\", 97, 10, 67], [32, 82, 19, 53, 4]]]", "is_correct_args": "[[[86, 100, 92, 37, 95], [88, \"_\", 97, 10, 67], [32, 82, 19, 53, 4]]]", "A*_args": "[\"[[86, 100, 92, 37, 95], [88, '_', 97, 10, 67], [32, 82, 19, 53, 4]]\"]"}
{"diff_sorted_id": "70", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: map, pahi, yeel, vial, wusp   The initial board: [['a', 'm', '_', 'p'], ['p', 'e', 'h', 'a'], ['l', 'e', 'y', 'l'], ['v', 'i', 'a', 'i'], ['w', 'u', 's', 'p']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.2252347469329834", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"a\", \"m\", \"_\", \"p\"], [\"p\", \"e\", \"h\", \"a\"], [\"l\", \"e\", \"y\", \"l\"], [\"v\", \"i\", \"a\", \"i\"], [\"w\", \"u\", \"s\", \"p\"]]]", "is_correct_args": "[[[\"a\", \"m\", \"_\", \"p\"], [\"p\", \"e\", \"h\", \"a\"], [\"l\", \"e\", \"y\", \"l\"], [\"v\", \"i\", \"a\", \"i\"], [\"w\", \"u\", \"s\", \"p\"]], [\"map\", \"pahi\", \"yeel\", \"vial\", \"wusp\"]]", "A*_args": "[\"[['a', 'm', '_', 'p'], ['p', 'e', 'h', 'a'], ['l', 'e', 'y', 'l'], ['v', 'i', 'a', 'i'], ['w', 'u', 's', 'p']]\", \"['map', 'pahi', 'yeel', 'vial', 'wusp']\"]"}
{"diff_sorted_id": "70", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'V'. Our task is to visit city E and city U excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from U and E, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  K I E B Y J U D L A X C F V \nK 0 1 0 0 0 0 0 0 0 0 0 1 0 0 \nI 0 0 0 0 1 0 1 1 0 0 0 0 0 0 \nE 0 0 0 1 1 0 0 1 0 0 1 0 0 0 \nB 0 0 0 0 0 0 1 0 0 0 0 0 0 0 \nY 1 0 0 0 0 0 0 1 0 0 1 0 0 0 \nJ 0 0 0 1 1 0 0 1 0 0 0 0 1 1 \nU 1 0 0 0 0 0 0 0 0 1 0 0 0 1 \nD 0 0 0 0 0 0 0 0 1 1 0 0 0 0 \nL 1 0 1 0 0 1 1 0 0 0 0 0 1 0 \nA 1 0 0 1 0 0 0 0 1 0 0 0 0 0 \nX 1 1 0 0 1 0 0 0 0 0 0 1 0 0 \nC 0 0 1 0 0 0 1 0 1 1 0 0 0 0 \nF 0 0 0 0 0 1 0 0 1 0 0 0 0 0 \nV 0 0 0 1 1 1 0 0 0 0 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[\"V\", \"B\", \"U\", \"A\", \"L\", \"E\", \"X\", \"I\", \"U\", \"K\", \"C\", \"E\"]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.04632735252380371", "solution_depth": "12", "max_successor_states": "14", "num_vars_per_state": "17", "is_feasible_args": "[[[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]], [\"K\", \"I\", \"E\", \"B\", \"Y\", \"J\", \"U\", \"D\", \"L\", \"A\", \"X\", \"C\", \"F\", \"V\"], \"E\", \"U\"]", "is_correct_args": "[[[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]], [\"K\", \"I\", \"E\", \"B\", \"Y\", \"J\", \"U\", \"D\", \"L\", \"A\", \"X\", \"C\", \"F\", \"V\"], \"V\", \"E\", \"U\"]", "A*_args": "[\"[[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]]\", \"['K', 'I', 'E', 'B', 'Y', 'J', 'U', 'D', 'L', 'A', 'X', 'C', 'F', 'V']\", \"['V']\", \"['E', 'U']\"]"}
{"diff_sorted_id": "70", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [30, 28, 81, 26, 24, 20, 5, 18, 33, 19, 30, 27, 6, 10, 22, 10, 33, 10, 15, 26, 9, 6, 22, 31, 36, 16, 4, 11, 24, 7, 17, 30, 3, 7, 8, 8, 34], such that the sum of the chosen coins adds up to 387. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {24: 7, 22: 3, 11: 10, 28: 17, 7: 7, 20: 10, 5: 2, 8: 2, 9: 5, 15: 14, 81: 17, 30: 5, 31: 17, 33: 9, 18: 3, 36: 2, 16: 14, 10: 1, 19: 15, 3: 1, 34: 12, 26: 13, 6: 3, 4: 1, 27: 11, 17: 5}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "21", "opt_solution": "[36, 30, 22, 10, 33, 30, 22, 18, 10, 8, 81, 30, 10, 8, 33, 6]", "opt_solution_cost": "71", "opt_solution_compute_t": "0.055295467376708984", "solution_depth": "16", "max_successor_states": "37", "num_vars_per_state": "37", "is_feasible_args": "[[30, 28, 81, 26, 24, 20, 5, 18, 33, 19, 30, 27, 6, 10, 22, 10, 33, 10, 15, 26, 9, 6, 22, 31, 36, 16, 4, 11, 24, 7, 17, 30, 3, 7, 8, 8, 34]]", "is_correct_args": "[[30, 28, 81, 26, 24, 20, 5, 18, 33, 19, 30, 27, 6, 10, 22, 10, 33, 10, 15, 26, 9, 6, 22, 31, 36, 16, 4, 11, 24, 7, 17, 30, 3, 7, 8, 8, 34], {\"24\": 7, \"22\": 3, \"11\": 10, \"28\": 17, \"7\": 7, \"20\": 10, \"5\": 2, \"8\": 2, \"9\": 5, \"15\": 14, \"81\": 17, \"30\": 5, \"31\": 17, \"33\": 9, \"18\": 3, \"36\": 2, \"16\": 14, \"10\": 1, \"19\": 15, \"3\": 1, \"34\": 12, \"26\": 13, \"6\": 3, \"4\": 1, \"27\": 11, \"17\": 5}, 387]", "A*_args": "[\"[30, 28, 81, 26, 24, 20, 5, 18, 33, 19, 30, 27, 6, 10, 22, 10, 33, 10, 15, 26, 9, 6, 22, 31, 36, 16, 4, 11, 24, 7, 17, 30, 3, 7, 8, 8, 34]\", \"{24: 7, 22: 3, 11: 10, 28: 17, 7: 7, 20: 10, 5: 2, 8: 2, 9: 5, 15: 14, 81: 17, 30: 5, 31: 17, 33: 9, 18: 3, 36: 2, 16: 14, 10: 1, 19: 15, 3: 1, 34: 12, 26: 13, 6: 3, 4: 1, 27: 11, 17: 5}\", \"387\"]"}
{"diff_sorted_id": "70", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Green', 'Green', 'Red', 'Blue'], ['Blue', 'Blue', 'Red', 'Green', 'Red'], ['Red', 'Green', 'Blue', 'Blue', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[1, 2], [1, 0], [1, 2], [1, 0], [2, 1], [2, 0], [2, 1], [0, 1], [2, 0], [2, 1], [2, 1], [2, 1], [0, 2], [0, 2], [0, 1], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 2], [1, 0], [1, 0], [1, 0], [2, 1], [2, 1]]", "opt_solution_cost": "26", "opt_solution_compute_t": "114.16396856307983", "solution_depth": "26", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Green\", \"Green\", \"Green\", \"Red\", \"Blue\"], [\"Blue\", \"Blue\", \"Red\", \"Green\", \"Red\"], [\"Red\", \"Green\", \"Blue\", \"Blue\", \"Red\"]], 8]", "is_correct_args": "[[[\"Green\", \"Green\", \"Green\", \"Red\", \"Blue\"], [\"Blue\", \"Blue\", \"Red\", \"Green\", \"Red\"], [\"Red\", \"Green\", \"Blue\", \"Blue\", \"Red\"]], 8]", "A*_args": "[\"[['Green', 'Green', 'Green', 'Red', 'Blue'], ['Blue', 'Blue', 'Red', 'Green', 'Red'], ['Red', 'Green', 'Blue', 'Blue', 'Red']]\", \"8\"]"}
{"diff_sorted_id": "70", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 12 to 57 (12 included in the range but 57 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '47' 'x' '55']\n ['29' '34' 'x' 'x']\n ['16' 'x' 'x' '35']\n ['x' '26' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "14", "opt_solution": "[[0, 1, 50], [0, 2, 52], [0, 3, 85], [1, 0, 48], [1, 2, 53], [2, 1, 54], [2, 2, 55], [3, 0, 44], [3, 1, 56], [3, 2, 57]]", "opt_solution_cost": "793", "opt_solution_compute_t": "8.519564151763916", "solution_depth": "10", "max_successor_states": "45", "num_vars_per_state": "16", "is_feasible_args": "[\"[['49', '', '', ''], ['', '51', '', '84'], ['47', '', '', '79'], ['', '', '', '77']]\", 44, 89]", "is_correct_args": "[\"[['49', '', '', ''], ['', '51', '', '84'], ['47', '', '', '79'], ['', '', '', '77']]\", 44, 89]", "A*_args": "[\"[['49', '', '', ''], ['', '51', '', '84'], ['47', '', '', '79'], ['', '', '', '77']]\", \"44\", \"89\"]"}
{"diff_sorted_id": "70", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 28 to 64. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 156, 185, None for columns 1 to 2 respectively, and the sums of rows must be None, 152, 158, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 165. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['36' '47' 'x' 'x']\n ['x' '28' '40' 'x']\n ['x' '33' 'x' 'x']\n ['50' 'x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 2, 31], [0, 3, 42], [1, 0, 35], [1, 3, 49], [2, 0, 30], [2, 2, 63], [2, 3, 32], [3, 1, 48], [3, 2, 51], [3, 3, 29]]", "opt_solution_cost": "644", "opt_solution_compute_t": "107.55870532989502", "solution_depth": "10", "max_successor_states": "26", "num_vars_per_state": "16", "is_feasible_args": "[\"[['36', '47', '', ''], ['', '28', '40', ''], ['', '33', '', ''], ['50', '', '', '']]\", 4, 28, 64]", "is_correct_args": "[\"[['36', '47', '', ''], ['', '28', '40', ''], ['', '33', '', ''], ['50', '', '', '']]\", 28, 64, [1, 3], [1, 3], [156, 185], [152, 158], 165]", "A*_args": "[\"[['36', '47', '', ''], ['', '28', '40', ''], ['', '33', '', ''], ['50', '', '', '']]\", \"28\", \"64\", \"[None, 156, 185, None]\", \"[None, 152, 158, None]\", \"165\"]"}
{"diff_sorted_id": "70", "problem_statement": "In 'Restricted Sorting', there are 10 stacks each with a capacity of 6 blocks, with 5 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 5 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 11, 1: 5, 2: 9, 3: 5, 4: 2, 5: 2, 6: 6, 7: 6, 8: 6, 9: 2}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Red', 'Green', 'Blue', 'Yellow', 'Yellow', 'Blue'], [], [], [], ['White', 'Black', 'White', 'Red', 'White', 'Blue'], ['Black', 'Green', 'Red', 'Black', 'Green', 'Yellow'], [], ['Red', 'White', 'Yellow', 'Black', 'Green', 'White'], [], ['Blue', 'Blue', 'Black', 'Green', 'Red', 'Yellow']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "3", "opt_solution": "[[0, 1], [0, 3], [7, 1], [0, 6], [5, 8], [5, 3], [5, 1], [5, 8], [5, 3], [9, 6], [9, 6], [9, 8], [9, 3], [9, 1], [5, 9], [7, 5], [7, 9], [7, 8], [7, 3], [4, 5], [4, 8], [4, 5], [4, 1], [4, 5], [0, 9], [0, 9], [0, 4], [6, 4], [6, 4], [6, 4], [7, 5]]", "opt_solution_cost": "124", "opt_solution_compute_t": "0.2532999515533447", "solution_depth": "31", "max_successor_states": "90", "num_vars_per_state": "30", "is_feasible_args": "[[[\"Red\", \"Green\", \"Blue\", \"Yellow\", \"Yellow\", \"Blue\"], [], [], [], [\"White\", \"Black\", \"White\", \"Red\", \"White\", \"Blue\"], [\"Black\", \"Green\", \"Red\", \"Black\", \"Green\", \"Yellow\"], [], [\"Red\", \"White\", \"Yellow\", \"Black\", \"Green\", \"White\"], [], [\"Blue\", \"Blue\", \"Black\", \"Green\", \"Red\", \"Yellow\"]], 6, {\"0\": 11, \"1\": 5, \"2\": 9, \"3\": 5, \"4\": 2, \"5\": 2, \"6\": 6, \"7\": 6, \"8\": 6, \"9\": 2}]", "is_correct_args": "[[[\"Red\", \"Green\", \"Blue\", \"Yellow\", \"Yellow\", \"Blue\"], [], [], [], [\"White\", \"Black\", \"White\", \"Red\", \"White\", \"Blue\"], [\"Black\", \"Green\", \"Red\", \"Black\", \"Green\", \"Yellow\"], [], [\"Red\", \"White\", \"Yellow\", \"Black\", \"Green\", \"White\"], [], [\"Blue\", \"Blue\", \"Black\", \"Green\", \"Red\", \"Yellow\"]], 6, {\"0\": 11, \"1\": 5, \"2\": 9, \"3\": 5, \"4\": 2, \"5\": 2, \"6\": 6, \"7\": 6, \"8\": 6, \"9\": 2}, 5]", "A*_args": "[\"[['Red', 'Green', 'Blue', 'Yellow', 'Yellow', 'Blue'], [], [], [], ['White', 'Black', 'White', 'Red', 'White', 'Blue'], ['Black', 'Green', 'Red', 'Black', 'Green', 'Yellow'], [], ['Red', 'White', 'Yellow', 'Black', 'Green', 'White'], [], ['Blue', 'Blue', 'Black', 'Green', 'Red', 'Yellow']]\", \"{0: 11, 1: 5, 2: 9, 3: 5, 4: 2, 5: 2, 6: 6, 7: 6, 8: 6, 9: 2}\", \"6\", \"5\"]"}
{"diff_sorted_id": "70", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (5, 1) to his destination workshop at index (2, 11), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 5, and district 3 covering rows 6 to 12. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[13 x 10 17 x 4 8 x 7 x 12 19 4]\n[17 x 8 11 7 x x 19 x 11 x 13 18]\n[15 6 2 12 16 7 x 14 x 2 x 14 4]\n[x 18 4 x x x 13 14 2 4 20 10 7]\n[7 2 19 16 x x x 18 x x x 2 2]\n[10 17 14 7 17 3 3 19 x 19 x x 9]\n[9 x x x 5 18 13 6 x x x 19 10]\n[x x x x x 2 7 4 x x x x x]\n[x x 6 3 x 1 x x 14 x 18 x 1]\n[14 x 4 18 14 12 x x x x 2 x 13]\n[12 x 3 1 12 9 x 6 x x 16 x 18]\n[13 x 11 5 3 4 x x x x x x 18]\n[15 9 9 1 x 6 x x 14 x x 1 14]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "5", "opt_solution": "[[5, 1], [5, 2], [5, 3], [5, 4], [5, 5], [5, 6], [6, 6], [5, 6], [5, 7], [4, 7], [3, 7], [3, 8], [3, 9], [2, 9], [1, 9], [2, 9], [3, 9], [3, 10], [3, 11], [2, 11]]", "opt_solution_cost": "180", "opt_solution_compute_t": "0.020688772201538086", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"13\", \"x\", \"10\", \"17\", \"x\", \"4\", \"8\", \"x\", \"7\", \"x\", \"12\", \"19\", \"4\"], [\"17\", \"x\", \"8\", \"11\", \"7\", \"x\", \"x\", \"19\", \"x\", \"11\", \"x\", \"13\", \"18\"], [\"15\", \"6\", \"2\", \"12\", \"16\", \"7\", \"x\", \"14\", \"x\", \"2\", \"x\", \"14\", \"4\"], [\"x\", \"18\", \"4\", \"x\", \"x\", \"x\", \"13\", \"14\", \"2\", \"4\", \"20\", \"10\", \"7\"], [\"7\", \"2\", \"19\", \"16\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\", \"x\", \"2\", \"2\"], [\"10\", \"17\", \"14\", \"7\", \"17\", \"3\", \"3\", \"19\", \"x\", \"19\", \"x\", \"x\", \"9\"], [\"9\", \"x\", \"x\", \"x\", \"5\", \"18\", \"13\", \"6\", \"x\", \"x\", \"x\", \"19\", \"10\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"2\", \"7\", \"4\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"6\", \"3\", \"x\", \"1\", \"x\", \"x\", \"14\", \"x\", \"18\", \"x\", \"1\"], [\"14\", \"x\", \"4\", \"18\", \"14\", \"12\", \"x\", \"x\", \"x\", \"x\", \"2\", \"x\", \"13\"], [\"12\", \"x\", \"3\", \"1\", \"12\", \"9\", \"x\", \"6\", \"x\", \"x\", \"16\", \"x\", \"18\"], [\"13\", \"x\", \"11\", \"5\", \"3\", \"4\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"18\"], [\"15\", \"9\", \"9\", \"1\", \"x\", \"6\", \"x\", \"x\", \"14\", \"x\", \"x\", \"1\", \"14\"]]]", "is_correct_args": "[[[\"13\", \"x\", \"10\", \"17\", \"x\", \"4\", \"8\", \"x\", \"7\", \"x\", \"12\", \"19\", \"4\"], [\"17\", \"x\", \"8\", \"11\", \"7\", \"x\", \"x\", \"19\", \"x\", \"11\", \"x\", \"13\", \"18\"], [\"15\", \"6\", \"2\", \"12\", \"16\", \"7\", \"x\", \"14\", \"x\", \"2\", \"x\", \"14\", \"4\"], [\"x\", \"18\", \"4\", \"x\", \"x\", \"x\", \"13\", \"14\", \"2\", \"4\", \"20\", \"10\", \"7\"], [\"7\", \"2\", \"19\", \"16\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\", \"x\", \"2\", \"2\"], [\"10\", \"17\", \"14\", \"7\", \"17\", \"3\", \"3\", \"19\", \"x\", \"19\", \"x\", \"x\", \"9\"], [\"9\", \"x\", \"x\", \"x\", \"5\", \"18\", \"13\", \"6\", \"x\", \"x\", \"x\", \"19\", \"10\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"2\", \"7\", \"4\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"6\", \"3\", \"x\", \"1\", \"x\", \"x\", \"14\", \"x\", \"18\", \"x\", \"1\"], [\"14\", \"x\", \"4\", \"18\", \"14\", \"12\", \"x\", \"x\", \"x\", \"x\", \"2\", \"x\", \"13\"], [\"12\", \"x\", \"3\", \"1\", \"12\", \"9\", \"x\", \"6\", \"x\", \"x\", \"16\", \"x\", \"18\"], [\"13\", \"x\", \"11\", \"5\", \"3\", \"4\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"18\"], [\"15\", \"9\", \"9\", \"1\", \"x\", \"6\", \"x\", \"x\", \"14\", \"x\", \"x\", \"1\", \"14\"]], [5, 1], [2, 11], 1, 5]", "A*_args": "[\"[['13', 'x', '10', '17', 'x', '4', '8', 'x', '7', 'x', '12', '19', '4'], ['17', 'x', '8', '11', '7', 'x', 'x', '19', 'x', '11', 'x', '13', '18'], ['15', '6', '2', '12', '16', '7', 'x', '14', 'x', '2', 'x', '14', '4'], ['x', '18', '4', 'x', 'x', 'x', '13', '14', '2', '4', '20', '10', '7'], ['7', '2', '19', '16', 'x', 'x', 'x', '18', 'x', 'x', 'x', '2', '2'], ['10', '17', '14', '7', '17', '3', '3', '19', 'x', '19', 'x', 'x', '9'], ['9', 'x', 'x', 'x', '5', '18', '13', '6', 'x', 'x', 'x', '19', '10'], ['x', 'x', 'x', 'x', 'x', '2', '7', '4', 'x', 'x', 'x', 'x', 'x'], ['x', 'x', '6', '3', 'x', '1', 'x', 'x', '14', 'x', '18', 'x', '1'], ['14', 'x', '4', '18', '14', '12', 'x', 'x', 'x', 'x', '2', 'x', '13'], ['12', 'x', '3', '1', '12', '9', 'x', '6', 'x', 'x', '16', 'x', '18'], ['13', 'x', '11', '5', '3', '4', 'x', 'x', 'x', 'x', 'x', 'x', '18'], ['15', '9', '9', '1', 'x', '6', 'x', 'x', '14', 'x', 'x', '1', '14']]\", \"(5, 1)\", \"(2, 11)\", \"1\", \"5\"]"}
{"diff_sorted_id": "70", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 13x13. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 8) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (10, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 0 0 0 0 0 0 1 0 0 1 1\n1 0 0 0 0 0 0 1 0 1 1 1 1\n1 0 0 1 0 0 1 0 0 0 0 1 1\n1 1 0 0 1 1 1 1 1 1 1 1 1\n1 1 0 0 0 1 0 0 0 0 1 0 1\n1 1 0 0 1 1 0 0 1 0 1 1 1\n0 0 0 0 0 1 1 1 0 0 0 0 0\n1 1 0 0 1 1 0 1 0 0 1 1 0\n1 1 0 0 1 1 1 1 1 0 1 0 1\n0 0 0 0 1 1 0 0 1 0 1 1 0\n0 0 0 0 1 0 1 0 0 1 1 0 1\n0 1 1 1 1 1 1 0 0 1 1 1 0\n0 1 1 0 1 1 1 1 1 1 0 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[[1, 8], [2, 7], [1, 6], [1, 5], [2, 5], [2, 4], [3, 3], [4, 3], [5, 3], [6, 3], [7, 3], [7, 2], [8, 2], [9, 1], [9, 0], [10, 0]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.026613712310791016", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1], [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0], [1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1], [0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1], [0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0], [0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0]]\", 4]", "is_correct_args": "[\"[[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1], [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0], [1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1], [0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1], [0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0], [0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0]]\", [1, 8], [10, 0], 4]", "A*_args": "[\"[[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1], [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1], [1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0], [1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1], [0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1], [0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0], [0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0]]\", \"(1, 8)\", \"(10, 0)\", \"4\"]"}
{"diff_sorted_id": "70", "problem_statement": "Given 5 labeled water jugs with capacities 44, 128, 127, 85, 40, 125 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 283, 295, 428, 428 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 44, 4], [\"+\", 128, 4], [\"+\", 128, 4], [\"+\", 128, 4], [\"+\", 44, 3], [\"+\", 128, 3], [\"+\", 128, 3], [\"+\", 128, 3], [\"+\", 127, 2], [\"+\", 128, 2], [\"+\", 40, 2], [\"+\", 40, 1], [\"+\", 40, 1], [\"+\", 40, 1], [\"+\", 40, 1], [\"+\", 40, 1], [\"-\", 44, 1], [\"+\", 127, 1]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.03569626808166504", "solution_depth": "18", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[44, 128, 127, 85, 40, 125], [283, 295, 428, 428]]", "is_correct_args": "[[44, 128, 127, 85, 40, 125], [283, 295, 428, 428]]", "A*_args": "[\"[44, 128, 127, 85, 40, 125]\", \"[283, 295, 428, 428]\"]"}
{"diff_sorted_id": "71", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[91, 86, 16, 48, 81], [13, 89, 5, '_', 58], [54, 22, 36, 37, 31]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[37, 36, 5, 16, 86, 89, 13, 54, 22, 13, 16, 37, 48, 86, 37, 48, 36, 5, 13, 16, 48, 37, 86, 81, 58, 31]", "opt_solution_cost": "26", "opt_solution_compute_t": "0.15856218338012695", "solution_depth": "26", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[91, 86, 16, 48, 81], [13, 89, 5, \"_\", 58], [54, 22, 36, 37, 31]]]", "is_correct_args": "[[[91, 86, 16, 48, 81], [13, 89, 5, \"_\", 58], [54, 22, 36, 37, 31]]]", "A*_args": "[\"[[91, 86, 16, 48, 81], [13, 89, 5, '_', 58], [54, 22, 36, 37, 31]]\"]"}
{"diff_sorted_id": "71", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: nab, gull, book, talc, flob   The initial board: [['u', 'n', 'a', 'b'], ['g', 'b', 'l', 'l'], ['a', 'o', '_', 'k'], ['t', 'o', 'l', 'c'], ['f', 'l', 'o', 'b']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "4", "opt_solution_compute_t": "0.1806783676147461", "solution_depth": "4", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"u\", \"n\", \"a\", \"b\"], [\"g\", \"b\", \"l\", \"l\"], [\"a\", \"o\", \"_\", \"k\"], [\"t\", \"o\", \"l\", \"c\"], [\"f\", \"l\", \"o\", \"b\"]]]", "is_correct_args": "[[[\"u\", \"n\", \"a\", \"b\"], [\"g\", \"b\", \"l\", \"l\"], [\"a\", \"o\", \"_\", \"k\"], [\"t\", \"o\", \"l\", \"c\"], [\"f\", \"l\", \"o\", \"b\"]], [\"nab\", \"gull\", \"book\", \"talc\", \"flob\"]]", "A*_args": "[\"[['u', 'n', 'a', 'b'], ['g', 'b', 'l', 'l'], ['a', 'o', '_', 'k'], ['t', 'o', 'l', 'c'], ['f', 'l', 'o', 'b']]\", \"['nab', 'gull', 'book', 'talc', 'flob']\"]"}
{"diff_sorted_id": "71", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'K'. Our task is to visit city F and city Z excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from Z and F, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  E V G W U F S H K B Z N L J \nE 0 1 0 0 0 1 0 0 0 1 0 0 0 1 \nV 0 0 1 0 0 0 0 0 0 0 0 0 0 1 \nG 0 0 0 0 1 1 0 0 0 0 0 1 0 0 \nW 1 1 0 0 1 1 0 0 0 1 0 0 0 0 \nU 1 1 0 0 0 1 0 0 0 0 0 0 0 0 \nF 0 0 0 1 0 0 0 1 0 1 0 1 1 0 \nS 0 0 1 0 0 0 0 1 0 1 0 0 1 0 \nH 1 0 0 0 0 0 0 0 0 0 0 0 0 1 \nK 1 1 1 0 0 0 1 0 0 0 0 0 0 0 \nB 0 0 0 0 0 0 0 1 1 0 0 1 0 0 \nZ 0 1 1 0 0 0 1 1 0 0 0 1 0 1 \nN 0 1 0 0 0 0 1 0 1 0 1 0 1 0 \nL 0 1 0 1 0 0 0 0 0 0 0 0 0 1 \nJ 0 0 0 0 0 0 0 0 0 0 1 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[\"K\", \"E\", \"F\", \"N\", \"Z\", \"J\", \"Z\", \"G\", \"F\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.031167984008789062", "solution_depth": "9", "max_successor_states": "14", "num_vars_per_state": "17", "is_feasible_args": "[[[0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]], [\"E\", \"V\", \"G\", \"W\", \"U\", \"F\", \"S\", \"H\", \"K\", \"B\", \"Z\", \"N\", \"L\", \"J\"], \"F\", \"Z\"]", "is_correct_args": "[[[0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]], [\"E\", \"V\", \"G\", \"W\", \"U\", \"F\", \"S\", \"H\", \"K\", \"B\", \"Z\", \"N\", \"L\", \"J\"], \"K\", \"F\", \"Z\"]", "A*_args": "[\"[[0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]]\", \"['E', 'V', 'G', 'W', 'U', 'F', 'S', 'H', 'K', 'B', 'Z', 'N', 'L', 'J']\", \"['K']\", \"['F', 'Z']\"]"}
{"diff_sorted_id": "71", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [18, 11, 14, 3, 7, 18, 40, 3, 35, 30, 24, 29, 34, 11, 17, 14, 14, 10, 5, 40, 4, 31, 25, 14, 39, 12, 26, 24, 3, 8, 34, 2, 22, 189, 40], such that the sum of the chosen coins adds up to 400. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {29: 9, 40: 8, 30: 5, 17: 16, 3: 3, 5: 3, 2: 2, 22: 17, 11: 1, 14: 4, 8: 5, 18: 11, 26: 8, 39: 15, 7: 1, 31: 2, 24: 17, 189: 5, 12: 4, 25: 10, 35: 18, 10: 1, 4: 3, 34: 16}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "22", "opt_solution": "[7, 11, 11, 31, 30, 14, 189, 40, 14, 10, 29, 14]", "opt_solution_cost": "45", "opt_solution_compute_t": "0.04481005668640137", "solution_depth": "12", "max_successor_states": "35", "num_vars_per_state": "35", "is_feasible_args": "[[18, 11, 14, 3, 7, 18, 40, 3, 35, 30, 24, 29, 34, 11, 17, 14, 14, 10, 5, 40, 4, 31, 25, 14, 39, 12, 26, 24, 3, 8, 34, 2, 22, 189, 40]]", "is_correct_args": "[[18, 11, 14, 3, 7, 18, 40, 3, 35, 30, 24, 29, 34, 11, 17, 14, 14, 10, 5, 40, 4, 31, 25, 14, 39, 12, 26, 24, 3, 8, 34, 2, 22, 189, 40], {\"29\": 9, \"40\": 8, \"30\": 5, \"17\": 16, \"3\": 3, \"5\": 3, \"2\": 2, \"22\": 17, \"11\": 1, \"14\": 4, \"8\": 5, \"18\": 11, \"26\": 8, \"39\": 15, \"7\": 1, \"31\": 2, \"24\": 17, \"189\": 5, \"12\": 4, \"25\": 10, \"35\": 18, \"10\": 1, \"4\": 3, \"34\": 16}, 400]", "A*_args": "[\"[18, 11, 14, 3, 7, 18, 40, 3, 35, 30, 24, 29, 34, 11, 17, 14, 14, 10, 5, 40, 4, 31, 25, 14, 39, 12, 26, 24, 3, 8, 34, 2, 22, 189, 40]\", \"{29: 9, 40: 8, 30: 5, 17: 16, 3: 3, 5: 3, 2: 2, 22: 17, 11: 1, 14: 4, 8: 5, 18: 11, 26: 8, 39: 15, 7: 1, 31: 2, 24: 17, 189: 5, 12: 4, 25: 10, 35: 18, 10: 1, 4: 3, 34: 16}\", \"400\"]"}
{"diff_sorted_id": "71", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Blue', 'Blue', 'Blue', 'Green'], ['Red', 'Green', 'Green', 'Red', 'Green'], ['Red', 'Red', 'Blue', 'Green', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[0, 2], [1, 2], [0, 1], [0, 1], [0, 1], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [1, 0], [2, 1], [2, 0], [1, 2], [1, 2], [1, 2], [1, 2], [1, 0], [1, 0], [1, 2], [0, 1], [0, 1], [0, 1], [0, 1], [2, 0]]", "opt_solution_cost": "25", "opt_solution_compute_t": "59.01675891876221", "solution_depth": "25", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Blue\", \"Green\"], [\"Red\", \"Green\", \"Green\", \"Red\", \"Green\"], [\"Red\", \"Red\", \"Blue\", \"Green\", \"Blue\"]], 8]", "is_correct_args": "[[[\"Red\", \"Blue\", \"Blue\", \"Blue\", \"Green\"], [\"Red\", \"Green\", \"Green\", \"Red\", \"Green\"], [\"Red\", \"Red\", \"Blue\", \"Green\", \"Blue\"]], 8]", "A*_args": "[\"[['Red', 'Blue', 'Blue', 'Blue', 'Green'], ['Red', 'Green', 'Green', 'Red', 'Green'], ['Red', 'Red', 'Blue', 'Green', 'Blue']]\", \"8\"]"}
{"diff_sorted_id": "71", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 25 to 70 (25 included in the range but 70 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '40' 'x' '65']\n ['34' 'x' '53' 'x']\n ['x' 'x' 'x' '63']\n ['x' '56' 'x' '62']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "14", "opt_solution": "[[0, 0, 28], [1, 0, 29], [1, 1, 55], [1, 3, 73], [2, 3, 75], [3, 3, 77]]", "opt_solution_cost": "734", "opt_solution_compute_t": "0.5243852138519287", "solution_depth": "6", "max_successor_states": "45", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '53', '60', '67'], ['', '', '72', ''], ['50', '56', '74', ''], ['54', '65', '76', '']]\", 28, 78]", "is_correct_args": "[\"[['', '53', '60', '67'], ['', '', '72', ''], ['50', '56', '74', ''], ['54', '65', '76', '']]\", 28, 78]", "A*_args": "[\"[['', '53', '60', '67'], ['', '', '72', ''], ['50', '56', '74', ''], ['54', '65', '76', '']]\", \"28\", \"78\"]"}
{"diff_sorted_id": "71", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 28 to 64. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 218, 203, None for columns 1 to 2 respectively, and the sums of rows must be None, 186, 174, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 221. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['55' 'x' '53' 'x']\n ['x' '50' '52' 'x']\n ['x' 'x' 'x' '35']\n ['x' '62' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 1, 43], [0, 3, 45], [1, 0, 30], [1, 3, 54], [2, 0, 29], [2, 1, 63], [2, 2, 47], [3, 0, 61], [3, 2, 51], [3, 3, 28]]", "opt_solution_cost": "758", "opt_solution_compute_t": "77.56224489212036", "solution_depth": "10", "max_successor_states": "26", "num_vars_per_state": "16", "is_feasible_args": "[\"[['55', '', '53', ''], ['', '50', '52', ''], ['', '', '', '35'], ['', '62', '', '']]\", 4, 28, 64]", "is_correct_args": "[\"[['55', '', '53', ''], ['', '50', '52', ''], ['', '', '', '35'], ['', '62', '', '']]\", 28, 64, [1, 3], [1, 3], [218, 203], [186, 174], 221]", "A*_args": "[\"[['55', '', '53', ''], ['', '50', '52', ''], ['', '', '', '35'], ['', '62', '', '']]\", \"28\", \"64\", \"[None, 218, 203, None]\", \"[None, 186, 174, None]\", \"221\"]"}
{"diff_sorted_id": "71", "problem_statement": "In 'Restricted Sorting', there are 10 stacks each with a capacity of 6 blocks, with 5 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 5 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 4, 1: 1, 2: 1, 3: 9, 4: 2, 5: 9, 6: 1, 7: 9, 8: 6, 9: 4}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], ['White', 'Yellow', 'Yellow', 'Green', 'Blue', 'Green'], ['Red', 'Yellow', 'White', 'Blue', 'Black', 'Black'], ['Black', 'Red', 'Blue', 'Black', 'Green', 'Green'], ['Green', 'Black', 'Yellow', 'Red', 'White', 'Red'], ['White', 'Blue', 'Red', 'Blue', 'White', 'Yellow'], [], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "3", "opt_solution": "[[2, 8], [6, 8], [3, 0], [6, 9], [6, 0], [6, 9], [6, 8], [3, 6], [3, 8], [4, 1], [4, 0], [4, 9], [4, 1], [5, 4], [5, 1], [5, 6], [5, 0], [5, 8], [3, 9], [5, 0], [2, 6], [2, 6], [2, 4], [2, 9], [2, 4], [3, 1], [3, 1]]", "opt_solution_cost": "85", "opt_solution_compute_t": "78.48496198654175", "solution_depth": "27", "max_successor_states": "90", "num_vars_per_state": "30", "is_feasible_args": "[[[], [], [\"White\", \"Yellow\", \"Yellow\", \"Green\", \"Blue\", \"Green\"], [\"Red\", \"Yellow\", \"White\", \"Blue\", \"Black\", \"Black\"], [\"Black\", \"Red\", \"Blue\", \"Black\", \"Green\", \"Green\"], [\"Green\", \"Black\", \"Yellow\", \"Red\", \"White\", \"Red\"], [\"White\", \"Blue\", \"Red\", \"Blue\", \"White\", \"Yellow\"], [], [], []], 6, {\"0\": 4, \"1\": 1, \"2\": 1, \"3\": 9, \"4\": 2, \"5\": 9, \"6\": 1, \"7\": 9, \"8\": 6, \"9\": 4}]", "is_correct_args": "[[[], [], [\"White\", \"Yellow\", \"Yellow\", \"Green\", \"Blue\", \"Green\"], [\"Red\", \"Yellow\", \"White\", \"Blue\", \"Black\", \"Black\"], [\"Black\", \"Red\", \"Blue\", \"Black\", \"Green\", \"Green\"], [\"Green\", \"Black\", \"Yellow\", \"Red\", \"White\", \"Red\"], [\"White\", \"Blue\", \"Red\", \"Blue\", \"White\", \"Yellow\"], [], [], []], 6, {\"0\": 4, \"1\": 1, \"2\": 1, \"3\": 9, \"4\": 2, \"5\": 9, \"6\": 1, \"7\": 9, \"8\": 6, \"9\": 4}, 5]", "A*_args": "[\"[[], [], ['White', 'Yellow', 'Yellow', 'Green', 'Blue', 'Green'], ['Red', 'Yellow', 'White', 'Blue', 'Black', 'Black'], ['Black', 'Red', 'Blue', 'Black', 'Green', 'Green'], ['Green', 'Black', 'Yellow', 'Red', 'White', 'Red'], ['White', 'Blue', 'Red', 'Blue', 'White', 'Yellow'], [], [], []]\", \"{0: 4, 1: 1, 2: 1, 3: 9, 4: 2, 5: 9, 6: 1, 7: 9, 8: 6, 9: 4}\", \"6\", \"5\"]"}
{"diff_sorted_id": "71", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (6, 12) to his destination workshop at index (4, 1), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 4, district 2 covering rows 5 to 5, and district 3 covering rows 6 to 12. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 12 x x x 5 9 14 6 x 3 14 x]\n[x x 3 x 11 x 13 x x x x 9 8]\n[x 18 x x x 13 4 5 x x x 13 x]\n[10 4 x x x x x 18 x 15 x x x]\n[x 1 7 x 7 6 x 3 x 2 x x 5]\n[x 15 5 x x 10 x 19 x x x 10 6]\n[x 18 1 2 x 7 16 19 x x 10 8 8]\n[8 x x 6 2 x x x 7 11 5 11 2]\n[x 4 1 1 5 12 3 6 2 1 x 3 8]\n[x x 5 5 14 15 7 x x 11 x 7 9]\n[x 6 12 16 17 x x 4 x 19 9 5 x]\n[12 x 4 x 8 4 x 5 x x x 5 x]\n[x 5 x x x x x 7 x x 11 x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "5", "opt_solution": "[[6, 12], [7, 12], [7, 11], [7, 10], [7, 9], [8, 9], [8, 8], [8, 7], [8, 6], [8, 5], [8, 4], [8, 3], [7, 3], [6, 3], [6, 2], [5, 2], [4, 2], [4, 1]]", "opt_solution_cost": "81", "opt_solution_compute_t": "0.021131515502929688", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"12\", \"x\", \"x\", \"x\", \"5\", \"9\", \"14\", \"6\", \"x\", \"3\", \"14\", \"x\"], [\"x\", \"x\", \"3\", \"x\", \"11\", \"x\", \"13\", \"x\", \"x\", \"x\", \"x\", \"9\", \"8\"], [\"x\", \"18\", \"x\", \"x\", \"x\", \"13\", \"4\", \"5\", \"x\", \"x\", \"x\", \"13\", \"x\"], [\"10\", \"4\", \"x\", \"x\", \"x\", \"x\", \"x\", \"18\", \"x\", \"15\", \"x\", \"x\", \"x\"], [\"x\", \"1\", \"7\", \"x\", \"7\", \"6\", \"x\", \"3\", \"x\", \"2\", \"x\", \"x\", \"5\"], [\"x\", \"15\", \"5\", \"x\", \"x\", \"10\", \"x\", \"19\", \"x\", \"x\", \"x\", \"10\", \"6\"], [\"x\", \"18\", \"1\", \"2\", \"x\", \"7\", \"16\", \"19\", \"x\", \"x\", \"10\", \"8\", \"8\"], [\"8\", \"x\", \"x\", \"6\", \"2\", \"x\", \"x\", \"x\", \"7\", \"11\", \"5\", \"11\", \"2\"], [\"x\", \"4\", \"1\", \"1\", \"5\", \"12\", \"3\", \"6\", \"2\", \"1\", \"x\", \"3\", \"8\"], [\"x\", \"x\", \"5\", \"5\", \"14\", \"15\", \"7\", \"x\", \"x\", \"11\", \"x\", \"7\", \"9\"], [\"x\", \"6\", \"12\", \"16\", \"17\", \"x\", \"x\", \"4\", \"x\", \"19\", \"9\", \"5\", \"x\"], [\"12\", \"x\", \"4\", \"x\", \"8\", \"4\", \"x\", \"5\", \"x\", \"x\", \"x\", \"5\", \"x\"], [\"x\", \"5\", \"x\", \"x\", \"x\", \"x\", \"x\", \"7\", \"x\", \"x\", \"11\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"12\", \"x\", \"x\", \"x\", \"5\", \"9\", \"14\", \"6\", \"x\", \"3\", \"14\", \"x\"], [\"x\", \"x\", \"3\", \"x\", \"11\", \"x\", \"13\", \"x\", \"x\", \"x\", \"x\", \"9\", \"8\"], [\"x\", \"18\", \"x\", \"x\", \"x\", \"13\", \"4\", \"5\", \"x\", \"x\", \"x\", \"13\", \"x\"], [\"10\", \"4\", \"x\", \"x\", \"x\", \"x\", \"x\", \"18\", \"x\", \"15\", \"x\", \"x\", \"x\"], [\"x\", \"1\", \"7\", \"x\", \"7\", \"6\", \"x\", \"3\", \"x\", \"2\", \"x\", \"x\", \"5\"], [\"x\", \"15\", \"5\", \"x\", \"x\", \"10\", \"x\", \"19\", \"x\", \"x\", \"x\", \"10\", \"6\"], [\"x\", \"18\", \"1\", \"2\", \"x\", \"7\", \"16\", \"19\", \"x\", \"x\", \"10\", \"8\", \"8\"], [\"8\", \"x\", \"x\", \"6\", \"2\", \"x\", \"x\", \"x\", \"7\", \"11\", \"5\", \"11\", \"2\"], [\"x\", \"4\", \"1\", \"1\", \"5\", \"12\", \"3\", \"6\", \"2\", \"1\", \"x\", \"3\", \"8\"], [\"x\", \"x\", \"5\", \"5\", \"14\", \"15\", \"7\", \"x\", \"x\", \"11\", \"x\", \"7\", \"9\"], [\"x\", \"6\", \"12\", \"16\", \"17\", \"x\", \"x\", \"4\", \"x\", \"19\", \"9\", \"5\", \"x\"], [\"12\", \"x\", \"4\", \"x\", \"8\", \"4\", \"x\", \"5\", \"x\", \"x\", \"x\", \"5\", \"x\"], [\"x\", \"5\", \"x\", \"x\", \"x\", \"x\", \"x\", \"7\", \"x\", \"x\", \"11\", \"x\", \"x\"]], [6, 12], [4, 1], 4, 5]", "A*_args": "[\"[['x', '12', 'x', 'x', 'x', '5', '9', '14', '6', 'x', '3', '14', 'x'], ['x', 'x', '3', 'x', '11', 'x', '13', 'x', 'x', 'x', 'x', '9', '8'], ['x', '18', 'x', 'x', 'x', '13', '4', '5', 'x', 'x', 'x', '13', 'x'], ['10', '4', 'x', 'x', 'x', 'x', 'x', '18', 'x', '15', 'x', 'x', 'x'], ['x', '1', '7', 'x', '7', '6', 'x', '3', 'x', '2', 'x', 'x', '5'], ['x', '15', '5', 'x', 'x', '10', 'x', '19', 'x', 'x', 'x', '10', '6'], ['x', '18', '1', '2', 'x', '7', '16', '19', 'x', 'x', '10', '8', '8'], ['8', 'x', 'x', '6', '2', 'x', 'x', 'x', '7', '11', '5', '11', '2'], ['x', '4', '1', '1', '5', '12', '3', '6', '2', '1', 'x', '3', '8'], ['x', 'x', '5', '5', '14', '15', '7', 'x', 'x', '11', 'x', '7', '9'], ['x', '6', '12', '16', '17', 'x', 'x', '4', 'x', '19', '9', '5', 'x'], ['12', 'x', '4', 'x', '8', '4', 'x', '5', 'x', 'x', 'x', '5', 'x'], ['x', '5', 'x', 'x', 'x', 'x', 'x', '7', 'x', 'x', '11', 'x', 'x']]\", \"(6, 12)\", \"(4, 1)\", \"4\", \"5\"]"}
{"diff_sorted_id": "71", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 13x13. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (12, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (1, 6). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 1 0 1 1 1 0 1 0 0 1\n1 1 1 0 0 0 0 1 1 0 0 1 1\n1 0 0 0 0 0 0 0 0 0 1 0 1\n1 1 1 0 1 0 0 1 0 1 1 0 0\n0 1 0 1 0 1 0 1 0 0 0 0 0\n1 1 1 0 0 1 0 0 1 0 1 1 0\n0 1 1 1 1 1 0 1 0 0 1 0 1\n1 0 1 1 1 1 0 0 1 1 0 1 1\n0 0 0 0 0 0 0 0 1 0 1 1 1\n0 0 0 0 0 0 0 0 0 0 1 0 1\n0 0 1 1 0 1 0 1 1 0 1 0 1\n0 0 1 1 0 0 0 0 1 1 0 0 0\n0 1 1 0 1 1 1 0 1 1 0 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[[12, 0], [11, 0], [10, 1], [9, 2], [8, 3], [8, 4], [8, 5], [7, 6], [6, 6], [5, 6], [4, 6], [3, 6], [2, 6], [1, 6]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.024829626083374023", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0], [0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1], [1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0]]\", 4]", "is_correct_args": "[\"[[1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0], [0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1], [1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0]]\", [12, 0], [1, 6], 4]", "A*_args": "[\"[[1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0], [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0], [0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1], [1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0]]\", \"(12, 0)\", \"(1, 6)\", \"4\"]"}
{"diff_sorted_id": "71", "problem_statement": "Given 5 labeled water jugs with capacities 141, 92, 12, 77, 49, 140 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 304, 333, 349, 413 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 77, 4], [\"+\", 92, 4], [\"+\", 92, 4], [\"+\", 140, 4], [\"+\", 12, 4], [\"+\", 12, 3], [\"+\", 92, 3], [\"+\", 92, 3], [\"+\", 12, 3], [\"+\", 141, 3], [\"+\", 77, 2], [\"+\", 140, 2], [\"+\", 12, 2], [\"+\", 12, 2], [\"+\", 92, 2], [\"+\", 12, 1], [\"+\", 140, 1], [\"+\", 140, 1], [\"+\", 12, 1]]", "opt_solution_cost": "19", "opt_solution_compute_t": "0.04270505905151367", "solution_depth": "19", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[141, 92, 12, 77, 49, 140], [304, 333, 349, 413]]", "is_correct_args": "[[141, 92, 12, 77, 49, 140], [304, 333, 349, 413]]", "A*_args": "[\"[141, 92, 12, 77, 49, 140]\", \"[304, 333, 349, 413]\"]"}
{"diff_sorted_id": "72", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [['_', 92, 90, 50, 40], [52, 39, 31, 83, 16], [36, 56, 51, 70, 49]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[52, 39, 56, 51, 31, 56, 51, 36, 39, 52, 92, 90, 50, 83, 56, 50, 83, 56, 70, 49, 16, 40, 56, 70, 49, 16]", "opt_solution_cost": "26", "opt_solution_compute_t": "0.03201866149902344", "solution_depth": "26", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[\"_\", 92, 90, 50, 40], [52, 39, 31, 83, 16], [36, 56, 51, 70, 49]]]", "is_correct_args": "[[[\"_\", 92, 90, 50, 40], [52, 39, 31, 83, 16], [36, 56, 51, 70, 49]]]", "A*_args": "[\"[['_', 92, 90, 50, 40], [52, 39, 31, 83, 16], [36, 56, 51, 70, 49]]\"]"}
{"diff_sorted_id": "72", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: lit, poor, kirk, cake, slam   The initial board: [['o', 'l', '_', 't'], ['p', 'r', 'o', 'a'], ['e', 'i', 'k', 'k'], ['c', 'i', 'k', 'a'], ['s', 'l', 'r', 'm']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "2", "opt_solution": "[\"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.3410513401031494", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "20", "is_feasible_args": "[[[\"o\", \"l\", \"_\", \"t\"], [\"p\", \"r\", \"o\", \"a\"], [\"e\", \"i\", \"k\", \"k\"], [\"c\", \"i\", \"k\", \"a\"], [\"s\", \"l\", \"r\", \"m\"]]]", "is_correct_args": "[[[\"o\", \"l\", \"_\", \"t\"], [\"p\", \"r\", \"o\", \"a\"], [\"e\", \"i\", \"k\", \"k\"], [\"c\", \"i\", \"k\", \"a\"], [\"s\", \"l\", \"r\", \"m\"]], [\"lit\", \"poor\", \"kirk\", \"cake\", \"slam\"]]", "A*_args": "[\"[['o', 'l', '_', 't'], ['p', 'r', 'o', 'a'], ['e', 'i', 'k', 'k'], ['c', 'i', 'k', 'a'], ['s', 'l', 'r', 'm']]\", \"['lit', 'poor', 'kirk', 'cake', 'slam']\"]"}
{"diff_sorted_id": "72", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'Q'. Our task is to visit city M and city L excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from L and M, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  F Z M Q I V L C J D N E B O \nF 0 1 1 1 0 0 0 0 1 0 1 0 0 0 \nZ 0 0 0 1 0 0 0 0 0 0 0 1 0 1 \nM 0 1 0 0 0 0 0 1 1 0 1 1 1 0 \nQ 0 0 0 0 0 0 0 1 0 1 0 0 0 0 \nI 0 0 0 0 0 0 1 0 0 1 0 0 0 0 \nV 1 0 0 0 0 0 0 0 0 1 0 0 0 0 \nL 0 1 0 1 0 1 0 0 0 0 0 0 0 0 \nC 1 1 0 0 0 0 0 0 1 1 0 0 1 0 \nJ 0 1 0 1 0 0 1 0 0 1 0 0 1 1 \nD 1 0 1 0 0 1 0 0 0 0 1 0 0 0 \nN 0 0 0 0 1 1 1 0 0 0 0 1 0 0 \nE 0 0 0 0 1 1 1 1 0 0 0 0 0 0 \nB 1 1 1 1 1 0 1 0 0 0 1 1 0 0 \nO 0 0 1 0 0 1 1 0 0 1 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[\"Q\", \"D\", \"M\", \"B\", \"L\", \"V\", \"F\", \"M\", \"E\", \"L\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.07921767234802246", "solution_depth": "10", "max_successor_states": "14", "num_vars_per_state": "17", "is_feasible_args": "[[[0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0], [0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1], [1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0]], [\"F\", \"Z\", \"M\", \"Q\", \"I\", \"V\", \"L\", \"C\", \"J\", \"D\", \"N\", \"E\", \"B\", \"O\"], \"M\", \"L\"]", "is_correct_args": "[[[0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0], [0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1], [1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0]], [\"F\", \"Z\", \"M\", \"Q\", \"I\", \"V\", \"L\", \"C\", \"J\", \"D\", \"N\", \"E\", \"B\", \"O\"], \"Q\", \"M\", \"L\"]", "A*_args": "[\"[[0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0], [0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1], [1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0]]\", \"['F', 'Z', 'M', 'Q', 'I', 'V', 'L', 'C', 'J', 'D', 'N', 'E', 'B', 'O']\", \"['Q']\", \"['M', 'L']\"]"}
{"diff_sorted_id": "72", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [13, 3, 34, 36, 19, 31, 6, 7, 10, 24, 92, 3, 24, 33, 33, 22, 93, 13, 17, 28, 25, 16, 21, 16, 20, 26, 24, 16, 11, 18, 2, 30, 25, 23, 28, 21], such that the sum of the chosen coins adds up to 384. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {3: 1, 23: 1, 34: 8, 17: 14, 20: 16, 11: 5, 28: 7, 13: 3, 22: 19, 16: 4, 26: 20, 93: 7, 31: 11, 6: 2, 36: 12, 33: 15, 18: 1, 19: 2, 7: 7, 21: 7, 10: 9, 24: 11, 30: 4, 25: 7, 2: 2, 92: 19}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "23", "opt_solution": "[18, 19, 16, 23, 93, 92, 34, 30, 28, 6, 25]", "opt_solution_cost": "62", "opt_solution_compute_t": "0.052675724029541016", "solution_depth": "11", "max_successor_states": "36", "num_vars_per_state": "36", "is_feasible_args": "[[13, 3, 34, 36, 19, 31, 6, 7, 10, 24, 92, 3, 24, 33, 33, 22, 93, 13, 17, 28, 25, 16, 21, 16, 20, 26, 24, 16, 11, 18, 2, 30, 25, 23, 28, 21]]", "is_correct_args": "[[13, 3, 34, 36, 19, 31, 6, 7, 10, 24, 92, 3, 24, 33, 33, 22, 93, 13, 17, 28, 25, 16, 21, 16, 20, 26, 24, 16, 11, 18, 2, 30, 25, 23, 28, 21], {\"3\": 1, \"23\": 1, \"34\": 8, \"17\": 14, \"20\": 16, \"11\": 5, \"28\": 7, \"13\": 3, \"22\": 19, \"16\": 4, \"26\": 20, \"93\": 7, \"31\": 11, \"6\": 2, \"36\": 12, \"33\": 15, \"18\": 1, \"19\": 2, \"7\": 7, \"21\": 7, \"10\": 9, \"24\": 11, \"30\": 4, \"25\": 7, \"2\": 2, \"92\": 19}, 384]", "A*_args": "[\"[13, 3, 34, 36, 19, 31, 6, 7, 10, 24, 92, 3, 24, 33, 33, 22, 93, 13, 17, 28, 25, 16, 21, 16, 20, 26, 24, 16, 11, 18, 2, 30, 25, 23, 28, 21]\", \"{3: 1, 23: 1, 34: 8, 17: 14, 20: 16, 11: 5, 28: 7, 13: 3, 22: 19, 16: 4, 26: 20, 93: 7, 31: 11, 6: 2, 36: 12, 33: 15, 18: 1, 19: 2, 7: 7, 21: 7, 10: 9, 24: 11, 30: 4, 25: 7, 2: 2, 92: 19}\", \"384\"]"}
{"diff_sorted_id": "72", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Red', 'Blue', 'Green', 'Red'], ['Blue', 'Green', 'Green', 'Red', 'Red'], ['Blue', 'Blue', 'Green', 'Green', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[1, 0], [2, 0], [2, 0], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 1], [0, 1], [0, 2], [1, 2], [0, 1], [0, 2], [1, 0], [1, 2], [1, 0], [1, 0], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1]]", "opt_solution_cost": "23", "opt_solution_compute_t": "30.480061292648315", "solution_depth": "23", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Red\", \"Red\", \"Blue\", \"Green\", \"Red\"], [\"Blue\", \"Green\", \"Green\", \"Red\", \"Red\"], [\"Blue\", \"Blue\", \"Green\", \"Green\", \"Blue\"]], 8]", "is_correct_args": "[[[\"Red\", \"Red\", \"Blue\", \"Green\", \"Red\"], [\"Blue\", \"Green\", \"Green\", \"Red\", \"Red\"], [\"Blue\", \"Blue\", \"Green\", \"Green\", \"Blue\"]], 8]", "A*_args": "[\"[['Red', 'Red', 'Blue', 'Green', 'Red'], ['Blue', 'Green', 'Green', 'Red', 'Red'], ['Blue', 'Blue', 'Green', 'Green', 'Blue']]\", \"8\"]"}
{"diff_sorted_id": "72", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 9 to 54 (9 included in the range but 54 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['24' 'x' 'x' '53']\n ['25' '31' 'x' 'x']\n ['26' '29' '31' 'x']\n ['x' 'x' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "14", "opt_solution": "[[0, 1, 26], [0, 2, 27], [1, 3, 59], [2, 1, 47], [2, 3, 60], [3, 1, 48]]", "opt_solution_cost": "577", "opt_solution_compute_t": "5.510742425918579", "solution_depth": "6", "max_successor_states": "45", "num_vars_per_state": "16", "is_feasible_args": "[\"[['25', '', '', '57'], ['39', '45', '56', ''], ['43', '', '58', ''], ['46', '', '65', '69']]\", 21, 71]", "is_correct_args": "[\"[['25', '', '', '57'], ['39', '45', '56', ''], ['43', '', '58', ''], ['46', '', '65', '69']]\", 21, 71]", "A*_args": "[\"[['25', '', '', '57'], ['39', '45', '56', ''], ['43', '', '58', ''], ['46', '', '65', '69']]\", \"21\", \"71\"]"}
{"diff_sorted_id": "72", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 28 to 64. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 157, 200, None for columns 1 to 2 respectively, and the sums of rows must be None, 193, 158, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 183. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' '60' '63']\n ['35' 'x' 'x' 'x']\n ['x' 'x' 'x' '50']\n ['34' 'x' '37' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 0, 28], [0, 1, 32], [1, 1, 62], [1, 2, 56], [1, 3, 40], [2, 0, 31], [2, 1, 30], [2, 2, 47], [3, 1, 33], [3, 3, 29]]", "opt_solution_cost": "667", "opt_solution_compute_t": "42.7963764667511", "solution_depth": "10", "max_successor_states": "26", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '60', '63'], ['35', '', '', ''], ['', '', '', '50'], ['34', '', '37', '']]\", 4, 28, 64]", "is_correct_args": "[\"[['', '', '60', '63'], ['35', '', '', ''], ['', '', '', '50'], ['34', '', '37', '']]\", 28, 64, [1, 3], [1, 3], [157, 200], [193, 158], 183]", "A*_args": "[\"[['', '', '60', '63'], ['35', '', '', ''], ['', '', '', '50'], ['34', '', '37', '']]\", \"28\", \"64\", \"[None, 157, 200, None]\", \"[None, 193, 158, None]\", \"183\"]"}
{"diff_sorted_id": "72", "problem_statement": "In 'Restricted Sorting', there are 10 stacks each with a capacity of 6 blocks, with 5 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 5 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 3, 1: 10, 2: 9, 3: 8, 4: 8, 5: 7, 6: 6, 7: 9, 8: 2, 9: 8}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], ['Blue', 'Blue', 'Blue', 'Green', 'Black', 'Red'], [], ['Red', 'Black', 'Blue', 'White', 'Blue', 'Yellow'], ['Yellow', 'White', 'Green', 'Black', 'Yellow', 'Red'], [], [], ['White', 'Black', 'White', 'White', 'Black', 'Red'], ['Red', 'Green', 'Green', 'Yellow', 'Yellow', 'Green']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "3", "opt_solution": "[[4, 0], [9, 0], [4, 3], [8, 6], [8, 3], [8, 6], [8, 6], [8, 3], [8, 0], [5, 8], [5, 6], [5, 7], [5, 3], [5, 8], [5, 0], [4, 5], [4, 6], [4, 5], [2, 5], [2, 5], [2, 5], [2, 7], [2, 1], [9, 7], [9, 7], [9, 4], [9, 4], [9, 7], [1, 3], [2, 0], [4, 8], [4, 8], [4, 8]]", "opt_solution_cost": "201", "opt_solution_compute_t": "0.46176815032958984", "solution_depth": "33", "max_successor_states": "90", "num_vars_per_state": "30", "is_feasible_args": "[[[], [], [\"Blue\", \"Blue\", \"Blue\", \"Green\", \"Black\", \"Red\"], [], [\"Red\", \"Black\", \"Blue\", \"White\", \"Blue\", \"Yellow\"], [\"Yellow\", \"White\", \"Green\", \"Black\", \"Yellow\", \"Red\"], [], [], [\"White\", \"Black\", \"White\", \"White\", \"Black\", \"Red\"], [\"Red\", \"Green\", \"Green\", \"Yellow\", \"Yellow\", \"Green\"]], 6, {\"0\": 3, \"1\": 10, \"2\": 9, \"3\": 8, \"4\": 8, \"5\": 7, \"6\": 6, \"7\": 9, \"8\": 2, \"9\": 8}]", "is_correct_args": "[[[], [], [\"Blue\", \"Blue\", \"Blue\", \"Green\", \"Black\", \"Red\"], [], [\"Red\", \"Black\", \"Blue\", \"White\", \"Blue\", \"Yellow\"], [\"Yellow\", \"White\", \"Green\", \"Black\", \"Yellow\", \"Red\"], [], [], [\"White\", \"Black\", \"White\", \"White\", \"Black\", \"Red\"], [\"Red\", \"Green\", \"Green\", \"Yellow\", \"Yellow\", \"Green\"]], 6, {\"0\": 3, \"1\": 10, \"2\": 9, \"3\": 8, \"4\": 8, \"5\": 7, \"6\": 6, \"7\": 9, \"8\": 2, \"9\": 8}, 5]", "A*_args": "[\"[[], [], ['Blue', 'Blue', 'Blue', 'Green', 'Black', 'Red'], [], ['Red', 'Black', 'Blue', 'White', 'Blue', 'Yellow'], ['Yellow', 'White', 'Green', 'Black', 'Yellow', 'Red'], [], [], ['White', 'Black', 'White', 'White', 'Black', 'Red'], ['Red', 'Green', 'Green', 'Yellow', 'Yellow', 'Green']]\", \"{0: 3, 1: 10, 2: 9, 3: 8, 4: 8, 5: 7, 6: 6, 7: 9, 8: 2, 9: 8}\", \"6\", \"5\"]"}
{"diff_sorted_id": "72", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (6, 12) to his destination workshop at index (5, 0), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 5, and district 3 covering rows 6 to 12. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x x x 9 1 14 x x x 11 15 12]\n[2 x 18 x 14 x 11 3 x x x x x]\n[10 x 3 x x x 8 6 x 10 9 7 x]\n[1 18 2 6 x x 1 5 x x 6 x x]\n[4 14 12 3 2 2 15 8 19 3 18 x x]\n[5 6 2 2 13 x 7 3 12 x 16 10 5]\n[x 2 13 x x 9 5 x x x 7 10 11]\n[17 10 3 11 4 x x 19 x 5 x x 9]\n[13 x x x x 9 13 4 7 x 13 10 x]\n[x x x 9 x 8 8 14 x x 19 x x]\n[6 x x x x x 1 11 x 4 13 x x]\n[x x x 11 11 x 9 16 12 x 6 x 5]\n[16 19 14 x 5 13 x x x x x 13 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "5", "opt_solution": "[[6, 12], [5, 12], [5, 11], [5, 10], [4, 10], [4, 9], [4, 8], [4, 7], [3, 7], [3, 6], [4, 6], [4, 5], [4, 4], [4, 3], [5, 3], [5, 2], [5, 1], [5, 0]]", "opt_solution_cost": "122", "opt_solution_compute_t": "0.020214080810546875", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"x\", \"x\", \"9\", \"1\", \"14\", \"x\", \"x\", \"x\", \"11\", \"15\", \"12\"], [\"2\", \"x\", \"18\", \"x\", \"14\", \"x\", \"11\", \"3\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"10\", \"x\", \"3\", \"x\", \"x\", \"x\", \"8\", \"6\", \"x\", \"10\", \"9\", \"7\", \"x\"], [\"1\", \"18\", \"2\", \"6\", \"x\", \"x\", \"1\", \"5\", \"x\", \"x\", \"6\", \"x\", \"x\"], [\"4\", \"14\", \"12\", \"3\", \"2\", \"2\", \"15\", \"8\", \"19\", \"3\", \"18\", \"x\", \"x\"], [\"5\", \"6\", \"2\", \"2\", \"13\", \"x\", \"7\", \"3\", \"12\", \"x\", \"16\", \"10\", \"5\"], [\"x\", \"2\", \"13\", \"x\", \"x\", \"9\", \"5\", \"x\", \"x\", \"x\", \"7\", \"10\", \"11\"], [\"17\", \"10\", \"3\", \"11\", \"4\", \"x\", \"x\", \"19\", \"x\", \"5\", \"x\", \"x\", \"9\"], [\"13\", \"x\", \"x\", \"x\", \"x\", \"9\", \"13\", \"4\", \"7\", \"x\", \"13\", \"10\", \"x\"], [\"x\", \"x\", \"x\", \"9\", \"x\", \"8\", \"8\", \"14\", \"x\", \"x\", \"19\", \"x\", \"x\"], [\"6\", \"x\", \"x\", \"x\", \"x\", \"x\", \"1\", \"11\", \"x\", \"4\", \"13\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"11\", \"11\", \"x\", \"9\", \"16\", \"12\", \"x\", \"6\", \"x\", \"5\"], [\"16\", \"19\", \"14\", \"x\", \"5\", \"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"13\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"x\", \"x\", \"9\", \"1\", \"14\", \"x\", \"x\", \"x\", \"11\", \"15\", \"12\"], [\"2\", \"x\", \"18\", \"x\", \"14\", \"x\", \"11\", \"3\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"10\", \"x\", \"3\", \"x\", \"x\", \"x\", \"8\", \"6\", \"x\", \"10\", \"9\", \"7\", \"x\"], [\"1\", \"18\", \"2\", \"6\", \"x\", \"x\", \"1\", \"5\", \"x\", \"x\", \"6\", \"x\", \"x\"], [\"4\", \"14\", \"12\", \"3\", \"2\", \"2\", \"15\", \"8\", \"19\", \"3\", \"18\", \"x\", \"x\"], [\"5\", \"6\", \"2\", \"2\", \"13\", \"x\", \"7\", \"3\", \"12\", \"x\", \"16\", \"10\", \"5\"], [\"x\", \"2\", \"13\", \"x\", \"x\", \"9\", \"5\", \"x\", \"x\", \"x\", \"7\", \"10\", \"11\"], [\"17\", \"10\", \"3\", \"11\", \"4\", \"x\", \"x\", \"19\", \"x\", \"5\", \"x\", \"x\", \"9\"], [\"13\", \"x\", \"x\", \"x\", \"x\", \"9\", \"13\", \"4\", \"7\", \"x\", \"13\", \"10\", \"x\"], [\"x\", \"x\", \"x\", \"9\", \"x\", \"8\", \"8\", \"14\", \"x\", \"x\", \"19\", \"x\", \"x\"], [\"6\", \"x\", \"x\", \"x\", \"x\", \"x\", \"1\", \"11\", \"x\", \"4\", \"13\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"11\", \"11\", \"x\", \"9\", \"16\", \"12\", \"x\", \"6\", \"x\", \"5\"], [\"16\", \"19\", \"14\", \"x\", \"5\", \"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"13\", \"x\"]], [6, 12], [5, 0], 3, 5]", "A*_args": "[\"[['x', 'x', 'x', 'x', '9', '1', '14', 'x', 'x', 'x', '11', '15', '12'], ['2', 'x', '18', 'x', '14', 'x', '11', '3', 'x', 'x', 'x', 'x', 'x'], ['10', 'x', '3', 'x', 'x', 'x', '8', '6', 'x', '10', '9', '7', 'x'], ['1', '18', '2', '6', 'x', 'x', '1', '5', 'x', 'x', '6', 'x', 'x'], ['4', '14', '12', '3', '2', '2', '15', '8', '19', '3', '18', 'x', 'x'], ['5', '6', '2', '2', '13', 'x', '7', '3', '12', 'x', '16', '10', '5'], ['x', '2', '13', 'x', 'x', '9', '5', 'x', 'x', 'x', '7', '10', '11'], ['17', '10', '3', '11', '4', 'x', 'x', '19', 'x', '5', 'x', 'x', '9'], ['13', 'x', 'x', 'x', 'x', '9', '13', '4', '7', 'x', '13', '10', 'x'], ['x', 'x', 'x', '9', 'x', '8', '8', '14', 'x', 'x', '19', 'x', 'x'], ['6', 'x', 'x', 'x', 'x', 'x', '1', '11', 'x', '4', '13', 'x', 'x'], ['x', 'x', 'x', '11', '11', 'x', '9', '16', '12', 'x', '6', 'x', '5'], ['16', '19', '14', 'x', '5', '13', 'x', 'x', 'x', 'x', 'x', '13', 'x']]\", \"(6, 12)\", \"(5, 0)\", \"3\", \"5\"]"}
{"diff_sorted_id": "72", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 13x13. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (8, 12) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (1, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 0 1 0 0 0 1 1 1 0 0 1\n0 0 0 0 0 1 0 0 0 1 1 0 1\n0 1 0 0 1 0 0 0 0 0 1 0 1\n1 1 1 1 1 0 0 1 0 0 1 1 1\n0 0 0 0 1 0 0 0 1 0 0 0 0\n0 1 0 1 0 1 1 1 0 1 0 1 0\n1 0 1 1 1 0 0 0 1 1 0 0 0\n0 0 0 0 1 0 0 1 1 0 0 0 0\n0 0 0 0 0 0 0 1 1 1 0 0 0\n1 1 1 0 1 0 1 0 1 1 1 0 1\n1 0 0 1 1 1 0 1 1 0 0 1 1\n1 0 0 1 1 1 1 0 1 1 1 1 0\n1 0 1 1 0 1 0 0 1 1 0 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[[8, 12], [7, 11], [6, 10], [5, 10], [4, 9], [3, 9], [3, 8], [2, 8], [2, 7], [2, 6], [2, 5], [1, 4], [1, 3], [1, 2], [1, 1]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.02518010139465332", "solution_depth": "15", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1], [1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0], [1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1]]\", 4]", "is_correct_args": "[\"[[0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1], [1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0], [1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1]]\", [8, 12], [1, 1], 4]", "A*_args": "[\"[[0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1], [1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0], [1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1]]\", \"(8, 12)\", \"(1, 1)\", \"4\"]"}
{"diff_sorted_id": "72", "problem_statement": "Given 5 labeled water jugs with capacities 57, 98, 149, 99, 105, 28 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 281, 401, 423, 427 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "5", "opt_solution": "[[\"+\", 98, 4], [\"+\", 98, 4], [\"+\", 98, 4], [\"+\", 105, 4], [\"+\", 28, 4], [\"+\", 98, 3], [\"+\", 99, 3], [\"+\", 99, 3], [\"+\", 99, 3], [\"+\", 28, 3], [\"+\", 98, 2], [\"+\", 99, 2], [\"+\", 99, 2], [\"+\", 105, 2], [\"+\", 28, 1], [\"+\", 98, 1], [\"+\", 98, 1], [\"+\", 57, 1]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.04359149932861328", "solution_depth": "18", "max_successor_states": "48", "num_vars_per_state": "3", "is_feasible_args": "[[57, 98, 149, 99, 105, 28], [281, 401, 423, 427]]", "is_correct_args": "[[57, 98, 149, 99, 105, 28], [281, 401, 423, 427]]", "A*_args": "[\"[57, 98, 149, 99, 105, 28]\", \"[281, 401, 423, 427]\"]"}
{"diff_sorted_id": "73", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[96, 93, '_', 26, 66], [46, 59, 38, 92, 50], [27, 7, 39, 77, 18]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[26, 92, 50, 18, 77, 39, 38, 59, 46, 96, 93, 46, 59, 26, 46, 93, 96, 59, 26, 50, 18, 77, 39, 38, 7, 26, 50, 18, 77, 39, 38, 7, 18, 46, 92, 77, 39, 38]", "opt_solution_cost": "38", "opt_solution_compute_t": "20.599369525909424", "solution_depth": "38", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[96, 93, \"_\", 26, 66], [46, 59, 38, 92, 50], [27, 7, 39, 77, 18]]]", "is_correct_args": "[[[96, 93, \"_\", 26, 66], [46, 59, 38, 92, 50], [27, 7, 39, 77, 18]]]", "A*_args": "[\"[[96, 93, '_', 26, 66], [46, 59, 38, 92, 50], [27, 7, 39, 77, 18]]\"]"}
{"diff_sorted_id": "73", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: trag, hoped, shelf, neath, farse   The initial board: [['o', 't', 'f', 'a', 'g'], ['h', 'r', 'p', 'r', 'd'], ['s', 'h', '_', 'l', 't'], ['n', 'e', 'a', 'e', 'h'], ['f', 'a', 'e', 's', 'e']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.3264577388763428", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"o\", \"t\", \"f\", \"a\", \"g\"], [\"h\", \"r\", \"p\", \"r\", \"d\"], [\"s\", \"h\", \"_\", \"l\", \"t\"], [\"n\", \"e\", \"a\", \"e\", \"h\"], [\"f\", \"a\", \"e\", \"s\", \"e\"]]]", "is_correct_args": "[[[\"o\", \"t\", \"f\", \"a\", \"g\"], [\"h\", \"r\", \"p\", \"r\", \"d\"], [\"s\", \"h\", \"_\", \"l\", \"t\"], [\"n\", \"e\", \"a\", \"e\", \"h\"], [\"f\", \"a\", \"e\", \"s\", \"e\"]], [\"trag\", \"hoped\", \"shelf\", \"neath\", \"farse\"]]", "A*_args": "[\"[['o', 't', 'f', 'a', 'g'], ['h', 'r', 'p', 'r', 'd'], ['s', 'h', '_', 'l', 't'], ['n', 'e', 'a', 'e', 'h'], ['f', 'a', 'e', 's', 'e']]\", \"['trag', 'hoped', 'shelf', 'neath', 'farse']\"]"}
{"diff_sorted_id": "73", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'Y'. Our task is to visit city S and city K excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from K and S, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  K N S Y O I T D M Z R B E F \nK 0 1 0 0 0 1 0 1 0 0 1 0 0 1 \nN 0 0 0 0 0 0 0 0 1 0 0 1 0 0 \nS 0 0 0 0 1 0 0 0 0 0 1 1 0 0 \nY 0 0 0 0 0 0 0 0 0 0 1 0 0 0 \nO 1 0 0 0 0 0 0 0 0 1 0 0 0 0 \nI 1 0 0 0 1 0 1 0 0 0 0 0 1 0 \nT 0 0 0 1 0 0 0 1 0 1 0 0 0 1 \nD 1 0 0 0 0 1 1 0 0 1 0 0 0 0 \nM 1 0 1 1 0 1 0 0 0 1 0 0 0 0 \nZ 0 0 0 0 1 1 0 0 0 0 1 0 0 0 \nR 0 1 0 0 0 0 0 1 0 0 0 0 1 0 \nB 1 0 0 1 1 1 1 0 0 1 0 0 1 0 \nE 1 0 0 0 0 0 1 0 1 1 0 0 0 1 \nF 0 0 1 1 0 1 0 0 0 0 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[\"Y\", \"R\", \"E\", \"M\", \"S\", \"B\", \"K\", \"F\", \"S\", \"O\", \"K\"]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.052919864654541016", "solution_depth": "11", "max_successor_states": "14", "num_vars_per_state": "17", "is_feasible_args": "[[[0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0]], [\"K\", \"N\", \"S\", \"Y\", \"O\", \"I\", \"T\", \"D\", \"M\", \"Z\", \"R\", \"B\", \"E\", \"F\"], \"S\", \"K\"]", "is_correct_args": "[[[0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0]], [\"K\", \"N\", \"S\", \"Y\", \"O\", \"I\", \"T\", \"D\", \"M\", \"Z\", \"R\", \"B\", \"E\", \"F\"], \"Y\", \"S\", \"K\"]", "A*_args": "[\"[[0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0], [1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0]]\", \"['K', 'N', 'S', 'Y', 'O', 'I', 'T', 'D', 'M', 'Z', 'R', 'B', 'E', 'F']\", \"['Y']\", \"['S', 'K']\"]"}
{"diff_sorted_id": "73", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [15, 2, 37, 38, 21, 30, 19, 28, 3, 35, 16, 32, 3, 28, 24, 27, 10, 1, 14, 3, 33, 6, 18, 37, 20, 19, 4, 31, 34, 39, 7, 13, 29, 38, 34, 14, 29, 13, 5, 33, 31, 24], such that the sum of the chosen coins adds up to 397. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {33: 10, 13: 12, 6: 1, 15: 2, 20: 15, 4: 3, 27: 7, 35: 5, 19: 18, 14: 13, 16: 4, 2: 2, 39: 19, 21: 18, 3: 2, 37: 14, 10: 1, 24: 3, 32: 2, 7: 4, 1: 1, 5: 4, 31: 4, 34: 7, 30: 8, 28: 11, 18: 9, 29: 2, 38: 1}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "24", "opt_solution": "[38, 32, 24, 29, 24, 10, 15, 29, 31, 31, 6, 27, 35, 34, 30, 2]", "opt_solution_cost": "54", "opt_solution_compute_t": "0.053344011306762695", "solution_depth": "16", "max_successor_states": "42", "num_vars_per_state": "42", "is_feasible_args": "[[15, 2, 37, 38, 21, 30, 19, 28, 3, 35, 16, 32, 3, 28, 24, 27, 10, 1, 14, 3, 33, 6, 18, 37, 20, 19, 4, 31, 34, 39, 7, 13, 29, 38, 34, 14, 29, 13, 5, 33, 31, 24]]", "is_correct_args": "[[15, 2, 37, 38, 21, 30, 19, 28, 3, 35, 16, 32, 3, 28, 24, 27, 10, 1, 14, 3, 33, 6, 18, 37, 20, 19, 4, 31, 34, 39, 7, 13, 29, 38, 34, 14, 29, 13, 5, 33, 31, 24], {\"33\": 10, \"13\": 12, \"6\": 1, \"15\": 2, \"20\": 15, \"4\": 3, \"27\": 7, \"35\": 5, \"19\": 18, \"14\": 13, \"16\": 4, \"2\": 2, \"39\": 19, \"21\": 18, \"3\": 2, \"37\": 14, \"10\": 1, \"24\": 3, \"32\": 2, \"7\": 4, \"1\": 1, \"5\": 4, \"31\": 4, \"34\": 7, \"30\": 8, \"28\": 11, \"18\": 9, \"29\": 2, \"38\": 1}, 397]", "A*_args": "[\"[15, 2, 37, 38, 21, 30, 19, 28, 3, 35, 16, 32, 3, 28, 24, 27, 10, 1, 14, 3, 33, 6, 18, 37, 20, 19, 4, 31, 34, 39, 7, 13, 29, 38, 34, 14, 29, 13, 5, 33, 31, 24]\", \"{33: 10, 13: 12, 6: 1, 15: 2, 20: 15, 4: 3, 27: 7, 35: 5, 19: 18, 14: 13, 16: 4, 2: 2, 39: 19, 21: 18, 3: 2, 37: 14, 10: 1, 24: 3, 32: 2, 7: 4, 1: 1, 5: 4, 31: 4, 34: 7, 30: 8, 28: 11, 18: 9, 29: 2, 38: 1}\", \"397\"]"}
{"diff_sorted_id": "73", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Red', 'Blue', 'Green'], ['Red', 'Blue', 'Green', 'Blue', 'Blue'], ['Green', 'Red', 'Red', 'Green', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[1, 0], [2, 1], [2, 0], [2, 0], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [0, 1], [0, 2], [0, 2], [1, 0], [1, 2], [1, 0], [1, 0], [1, 2], [1, 0], [2, 1], [2, 1], [2, 1]]", "opt_solution_cost": "22", "opt_solution_compute_t": "15.575777530670166", "solution_depth": "22", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Red\", \"Green\", \"Red\", \"Blue\", \"Green\"], [\"Red\", \"Blue\", \"Green\", \"Blue\", \"Blue\"], [\"Green\", \"Red\", \"Red\", \"Green\", \"Blue\"]], 8]", "is_correct_args": "[[[\"Red\", \"Green\", \"Red\", \"Blue\", \"Green\"], [\"Red\", \"Blue\", \"Green\", \"Blue\", \"Blue\"], [\"Green\", \"Red\", \"Red\", \"Green\", \"Blue\"]], 8]", "A*_args": "[\"[['Red', 'Green', 'Red', 'Blue', 'Green'], ['Red', 'Blue', 'Green', 'Blue', 'Blue'], ['Green', 'Red', 'Red', 'Green', 'Blue']]\", \"8\"]"}
{"diff_sorted_id": "73", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 22 to 67 (22 included in the range but 67 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['22' 'x' 'x' '66']\n ['x' 'x' 'x' 'x']\n ['50' '52' 'x' '57']\n ['x' '55' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "15", "opt_solution": "[[2, 0, 21], [2, 1, 22], [3, 0, 20], [3, 1, 19], [3, 2, 18], [3, 3, 17]]", "opt_solution_cost": "508", "opt_solution_compute_t": "8.582459211349487", "solution_depth": "6", "max_successor_states": "45", "num_vars_per_state": "16", "is_feasible_args": "[\"[['39', '40', '44', '62'], ['29', '33', '38', '61'], ['', '', '35', '59'], ['', '', '', '']]\", 17, 67]", "is_correct_args": "[\"[['39', '40', '44', '62'], ['29', '33', '38', '61'], ['', '', '35', '59'], ['', '', '', '']]\", 17, 67]", "A*_args": "[\"[['39', '40', '44', '62'], ['29', '33', '38', '61'], ['', '', '35', '59'], ['', '', '', '']]\", \"17\", \"67\"]"}
{"diff_sorted_id": "73", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 6 to 47. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 144, 76, None for columns 1 to 2 respectively, and the sums of rows must be None, 116, 124, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 75. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x' 'x']\n ['x' '41' '17' 'x']\n ['x' 'x' '13' '43']\n ['9' '24' '27' '11']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 6], [0, 1, 37], [0, 2, 19], [0, 3, 7], [1, 0, 12], [1, 3, 46], [2, 0, 26], [2, 1, 42]]", "opt_solution_cost": "380", "opt_solution_compute_t": "156.1415274143219", "solution_depth": "8", "max_successor_states": "31", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '', ''], ['', '41', '17', ''], ['', '', '13', '43'], ['9', '24', '27', '11']]\", 4, 6, 47]", "is_correct_args": "[\"[['', '', '', ''], ['', '41', '17', ''], ['', '', '13', '43'], ['9', '24', '27', '11']]\", 6, 47, [1, 3], [1, 3], [144, 76], [116, 124], 75]", "A*_args": "[\"[['', '', '', ''], ['', '41', '17', ''], ['', '', '13', '43'], ['9', '24', '27', '11']]\", \"6\", \"47\", \"[None, 144, 76, None]\", \"[None, 116, 124, None]\", \"75\"]"}
{"diff_sorted_id": "73", "problem_statement": "In 'Restricted Sorting', there are 10 stacks each with a capacity of 6 blocks, with 5 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 5 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 11, 1: 8, 2: 4, 3: 6, 4: 4, 5: 3, 6: 6, 7: 9, 8: 5, 9: 10}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Black', 'Red', 'Black', 'Green', 'Blue', 'Yellow'], ['Yellow', 'Yellow', 'Black', 'Blue', 'Red', 'Green'], [], [], [], [], ['Yellow', 'Black', 'White', 'Yellow', 'Red', 'Black'], ['Green', 'Blue', 'Green', 'White', 'Blue', 'Green'], ['Red', 'White', 'Blue', 'White', 'White', 'Red'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "3", "opt_solution": "[[6, 5], [8, 2], [1, 5], [1, 5], [1, 4], [1, 3], [1, 2], [0, 4], [0, 2], [0, 4], [0, 1], [0, 3], [7, 1], [7, 3], [6, 4], [6, 9], [6, 5], [6, 2], [6, 4], [8, 6], [8, 3], [8, 6], [8, 6], [8, 2], [7, 8], [7, 6], [7, 3], [7, 1], [8, 1], [9, 6], [0, 5]]", "opt_solution_cost": "162", "opt_solution_compute_t": "0.21412134170532227", "solution_depth": "31", "max_successor_states": "90", "num_vars_per_state": "30", "is_feasible_args": "[[[\"Black\", \"Red\", \"Black\", \"Green\", \"Blue\", \"Yellow\"], [\"Yellow\", \"Yellow\", \"Black\", \"Blue\", \"Red\", \"Green\"], [], [], [], [], [\"Yellow\", \"Black\", \"White\", \"Yellow\", \"Red\", \"Black\"], [\"Green\", \"Blue\", \"Green\", \"White\", \"Blue\", \"Green\"], [\"Red\", \"White\", \"Blue\", \"White\", \"White\", \"Red\"], []], 6, {\"0\": 11, \"1\": 8, \"2\": 4, \"3\": 6, \"4\": 4, \"5\": 3, \"6\": 6, \"7\": 9, \"8\": 5, \"9\": 10}]", "is_correct_args": "[[[\"Black\", \"Red\", \"Black\", \"Green\", \"Blue\", \"Yellow\"], [\"Yellow\", \"Yellow\", \"Black\", \"Blue\", \"Red\", \"Green\"], [], [], [], [], [\"Yellow\", \"Black\", \"White\", \"Yellow\", \"Red\", \"Black\"], [\"Green\", \"Blue\", \"Green\", \"White\", \"Blue\", \"Green\"], [\"Red\", \"White\", \"Blue\", \"White\", \"White\", \"Red\"], []], 6, {\"0\": 11, \"1\": 8, \"2\": 4, \"3\": 6, \"4\": 4, \"5\": 3, \"6\": 6, \"7\": 9, \"8\": 5, \"9\": 10}, 5]", "A*_args": "[\"[['Black', 'Red', 'Black', 'Green', 'Blue', 'Yellow'], ['Yellow', 'Yellow', 'Black', 'Blue', 'Red', 'Green'], [], [], [], [], ['Yellow', 'Black', 'White', 'Yellow', 'Red', 'Black'], ['Green', 'Blue', 'Green', 'White', 'Blue', 'Green'], ['Red', 'White', 'Blue', 'White', 'White', 'Red'], []]\", \"{0: 11, 1: 8, 2: 4, 3: 6, 4: 4, 5: 3, 6: 6, 7: 9, 8: 5, 9: 10}\", \"6\", \"5\"]"}
{"diff_sorted_id": "73", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 8) to his destination workshop at index (8, 0), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 7, and district 3 covering rows 8 to 12. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 14 15 10 x 14 x x 18 6 x x 4]\n[6 x x x 1 x 15 x x 2 x 17 x]\n[x 4 x 17 3 14 4 2 x 3 x 11 x]\n[6 6 x 19 x 13 x 11 13 6 3 x x]\n[3 10 11 x x 4 4 1 19 x x x 17]\n[8 x x 8 11 18 17 19 18 x 1 1 x]\n[14 14 1 19 6 x 19 19 18 9 x 12 18]\n[17 6 8 x 1 14 19 13 x x 9 x 3]\n[16 4 x x x 9 5 x x x 18 x x]\n[x x 10 x 18 x 1 x x 12 9 8 3]\n[x 13 17 x x x 5 8 1 x 1 10 x]\n[10 11 x 12 x 6 11 x 9 9 15 x 10]\n[5 15 1 x 8 5 x 6 x 9 18 x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "5", "opt_solution": "[[3, 8], [3, 7], [4, 7], [4, 6], [4, 5], [5, 5], [5, 4], [6, 4], [6, 3], [6, 2], [7, 2], [7, 1], [8, 1], [8, 0]]", "opt_solution_cost": "109", "opt_solution_compute_t": "0.018488407135009766", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"14\", \"15\", \"10\", \"x\", \"14\", \"x\", \"x\", \"18\", \"6\", \"x\", \"x\", \"4\"], [\"6\", \"x\", \"x\", \"x\", \"1\", \"x\", \"15\", \"x\", \"x\", \"2\", \"x\", \"17\", \"x\"], [\"x\", \"4\", \"x\", \"17\", \"3\", \"14\", \"4\", \"2\", \"x\", \"3\", \"x\", \"11\", \"x\"], [\"6\", \"6\", \"x\", \"19\", \"x\", \"13\", \"x\", \"11\", \"13\", \"6\", \"3\", \"x\", \"x\"], [\"3\", \"10\", \"11\", \"x\", \"x\", \"4\", \"4\", \"1\", \"19\", \"x\", \"x\", \"x\", \"17\"], [\"8\", \"x\", \"x\", \"8\", \"11\", \"18\", \"17\", \"19\", \"18\", \"x\", \"1\", \"1\", \"x\"], [\"14\", \"14\", \"1\", \"19\", \"6\", \"x\", \"19\", \"19\", \"18\", \"9\", \"x\", \"12\", \"18\"], [\"17\", \"6\", \"8\", \"x\", \"1\", \"14\", \"19\", \"13\", \"x\", \"x\", \"9\", \"x\", \"3\"], [\"16\", \"4\", \"x\", \"x\", \"x\", \"9\", \"5\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\"], [\"x\", \"x\", \"10\", \"x\", \"18\", \"x\", \"1\", \"x\", \"x\", \"12\", \"9\", \"8\", \"3\"], [\"x\", \"13\", \"17\", \"x\", \"x\", \"x\", \"5\", \"8\", \"1\", \"x\", \"1\", \"10\", \"x\"], [\"10\", \"11\", \"x\", \"12\", \"x\", \"6\", \"11\", \"x\", \"9\", \"9\", \"15\", \"x\", \"10\"], [\"5\", \"15\", \"1\", \"x\", \"8\", \"5\", \"x\", \"6\", \"x\", \"9\", \"18\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"14\", \"15\", \"10\", \"x\", \"14\", \"x\", \"x\", \"18\", \"6\", \"x\", \"x\", \"4\"], [\"6\", \"x\", \"x\", \"x\", \"1\", \"x\", \"15\", \"x\", \"x\", \"2\", \"x\", \"17\", \"x\"], [\"x\", \"4\", \"x\", \"17\", \"3\", \"14\", \"4\", \"2\", \"x\", \"3\", \"x\", \"11\", \"x\"], [\"6\", \"6\", \"x\", \"19\", \"x\", \"13\", \"x\", \"11\", \"13\", \"6\", \"3\", \"x\", \"x\"], [\"3\", \"10\", \"11\", \"x\", \"x\", \"4\", \"4\", \"1\", \"19\", \"x\", \"x\", \"x\", \"17\"], [\"8\", \"x\", \"x\", \"8\", \"11\", \"18\", \"17\", \"19\", \"18\", \"x\", \"1\", \"1\", \"x\"], [\"14\", \"14\", \"1\", \"19\", \"6\", \"x\", \"19\", \"19\", \"18\", \"9\", \"x\", \"12\", \"18\"], [\"17\", \"6\", \"8\", \"x\", \"1\", \"14\", \"19\", \"13\", \"x\", \"x\", \"9\", \"x\", \"3\"], [\"16\", \"4\", \"x\", \"x\", \"x\", \"9\", \"5\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\"], [\"x\", \"x\", \"10\", \"x\", \"18\", \"x\", \"1\", \"x\", \"x\", \"12\", \"9\", \"8\", \"3\"], [\"x\", \"13\", \"17\", \"x\", \"x\", \"x\", \"5\", \"8\", \"1\", \"x\", \"1\", \"10\", \"x\"], [\"10\", \"11\", \"x\", \"12\", \"x\", \"6\", \"11\", \"x\", \"9\", \"9\", \"15\", \"x\", \"10\"], [\"5\", \"15\", \"1\", \"x\", \"8\", \"5\", \"x\", \"6\", \"x\", \"9\", \"18\", \"x\", \"x\"]], [3, 8], [8, 0], 3, 7]", "A*_args": "[\"[['x', '14', '15', '10', 'x', '14', 'x', 'x', '18', '6', 'x', 'x', '4'], ['6', 'x', 'x', 'x', '1', 'x', '15', 'x', 'x', '2', 'x', '17', 'x'], ['x', '4', 'x', '17', '3', '14', '4', '2', 'x', '3', 'x', '11', 'x'], ['6', '6', 'x', '19', 'x', '13', 'x', '11', '13', '6', '3', 'x', 'x'], ['3', '10', '11', 'x', 'x', '4', '4', '1', '19', 'x', 'x', 'x', '17'], ['8', 'x', 'x', '8', '11', '18', '17', '19', '18', 'x', '1', '1', 'x'], ['14', '14', '1', '19', '6', 'x', '19', '19', '18', '9', 'x', '12', '18'], ['17', '6', '8', 'x', '1', '14', '19', '13', 'x', 'x', '9', 'x', '3'], ['16', '4', 'x', 'x', 'x', '9', '5', 'x', 'x', 'x', '18', 'x', 'x'], ['x', 'x', '10', 'x', '18', 'x', '1', 'x', 'x', '12', '9', '8', '3'], ['x', '13', '17', 'x', 'x', 'x', '5', '8', '1', 'x', '1', '10', 'x'], ['10', '11', 'x', '12', 'x', '6', '11', 'x', '9', '9', '15', 'x', '10'], ['5', '15', '1', 'x', '8', '5', 'x', '6', 'x', '9', '18', 'x', 'x']]\", \"(3, 8)\", \"(8, 0)\", \"3\", \"7\"]"}
{"diff_sorted_id": "73", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 13x13. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 12) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (8, 2). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 1 1 1 1 0 0 1 1 1 1 1\n1 0 0 1 0 1 0 0 1 1 0 1 0\n1 0 0 1 0 0 0 0 0 1 0 0 0\n1 1 1 1 1 0 1 0 1 1 0 0 0\n1 1 1 0 0 1 1 1 1 0 0 1 0\n1 1 0 1 1 1 0 0 0 0 0 1 0\n1 0 0 0 0 0 0 1 1 1 0 0 0\n1 1 1 1 0 0 1 1 0 1 0 1 1\n1 1 0 0 0 0 1 0 0 1 1 0 1\n1 1 1 0 0 1 1 1 0 0 0 1 0\n0 1 0 0 1 0 1 1 0 0 0 1 1\n1 1 1 1 1 0 1 0 1 0 1 0 1\n1 1 0 0 1 1 0 1 1 0 0 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[[1, 12], [2, 11], [2, 10], [3, 10], [4, 9], [5, 8], [5, 7], [5, 6], [6, 5], [6, 4], [7, 4], [8, 4], [8, 3], [8, 2]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.024569988250732422", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1], [1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0], [1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0], [1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1], [1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1], [1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1], [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1]]\", 4]", "is_correct_args": "[\"[[1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1], [1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0], [1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0], [1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1], [1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1], [1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1], [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1]]\", [1, 12], [8, 2], 4]", "A*_args": "[\"[[1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1], [1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0], [1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0], [1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1], [1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1], [1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1], [1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1]]\", \"(1, 12)\", \"(8, 2)\", \"4\"]"}
{"diff_sorted_id": "73", "problem_statement": "Given 7 labeled water jugs with capacities 56, 81, 132, 41, 86, 128, 57, 138 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 232, 401, 444, 451 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 128, 4], [\"+\", 128, 4], [\"+\", 138, 4], [\"+\", 57, 4], [\"+\", 128, 3], [\"+\", 128, 3], [\"+\", 56, 3], [\"+\", 132, 3], [\"+\", 132, 2], [\"+\", 132, 2], [\"+\", 56, 2], [\"+\", 81, 2], [\"+\", 57, 1], [\"+\", 128, 1], [\"-\", 81, 1], [\"+\", 128, 1]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.05008697509765625", "solution_depth": "16", "max_successor_states": "64", "num_vars_per_state": "3", "is_feasible_args": "[[56, 81, 132, 41, 86, 128, 57, 138], [232, 401, 444, 451]]", "is_correct_args": "[[56, 81, 132, 41, 86, 128, 57, 138], [232, 401, 444, 451]]", "A*_args": "[\"[56, 81, 132, 41, 86, 128, 57, 138]\", \"[232, 401, 444, 451]\"]"}
{"diff_sorted_id": "74", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[49, 20, 77, 78, 57], [41, '_', 52, 44, 72], [27, 81, 45, 16, 46]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[81, 27, 41, 81, 52, 45, 16, 44, 72, 46, 44, 16, 45, 77, 20, 49, 81, 52, 77, 20, 78, 72, 46, 44, 16, 45, 20, 77, 49, 78, 77, 46, 45, 16]", "opt_solution_cost": "34", "opt_solution_compute_t": "2.7185001373291016", "solution_depth": "34", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[49, 20, 77, 78, 57], [41, \"_\", 52, 44, 72], [27, 81, 45, 16, 46]]]", "is_correct_args": "[[[49, 20, 77, 78, 57], [41, \"_\", 52, 44, 72], [27, 81, 45, 16, 46]]]", "A*_args": "[\"[[49, 20, 77, 78, 57], [41, '_', 52, 44, 72], [27, 81, 45, 16, 46]]\"]"}
{"diff_sorted_id": "74", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: zeta, sumac, showy, smeek, ajava   The initial board: [['u', 'z', 's', 't', 'a'], ['s', 'e', 'm', 'o', 'c'], ['a', 'h', '_', 'w', 'y'], ['s', 'a', 'e', 'm', 'k'], ['a', 'j', 'e', 'v', 'a']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.29548144340515137", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"u\", \"z\", \"s\", \"t\", \"a\"], [\"s\", \"e\", \"m\", \"o\", \"c\"], [\"a\", \"h\", \"_\", \"w\", \"y\"], [\"s\", \"a\", \"e\", \"m\", \"k\"], [\"a\", \"j\", \"e\", \"v\", \"a\"]]]", "is_correct_args": "[[[\"u\", \"z\", \"s\", \"t\", \"a\"], [\"s\", \"e\", \"m\", \"o\", \"c\"], [\"a\", \"h\", \"_\", \"w\", \"y\"], [\"s\", \"a\", \"e\", \"m\", \"k\"], [\"a\", \"j\", \"e\", \"v\", \"a\"]], [\"zeta\", \"sumac\", \"showy\", \"smeek\", \"ajava\"]]", "A*_args": "[\"[['u', 'z', 's', 't', 'a'], ['s', 'e', 'm', 'o', 'c'], ['a', 'h', '_', 'w', 'y'], ['s', 'a', 'e', 'm', 'k'], ['a', 'j', 'e', 'v', 'a']]\", \"['zeta', 'sumac', 'showy', 'smeek', 'ajava']\"]"}
{"diff_sorted_id": "74", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'M'. Our task is to visit city L and city Z excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from Z and L, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  O M U L Q P D A S B K V E Z \nO 0 0 0 0 1 0 0 0 0 0 0 0 0 1 \nM 0 0 0 0 0 0 0 0 0 0 0 1 0 0 \nU 0 1 0 1 0 0 0 0 0 1 1 0 0 0 \nL 1 0 0 0 0 1 1 1 0 0 1 0 0 0 \nQ 0 0 0 1 0 1 0 1 1 0 0 1 1 0 \nP 0 0 1 0 0 0 0 1 0 1 0 0 0 1 \nD 0 1 1 0 0 1 0 0 0 0 0 1 0 0 \nA 0 1 1 0 1 0 0 0 0 1 0 0 0 1 \nS 1 1 0 0 0 0 1 0 0 0 0 0 0 0 \nB 0 1 0 1 0 0 0 0 1 0 0 1 0 0 \nK 0 1 0 1 1 0 1 1 1 0 0 1 0 0 \nV 1 0 0 0 0 0 1 0 0 0 0 0 0 1 \nE 0 0 0 0 0 0 1 1 1 1 1 0 0 1 \nZ 1 0 1 0 1 0 1 0 1 0 1 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[\"M\", \"V\", \"Z\", \"E\", \"Z\", \"Q\", \"L\", \"K\", \"L\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.0362241268157959", "solution_depth": "9", "max_successor_states": "14", "num_vars_per_state": "17", "is_feasible_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]], [\"O\", \"M\", \"U\", \"L\", \"Q\", \"P\", \"D\", \"A\", \"S\", \"B\", \"K\", \"V\", \"E\", \"Z\"], \"L\", \"Z\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]], [\"O\", \"M\", \"U\", \"L\", \"Q\", \"P\", \"D\", \"A\", \"S\", \"B\", \"K\", \"V\", \"E\", \"Z\"], \"M\", \"L\", \"Z\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1], [0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]]\", \"['O', 'M', 'U', 'L', 'Q', 'P', 'D', 'A', 'S', 'B', 'K', 'V', 'E', 'Z']\", \"['M']\", \"['L', 'Z']\"]"}
{"diff_sorted_id": "74", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [5, 15, 15, 77, 12, 38, 41, 30, 31, 30, 13, 19, 9, 2, 23, 37, 14, 34, 29, 22, 22, 4, 16, 2, 12, 17, 9, 18, 19, 21, 4, 28, 40, 11, 30, 24, 19, 9, 10, 76, 34], such that the sum of the chosen coins adds up to 419. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {13: 8, 29: 10, 4: 4, 2: 2, 77: 17, 16: 10, 11: 2, 22: 18, 17: 10, 18: 18, 38: 7, 9: 6, 5: 2, 41: 14, 31: 3, 12: 10, 19: 5, 24: 16, 40: 6, 14: 4, 34: 13, 15: 3, 23: 20, 76: 16, 37: 2, 21: 2, 28: 3, 10: 2, 30: 16}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "25", "opt_solution": "[15, 31, 28, 37, 77, 76, 40, 38, 10, 11, 21, 2, 19, 14]", "opt_solution_cost": "74", "opt_solution_compute_t": "0.058817148208618164", "solution_depth": "14", "max_successor_states": "41", "num_vars_per_state": "41", "is_feasible_args": "[[5, 15, 15, 77, 12, 38, 41, 30, 31, 30, 13, 19, 9, 2, 23, 37, 14, 34, 29, 22, 22, 4, 16, 2, 12, 17, 9, 18, 19, 21, 4, 28, 40, 11, 30, 24, 19, 9, 10, 76, 34]]", "is_correct_args": "[[5, 15, 15, 77, 12, 38, 41, 30, 31, 30, 13, 19, 9, 2, 23, 37, 14, 34, 29, 22, 22, 4, 16, 2, 12, 17, 9, 18, 19, 21, 4, 28, 40, 11, 30, 24, 19, 9, 10, 76, 34], {\"13\": 8, \"29\": 10, \"4\": 4, \"2\": 2, \"77\": 17, \"16\": 10, \"11\": 2, \"22\": 18, \"17\": 10, \"18\": 18, \"38\": 7, \"9\": 6, \"5\": 2, \"41\": 14, \"31\": 3, \"12\": 10, \"19\": 5, \"24\": 16, \"40\": 6, \"14\": 4, \"34\": 13, \"15\": 3, \"23\": 20, \"76\": 16, \"37\": 2, \"21\": 2, \"28\": 3, \"10\": 2, \"30\": 16}, 419]", "A*_args": "[\"[5, 15, 15, 77, 12, 38, 41, 30, 31, 30, 13, 19, 9, 2, 23, 37, 14, 34, 29, 22, 22, 4, 16, 2, 12, 17, 9, 18, 19, 21, 4, 28, 40, 11, 30, 24, 19, 9, 10, 76, 34]\", \"{13: 8, 29: 10, 4: 4, 2: 2, 77: 17, 16: 10, 11: 2, 22: 18, 17: 10, 18: 18, 38: 7, 9: 6, 5: 2, 41: 14, 31: 3, 12: 10, 19: 5, 24: 16, 40: 6, 14: 4, 34: 13, 15: 3, 23: 20, 76: 16, 37: 2, 21: 2, 28: 3, 10: 2, 30: 16}\", \"419\"]"}
{"diff_sorted_id": "74", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Red', 'Green', 'Red', 'Green'], ['Blue', 'Red', 'Green', 'Blue', 'Green'], ['Red', 'Blue', 'Red', 'Blue', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[1, 0], [2, 1], [2, 0], [2, 1], [0, 2], [0, 2], [0, 2], [0, 1], [0, 2], [0, 1], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [0, 2], [0, 1]]", "opt_solution_cost": "23", "opt_solution_compute_t": "30.882342100143433", "solution_depth": "23", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Green\", \"Red\", \"Green\", \"Red\", \"Green\"], [\"Blue\", \"Red\", \"Green\", \"Blue\", \"Green\"], [\"Red\", \"Blue\", \"Red\", \"Blue\", \"Blue\"]], 8]", "is_correct_args": "[[[\"Green\", \"Red\", \"Green\", \"Red\", \"Green\"], [\"Blue\", \"Red\", \"Green\", \"Blue\", \"Green\"], [\"Red\", \"Blue\", \"Red\", \"Blue\", \"Blue\"]], 8]", "A*_args": "[\"[['Green', 'Red', 'Green', 'Red', 'Green'], ['Blue', 'Red', 'Green', 'Blue', 'Green'], ['Red', 'Blue', 'Red', 'Blue', 'Blue']]\", \"8\"]"}
{"diff_sorted_id": "74", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 44 to 89 (44 included in the range but 89 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['49' 'x' 'x' 'x']\n ['x' '51' 'x' '84']\n ['47' 'x' 'x' '79']\n ['x' 'x' 'x' '77']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "15", "opt_solution": "[[0, 0, 24], [0, 1, 28], [1, 0, 23], [1, 2, 29], [1, 3, 51], [2, 2, 26], [3, 0, 14]]", "opt_solution_cost": "495", "opt_solution_compute_t": "83.38021159172058", "solution_depth": "7", "max_successor_states": "45", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '53', '62'], ['', '27', '', ''], ['21', '22', '', '50'], ['', '20', '25', '44']]\", 14, 64]", "is_correct_args": "[\"[['', '', '53', '62'], ['', '27', '', ''], ['21', '22', '', '50'], ['', '20', '25', '44']]\", 14, 64]", "A*_args": "[\"[['', '', '53', '62'], ['', '27', '', ''], ['21', '22', '', '50'], ['', '20', '25', '44']]\", \"14\", \"64\"]"}
{"diff_sorted_id": "74", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 6 to 47. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 99, 126, None for columns 1 to 2 respectively, and the sums of rows must be None, 97, 107, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 124. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['15' '20' 'x' 'x']\n ['6' 'x' 'x' '40']\n ['x' 'x' '29' 'x']\n ['46' '42' '34' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 2, 24], [0, 3, 14], [1, 1, 12], [1, 2, 39], [2, 0, 8], [2, 1, 25], [2, 3, 45], [3, 3, 7]]", "opt_solution_cost": "406", "opt_solution_compute_t": "1.2863490581512451", "solution_depth": "8", "max_successor_states": "31", "num_vars_per_state": "16", "is_feasible_args": "[\"[['15', '20', '', ''], ['6', '', '', '40'], ['', '', '29', ''], ['46', '42', '34', '']]\", 4, 6, 47]", "is_correct_args": "[\"[['15', '20', '', ''], ['6', '', '', '40'], ['', '', '29', ''], ['46', '42', '34', '']]\", 6, 47, [1, 3], [1, 3], [99, 126], [97, 107], 124]", "A*_args": "[\"[['15', '20', '', ''], ['6', '', '', '40'], ['', '', '29', ''], ['46', '42', '34', '']]\", \"6\", \"47\", \"[None, 99, 126, None]\", \"[None, 97, 107, None]\", \"124\"]"}
{"diff_sorted_id": "74", "problem_statement": "In 'Restricted Sorting', there are 10 stacks each with a capacity of 6 blocks, with 5 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 5 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 3, 1: 8, 2: 5, 3: 10, 4: 8, 5: 2, 6: 3, 7: 4, 8: 11, 9: 3}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Black', 'Blue', 'Red', 'White', 'Red', 'Green'], ['Red', 'Black', 'Red', 'Green', 'Blue', 'Black'], ['Black', 'Yellow', 'Yellow', 'White', 'White', 'Yellow'], [], [], ['White', 'Green', 'Green', 'Red', 'Green', 'Yellow'], [], ['Blue', 'Blue', 'Blue', 'Black', 'White', 'Yellow'], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "3", "opt_solution": "[[0, 6], [0, 9], [2, 6], [5, 4], [7, 9], [7, 9], [7, 9], [7, 6], [7, 4], [1, 3], [2, 7], [2, 7], [2, 4], [2, 4], [2, 7], [0, 2], [0, 4], [0, 2], [1, 6], [1, 2], [1, 0], [1, 9], [5, 0], [5, 0], [5, 2], [5, 0], [3, 2], [5, 7], [1, 6]]", "opt_solution_cost": "133", "opt_solution_compute_t": "0.260591983795166", "solution_depth": "29", "max_successor_states": "90", "num_vars_per_state": "30", "is_feasible_args": "[[[\"Black\", \"Blue\", \"Red\", \"White\", \"Red\", \"Green\"], [\"Red\", \"Black\", \"Red\", \"Green\", \"Blue\", \"Black\"], [\"Black\", \"Yellow\", \"Yellow\", \"White\", \"White\", \"Yellow\"], [], [], [\"White\", \"Green\", \"Green\", \"Red\", \"Green\", \"Yellow\"], [], [\"Blue\", \"Blue\", \"Blue\", \"Black\", \"White\", \"Yellow\"], [], []], 6, {\"0\": 3, \"1\": 8, \"2\": 5, \"3\": 10, \"4\": 8, \"5\": 2, \"6\": 3, \"7\": 4, \"8\": 11, \"9\": 3}]", "is_correct_args": "[[[\"Black\", \"Blue\", \"Red\", \"White\", \"Red\", \"Green\"], [\"Red\", \"Black\", \"Red\", \"Green\", \"Blue\", \"Black\"], [\"Black\", \"Yellow\", \"Yellow\", \"White\", \"White\", \"Yellow\"], [], [], [\"White\", \"Green\", \"Green\", \"Red\", \"Green\", \"Yellow\"], [], [\"Blue\", \"Blue\", \"Blue\", \"Black\", \"White\", \"Yellow\"], [], []], 6, {\"0\": 3, \"1\": 8, \"2\": 5, \"3\": 10, \"4\": 8, \"5\": 2, \"6\": 3, \"7\": 4, \"8\": 11, \"9\": 3}, 5]", "A*_args": "[\"[['Black', 'Blue', 'Red', 'White', 'Red', 'Green'], ['Red', 'Black', 'Red', 'Green', 'Blue', 'Black'], ['Black', 'Yellow', 'Yellow', 'White', 'White', 'Yellow'], [], [], ['White', 'Green', 'Green', 'Red', 'Green', 'Yellow'], [], ['Blue', 'Blue', 'Blue', 'Black', 'White', 'Yellow'], [], []]\", \"{0: 3, 1: 8, 2: 5, 3: 10, 4: 8, 5: 2, 6: 3, 7: 4, 8: 11, 9: 3}\", \"6\", \"5\"]"}
{"diff_sorted_id": "74", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 12) to his destination workshop at index (7, 3), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 6, and district 3 covering rows 7 to 12. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[10 x x x 16 9 x 13 12 8 x 16 17]\n[9 2 x x 5 x x x 12 x 3 x x]\n[x x 7 3 12 x 11 18 10 x x 13 x]\n[x 6 x 19 2 x x 11 13 13 1 x 7]\n[x x 11 x 16 16 4 12 5 20 2 4 15]\n[19 x 18 5 11 x x 3 17 18 3 8 18]\n[12 x 9 x x x x 9 4 15 16 x 9]\n[x 15 x 6 10 x 1 1 x 9 4 7 1]\n[x 19 15 x 1 10 5 17 x 8 x 1 x]\n[x x x x 5 x 1 x x 7 4 x x]\n[9 x 4 x 5 13 x 15 x x 18 9 15]\n[17 2 x x x 18 8 x 8 x x 8 7]\n[x x 5 x x 8 x 8 x 15 19 x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "5", "opt_solution": "[[3, 12], [4, 12], [4, 11], [4, 10], [5, 10], [6, 10], [6, 9], [6, 8], [6, 7], [7, 7], [7, 6], [8, 6], [8, 5], [8, 4], [7, 4], [7, 3]]", "opt_solution_cost": "102", "opt_solution_compute_t": "0.02852487564086914", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"10\", \"x\", \"x\", \"x\", \"16\", \"9\", \"x\", \"13\", \"12\", \"8\", \"x\", \"16\", \"17\"], [\"9\", \"2\", \"x\", \"x\", \"5\", \"x\", \"x\", \"x\", \"12\", \"x\", \"3\", \"x\", \"x\"], [\"x\", \"x\", \"7\", \"3\", \"12\", \"x\", \"11\", \"18\", \"10\", \"x\", \"x\", \"13\", \"x\"], [\"x\", \"6\", \"x\", \"19\", \"2\", \"x\", \"x\", \"11\", \"13\", \"13\", \"1\", \"x\", \"7\"], [\"x\", \"x\", \"11\", \"x\", \"16\", \"16\", \"4\", \"12\", \"5\", \"20\", \"2\", \"4\", \"15\"], [\"19\", \"x\", \"18\", \"5\", \"11\", \"x\", \"x\", \"3\", \"17\", \"18\", \"3\", \"8\", \"18\"], [\"12\", \"x\", \"9\", \"x\", \"x\", \"x\", \"x\", \"9\", \"4\", \"15\", \"16\", \"x\", \"9\"], [\"x\", \"15\", \"x\", \"6\", \"10\", \"x\", \"1\", \"1\", \"x\", \"9\", \"4\", \"7\", \"1\"], [\"x\", \"19\", \"15\", \"x\", \"1\", \"10\", \"5\", \"17\", \"x\", \"8\", \"x\", \"1\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"5\", \"x\", \"1\", \"x\", \"x\", \"7\", \"4\", \"x\", \"x\"], [\"9\", \"x\", \"4\", \"x\", \"5\", \"13\", \"x\", \"15\", \"x\", \"x\", \"18\", \"9\", \"15\"], [\"17\", \"2\", \"x\", \"x\", \"x\", \"18\", \"8\", \"x\", \"8\", \"x\", \"x\", \"8\", \"7\"], [\"x\", \"x\", \"5\", \"x\", \"x\", \"8\", \"x\", \"8\", \"x\", \"15\", \"19\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"10\", \"x\", \"x\", \"x\", \"16\", \"9\", \"x\", \"13\", \"12\", \"8\", \"x\", \"16\", \"17\"], [\"9\", \"2\", \"x\", \"x\", \"5\", \"x\", \"x\", \"x\", \"12\", \"x\", \"3\", \"x\", \"x\"], [\"x\", \"x\", \"7\", \"3\", \"12\", \"x\", \"11\", \"18\", \"10\", \"x\", \"x\", \"13\", \"x\"], [\"x\", \"6\", \"x\", \"19\", \"2\", \"x\", \"x\", \"11\", \"13\", \"13\", \"1\", \"x\", \"7\"], [\"x\", \"x\", \"11\", \"x\", \"16\", \"16\", \"4\", \"12\", \"5\", \"20\", \"2\", \"4\", \"15\"], [\"19\", \"x\", \"18\", \"5\", \"11\", \"x\", \"x\", \"3\", \"17\", \"18\", \"3\", \"8\", \"18\"], [\"12\", \"x\", \"9\", \"x\", \"x\", \"x\", \"x\", \"9\", \"4\", \"15\", \"16\", \"x\", \"9\"], [\"x\", \"15\", \"x\", \"6\", \"10\", \"x\", \"1\", \"1\", \"x\", \"9\", \"4\", \"7\", \"1\"], [\"x\", \"19\", \"15\", \"x\", \"1\", \"10\", \"5\", \"17\", \"x\", \"8\", \"x\", \"1\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"5\", \"x\", \"1\", \"x\", \"x\", \"7\", \"4\", \"x\", \"x\"], [\"9\", \"x\", \"4\", \"x\", \"5\", \"13\", \"x\", \"15\", \"x\", \"x\", \"18\", \"9\", \"15\"], [\"17\", \"2\", \"x\", \"x\", \"x\", \"18\", \"8\", \"x\", \"8\", \"x\", \"x\", \"8\", \"7\"], [\"x\", \"x\", \"5\", \"x\", \"x\", \"8\", \"x\", \"8\", \"x\", \"15\", \"19\", \"x\", \"x\"]], [3, 12], [7, 3], 3, 6]", "A*_args": "[\"[['10', 'x', 'x', 'x', '16', '9', 'x', '13', '12', '8', 'x', '16', '17'], ['9', '2', 'x', 'x', '5', 'x', 'x', 'x', '12', 'x', '3', 'x', 'x'], ['x', 'x', '7', '3', '12', 'x', '11', '18', '10', 'x', 'x', '13', 'x'], ['x', '6', 'x', '19', '2', 'x', 'x', '11', '13', '13', '1', 'x', '7'], ['x', 'x', '11', 'x', '16', '16', '4', '12', '5', '20', '2', '4', '15'], ['19', 'x', '18', '5', '11', 'x', 'x', '3', '17', '18', '3', '8', '18'], ['12', 'x', '9', 'x', 'x', 'x', 'x', '9', '4', '15', '16', 'x', '9'], ['x', '15', 'x', '6', '10', 'x', '1', '1', 'x', '9', '4', '7', '1'], ['x', '19', '15', 'x', '1', '10', '5', '17', 'x', '8', 'x', '1', 'x'], ['x', 'x', 'x', 'x', '5', 'x', '1', 'x', 'x', '7', '4', 'x', 'x'], ['9', 'x', '4', 'x', '5', '13', 'x', '15', 'x', 'x', '18', '9', '15'], ['17', '2', 'x', 'x', 'x', '18', '8', 'x', '8', 'x', 'x', '8', '7'], ['x', 'x', '5', 'x', 'x', '8', 'x', '8', 'x', '15', '19', 'x', 'x']]\", \"(3, 12)\", \"(7, 3)\", \"3\", \"6\"]"}
{"diff_sorted_id": "74", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 13x13. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (11, 3) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (1, 10). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 0 1 1 0 0 0 0 1 1 1 1\n1 1 1 0 0 1 1 1 1 1 0 0 0\n0 1 1 1 1 1 1 1 1 1 0 0 1\n1 1 0 0 0 1 1 1 0 1 0 0 1\n1 1 0 0 0 1 0 1 0 0 0 1 1\n0 1 1 0 1 1 1 0 0 0 1 1 1\n0 1 0 1 1 0 1 0 0 1 1 1 0\n1 1 1 0 1 0 0 0 0 1 1 0 0\n1 0 1 0 1 0 0 1 1 1 0 0 1\n1 1 0 0 0 0 1 1 0 1 1 0 0\n0 0 0 0 1 0 1 0 0 1 0 0 1\n0 0 0 0 1 0 1 1 1 0 1 0 0\n0 0 0 0 1 1 1 1 0 0 1 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[[11, 3], [10, 3], [9, 3], [9, 4], [8, 5], [7, 5], [7, 6], [6, 7], [5, 7], [4, 8], [4, 9], [3, 10], [2, 10], [1, 10]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.024291276931762695", "solution_depth": "14", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1], [1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1], [1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1], [0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1], [0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0], [1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1], [1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1]]\", 4]", "is_correct_args": "[\"[[1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1], [1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1], [1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1], [0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1], [0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0], [1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1], [1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1]]\", [11, 3], [1, 10], 4]", "A*_args": "[\"[[1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1], [1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1], [1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1], [0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1], [0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0], [1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1], [1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1]]\", \"(11, 3)\", \"(1, 10)\", \"4\"]"}
{"diff_sorted_id": "74", "problem_statement": "Given 7 labeled water jugs with capacities 91, 141, 56, 65, 89, 40, 39, 92 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 294, 375, 459, 466 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 92, 4], [\"+\", 141, 4], [\"+\", 141, 4], [\"+\", 92, 4], [\"+\", 141, 3], [\"+\", 141, 3], [\"+\", 141, 3], [\"-\", 56, 3], [\"+\", 92, 3], [\"+\", 56, 2], [\"+\", 89, 2], [\"+\", 89, 2], [\"+\", 141, 2], [\"+\", 56, 1], [\"+\", 91, 1], [\"+\", 91, 1], [\"+\", 56, 1]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.0752251148223877", "solution_depth": "17", "max_successor_states": "64", "num_vars_per_state": "3", "is_feasible_args": "[[91, 141, 56, 65, 89, 40, 39, 92], [294, 375, 459, 466]]", "is_correct_args": "[[91, 141, 56, 65, 89, 40, 39, 92], [294, 375, 459, 466]]", "A*_args": "[\"[91, 141, 56, 65, 89, 40, 39, 92]\", \"[294, 375, 459, 466]\"]"}
{"diff_sorted_id": "75", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [['_', 67, 21, 97, 69], [61, 68, 55, 16, 73], [42, 41, 31, 83, 53]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[61, 42, 41, 31, 55, 21, 97, 16, 21, 68, 31, 55, 83, 21, 73, 69, 16, 73, 68, 83, 55, 31, 42, 61, 67, 97, 83, 42, 61, 67, 97, 83, 73, 68, 69, 16, 68, 69, 42, 55, 21, 53, 16, 42, 53, 16]", "opt_solution_cost": "46", "opt_solution_compute_t": "68.0147922039032", "solution_depth": "46", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[\"_\", 67, 21, 97, 69], [61, 68, 55, 16, 73], [42, 41, 31, 83, 53]]]", "is_correct_args": "[[[\"_\", 67, 21, 97, 69], [61, 68, 55, 16, 73], [42, 41, 31, 83, 53]]]", "A*_args": "[\"[['_', 67, 21, 97, 69], [61, 68, 55, 16, 73], [42, 41, 31, 83, 53]]\"]"}
{"diff_sorted_id": "75", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: soho, rilly, josip, drain, nival   The initial board: [['_', 's', 's', 'h', 'o'], ['r', 'i', 'l', 'o', 'y'], ['j', 'o', 'l', 'i', 'p'], ['d', 'r', 'a', 'i', 'n'], ['n', 'i', 'v', 'a', 'l']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "6", "opt_solution_compute_t": "0.19606399536132812", "solution_depth": "6", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"_\", \"s\", \"s\", \"h\", \"o\"], [\"r\", \"i\", \"l\", \"o\", \"y\"], [\"j\", \"o\", \"l\", \"i\", \"p\"], [\"d\", \"r\", \"a\", \"i\", \"n\"], [\"n\", \"i\", \"v\", \"a\", \"l\"]]]", "is_correct_args": "[[[\"_\", \"s\", \"s\", \"h\", \"o\"], [\"r\", \"i\", \"l\", \"o\", \"y\"], [\"j\", \"o\", \"l\", \"i\", \"p\"], [\"d\", \"r\", \"a\", \"i\", \"n\"], [\"n\", \"i\", \"v\", \"a\", \"l\"]], [\"soho\", \"rilly\", \"josip\", \"drain\", \"nival\"]]", "A*_args": "[\"[['_', 's', 's', 'h', 'o'], ['r', 'i', 'l', 'o', 'y'], ['j', 'o', 'l', 'i', 'p'], ['d', 'r', 'a', 'i', 'n'], ['n', 'i', 'v', 'a', 'l']]\", \"['soho', 'rilly', 'josip', 'drain', 'nival']\"]"}
{"diff_sorted_id": "75", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'B'. Our task is to visit city W and city F excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from F and W, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  L S P R N F O K B H T W U E \nL 0 0 1 0 1 1 0 1 1 0 0 0 0 0 \nS 0 0 0 1 0 1 0 0 0 0 0 0 1 0 \nP 0 0 0 0 1 0 0 1 0 0 0 0 0 0 \nR 0 0 1 0 0 1 0 0 0 1 0 0 0 0 \nN 0 0 0 1 0 0 1 1 0 0 1 0 0 0 \nF 0 0 0 1 0 0 1 0 0 0 0 0 0 1 \nO 0 1 0 0 0 0 0 1 0 0 1 0 0 0 \nK 0 1 0 0 0 1 0 0 1 0 0 1 0 0 \nB 0 0 1 0 1 0 0 0 0 0 0 0 0 1 \nH 0 1 0 0 0 1 1 0 0 0 0 0 1 0 \nT 1 0 0 0 0 0 0 0 0 1 0 1 0 1 \nW 1 0 1 0 0 1 0 0 0 1 0 0 0 1 \nU 1 0 1 0 0 0 0 1 1 0 1 0 0 1 \nE 0 1 0 1 0 0 1 1 0 0 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[\"B\", \"E\", \"W\", \"F\", \"O\", \"K\", \"W\", \"F\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.03292369842529297", "solution_depth": "8", "max_successor_states": "14", "num_vars_per_state": "17", "is_feasible_args": "[[[0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1], [0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0]], [\"L\", \"S\", \"P\", \"R\", \"N\", \"F\", \"O\", \"K\", \"B\", \"H\", \"T\", \"W\", \"U\", \"E\"], \"W\", \"F\"]", "is_correct_args": "[[[0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1], [0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0]], [\"L\", \"S\", \"P\", \"R\", \"N\", \"F\", \"O\", \"K\", \"B\", \"H\", \"T\", \"W\", \"U\", \"E\"], \"B\", \"W\", \"F\"]", "A*_args": "[\"[[0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1], [0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0]]\", \"['L', 'S', 'P', 'R', 'N', 'F', 'O', 'K', 'B', 'H', 'T', 'W', 'U', 'E']\", \"['B']\", \"['W', 'F']\"]"}
{"diff_sorted_id": "75", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [8, 31, 28, 24, 19, 18, 26, 31, 43, 32, 3, 21, 21, 10, 36, 40, 19, 38, 3, 5, 24, 12, 11, 14, 40, 7, 19, 4, 22, 5, 33, 31, 40, 7, 5, 34, 33, 22, 14, 6, 14, 29], such that the sum of the chosen coins adds up to 408. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {31: 12, 40: 17, 32: 19, 26: 14, 12: 1, 5: 3, 36: 1, 33: 5, 3: 2, 6: 1, 34: 19, 18: 18, 8: 7, 21: 11, 43: 20, 22: 20, 4: 4, 11: 6, 28: 20, 7: 3, 38: 13, 24: 12, 19: 16, 10: 7, 14: 9, 29: 3}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "26", "opt_solution": "[36, 6, 29, 33, 33, 43, 40, 38, 24, 31, 31, 31, 12, 21]", "opt_solution_cost": "125", "opt_solution_compute_t": "0.06368541717529297", "solution_depth": "14", "max_successor_states": "42", "num_vars_per_state": "42", "is_feasible_args": "[[8, 31, 28, 24, 19, 18, 26, 31, 43, 32, 3, 21, 21, 10, 36, 40, 19, 38, 3, 5, 24, 12, 11, 14, 40, 7, 19, 4, 22, 5, 33, 31, 40, 7, 5, 34, 33, 22, 14, 6, 14, 29]]", "is_correct_args": "[[8, 31, 28, 24, 19, 18, 26, 31, 43, 32, 3, 21, 21, 10, 36, 40, 19, 38, 3, 5, 24, 12, 11, 14, 40, 7, 19, 4, 22, 5, 33, 31, 40, 7, 5, 34, 33, 22, 14, 6, 14, 29], {\"31\": 12, \"40\": 17, \"32\": 19, \"26\": 14, \"12\": 1, \"5\": 3, \"36\": 1, \"33\": 5, \"3\": 2, \"6\": 1, \"34\": 19, \"18\": 18, \"8\": 7, \"21\": 11, \"43\": 20, \"22\": 20, \"4\": 4, \"11\": 6, \"28\": 20, \"7\": 3, \"38\": 13, \"24\": 12, \"19\": 16, \"10\": 7, \"14\": 9, \"29\": 3}, 408]", "A*_args": "[\"[8, 31, 28, 24, 19, 18, 26, 31, 43, 32, 3, 21, 21, 10, 36, 40, 19, 38, 3, 5, 24, 12, 11, 14, 40, 7, 19, 4, 22, 5, 33, 31, 40, 7, 5, 34, 33, 22, 14, 6, 14, 29]\", \"{31: 12, 40: 17, 32: 19, 26: 14, 12: 1, 5: 3, 36: 1, 33: 5, 3: 2, 6: 1, 34: 19, 18: 18, 8: 7, 21: 11, 43: 20, 22: 20, 4: 4, 11: 6, 28: 20, 7: 3, 38: 13, 24: 12, 19: 16, 10: 7, 14: 9, 29: 3}\", \"408\"]"}
{"diff_sorted_id": "75", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 5 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 8 balls. It is not allowed to place a ball in a tube that already has 8 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Red', 'Blue', 'Blue', 'Red'], ['Green', 'Green', 'Red', 'Red', 'Green'], ['Blue', 'Blue', 'Green', 'Blue', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "9", "opt_solution": "[[0, 1], [0, 1], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [0, 2], [0, 1], [0, 1], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [1, 2], [0, 1]]", "opt_solution_cost": "27", "opt_solution_compute_t": "153.86922955513", "solution_depth": "27", "max_successor_states": "6", "num_vars_per_state": "15", "is_feasible_args": "[[[\"Red\", \"Red\", \"Blue\", \"Blue\", \"Red\"], [\"Green\", \"Green\", \"Red\", \"Red\", \"Green\"], [\"Blue\", \"Blue\", \"Green\", \"Blue\", \"Green\"]], 8]", "is_correct_args": "[[[\"Red\", \"Red\", \"Blue\", \"Blue\", \"Red\"], [\"Green\", \"Green\", \"Red\", \"Red\", \"Green\"], [\"Blue\", \"Blue\", \"Green\", \"Blue\", \"Green\"]], 8]", "A*_args": "[\"[['Red', 'Red', 'Blue', 'Blue', 'Red'], ['Green', 'Green', 'Red', 'Red', 'Green'], ['Blue', 'Blue', 'Green', 'Blue', 'Green']]\", \"8\"]"}
{"diff_sorted_id": "75", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 33 to 78 (33 included in the range but 78 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '58' 'x' 'x']\n ['x' 'x' 'x' '70']\n ['x' '48' '52' 'x']\n ['x' '43' 'x' '67']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "15", "opt_solution": "[[0, 2, 51], [1, 0, 38], [1, 2, 47], [2, 2, 44], [3, 0, 42], [3, 2, 23], [3, 3, 22]]", "opt_solution_cost": "563", "opt_solution_compute_t": "0.643829345703125", "solution_depth": "7", "max_successor_states": "45", "num_vars_per_state": "16", "is_feasible_args": "[\"[['37', '50', '', '70'], ['', '46', '', '65'], ['41', '43', '', '49'], ['', '30', '', '']]\", 22, 72]", "is_correct_args": "[\"[['37', '50', '', '70'], ['', '46', '', '65'], ['41', '43', '', '49'], ['', '30', '', '']]\", 22, 72]", "A*_args": "[\"[['37', '50', '', '70'], ['', '46', '', '65'], ['41', '43', '', '49'], ['', '30', '', '']]\", \"22\", \"72\"]"}
{"diff_sorted_id": "75", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 6 to 47. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 125, 51, None for columns 1 to 2 respectively, and the sums of rows must be None, 101, 108, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 90. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x' 'x']\n ['28' '33' 'x' 'x']\n ['16' 'x' 'x' '37']\n ['36' '18' '7' '23']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 8], [0, 1, 40], [0, 2, 9], [0, 3, 6], [1, 2, 14], [1, 3, 26], [2, 1, 34], [2, 2, 21]]", "opt_solution_cost": "356", "opt_solution_compute_t": "132.15215873718262", "solution_depth": "8", "max_successor_states": "31", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '', ''], ['28', '33', '', ''], ['16', '', '', '37'], ['36', '18', '7', '23']]\", 4, 6, 47]", "is_correct_args": "[\"[['', '', '', ''], ['28', '33', '', ''], ['16', '', '', '37'], ['36', '18', '7', '23']]\", 6, 47, [1, 3], [1, 3], [125, 51], [101, 108], 90]", "A*_args": "[\"[['', '', '', ''], ['28', '33', '', ''], ['16', '', '', '37'], ['36', '18', '7', '23']]\", \"6\", \"47\", \"[None, 125, 51, None]\", \"[None, 101, 108, None]\", \"90\"]"}
{"diff_sorted_id": "75", "problem_statement": "In 'Restricted Sorting', there are 10 stacks each with a capacity of 6 blocks, with 5 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 5 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 8, 1: 8, 2: 10, 3: 6, 4: 8, 5: 4, 6: 3, 7: 7, 8: 11, 9: 9}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['White', 'Green', 'Red', 'Blue', 'Red', 'Yellow'], ['Black', 'Black', 'White', 'Blue', 'Green', 'Green'], ['White', 'Blue', 'White', 'Yellow', 'Black', 'Green'], [], [], [], [], ['Green', 'Yellow', 'Red', 'White', 'Blue', 'Black'], ['Yellow', 'Red', 'Blue', 'Red', 'Black', 'Yellow'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "3", "opt_solution": "[[0, 6], [0, 5], [7, 5], [1, 3], [1, 3], [1, 6], [1, 4], [7, 9], [8, 9], [2, 6], [2, 4], [2, 6], [2, 9], [2, 3], [1, 5], [1, 5], [7, 1], [7, 6], [7, 4], [0, 1], [0, 4], [0, 1], [8, 1], [8, 4], [8, 1], [8, 3], [0, 9], [8, 9], [7, 3], [2, 5]]", "opt_solution_cost": "190", "opt_solution_compute_t": "0.2266242504119873", "solution_depth": "30", "max_successor_states": "90", "num_vars_per_state": "30", "is_feasible_args": "[[[\"White\", \"Green\", \"Red\", \"Blue\", \"Red\", \"Yellow\"], [\"Black\", \"Black\", \"White\", \"Blue\", \"Green\", \"Green\"], [\"White\", \"Blue\", \"White\", \"Yellow\", \"Black\", \"Green\"], [], [], [], [], [\"Green\", \"Yellow\", \"Red\", \"White\", \"Blue\", \"Black\"], [\"Yellow\", \"Red\", \"Blue\", \"Red\", \"Black\", \"Yellow\"], []], 6, {\"0\": 8, \"1\": 8, \"2\": 10, \"3\": 6, \"4\": 8, \"5\": 4, \"6\": 3, \"7\": 7, \"8\": 11, \"9\": 9}]", "is_correct_args": "[[[\"White\", \"Green\", \"Red\", \"Blue\", \"Red\", \"Yellow\"], [\"Black\", \"Black\", \"White\", \"Blue\", \"Green\", \"Green\"], [\"White\", \"Blue\", \"White\", \"Yellow\", \"Black\", \"Green\"], [], [], [], [], [\"Green\", \"Yellow\", \"Red\", \"White\", \"Blue\", \"Black\"], [\"Yellow\", \"Red\", \"Blue\", \"Red\", \"Black\", \"Yellow\"], []], 6, {\"0\": 8, \"1\": 8, \"2\": 10, \"3\": 6, \"4\": 8, \"5\": 4, \"6\": 3, \"7\": 7, \"8\": 11, \"9\": 9}, 5]", "A*_args": "[\"[['White', 'Green', 'Red', 'Blue', 'Red', 'Yellow'], ['Black', 'Black', 'White', 'Blue', 'Green', 'Green'], ['White', 'Blue', 'White', 'Yellow', 'Black', 'Green'], [], [], [], [], ['Green', 'Yellow', 'Red', 'White', 'Blue', 'Black'], ['Yellow', 'Red', 'Blue', 'Red', 'Black', 'Yellow'], []]\", \"{0: 8, 1: 8, 2: 10, 3: 6, 4: 8, 5: 4, 6: 3, 7: 7, 8: 11, 9: 9}\", \"6\", \"5\"]"}
{"diff_sorted_id": "75", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (7, 1) to his destination workshop at index (2, 10), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 7, and district 3 covering rows 8 to 12. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 9 4 8 x x 4 x 8 12 x x 14]\n[17 x 3 x 6 x 12 2 x x x 5 19]\n[x 8 8 x 5 x 15 14 14 3 10 12 3]\n[4 x 16 x x 11 12 x x 6 5 18 19]\n[x 4 9 17 x x x 13 4 7 x 2 16]\n[3 6 x x x 10 5 x 18 10 9 20 4]\n[x x x 14 18 x x x x 16 x x 4]\n[14 12 x 4 12 11 19 x 3 2 x 13 x]\n[19 6 2 18 x x 8 7 1 12 19 x x]\n[x 9 16 17 5 12 19 8 x 3 10 x x]\n[x 10 3 x 14 16 2 16 4 10 18 15 x]\n[15 5 5 x 13 x 3 7 x 4 1 17 15]\n[5 2 6 x x x x 8 16 x x x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "5", "opt_solution": "[[7, 1], [8, 1], [8, 2], [8, 3], [7, 3], [7, 4], [7, 5], [7, 6], [8, 6], [8, 7], [8, 8], [7, 8], [7, 9], [6, 9], [5, 9], [4, 9], [3, 9], [2, 9], [2, 10]]", "opt_solution_cost": "145", "opt_solution_compute_t": "0.027338504791259766", "solution_depth": "19", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"9\", \"4\", \"8\", \"x\", \"x\", \"4\", \"x\", \"8\", \"12\", \"x\", \"x\", \"14\"], [\"17\", \"x\", \"3\", \"x\", \"6\", \"x\", \"12\", \"2\", \"x\", \"x\", \"x\", \"5\", \"19\"], [\"x\", \"8\", \"8\", \"x\", \"5\", \"x\", \"15\", \"14\", \"14\", \"3\", \"10\", \"12\", \"3\"], [\"4\", \"x\", \"16\", \"x\", \"x\", \"11\", \"12\", \"x\", \"x\", \"6\", \"5\", \"18\", \"19\"], [\"x\", \"4\", \"9\", \"17\", \"x\", \"x\", \"x\", \"13\", \"4\", \"7\", \"x\", \"2\", \"16\"], [\"3\", \"6\", \"x\", \"x\", \"x\", \"10\", \"5\", \"x\", \"18\", \"10\", \"9\", \"20\", \"4\"], [\"x\", \"x\", \"x\", \"14\", \"18\", \"x\", \"x\", \"x\", \"x\", \"16\", \"x\", \"x\", \"4\"], [\"14\", \"12\", \"x\", \"4\", \"12\", \"11\", \"19\", \"x\", \"3\", \"2\", \"x\", \"13\", \"x\"], [\"19\", \"6\", \"2\", \"18\", \"x\", \"x\", \"8\", \"7\", \"1\", \"12\", \"19\", \"x\", \"x\"], [\"x\", \"9\", \"16\", \"17\", \"5\", \"12\", \"19\", \"8\", \"x\", \"3\", \"10\", \"x\", \"x\"], [\"x\", \"10\", \"3\", \"x\", \"14\", \"16\", \"2\", \"16\", \"4\", \"10\", \"18\", \"15\", \"x\"], [\"15\", \"5\", \"5\", \"x\", \"13\", \"x\", \"3\", \"7\", \"x\", \"4\", \"1\", \"17\", \"15\"], [\"5\", \"2\", \"6\", \"x\", \"x\", \"x\", \"x\", \"8\", \"16\", \"x\", \"x\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"9\", \"4\", \"8\", \"x\", \"x\", \"4\", \"x\", \"8\", \"12\", \"x\", \"x\", \"14\"], [\"17\", \"x\", \"3\", \"x\", \"6\", \"x\", \"12\", \"2\", \"x\", \"x\", \"x\", \"5\", \"19\"], [\"x\", \"8\", \"8\", \"x\", \"5\", \"x\", \"15\", \"14\", \"14\", \"3\", \"10\", \"12\", \"3\"], [\"4\", \"x\", \"16\", \"x\", \"x\", \"11\", \"12\", \"x\", \"x\", \"6\", \"5\", \"18\", \"19\"], [\"x\", \"4\", \"9\", \"17\", \"x\", \"x\", \"x\", \"13\", \"4\", \"7\", \"x\", \"2\", \"16\"], [\"3\", \"6\", \"x\", \"x\", \"x\", \"10\", \"5\", \"x\", \"18\", \"10\", \"9\", \"20\", \"4\"], [\"x\", \"x\", \"x\", \"14\", \"18\", \"x\", \"x\", \"x\", \"x\", \"16\", \"x\", \"x\", \"4\"], [\"14\", \"12\", \"x\", \"4\", \"12\", \"11\", \"19\", \"x\", \"3\", \"2\", \"x\", \"13\", \"x\"], [\"19\", \"6\", \"2\", \"18\", \"x\", \"x\", \"8\", \"7\", \"1\", \"12\", \"19\", \"x\", \"x\"], [\"x\", \"9\", \"16\", \"17\", \"5\", \"12\", \"19\", \"8\", \"x\", \"3\", \"10\", \"x\", \"x\"], [\"x\", \"10\", \"3\", \"x\", \"14\", \"16\", \"2\", \"16\", \"4\", \"10\", \"18\", \"15\", \"x\"], [\"15\", \"5\", \"5\", \"x\", \"13\", \"x\", \"3\", \"7\", \"x\", \"4\", \"1\", \"17\", \"15\"], [\"5\", \"2\", \"6\", \"x\", \"x\", \"x\", \"x\", \"8\", \"16\", \"x\", \"x\", \"x\", \"x\"]], [7, 1], [2, 10], 2, 7]", "A*_args": "[\"[['x', '9', '4', '8', 'x', 'x', '4', 'x', '8', '12', 'x', 'x', '14'], ['17', 'x', '3', 'x', '6', 'x', '12', '2', 'x', 'x', 'x', '5', '19'], ['x', '8', '8', 'x', '5', 'x', '15', '14', '14', '3', '10', '12', '3'], ['4', 'x', '16', 'x', 'x', '11', '12', 'x', 'x', '6', '5', '18', '19'], ['x', '4', '9', '17', 'x', 'x', 'x', '13', '4', '7', 'x', '2', '16'], ['3', '6', 'x', 'x', 'x', '10', '5', 'x', '18', '10', '9', '20', '4'], ['x', 'x', 'x', '14', '18', 'x', 'x', 'x', 'x', '16', 'x', 'x', '4'], ['14', '12', 'x', '4', '12', '11', '19', 'x', '3', '2', 'x', '13', 'x'], ['19', '6', '2', '18', 'x', 'x', '8', '7', '1', '12', '19', 'x', 'x'], ['x', '9', '16', '17', '5', '12', '19', '8', 'x', '3', '10', 'x', 'x'], ['x', '10', '3', 'x', '14', '16', '2', '16', '4', '10', '18', '15', 'x'], ['15', '5', '5', 'x', '13', 'x', '3', '7', 'x', '4', '1', '17', '15'], ['5', '2', '6', 'x', 'x', 'x', 'x', '8', '16', 'x', 'x', 'x', 'x']]\", \"(7, 1)\", \"(2, 10)\", \"2\", \"7\"]"}
{"diff_sorted_id": "75", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 13x13. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 7) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (12, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 1 1 0 1 0 0 1 1 1 1 0\n1 0 0 0 0 1 0 0 1 1 1 1 1\n0 0 1 0 0 0 1 1 1 1 0 1 0\n1 1 1 1 0 0 1 0 1 1 0 1 0\n1 0 1 1 0 1 0 0 0 0 0 1 1\n0 0 0 0 0 0 0 1 1 1 1 1 1\n1 0 0 0 1 1 1 0 1 0 1 1 1\n0 0 0 0 1 1 1 1 0 1 0 1 1\n0 0 1 1 1 1 1 1 1 1 1 0 0\n0 0 1 1 1 0 1 0 1 0 1 1 0\n0 0 1 0 1 0 0 1 0 0 0 0 0\n0 0 0 1 1 1 1 0 0 1 1 0 1\n0 0 1 1 1 1 0 0 0 1 1 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "13", "opt_solution": "[[0, 7], [1, 6], [2, 5], [3, 4], [4, 4], [5, 3], [6, 3], [7, 3], [7, 2], [7, 1], [8, 1], [9, 1], [10, 1], [11, 1], [11, 0], [12, 0]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.021950483322143555", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0], [1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0], [1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0], [0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1], [0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1]]\", 4]", "is_correct_args": "[\"[[0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0], [1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0], [1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0], [0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1], [0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1]]\", [0, 7], [12, 0], 4]", "A*_args": "[\"[[0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0], [1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0], [1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0], [0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1], [0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1]]\", \"(0, 7)\", \"(12, 0)\", \"4\"]"}
{"diff_sorted_id": "75", "problem_statement": "Given 7 labeled water jugs with capacities 98, 121, 131, 126, 141, 125, 20 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 309, 395, 407, 429 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 131, 4], [\"+\", 141, 4], [\"+\", 141, 4], [\"-\", 125, 4], [\"+\", 141, 4], [\"+\", 125, 3], [\"+\", 141, 3], [\"+\", 141, 3], [\"+\", 125, 2], [\"+\", 125, 2], [\"+\", 20, 2], [\"+\", 125, 2], [\"+\", 141, 1], [\"+\", 141, 1], [\"-\", 98, 1], [\"+\", 125, 1]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.04790830612182617", "solution_depth": "16", "max_successor_states": "56", "num_vars_per_state": "3", "is_feasible_args": "[[98, 121, 131, 126, 141, 125, 20], [309, 395, 407, 429]]", "is_correct_args": "[[98, 121, 131, 126, 141, 125, 20], [309, 395, 407, 429]]", "A*_args": "[\"[98, 121, 131, 126, 141, 125, 20]\", \"[309, 395, 407, 429]\"]"}
{"diff_sorted_id": "76", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[86, 78, 77, 39, 76], [54, 45, 25, 59, 21], [38, 46, 43, 27, '_']]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[21, 59, 25, 43, 27, 25, 39, 76, 59, 39, 43, 45, 46, 27, 25, 21]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.03995919227600098", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[86, 78, 77, 39, 76], [54, 45, 25, 59, 21], [38, 46, 43, 27, \"_\"]]]", "is_correct_args": "[[[86, 78, 77, 39, 76], [54, 45, 25, 59, 21], [38, 46, 43, 27, \"_\"]]]", "A*_args": "[\"[[86, 78, 77, 39, 76], [54, 45, 25, 59, 21], [38, 46, 43, 27, '_']]\"]"}
{"diff_sorted_id": "76", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: quad, bhang, decay, honor, picky   The initial board: [['h', 'q', 'n', 'a', '_'], ['b', 'y', 'a', 'd', 'g'], ['d', 'e', 'c', 'a', 'o'], ['h', 'o', 'n', 'u', 'r'], ['p', 'i', 'c', 'k', 'y']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-left\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.18000054359436035", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"h\", \"q\", \"n\", \"a\", \"_\"], [\"b\", \"y\", \"a\", \"d\", \"g\"], [\"d\", \"e\", \"c\", \"a\", \"o\"], [\"h\", \"o\", \"n\", \"u\", \"r\"], [\"p\", \"i\", \"c\", \"k\", \"y\"]]]", "is_correct_args": "[[[\"h\", \"q\", \"n\", \"a\", \"_\"], [\"b\", \"y\", \"a\", \"d\", \"g\"], [\"d\", \"e\", \"c\", \"a\", \"o\"], [\"h\", \"o\", \"n\", \"u\", \"r\"], [\"p\", \"i\", \"c\", \"k\", \"y\"]], [\"quad\", \"bhang\", \"decay\", \"honor\", \"picky\"]]", "A*_args": "[\"[['h', 'q', 'n', 'a', '_'], ['b', 'y', 'a', 'd', 'g'], ['d', 'e', 'c', 'a', 'o'], ['h', 'o', 'n', 'u', 'r'], ['p', 'i', 'c', 'k', 'y']]\", \"['quad', 'bhang', 'decay', 'honor', 'picky']\"]"}
{"diff_sorted_id": "76", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'D'. Our task is to visit city K and city X excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from X and K, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  Q A E R D G X K B Z W F O L \nQ 0 1 0 0 0 1 0 0 0 0 0 0 0 1 \nA 0 0 0 0 0 0 1 0 1 0 0 0 1 0 \nE 1 0 0 0 0 0 0 0 1 1 0 0 0 0 \nR 1 1 0 0 0 0 0 0 0 0 1 0 0 0 \nD 0 0 0 0 0 0 0 0 0 1 0 0 0 0 \nG 0 1 1 0 0 0 0 0 1 1 0 1 1 0 \nX 0 0 1 0 0 1 0 1 1 0 0 0 0 1 \nK 0 0 1 1 0 0 0 0 0 1 1 0 0 0 \nB 0 0 0 0 0 0 0 1 0 0 1 0 0 1 \nZ 0 1 0 0 0 0 0 0 1 0 0 1 1 0 \nW 0 0 0 0 0 1 0 0 0 1 0 0 0 1 \nF 0 0 0 1 0 1 0 1 1 0 1 0 1 1 \nO 0 0 0 0 0 0 0 1 1 0 0 0 0 0 \nL 0 1 0 1 0 0 1 1 0 0 0 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[\"D\", \"Z\", \"A\", \"X\", \"K\", \"W\", \"L\", \"X\", \"K\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.0372929573059082", "solution_depth": "9", "max_successor_states": "14", "num_vars_per_state": "17", "is_feasible_args": "[[[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0], [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0]], [\"Q\", \"A\", \"E\", \"R\", \"D\", \"G\", \"X\", \"K\", \"B\", \"Z\", \"W\", \"F\", \"O\", \"L\"], \"K\", \"X\"]", "is_correct_args": "[[[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0], [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0]], [\"Q\", \"A\", \"E\", \"R\", \"D\", \"G\", \"X\", \"K\", \"B\", \"Z\", \"W\", \"F\", \"O\", \"L\"], \"D\", \"K\", \"X\"]", "A*_args": "[\"[[0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0], [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0]]\", \"['Q', 'A', 'E', 'R', 'D', 'G', 'X', 'K', 'B', 'Z', 'W', 'F', 'O', 'L']\", \"['D']\", \"['K', 'X']\"]"}
{"diff_sorted_id": "76", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [8, 8, 6, 36, 7, 36, 33, 3, 31, 17, 21, 28, 41, 17, 23, 16, 39, 2, 3, 40, 23, 20, 5, 30, 8, 28, 17, 34, 38, 26, 16, 21, 15, 21, 11, 33, 5, 33, 2, 27, 26, 21, 14, 13, 7, 23], such that the sum of the chosen coins adds up to 403. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {28: 16, 5: 1, 3: 3, 40: 18, 33: 20, 34: 12, 20: 4, 39: 13, 2: 2, 31: 11, 36: 2, 17: 14, 7: 1, 14: 6, 23: 12, 8: 1, 30: 15, 27: 13, 15: 2, 21: 3, 11: 6, 26: 14, 41: 2, 38: 10, 6: 5, 16: 4, 13: 11}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "27", "opt_solution": "[7, 41, 36, 8, 15, 21, 21, 8, 21, 8, 21, 20, 16, 39, 38, 36, 16, 31]", "opt_solution_cost": "70", "opt_solution_compute_t": "0.0619659423828125", "solution_depth": "18", "max_successor_states": "46", "num_vars_per_state": "46", "is_feasible_args": "[[8, 8, 6, 36, 7, 36, 33, 3, 31, 17, 21, 28, 41, 17, 23, 16, 39, 2, 3, 40, 23, 20, 5, 30, 8, 28, 17, 34, 38, 26, 16, 21, 15, 21, 11, 33, 5, 33, 2, 27, 26, 21, 14, 13, 7, 23]]", "is_correct_args": "[[8, 8, 6, 36, 7, 36, 33, 3, 31, 17, 21, 28, 41, 17, 23, 16, 39, 2, 3, 40, 23, 20, 5, 30, 8, 28, 17, 34, 38, 26, 16, 21, 15, 21, 11, 33, 5, 33, 2, 27, 26, 21, 14, 13, 7, 23], {\"28\": 16, \"5\": 1, \"3\": 3, \"40\": 18, \"33\": 20, \"34\": 12, \"20\": 4, \"39\": 13, \"2\": 2, \"31\": 11, \"36\": 2, \"17\": 14, \"7\": 1, \"14\": 6, \"23\": 12, \"8\": 1, \"30\": 15, \"27\": 13, \"15\": 2, \"21\": 3, \"11\": 6, \"26\": 14, \"41\": 2, \"38\": 10, \"6\": 5, \"16\": 4, \"13\": 11}, 403]", "A*_args": "[\"[8, 8, 6, 36, 7, 36, 33, 3, 31, 17, 21, 28, 41, 17, 23, 16, 39, 2, 3, 40, 23, 20, 5, 30, 8, 28, 17, 34, 38, 26, 16, 21, 15, 21, 11, 33, 5, 33, 2, 27, 26, 21, 14, 13, 7, 23]\", \"{28: 16, 5: 1, 3: 3, 40: 18, 33: 20, 34: 12, 20: 4, 39: 13, 2: 2, 31: 11, 36: 2, 17: 14, 7: 1, 14: 6, 23: 12, 8: 1, 30: 15, 27: 13, 15: 2, 21: 3, 11: 6, 26: 14, 41: 2, 38: 10, 6: 5, 16: 4, 13: 11}\", \"403\"]"}
{"diff_sorted_id": "76", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Red', 'Red', 'Green', 'Blue'], ['Green', 'Blue', 'Blue', 'Blue', 'Red', 'Red'], ['Green', 'Green', 'Green', 'Blue', 'Red', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[1, 2], [1, 0], [1, 0], [1, 0], [1, 2], [1, 2], [0, 1], [0, 1], [0, 1], [0, 1], [2, 1], [2, 1], [0, 2], [0, 1], [0, 1], [0, 2], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [1, 0], [1, 2], [1, 2], [1, 2], [1, 2], [0, 1], [0, 1]]", "opt_solution_cost": "31", "opt_solution_compute_t": "491.6853485107422", "solution_depth": "31", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Red\", \"Red\", \"Green\", \"Blue\"], [\"Green\", \"Blue\", \"Blue\", \"Blue\", \"Red\", \"Red\"], [\"Green\", \"Green\", \"Green\", \"Blue\", \"Red\", \"Red\"]], 9]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Red\", \"Red\", \"Green\", \"Blue\"], [\"Green\", \"Blue\", \"Blue\", \"Blue\", \"Red\", \"Red\"], [\"Green\", \"Green\", \"Green\", \"Blue\", \"Red\", \"Red\"]], 9]", "A*_args": "[\"[['Blue', 'Green', 'Red', 'Red', 'Green', 'Blue'], ['Green', 'Blue', 'Blue', 'Blue', 'Red', 'Red'], ['Green', 'Green', 'Green', 'Blue', 'Red', 'Red']]\", \"9\"]"}
{"diff_sorted_id": "76", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 28 to 78 (28 included in the range but 78 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '53' '60' '67']\n ['x' 'x' '72' 'x']\n ['50' '56' '74' 'x']\n ['54' '65' '76' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "11", "opt_solution": "[[0, 2, 52], [1, 2, 56], [1, 3, 65], [2, 0, 54], [3, 0, 57], [3, 1, 58], [3, 3, 75]]", "opt_solution_cost": "735", "opt_solution_compute_t": "44.25528311729431", "solution_depth": "7", "max_successor_states": "50", "num_vars_per_state": "16", "is_feasible_args": "[\"[['47', '51', '', '64'], ['50', '53', '', ''], ['', '55', '68', '74'], ['', '', '72', '']]\", 37, 87]", "is_correct_args": "[\"[['47', '51', '', '64'], ['50', '53', '', ''], ['', '55', '68', '74'], ['', '', '72', '']]\", 37, 87]", "A*_args": "[\"[['47', '51', '', '64'], ['50', '53', '', ''], ['', '55', '68', '74'], ['', '', '72', '']]\", \"37\", \"87\"]"}
{"diff_sorted_id": "76", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 6 to 47. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 128, 80, None for columns 1 to 2 respectively, and the sums of rows must be None, 94, 109, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 99. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['26' '38' '27' 'x']\n ['x' 'x' 'x' '19']\n ['x' '43' 'x' 'x']\n ['42' 'x' '34' '20']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 3, 8], [1, 0, 29], [1, 1, 40], [1, 2, 6], [2, 0, 9], [2, 2, 13], [2, 3, 44], [3, 1, 7]]", "opt_solution_cost": "405", "opt_solution_compute_t": "1.2350444793701172", "solution_depth": "8", "max_successor_states": "31", "num_vars_per_state": "16", "is_feasible_args": "[\"[['26', '38', '27', ''], ['', '', '', '19'], ['', '43', '', ''], ['42', '', '34', '20']]\", 4, 6, 47]", "is_correct_args": "[\"[['26', '38', '27', ''], ['', '', '', '19'], ['', '43', '', ''], ['42', '', '34', '20']]\", 6, 47, [1, 3], [1, 3], [128, 80], [94, 109], 99]", "A*_args": "[\"[['26', '38', '27', ''], ['', '', '', '19'], ['', '43', '', ''], ['42', '', '34', '20']]\", \"6\", \"47\", \"[None, 128, 80, None]\", \"[None, 94, 109, None]\", \"99\"]"}
{"diff_sorted_id": "76", "problem_statement": "In 'Restricted Sorting', there are 12 stacks each with a capacity of 7 blocks, with 6 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 6 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 7, 1: 9, 2: 13, 3: 3, 4: 4, 5: 4, 6: 6, 7: 11, 8: 12, 9: 3, 10: 13, 11: 5}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Black', 'Blue', 'Green', 'Green', 'Pink', 'Black', 'Red'], [], ['Green', 'White', 'Yellow', 'Red', 'White', 'Blue', 'Pink'], [], [], ['Black', 'Green', 'Black', 'Yellow', 'Black', 'Blue', 'Black'], ['Green', 'Blue', 'Yellow', 'Yellow', 'Red', 'Yellow', 'Pink'], ['Red', 'White', 'Blue', 'Pink', 'Red', 'Blue', 'White'], [], [], ['Red', 'White', 'Pink', 'Green', 'Yellow', 'White', 'Pink'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "4", "opt_solution": "[[0, 3], [0, 9], [2, 4], [6, 4], [6, 9], [7, 11], [10, 11], [5, 3], [5, 4], [0, 4], [0, 4], [0, 1], [0, 3], [0, 11], [7, 0], [10, 0], [7, 9], [7, 1], [7, 11], [7, 9], [10, 1], [10, 4], [10, 8], [10, 0], [2, 0], [2, 8], [2, 11], [2, 0], [2, 9], [5, 3], [5, 8], [5, 3], [5, 9], [5, 3], [6, 5], [6, 5], [6, 11], [6, 5], [2, 1], [6, 1], [10, 1], [7, 0], [8, 5], [8, 5], [8, 5]]", "opt_solution_cost": "246", "opt_solution_compute_t": "1.6125590801239014", "solution_depth": "45", "max_successor_states": "132", "num_vars_per_state": "42", "is_feasible_args": "[[[\"Black\", \"Blue\", \"Green\", \"Green\", \"Pink\", \"Black\", \"Red\"], [], [\"Green\", \"White\", \"Yellow\", \"Red\", \"White\", \"Blue\", \"Pink\"], [], [], [\"Black\", \"Green\", \"Black\", \"Yellow\", \"Black\", \"Blue\", \"Black\"], [\"Green\", \"Blue\", \"Yellow\", \"Yellow\", \"Red\", \"Yellow\", \"Pink\"], [\"Red\", \"White\", \"Blue\", \"Pink\", \"Red\", \"Blue\", \"White\"], [], [], [\"Red\", \"White\", \"Pink\", \"Green\", \"Yellow\", \"White\", \"Pink\"], []], 7, {\"0\": 7, \"1\": 9, \"2\": 13, \"3\": 3, \"4\": 4, \"5\": 4, \"6\": 6, \"7\": 11, \"8\": 12, \"9\": 3, \"10\": 13, \"11\": 5}]", "is_correct_args": "[[[\"Black\", \"Blue\", \"Green\", \"Green\", \"Pink\", \"Black\", \"Red\"], [], [\"Green\", \"White\", \"Yellow\", \"Red\", \"White\", \"Blue\", \"Pink\"], [], [], [\"Black\", \"Green\", \"Black\", \"Yellow\", \"Black\", \"Blue\", \"Black\"], [\"Green\", \"Blue\", \"Yellow\", \"Yellow\", \"Red\", \"Yellow\", \"Pink\"], [\"Red\", \"White\", \"Blue\", \"Pink\", \"Red\", \"Blue\", \"White\"], [], [], [\"Red\", \"White\", \"Pink\", \"Green\", \"Yellow\", \"White\", \"Pink\"], []], 7, {\"0\": 7, \"1\": 9, \"2\": 13, \"3\": 3, \"4\": 4, \"5\": 4, \"6\": 6, \"7\": 11, \"8\": 12, \"9\": 3, \"10\": 13, \"11\": 5}, 6]", "A*_args": "[\"[['Black', 'Blue', 'Green', 'Green', 'Pink', 'Black', 'Red'], [], ['Green', 'White', 'Yellow', 'Red', 'White', 'Blue', 'Pink'], [], [], ['Black', 'Green', 'Black', 'Yellow', 'Black', 'Blue', 'Black'], ['Green', 'Blue', 'Yellow', 'Yellow', 'Red', 'Yellow', 'Pink'], ['Red', 'White', 'Blue', 'Pink', 'Red', 'Blue', 'White'], [], [], ['Red', 'White', 'Pink', 'Green', 'Yellow', 'White', 'Pink'], []]\", \"{0: 7, 1: 9, 2: 13, 3: 3, 4: 4, 5: 4, 6: 6, 7: 11, 8: 12, 9: 3, 10: 13, 11: 5}\", \"7\", \"6\"]"}
{"diff_sorted_id": "76", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (4, 3) to his destination workshop at index (8, 13), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 7, and district 3 covering rows 8 to 13. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 12 8 4 4 16 8 x x 17 18 9 x 16]\n[2 9 x 1 4 13 20 11 2 x 11 7 14 12]\n[x x x x 17 15 8 12 x x 7 x x x]\n[2 2 x 5 14 x 1 5 4 14 7 x x x]\n[19 x 11 1 19 19 12 x 12 13 5 3 17 17]\n[x x x x x 1 x x 4 x x x 8 19]\n[6 x 10 x 7 1 11 x x 3 x 3 2 x]\n[19 x 3 11 x 6 11 x 12 14 10 x 11 18]\n[13 x x x x x 4 x x x x x 10 5]\n[19 x x 16 x x 18 x 8 x 2 11 x 12]\n[x 14 x 6 x 18 x 11 x x 14 11 2 x]\n[x x 6 8 10 8 14 x x 13 x 10 x 19]\n[x 19 x 7 12 17 x 15 x 16 19 x 5 x]\n[8 x 17 x x 5 15 x x 16 1 x x 17]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "6", "opt_solution": "[[4, 3], [3, 3], [3, 4], [2, 4], [2, 5], [2, 6], [3, 6], [3, 7], [3, 8], [3, 9], [3, 10], [4, 10], [4, 11], [4, 12], [5, 12], [6, 12], [7, 12], [8, 12], [8, 13]]", "opt_solution_cost": "151", "opt_solution_compute_t": "0.02843952178955078", "solution_depth": "19", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"12\", \"8\", \"4\", \"4\", \"16\", \"8\", \"x\", \"x\", \"17\", \"18\", \"9\", \"x\", \"16\"], [\"2\", \"9\", \"x\", \"1\", \"4\", \"13\", \"20\", \"11\", \"2\", \"x\", \"11\", \"7\", \"14\", \"12\"], [\"x\", \"x\", \"x\", \"x\", \"17\", \"15\", \"8\", \"12\", \"x\", \"x\", \"7\", \"x\", \"x\", \"x\"], [\"2\", \"2\", \"x\", \"5\", \"14\", \"x\", \"1\", \"5\", \"4\", \"14\", \"7\", \"x\", \"x\", \"x\"], [\"19\", \"x\", \"11\", \"1\", \"19\", \"19\", \"12\", \"x\", \"12\", \"13\", \"5\", \"3\", \"17\", \"17\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"1\", \"x\", \"x\", \"4\", \"x\", \"x\", \"x\", \"8\", \"19\"], [\"6\", \"x\", \"10\", \"x\", \"7\", \"1\", \"11\", \"x\", \"x\", \"3\", \"x\", \"3\", \"2\", \"x\"], [\"19\", \"x\", \"3\", \"11\", \"x\", \"6\", \"11\", \"x\", \"12\", \"14\", \"10\", \"x\", \"11\", \"18\"], [\"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"4\", \"x\", \"x\", \"x\", \"x\", \"x\", \"10\", \"5\"], [\"19\", \"x\", \"x\", \"16\", \"x\", \"x\", \"18\", \"x\", \"8\", \"x\", \"2\", \"11\", \"x\", \"12\"], [\"x\", \"14\", \"x\", \"6\", \"x\", \"18\", \"x\", \"11\", \"x\", \"x\", \"14\", \"11\", \"2\", \"x\"], [\"x\", \"x\", \"6\", \"8\", \"10\", \"8\", \"14\", \"x\", \"x\", \"13\", \"x\", \"10\", \"x\", \"19\"], [\"x\", \"19\", \"x\", \"7\", \"12\", \"17\", \"x\", \"15\", \"x\", \"16\", \"19\", \"x\", \"5\", \"x\"], [\"8\", \"x\", \"17\", \"x\", \"x\", \"5\", \"15\", \"x\", \"x\", \"16\", \"1\", \"x\", \"x\", \"17\"]]]", "is_correct_args": "[[[\"x\", \"12\", \"8\", \"4\", \"4\", \"16\", \"8\", \"x\", \"x\", \"17\", \"18\", \"9\", \"x\", \"16\"], [\"2\", \"9\", \"x\", \"1\", \"4\", \"13\", \"20\", \"11\", \"2\", \"x\", \"11\", \"7\", \"14\", \"12\"], [\"x\", \"x\", \"x\", \"x\", \"17\", \"15\", \"8\", \"12\", \"x\", \"x\", \"7\", \"x\", \"x\", \"x\"], [\"2\", \"2\", \"x\", \"5\", \"14\", \"x\", \"1\", \"5\", \"4\", \"14\", \"7\", \"x\", \"x\", \"x\"], [\"19\", \"x\", \"11\", \"1\", \"19\", \"19\", \"12\", \"x\", \"12\", \"13\", \"5\", \"3\", \"17\", \"17\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"1\", \"x\", \"x\", \"4\", \"x\", \"x\", \"x\", \"8\", \"19\"], [\"6\", \"x\", \"10\", \"x\", \"7\", \"1\", \"11\", \"x\", \"x\", \"3\", \"x\", \"3\", \"2\", \"x\"], [\"19\", \"x\", \"3\", \"11\", \"x\", \"6\", \"11\", \"x\", \"12\", \"14\", \"10\", \"x\", \"11\", \"18\"], [\"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"4\", \"x\", \"x\", \"x\", \"x\", \"x\", \"10\", \"5\"], [\"19\", \"x\", \"x\", \"16\", \"x\", \"x\", \"18\", \"x\", \"8\", \"x\", \"2\", \"11\", \"x\", \"12\"], [\"x\", \"14\", \"x\", \"6\", \"x\", \"18\", \"x\", \"11\", \"x\", \"x\", \"14\", \"11\", \"2\", \"x\"], [\"x\", \"x\", \"6\", \"8\", \"10\", \"8\", \"14\", \"x\", \"x\", \"13\", \"x\", \"10\", \"x\", \"19\"], [\"x\", \"19\", \"x\", \"7\", \"12\", \"17\", \"x\", \"15\", \"x\", \"16\", \"19\", \"x\", \"5\", \"x\"], [\"8\", \"x\", \"17\", \"x\", \"x\", \"5\", \"15\", \"x\", \"x\", \"16\", \"1\", \"x\", \"x\", \"17\"]], [4, 3], [8, 13], 2, 7]", "A*_args": "[\"[['x', '12', '8', '4', '4', '16', '8', 'x', 'x', '17', '18', '9', 'x', '16'], ['2', '9', 'x', '1', '4', '13', '20', '11', '2', 'x', '11', '7', '14', '12'], ['x', 'x', 'x', 'x', '17', '15', '8', '12', 'x', 'x', '7', 'x', 'x', 'x'], ['2', '2', 'x', '5', '14', 'x', '1', '5', '4', '14', '7', 'x', 'x', 'x'], ['19', 'x', '11', '1', '19', '19', '12', 'x', '12', '13', '5', '3', '17', '17'], ['x', 'x', 'x', 'x', 'x', '1', 'x', 'x', '4', 'x', 'x', 'x', '8', '19'], ['6', 'x', '10', 'x', '7', '1', '11', 'x', 'x', '3', 'x', '3', '2', 'x'], ['19', 'x', '3', '11', 'x', '6', '11', 'x', '12', '14', '10', 'x', '11', '18'], ['13', 'x', 'x', 'x', 'x', 'x', '4', 'x', 'x', 'x', 'x', 'x', '10', '5'], ['19', 'x', 'x', '16', 'x', 'x', '18', 'x', '8', 'x', '2', '11', 'x', '12'], ['x', '14', 'x', '6', 'x', '18', 'x', '11', 'x', 'x', '14', '11', '2', 'x'], ['x', 'x', '6', '8', '10', '8', '14', 'x', 'x', '13', 'x', '10', 'x', '19'], ['x', '19', 'x', '7', '12', '17', 'x', '15', 'x', '16', '19', 'x', '5', 'x'], ['8', 'x', '17', 'x', 'x', '5', '15', 'x', 'x', '16', '1', 'x', 'x', '17']]\", \"(4, 3)\", \"(8, 13)\", \"2\", \"7\"]"}
{"diff_sorted_id": "76", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 14x14. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (2, 12) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (10, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 1 1 1 1 1 1 1 1 1 1 1\n1 1 1 1 1 0 0 0 1 0 0 1 1 1\n1 1 1 1 0 0 0 0 0 0 0 1 0 0\n0 0 1 1 1 0 0 0 1 0 0 0 0 0\n0 0 1 1 0 0 0 1 1 1 0 0 0 1\n0 0 1 1 0 1 0 0 1 0 1 1 1 0\n1 0 1 1 0 1 0 1 1 1 1 1 1 1\n0 1 1 1 0 0 1 0 1 1 1 1 0 1\n0 0 0 0 0 0 1 1 1 1 0 0 0 0\n0 0 1 1 1 0 0 1 1 1 1 0 1 0\n1 0 1 1 0 0 1 1 1 1 0 1 1 0\n1 1 0 1 0 0 1 0 0 1 0 0 0 1\n1 1 1 1 1 1 1 1 0 1 1 1 0 1\n1 0 0 1 1 1 1 1 1 0 1 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[[2, 12], [3, 11], [2, 10], [2, 9], [2, 8], [2, 7], [3, 7], [3, 6], [4, 6], [4, 5], [4, 4], [5, 4], [6, 4], [7, 4], [8, 3], [8, 2], [9, 1], [10, 1]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.029042482376098633", "solution_depth": "18", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1], [0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1]]\", 4]", "is_correct_args": "[\"[[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1], [0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1]]\", [2, 12], [10, 1], 4]", "A*_args": "[\"[[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1], [0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1], [1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1]]\", \"(2, 12)\", \"(10, 1)\", \"4\"]"}
{"diff_sorted_id": "76", "problem_statement": "Given 7 labeled water jugs with capacities 117, 118, 23, 86, 109, 128, 104, 61 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 367, 390, 400, 470 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 86, 4], [\"+\", 128, 4], [\"+\", 128, 4], [\"+\", 128, 4], [\"+\", 61, 3], [\"+\", 104, 3], [\"+\", 117, 3], [\"+\", 118, 3], [\"+\", 109, 2], [\"+\", 109, 2], [\"+\", 86, 2], [\"+\", 86, 2], [\"+\", 109, 1], [\"+\", 117, 1], [\"+\", 23, 1], [\"+\", 118, 1]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.038893938064575195", "solution_depth": "16", "max_successor_states": "64", "num_vars_per_state": "3", "is_feasible_args": "[[117, 118, 23, 86, 109, 128, 104, 61], [367, 390, 400, 470]]", "is_correct_args": "[[117, 118, 23, 86, 109, 128, 104, 61], [367, 390, 400, 470]]", "A*_args": "[\"[117, 118, 23, 86, 109, 128, 104, 61]\", \"[367, 390, 400, 470]\"]"}
{"diff_sorted_id": "77", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[60, 66, 46, 8, 36], [81, '_', 88, 70, 24], [20, 17, 6, 62, 28]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[88, 46, 66, 88, 81, 60, 88, 81, 46, 70, 8, 66, 70, 8, 24, 28, 62, 24, 28, 36, 66, 28, 36, 62, 24, 6, 8, 36, 28, 66, 62, 24]", "opt_solution_cost": "32", "opt_solution_compute_t": "1.3497884273529053", "solution_depth": "32", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[60, 66, 46, 8, 36], [81, \"_\", 88, 70, 24], [20, 17, 6, 62, 28]]]", "is_correct_args": "[[[60, 66, 46, 8, 36], [81, \"_\", 88, 70, 24], [20, 17, 6, 62, 28]]]", "A*_args": "[\"[[60, 66, 46, 8, 36], [81, '_', 88, 70, 24], [20, 17, 6, 62, 28]]\"]"}
{"diff_sorted_id": "77", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: gong, clown, brent, dewax, thorp   The initial board: [['l', 'g', 'a', 'n', 'g'], ['c', 'o', 'o', 'e', 'n'], ['e', 'r', '_', 'n', 't'], ['d', 'b', 'w', 'o', 'x'], ['t', 'h', 'w', 'r', 'p']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-left\"]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.6303999423980713", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"l\", \"g\", \"a\", \"n\", \"g\"], [\"c\", \"o\", \"o\", \"e\", \"n\"], [\"e\", \"r\", \"_\", \"n\", \"t\"], [\"d\", \"b\", \"w\", \"o\", \"x\"], [\"t\", \"h\", \"w\", \"r\", \"p\"]]]", "is_correct_args": "[[[\"l\", \"g\", \"a\", \"n\", \"g\"], [\"c\", \"o\", \"o\", \"e\", \"n\"], [\"e\", \"r\", \"_\", \"n\", \"t\"], [\"d\", \"b\", \"w\", \"o\", \"x\"], [\"t\", \"h\", \"w\", \"r\", \"p\"]], [\"gong\", \"clown\", \"brent\", \"dewax\", \"thorp\"]]", "A*_args": "[\"[['l', 'g', 'a', 'n', 'g'], ['c', 'o', 'o', 'e', 'n'], ['e', 'r', '_', 'n', 't'], ['d', 'b', 'w', 'o', 'x'], ['t', 'h', 'w', 'r', 'p']]\", \"['gong', 'clown', 'brent', 'dewax', 'thorp']\"]"}
{"diff_sorted_id": "77", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'O'. Our task is to visit city B and city H excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from H and B, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  S E D Y F B O H U I C Q Z J \nS 0 0 0 0 0 0 0 1 0 0 0 0 0 0 \nE 0 0 0 0 1 1 0 0 0 1 0 0 1 0 \nD 0 0 0 0 0 1 0 0 0 0 0 0 0 0 \nY 0 1 1 0 0 0 0 0 0 0 1 0 1 0 \nF 0 0 0 0 0 1 1 0 1 1 0 0 0 0 \nB 1 0 1 1 0 0 0 0 1 0 1 0 0 0 \nO 1 0 0 0 0 0 0 0 0 0 1 1 0 1 \nH 0 0 0 1 1 0 0 0 0 0 0 1 0 1 \nU 1 0 1 1 0 0 0 1 0 0 1 0 0 0 \nI 1 0 0 0 0 0 1 0 0 0 0 0 1 0 \nC 0 0 0 0 0 0 0 0 0 1 0 0 0 0 \nQ 0 0 1 0 1 0 0 0 1 0 0 0 0 1 \nZ 0 1 1 0 0 0 1 1 0 0 0 1 0 1 \nJ 0 1 1 1 1 0 0 0 1 0 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[\"O\", \"S\", \"H\", \"F\", \"B\", \"D\", \"B\", \"U\", \"H\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.04355263710021973", "solution_depth": "9", "max_successor_states": "14", "num_vars_per_state": "17", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]], [\"S\", \"E\", \"D\", \"Y\", \"F\", \"B\", \"O\", \"H\", \"U\", \"I\", \"C\", \"Q\", \"Z\", \"J\"], \"B\", \"H\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]], [\"S\", \"E\", \"D\", \"Y\", \"F\", \"B\", \"O\", \"H\", \"U\", \"I\", \"C\", \"Q\", \"Z\", \"J\"], \"O\", \"B\", \"H\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0]]\", \"['S', 'E', 'D', 'Y', 'F', 'B', 'O', 'H', 'U', 'I', 'C', 'Q', 'Z', 'J']\", \"['O']\", \"['B', 'H']\"]"}
{"diff_sorted_id": "77", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [26, 32, 14, 36, 14, 8, 9, 3, 8, 18, 7, 23, 6, 20, 34, 8, 37, 19, 15, 6, 2, 13, 37, 7, 31, 2, 7, 4, 17, 9, 4, 22, 7, 16, 33, 14, 11, 30, 36, 14, 34, 37, 36, 37, 32, 38, 15, 17, 19, 14], such that the sum of the chosen coins adds up to 396. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {17: 16, 4: 2, 15: 2, 8: 1, 19: 5, 9: 4, 23: 7, 3: 2, 16: 13, 2: 1, 38: 13, 11: 2, 31: 6, 7: 6, 36: 8, 14: 8, 37: 17, 32: 5, 6: 1, 13: 11, 22: 9, 20: 8, 18: 4, 30: 6, 34: 2, 33: 1, 26: 3}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "28", "opt_solution": "[34, 26, 8, 15, 8, 15, 33, 32, 8, 11, 31, 30, 37, 34, 32, 2, 19, 19, 2]", "opt_solution_cost": "68", "opt_solution_compute_t": "0.06271767616271973", "solution_depth": "19", "max_successor_states": "50", "num_vars_per_state": "50", "is_feasible_args": "[[26, 32, 14, 36, 14, 8, 9, 3, 8, 18, 7, 23, 6, 20, 34, 8, 37, 19, 15, 6, 2, 13, 37, 7, 31, 2, 7, 4, 17, 9, 4, 22, 7, 16, 33, 14, 11, 30, 36, 14, 34, 37, 36, 37, 32, 38, 15, 17, 19, 14]]", "is_correct_args": "[[26, 32, 14, 36, 14, 8, 9, 3, 8, 18, 7, 23, 6, 20, 34, 8, 37, 19, 15, 6, 2, 13, 37, 7, 31, 2, 7, 4, 17, 9, 4, 22, 7, 16, 33, 14, 11, 30, 36, 14, 34, 37, 36, 37, 32, 38, 15, 17, 19, 14], {\"17\": 16, \"4\": 2, \"15\": 2, \"8\": 1, \"19\": 5, \"9\": 4, \"23\": 7, \"3\": 2, \"16\": 13, \"2\": 1, \"38\": 13, \"11\": 2, \"31\": 6, \"7\": 6, \"36\": 8, \"14\": 8, \"37\": 17, \"32\": 5, \"6\": 1, \"13\": 11, \"22\": 9, \"20\": 8, \"18\": 4, \"30\": 6, \"34\": 2, \"33\": 1, \"26\": 3}, 396]", "A*_args": "[\"[26, 32, 14, 36, 14, 8, 9, 3, 8, 18, 7, 23, 6, 20, 34, 8, 37, 19, 15, 6, 2, 13, 37, 7, 31, 2, 7, 4, 17, 9, 4, 22, 7, 16, 33, 14, 11, 30, 36, 14, 34, 37, 36, 37, 32, 38, 15, 17, 19, 14]\", \"{17: 16, 4: 2, 15: 2, 8: 1, 19: 5, 9: 4, 23: 7, 3: 2, 16: 13, 2: 1, 38: 13, 11: 2, 31: 6, 7: 6, 36: 8, 14: 8, 37: 17, 32: 5, 6: 1, 13: 11, 22: 9, 20: 8, 18: 4, 30: 6, 34: 2, 33: 1, 26: 3}\", \"396\"]"}
{"diff_sorted_id": "77", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Blue', 'Green', 'Red', 'Blue', 'Green'], ['Blue', 'Green', 'Green', 'Blue', 'Red', 'Blue'], ['Green', 'Red', 'Red', 'Green', 'Blue', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[2, 1], [2, 0], [2, 0], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [1, 2], [0, 1], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [1, 2], [1, 0], [1, 0], [1, 0], [1, 0], [2, 1], [2, 1], [2, 0], [2, 1], [2, 1], [0, 2], [0, 2], [0, 1]]", "opt_solution_cost": "29", "opt_solution_compute_t": "413.2857873439789", "solution_depth": "29", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Red\", \"Blue\", \"Green\", \"Red\", \"Blue\", \"Green\"], [\"Blue\", \"Green\", \"Green\", \"Blue\", \"Red\", \"Blue\"], [\"Green\", \"Red\", \"Red\", \"Green\", \"Blue\", \"Red\"]], 9]", "is_correct_args": "[[[\"Red\", \"Blue\", \"Green\", \"Red\", \"Blue\", \"Green\"], [\"Blue\", \"Green\", \"Green\", \"Blue\", \"Red\", \"Blue\"], [\"Green\", \"Red\", \"Red\", \"Green\", \"Blue\", \"Red\"]], 9]", "A*_args": "[\"[['Red', 'Blue', 'Green', 'Red', 'Blue', 'Green'], ['Blue', 'Green', 'Green', 'Blue', 'Red', 'Blue'], ['Green', 'Red', 'Red', 'Green', 'Blue', 'Red']]\", \"9\"]"}
{"diff_sorted_id": "77", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 21 to 71 (21 included in the range but 71 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['25' 'x' 'x' '57']\n ['39' '45' '56' 'x']\n ['43' 'x' '58' 'x']\n ['46' 'x' '65' '69']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "11", "opt_solution": "[[1, 0, 22], [1, 1, 23], [1, 2, 34], [2, 0, 24], [2, 2, 39], [2, 3, 48], [3, 1, 40], [3, 3, 47]]", "opt_solution_cost": "467", "opt_solution_compute_t": "163.82063746452332", "solution_depth": "8", "max_successor_states": "50", "num_vars_per_state": "16", "is_feasible_args": "[\"[['20', '21', '33', '60'], ['', '', '', '49'], ['', '38', '', ''], ['36', '', '46', '']]\", 14, 64]", "is_correct_args": "[\"[['20', '21', '33', '60'], ['', '', '', '49'], ['', '38', '', ''], ['36', '', '46', '']]\", 14, 64]", "A*_args": "[\"[['20', '21', '33', '60'], ['', '', '', '49'], ['', '38', '', ''], ['36', '', '46', '']]\", \"14\", \"64\"]"}
{"diff_sorted_id": "77", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 13 to 54. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 147, 128, None for columns 1 to 2 respectively, and the sums of rows must be None, 159, 114, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 150. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' '37' '31']\n ['x' 'x' 'x' '51']\n ['x' 'x' '16' 'x']\n ['41' 'x' '43' '42']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 13], [0, 1, 14], [1, 0, 23], [1, 1, 53], [1, 2, 32], [2, 0, 17], [2, 1, 46], [2, 3, 35], [3, 1, 34]]", "opt_solution_cost": "528", "opt_solution_compute_t": "61.967140197753906", "solution_depth": "9", "max_successor_states": "31", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '37', '31'], ['', '', '', '51'], ['', '', '16', ''], ['41', '', '43', '42']]\", 4, 13, 54]", "is_correct_args": "[\"[['', '', '37', '31'], ['', '', '', '51'], ['', '', '16', ''], ['41', '', '43', '42']]\", 13, 54, [1, 3], [1, 3], [147, 128], [159, 114], 150]", "A*_args": "[\"[['', '', '37', '31'], ['', '', '', '51'], ['', '', '16', ''], ['41', '', '43', '42']]\", \"13\", \"54\", \"[None, 147, 128, None]\", \"[None, 159, 114, None]\", \"150\"]"}
{"diff_sorted_id": "77", "problem_statement": "In 'Restricted Sorting', there are 12 stacks each with a capacity of 7 blocks, with 6 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 6 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 13, 1: 5, 2: 8, 3: 11, 4: 6, 5: 9, 6: 5, 7: 11, 8: 2, 9: 11, 10: 11, 11: 7}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Green', 'Black', 'White', 'Red', 'White', 'Yellow', 'Blue'], [], ['White', 'Pink', 'White', 'White', 'Green', 'Red', 'Blue'], [], ['Pink', 'Black', 'Black', 'White', 'Black', 'Green', 'Blue'], ['Pink', 'Green', 'Pink', 'Yellow', 'Yellow', 'Blue', 'Red'], [], ['Red', 'Yellow', 'Yellow', 'Yellow', 'Blue', 'Red', 'Black'], [], [], [], ['Red', 'Green', 'Black', 'Blue', 'Pink', 'Pink', 'Green']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "4", "opt_solution": "[[4, 8], [5, 8], [0, 1], [5, 1], [5, 8], [7, 6], [11, 6], [11, 1], [0, 3], [11, 3], [11, 9], [11, 8], [11, 8], [11, 1], [0, 11], [0, 6], [0, 11], [2, 11], [2, 8], [2, 11], [2, 11], [2, 1], [2, 6], [0, 10], [5, 10], [5, 10], [5, 0], [4, 3], [4, 3], [4, 11], [4, 3], [4, 1], [7, 10], [7, 10], [7, 10], [7, 4], [7, 5], [7, 3], [0, 4], [0, 4], [2, 4], [9, 4], [5, 6], [5, 6]]", "opt_solution_cost": "309", "opt_solution_compute_t": "44.145676374435425", "solution_depth": "44", "max_successor_states": "132", "num_vars_per_state": "42", "is_feasible_args": "[[[\"Green\", \"Black\", \"White\", \"Red\", \"White\", \"Yellow\", \"Blue\"], [], [\"White\", \"Pink\", \"White\", \"White\", \"Green\", \"Red\", \"Blue\"], [], [\"Pink\", \"Black\", \"Black\", \"White\", \"Black\", \"Green\", \"Blue\"], [\"Pink\", \"Green\", \"Pink\", \"Yellow\", \"Yellow\", \"Blue\", \"Red\"], [], [\"Red\", \"Yellow\", \"Yellow\", \"Yellow\", \"Blue\", \"Red\", \"Black\"], [], [], [], [\"Red\", \"Green\", \"Black\", \"Blue\", \"Pink\", \"Pink\", \"Green\"]], 7, {\"0\": 13, \"1\": 5, \"2\": 8, \"3\": 11, \"4\": 6, \"5\": 9, \"6\": 5, \"7\": 11, \"8\": 2, \"9\": 11, \"10\": 11, \"11\": 7}]", "is_correct_args": "[[[\"Green\", \"Black\", \"White\", \"Red\", \"White\", \"Yellow\", \"Blue\"], [], [\"White\", \"Pink\", \"White\", \"White\", \"Green\", \"Red\", \"Blue\"], [], [\"Pink\", \"Black\", \"Black\", \"White\", \"Black\", \"Green\", \"Blue\"], [\"Pink\", \"Green\", \"Pink\", \"Yellow\", \"Yellow\", \"Blue\", \"Red\"], [], [\"Red\", \"Yellow\", \"Yellow\", \"Yellow\", \"Blue\", \"Red\", \"Black\"], [], [], [], [\"Red\", \"Green\", \"Black\", \"Blue\", \"Pink\", \"Pink\", \"Green\"]], 7, {\"0\": 13, \"1\": 5, \"2\": 8, \"3\": 11, \"4\": 6, \"5\": 9, \"6\": 5, \"7\": 11, \"8\": 2, \"9\": 11, \"10\": 11, \"11\": 7}, 6]", "A*_args": "[\"[['Green', 'Black', 'White', 'Red', 'White', 'Yellow', 'Blue'], [], ['White', 'Pink', 'White', 'White', 'Green', 'Red', 'Blue'], [], ['Pink', 'Black', 'Black', 'White', 'Black', 'Green', 'Blue'], ['Pink', 'Green', 'Pink', 'Yellow', 'Yellow', 'Blue', 'Red'], [], ['Red', 'Yellow', 'Yellow', 'Yellow', 'Blue', 'Red', 'Black'], [], [], [], ['Red', 'Green', 'Black', 'Blue', 'Pink', 'Pink', 'Green']]\", \"{0: 13, 1: 5, 2: 8, 3: 11, 4: 6, 5: 9, 6: 5, 7: 11, 8: 2, 9: 11, 10: 11, 11: 7}\", \"7\", \"6\"]"}
{"diff_sorted_id": "77", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (6, 1) to his destination workshop at index (3, 13), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 5, and district 3 covering rows 6 to 13. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 5 9 6 13 13 8 6 13 x 13 x x x]\n[3 10 16 x x 3 13 1 11 9 7 6 x 18]\n[9 11 3 x x 6 13 x 14 x 12 1 2 4]\n[x 17 13 x 14 4 6 8 x x 1 x 6 2]\n[7 x 11 x 14 x 11 7 x 5 x 1 12 x]\n[x 20 20 19 x 18 2 19 1 6 12 x x 16]\n[8 5 7 11 x 1 x x x 11 4 x x 3]\n[x 11 x 11 11 x x 18 x x x 7 6 x]\n[2 2 14 5 5 x x 11 19 16 x 14 7 19]\n[x 5 x x 7 x 10 x x x 3 15 x x]\n[19 x x x x 8 3 19 x 18 x x x 9]\n[17 x 19 x x x 5 3 x x 7 4 x x]\n[x x x x x 12 11 x x x x x 6 6]\n[x x x x x x 4 x x x 7 x 6 3]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "6", "opt_solution": "[[6, 1], [6, 2], [5, 2], [4, 2], [3, 2], [2, 2], [1, 2], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [1, 7], [1, 8], [1, 9], [1, 10], [1, 11], [2, 11], [2, 12], [2, 13], [3, 13]]", "opt_solution_cost": "168", "opt_solution_compute_t": "0.022469043731689453", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"5\", \"9\", \"6\", \"13\", \"13\", \"8\", \"6\", \"13\", \"x\", \"13\", \"x\", \"x\", \"x\"], [\"3\", \"10\", \"16\", \"x\", \"x\", \"3\", \"13\", \"1\", \"11\", \"9\", \"7\", \"6\", \"x\", \"18\"], [\"9\", \"11\", \"3\", \"x\", \"x\", \"6\", \"13\", \"x\", \"14\", \"x\", \"12\", \"1\", \"2\", \"4\"], [\"x\", \"17\", \"13\", \"x\", \"14\", \"4\", \"6\", \"8\", \"x\", \"x\", \"1\", \"x\", \"6\", \"2\"], [\"7\", \"x\", \"11\", \"x\", \"14\", \"x\", \"11\", \"7\", \"x\", \"5\", \"x\", \"1\", \"12\", \"x\"], [\"x\", \"20\", \"20\", \"19\", \"x\", \"18\", \"2\", \"19\", \"1\", \"6\", \"12\", \"x\", \"x\", \"16\"], [\"8\", \"5\", \"7\", \"11\", \"x\", \"1\", \"x\", \"x\", \"x\", \"11\", \"4\", \"x\", \"x\", \"3\"], [\"x\", \"11\", \"x\", \"11\", \"11\", \"x\", \"x\", \"18\", \"x\", \"x\", \"x\", \"7\", \"6\", \"x\"], [\"2\", \"2\", \"14\", \"5\", \"5\", \"x\", \"x\", \"11\", \"19\", \"16\", \"x\", \"14\", \"7\", \"19\"], [\"x\", \"5\", \"x\", \"x\", \"7\", \"x\", \"10\", \"x\", \"x\", \"x\", \"3\", \"15\", \"x\", \"x\"], [\"19\", \"x\", \"x\", \"x\", \"x\", \"8\", \"3\", \"19\", \"x\", \"18\", \"x\", \"x\", \"x\", \"9\"], [\"17\", \"x\", \"19\", \"x\", \"x\", \"x\", \"5\", \"3\", \"x\", \"x\", \"7\", \"4\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"12\", \"11\", \"x\", \"x\", \"x\", \"x\", \"x\", \"6\", \"6\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"4\", \"x\", \"x\", \"x\", \"7\", \"x\", \"6\", \"3\"]]]", "is_correct_args": "[[[\"x\", \"5\", \"9\", \"6\", \"13\", \"13\", \"8\", \"6\", \"13\", \"x\", \"13\", \"x\", \"x\", \"x\"], [\"3\", \"10\", \"16\", \"x\", \"x\", \"3\", \"13\", \"1\", \"11\", \"9\", \"7\", \"6\", \"x\", \"18\"], [\"9\", \"11\", \"3\", \"x\", \"x\", \"6\", \"13\", \"x\", \"14\", \"x\", \"12\", \"1\", \"2\", \"4\"], [\"x\", \"17\", \"13\", \"x\", \"14\", \"4\", \"6\", \"8\", \"x\", \"x\", \"1\", \"x\", \"6\", \"2\"], [\"7\", \"x\", \"11\", \"x\", \"14\", \"x\", \"11\", \"7\", \"x\", \"5\", \"x\", \"1\", \"12\", \"x\"], [\"x\", \"20\", \"20\", \"19\", \"x\", \"18\", \"2\", \"19\", \"1\", \"6\", \"12\", \"x\", \"x\", \"16\"], [\"8\", \"5\", \"7\", \"11\", \"x\", \"1\", \"x\", \"x\", \"x\", \"11\", \"4\", \"x\", \"x\", \"3\"], [\"x\", \"11\", \"x\", \"11\", \"11\", \"x\", \"x\", \"18\", \"x\", \"x\", \"x\", \"7\", \"6\", \"x\"], [\"2\", \"2\", \"14\", \"5\", \"5\", \"x\", \"x\", \"11\", \"19\", \"16\", \"x\", \"14\", \"7\", \"19\"], [\"x\", \"5\", \"x\", \"x\", \"7\", \"x\", \"10\", \"x\", \"x\", \"x\", \"3\", \"15\", \"x\", \"x\"], [\"19\", \"x\", \"x\", \"x\", \"x\", \"8\", \"3\", \"19\", \"x\", \"18\", \"x\", \"x\", \"x\", \"9\"], [\"17\", \"x\", \"19\", \"x\", \"x\", \"x\", \"5\", \"3\", \"x\", \"x\", \"7\", \"4\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"12\", \"11\", \"x\", \"x\", \"x\", \"x\", \"x\", \"6\", \"6\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"4\", \"x\", \"x\", \"x\", \"7\", \"x\", \"6\", \"3\"]], [6, 1], [3, 13], 1, 5]", "A*_args": "[\"[['x', '5', '9', '6', '13', '13', '8', '6', '13', 'x', '13', 'x', 'x', 'x'], ['3', '10', '16', 'x', 'x', '3', '13', '1', '11', '9', '7', '6', 'x', '18'], ['9', '11', '3', 'x', 'x', '6', '13', 'x', '14', 'x', '12', '1', '2', '4'], ['x', '17', '13', 'x', '14', '4', '6', '8', 'x', 'x', '1', 'x', '6', '2'], ['7', 'x', '11', 'x', '14', 'x', '11', '7', 'x', '5', 'x', '1', '12', 'x'], ['x', '20', '20', '19', 'x', '18', '2', '19', '1', '6', '12', 'x', 'x', '16'], ['8', '5', '7', '11', 'x', '1', 'x', 'x', 'x', '11', '4', 'x', 'x', '3'], ['x', '11', 'x', '11', '11', 'x', 'x', '18', 'x', 'x', 'x', '7', '6', 'x'], ['2', '2', '14', '5', '5', 'x', 'x', '11', '19', '16', 'x', '14', '7', '19'], ['x', '5', 'x', 'x', '7', 'x', '10', 'x', 'x', 'x', '3', '15', 'x', 'x'], ['19', 'x', 'x', 'x', 'x', '8', '3', '19', 'x', '18', 'x', 'x', 'x', '9'], ['17', 'x', '19', 'x', 'x', 'x', '5', '3', 'x', 'x', '7', '4', 'x', 'x'], ['x', 'x', 'x', 'x', 'x', '12', '11', 'x', 'x', 'x', 'x', 'x', '6', '6'], ['x', 'x', 'x', 'x', 'x', 'x', '4', 'x', 'x', 'x', '7', 'x', '6', '3']]\", \"(6, 1)\", \"(3, 13)\", \"1\", \"5\"]"}
{"diff_sorted_id": "77", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 14x14. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 13) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (8, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 1 1 0 0 1 1 1 1 0 0 0 0\n0 1 0 1 0 1 1 1 1 1 0 0 0 0\n1 0 1 1 0 1 0 0 1 1 0 0 0 0\n1 1 1 0 1 1 0 0 0 0 0 0 1 0\n0 1 1 1 1 1 0 0 0 0 0 1 1 0\n0 0 0 1 1 0 1 0 0 1 1 1 1 0\n1 0 1 1 1 1 0 0 1 0 1 1 0 0\n1 0 0 0 0 0 0 1 1 1 0 1 0 0\n1 0 1 0 0 1 0 1 1 0 1 1 1 1\n1 0 0 0 1 1 0 0 0 0 1 1 0 1\n1 1 1 1 0 0 1 1 0 1 1 1 0 0\n0 1 1 0 1 0 0 0 0 0 1 1 1 1\n0 0 0 0 0 1 1 1 1 1 0 1 0 0\n1 0 1 0 0 1 1 1 0 1 0 1 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[[0, 13], [0, 12], [0, 11], [0, 10], [1, 10], [2, 10], [3, 9], [3, 8], [3, 7], [4, 7], [5, 7], [6, 6], [7, 5], [7, 4], [7, 3], [7, 2], [8, 1]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.03951430320739746", "solution_depth": "17", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0], [1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1], [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1]]\", 4]", "is_correct_args": "[\"[[0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0], [1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1], [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1]]\", [0, 13], [8, 1], 4]", "A*_args": "[\"[[0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0], [1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1], [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0], [1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1]]\", \"(0, 13)\", \"(8, 1)\", \"4\"]"}
{"diff_sorted_id": "77", "problem_statement": "Given 7 labeled water jugs with capacities 60, 59, 72, 93, 39, 74, 71, 84 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 166, 239, 286, 421 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 71, 4], [\"+\", 71, 4], [\"+\", 93, 4], [\"+\", 93, 4], [\"+\", 93, 4], [\"+\", 71, 3], [\"+\", 84, 3], [\"+\", 60, 3], [\"+\", 71, 3], [\"+\", 71, 2], [\"+\", 84, 2], [\"+\", 84, 2], [\"+\", 39, 1], [\"+\", 93, 1], [\"-\", 59, 1], [\"+\", 93, 1]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.05889129638671875", "solution_depth": "16", "max_successor_states": "64", "num_vars_per_state": "3", "is_feasible_args": "[[60, 59, 72, 93, 39, 74, 71, 84], [166, 239, 286, 421]]", "is_correct_args": "[[60, 59, 72, 93, 39, 74, 71, 84], [166, 239, 286, 421]]", "A*_args": "[\"[60, 59, 72, 93, 39, 74, 71, 84]\", \"[166, 239, 286, 421]\"]"}
{"diff_sorted_id": "78", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[94, 92, 77, 88, '_'], [82, 43, 76, 85, 87], [24, 66, 17, 79, 75]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[87, 85, 76, 17, 66, 24, 82, 43, 24, 66, 17, 24, 43, 82, 66, 17, 79, 76, 24, 79, 17, 43, 79, 24, 76, 17, 24, 77, 88, 87, 85, 75]", "opt_solution_cost": "32", "opt_solution_compute_t": "4.894534587860107", "solution_depth": "32", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[94, 92, 77, 88, \"_\"], [82, 43, 76, 85, 87], [24, 66, 17, 79, 75]]]", "is_correct_args": "[[[94, 92, 77, 88, \"_\"], [82, 43, 76, 85, 87], [24, 66, 17, 79, 75]]]", "A*_args": "[\"[[94, 92, 77, 88, '_'], [82, 43, 76, 85, 87], [24, 66, 17, 79, 75]]\"]"}
{"diff_sorted_id": "78", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: jake, tawse, trypa, smash, creep   The initial board: [['a', 'j', '_', 'k', 'e'], ['t', 's', 'w', 'y', 'e'], ['t', 'r', 'a', 'p', 'a'], ['s', 'e', 'a', 'm', 'h'], ['c', 'r', 's', 'e', 'p']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-left\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.18477082252502441", "solution_depth": "10", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"a\", \"j\", \"_\", \"k\", \"e\"], [\"t\", \"s\", \"w\", \"y\", \"e\"], [\"t\", \"r\", \"a\", \"p\", \"a\"], [\"s\", \"e\", \"a\", \"m\", \"h\"], [\"c\", \"r\", \"s\", \"e\", \"p\"]]]", "is_correct_args": "[[[\"a\", \"j\", \"_\", \"k\", \"e\"], [\"t\", \"s\", \"w\", \"y\", \"e\"], [\"t\", \"r\", \"a\", \"p\", \"a\"], [\"s\", \"e\", \"a\", \"m\", \"h\"], [\"c\", \"r\", \"s\", \"e\", \"p\"]], [\"jake\", \"tawse\", \"trypa\", \"smash\", \"creep\"]]", "A*_args": "[\"[['a', 'j', '_', 'k', 'e'], ['t', 's', 'w', 'y', 'e'], ['t', 'r', 'a', 'p', 'a'], ['s', 'e', 'a', 'm', 'h'], ['c', 'r', 's', 'e', 'p']]\", \"['jake', 'tawse', 'trypa', 'smash', 'creep']\"]"}
{"diff_sorted_id": "78", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'A'. Our task is to visit city H and city W excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from W and H, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  B A M G V J T N W X K Y H C \nB 0 0 0 0 0 0 1 0 0 0 0 1 0 1 \nA 1 0 0 0 0 0 0 0 0 0 0 0 0 0 \nM 0 0 0 0 0 0 0 1 0 0 0 0 0 0 \nG 0 0 1 0 0 1 0 0 1 0 0 0 0 0 \nV 1 1 1 1 0 0 0 1 0 1 0 0 0 0 \nJ 0 0 0 0 0 0 1 0 0 0 0 0 0 1 \nT 0 1 0 1 0 0 0 0 1 0 0 0 0 0 \nN 0 0 0 1 0 1 0 0 0 0 0 0 1 0 \nW 0 0 1 1 1 0 0 0 0 0 0 0 1 1 \nX 0 1 1 1 0 0 1 0 1 0 0 0 1 0 \nK 0 0 0 0 1 0 0 1 0 0 0 0 0 0 \nY 0 0 1 1 1 0 1 0 0 1 1 0 0 0 \nH 0 0 1 0 0 1 0 0 0 0 1 0 0 0 \nC 0 0 0 0 1 0 1 0 0 0 0 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[\"A\", \"B\", \"C\", \"H\", \"J\", \"T\", \"W\", \"G\", \"W\", \"H\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.0448455810546875", "solution_depth": "10", "max_successor_states": "14", "num_vars_per_state": "17", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0]], [\"B\", \"A\", \"M\", \"G\", \"V\", \"J\", \"T\", \"N\", \"W\", \"X\", \"K\", \"Y\", \"H\", \"C\"], \"H\", \"W\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0]], [\"B\", \"A\", \"M\", \"G\", \"V\", \"J\", \"T\", \"N\", \"W\", \"X\", \"K\", \"Y\", \"H\", \"C\"], \"A\", \"H\", \"W\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0]]\", \"['B', 'A', 'M', 'G', 'V', 'J', 'T', 'N', 'W', 'X', 'K', 'Y', 'H', 'C']\", \"['A']\", \"['H', 'W']\"]"}
{"diff_sorted_id": "78", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [29, 32, 2, 34, 7, 25, 7, 14, 33, 1, 26, 18, 13, 11, 32, 31, 13, 2, 28, 21, 38, 8, 11, 28, 26, 9, 4, 28, 34, 23, 18, 31, 35, 2, 25, 20, 15, 5, 12, 10, 7, 14, 17, 4, 13, 24, 11, 16, 14, 27, 29], such that the sum of the chosen coins adds up to 392. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {10: 1, 25: 18, 1: 1, 15: 7, 12: 1, 23: 16, 9: 7, 27: 15, 29: 16, 28: 2, 32: 12, 24: 6, 5: 1, 8: 1, 11: 8, 17: 13, 13: 6, 38: 6, 31: 19, 4: 2, 34: 12, 21: 3, 2: 2, 33: 12, 20: 13, 18: 1, 14: 13, 16: 8, 7: 5, 35: 16, 26: 10}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "29", "opt_solution": "[28, 18, 12, 10, 8, 21, 33, 28, 24, 18, 35, 34, 32, 28, 26, 2, 5, 4, 13, 13]", "opt_solution_cost": "99", "opt_solution_compute_t": "0.0646202564239502", "solution_depth": "20", "max_successor_states": "51", "num_vars_per_state": "51", "is_feasible_args": "[[29, 32, 2, 34, 7, 25, 7, 14, 33, 1, 26, 18, 13, 11, 32, 31, 13, 2, 28, 21, 38, 8, 11, 28, 26, 9, 4, 28, 34, 23, 18, 31, 35, 2, 25, 20, 15, 5, 12, 10, 7, 14, 17, 4, 13, 24, 11, 16, 14, 27, 29]]", "is_correct_args": "[[29, 32, 2, 34, 7, 25, 7, 14, 33, 1, 26, 18, 13, 11, 32, 31, 13, 2, 28, 21, 38, 8, 11, 28, 26, 9, 4, 28, 34, 23, 18, 31, 35, 2, 25, 20, 15, 5, 12, 10, 7, 14, 17, 4, 13, 24, 11, 16, 14, 27, 29], {\"10\": 1, \"25\": 18, \"1\": 1, \"15\": 7, \"12\": 1, \"23\": 16, \"9\": 7, \"27\": 15, \"29\": 16, \"28\": 2, \"32\": 12, \"24\": 6, \"5\": 1, \"8\": 1, \"11\": 8, \"17\": 13, \"13\": 6, \"38\": 6, \"31\": 19, \"4\": 2, \"34\": 12, \"21\": 3, \"2\": 2, \"33\": 12, \"20\": 13, \"18\": 1, \"14\": 13, \"16\": 8, \"7\": 5, \"35\": 16, \"26\": 10}, 392]", "A*_args": "[\"[29, 32, 2, 34, 7, 25, 7, 14, 33, 1, 26, 18, 13, 11, 32, 31, 13, 2, 28, 21, 38, 8, 11, 28, 26, 9, 4, 28, 34, 23, 18, 31, 35, 2, 25, 20, 15, 5, 12, 10, 7, 14, 17, 4, 13, 24, 11, 16, 14, 27, 29]\", \"{10: 1, 25: 18, 1: 1, 15: 7, 12: 1, 23: 16, 9: 7, 27: 15, 29: 16, 28: 2, 32: 12, 24: 6, 5: 1, 8: 1, 11: 8, 17: 13, 13: 6, 38: 6, 31: 19, 4: 2, 34: 12, 21: 3, 2: 2, 33: 12, 20: 13, 18: 1, 14: 13, 16: 8, 7: 5, 35: 16, 26: 10}\", \"392\"]"}
{"diff_sorted_id": "78", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Blue', 'Red', 'Green', 'Blue'], ['Blue', 'Blue', 'Red', 'Blue', 'Green', 'Red'], ['Green', 'Red', 'Green', 'Blue', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[0, 1], [2, 0], [2, 1], [2, 0], [2, 1], [2, 0], [1, 0], [1, 2], [1, 2], [1, 2], [0, 2], [1, 2], [1, 2], [1, 2], [1, 0], [1, 2], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [2, 1], [0, 2], [0, 1], [0, 1], [2, 0], [2, 0], [2, 1], [2, 0], [2, 0], [2, 0], [1, 2], [1, 0], [1, 2], [1, 2], [0, 1]]", "opt_solution_cost": "36", "opt_solution_compute_t": "552.3669350147247", "solution_depth": "36", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Red\", \"Green\", \"Blue\", \"Red\", \"Green\", \"Blue\"], [\"Blue\", \"Blue\", \"Red\", \"Blue\", \"Green\", \"Red\"], [\"Green\", \"Red\", \"Green\", \"Blue\", \"Green\", \"Red\"]], 9]", "is_correct_args": "[[[\"Red\", \"Green\", \"Blue\", \"Red\", \"Green\", \"Blue\"], [\"Blue\", \"Blue\", \"Red\", \"Blue\", \"Green\", \"Red\"], [\"Green\", \"Red\", \"Green\", \"Blue\", \"Green\", \"Red\"]], 9]", "A*_args": "[\"[['Red', 'Green', 'Blue', 'Red', 'Green', 'Blue'], ['Blue', 'Blue', 'Red', 'Blue', 'Green', 'Red'], ['Green', 'Red', 'Green', 'Blue', 'Green', 'Red']]\", \"9\"]"}
{"diff_sorted_id": "78", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 17 to 67 (17 included in the range but 67 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['39' '40' '44' '62']\n ['29' '33' '38' '61']\n ['x' 'x' '35' '59']\n ['x' 'x' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "11", "opt_solution": "[[0, 0, 61], [0, 1, 60], [0, 3, 36], [1, 3, 62], [2, 1, 45], [3, 0, 37], [3, 1, 38], [3, 2, 64]]", "opt_solution_cost": "734", "opt_solution_compute_t": "0.4792149066925049", "solution_depth": "8", "max_successor_states": "50", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '58', ''], ['44', '54', '59', ''], ['43', '', '63', '75'], ['', '', '', '84']]\", 36, 86]", "is_correct_args": "[\"[['', '', '58', ''], ['44', '54', '59', ''], ['43', '', '63', '75'], ['', '', '', '84']]\", 36, 86]", "A*_args": "[\"[['', '', '58', ''], ['44', '54', '59', ''], ['43', '', '63', '75'], ['', '', '', '84']]\", \"36\", \"86\"]"}
{"diff_sorted_id": "78", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 13 to 54. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 135, 153, None for columns 1 to 2 respectively, and the sums of rows must be None, 158, 87, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 140. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '22' 'x' 'x']\n ['28' '47' '42' 'x']\n ['16' 'x' '30' '24']\n ['x' 'x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 13], [0, 2, 29], [0, 3, 31], [1, 3, 41], [2, 1, 17], [3, 0, 50], [3, 1, 49], [3, 2, 52], [3, 3, 14]]", "opt_solution_cost": "505", "opt_solution_compute_t": "17.9815993309021", "solution_depth": "9", "max_successor_states": "31", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '22', '', ''], ['28', '47', '42', ''], ['16', '', '30', '24'], ['', '', '', '']]\", 4, 13, 54]", "is_correct_args": "[\"[['', '22', '', ''], ['28', '47', '42', ''], ['16', '', '30', '24'], ['', '', '', '']]\", 13, 54, [1, 3], [1, 3], [135, 153], [158, 87], 140]", "A*_args": "[\"[['', '22', '', ''], ['28', '47', '42', ''], ['16', '', '30', '24'], ['', '', '', '']]\", \"13\", \"54\", \"[None, 135, 153, None]\", \"[None, 158, 87, None]\", \"140\"]"}
{"diff_sorted_id": "78", "problem_statement": "In 'Restricted Sorting', there are 12 stacks each with a capacity of 7 blocks, with 6 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 6 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 2, 1: 7, 2: 5, 3: 11, 4: 6, 5: 13, 6: 12, 7: 7, 8: 8, 9: 6, 10: 7, 11: 7}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Blue', 'Pink', 'Red', 'Red', 'Yellow', 'White', 'Green'], [], [], ['White', 'Black', 'Blue', 'Yellow', 'Yellow', 'Pink', 'White'], ['Green', 'Pink', 'White', 'Blue', 'Pink', 'Red', 'Pink'], ['Black', 'Green', 'Yellow', 'White', 'Yellow', 'Red', 'Blue'], [], ['Red', 'White', 'Black', 'Blue', 'Black', 'Yellow', 'Green'], [], ['Green', 'Black', 'Pink', 'Black', 'Red', 'Green', 'Blue'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "4", "opt_solution": "[[5, 0], [10, 0], [6, 2], [6, 0], [4, 9], [4, 2], [1, 7], [4, 7], [8, 11], [8, 9], [8, 2], [8, 7], [8, 2], [8, 3], [8, 0], [1, 8], [10, 2], [10, 8], [10, 2], [10, 11], [10, 0], [1, 11], [1, 11], [10, 7], [1, 10], [1, 9], [4, 10], [4, 10], [4, 8], [6, 10], [6, 4], [6, 10], [6, 11], [5, 8], [5, 4], [5, 7], [5, 8], [5, 11], [5, 8], [3, 10], [6, 7], [4, 9], [4, 9], [4, 9], [1, 0]]", "opt_solution_cost": "275", "opt_solution_compute_t": "30.320260763168335", "solution_depth": "45", "max_successor_states": "132", "num_vars_per_state": "42", "is_feasible_args": "[[[], [\"Blue\", \"Pink\", \"Red\", \"Red\", \"Yellow\", \"White\", \"Green\"], [], [], [\"White\", \"Black\", \"Blue\", \"Yellow\", \"Yellow\", \"Pink\", \"White\"], [\"Green\", \"Pink\", \"White\", \"Blue\", \"Pink\", \"Red\", \"Pink\"], [\"Black\", \"Green\", \"Yellow\", \"White\", \"Yellow\", \"Red\", \"Blue\"], [], [\"Red\", \"White\", \"Black\", \"Blue\", \"Black\", \"Yellow\", \"Green\"], [], [\"Green\", \"Black\", \"Pink\", \"Black\", \"Red\", \"Green\", \"Blue\"], []], 7, {\"0\": 2, \"1\": 7, \"2\": 5, \"3\": 11, \"4\": 6, \"5\": 13, \"6\": 12, \"7\": 7, \"8\": 8, \"9\": 6, \"10\": 7, \"11\": 7}]", "is_correct_args": "[[[], [\"Blue\", \"Pink\", \"Red\", \"Red\", \"Yellow\", \"White\", \"Green\"], [], [], [\"White\", \"Black\", \"Blue\", \"Yellow\", \"Yellow\", \"Pink\", \"White\"], [\"Green\", \"Pink\", \"White\", \"Blue\", \"Pink\", \"Red\", \"Pink\"], [\"Black\", \"Green\", \"Yellow\", \"White\", \"Yellow\", \"Red\", \"Blue\"], [], [\"Red\", \"White\", \"Black\", \"Blue\", \"Black\", \"Yellow\", \"Green\"], [], [\"Green\", \"Black\", \"Pink\", \"Black\", \"Red\", \"Green\", \"Blue\"], []], 7, {\"0\": 2, \"1\": 7, \"2\": 5, \"3\": 11, \"4\": 6, \"5\": 13, \"6\": 12, \"7\": 7, \"8\": 8, \"9\": 6, \"10\": 7, \"11\": 7}, 6]", "A*_args": "[\"[[], ['Blue', 'Pink', 'Red', 'Red', 'Yellow', 'White', 'Green'], [], [], ['White', 'Black', 'Blue', 'Yellow', 'Yellow', 'Pink', 'White'], ['Green', 'Pink', 'White', 'Blue', 'Pink', 'Red', 'Pink'], ['Black', 'Green', 'Yellow', 'White', 'Yellow', 'Red', 'Blue'], [], ['Red', 'White', 'Black', 'Blue', 'Black', 'Yellow', 'Green'], [], ['Green', 'Black', 'Pink', 'Black', 'Red', 'Green', 'Blue'], []]\", \"{0: 2, 1: 7, 2: 5, 3: 11, 4: 6, 5: 13, 6: 12, 7: 7, 8: 8, 9: 6, 10: 7, 11: 7}\", \"7\", \"6\"]"}
{"diff_sorted_id": "78", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (7, 12) to his destination workshop at index (2, 0), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 6, and district 3 covering rows 7 to 13. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x x 16 11 12 x x 17 3 x x 4 6]\n[4 17 x x 3 x x 1 9 11 12 4 x x]\n[5 x x 7 14 4 5 7 13 4 7 x x x]\n[6 6 19 3 15 x x x x 4 10 19 2 4]\n[3 16 8 x 5 x 12 17 16 x 9 5 6 x]\n[17 2 x x 16 x 5 x x 5 17 7 2 5]\n[19 x x x x 2 15 15 x 3 11 x 4 x]\n[x x 11 x x 17 5 x 5 x x 19 6 x]\n[16 17 16 x 12 x 2 18 9 7 x 13 x x]\n[18 11 x x 19 5 x x 18 4 x x x x]\n[x x x x 2 5 4 12 3 x 4 14 7 19]\n[18 x x x 7 17 x x 3 15 x 16 x 10]\n[x 11 15 x x x x x 2 13 x x x 3]\n[4 8 x x x x 12 13 x x 19 x 6 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "6", "opt_solution": "[[7, 12], [6, 12], [5, 12], [4, 12], [4, 11], [4, 10], [3, 10], [3, 9], [2, 9], [2, 8], [2, 7], [2, 6], [2, 5], [2, 4], [2, 3], [3, 3], [3, 2], [3, 1], [3, 0], [2, 0]]", "opt_solution_cost": "133", "opt_solution_compute_t": "0.023016929626464844", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"x\", \"16\", \"11\", \"12\", \"x\", \"x\", \"17\", \"3\", \"x\", \"x\", \"4\", \"6\"], [\"4\", \"17\", \"x\", \"x\", \"3\", \"x\", \"x\", \"1\", \"9\", \"11\", \"12\", \"4\", \"x\", \"x\"], [\"5\", \"x\", \"x\", \"7\", \"14\", \"4\", \"5\", \"7\", \"13\", \"4\", \"7\", \"x\", \"x\", \"x\"], [\"6\", \"6\", \"19\", \"3\", \"15\", \"x\", \"x\", \"x\", \"x\", \"4\", \"10\", \"19\", \"2\", \"4\"], [\"3\", \"16\", \"8\", \"x\", \"5\", \"x\", \"12\", \"17\", \"16\", \"x\", \"9\", \"5\", \"6\", \"x\"], [\"17\", \"2\", \"x\", \"x\", \"16\", \"x\", \"5\", \"x\", \"x\", \"5\", \"17\", \"7\", \"2\", \"5\"], [\"19\", \"x\", \"x\", \"x\", \"x\", \"2\", \"15\", \"15\", \"x\", \"3\", \"11\", \"x\", \"4\", \"x\"], [\"x\", \"x\", \"11\", \"x\", \"x\", \"17\", \"5\", \"x\", \"5\", \"x\", \"x\", \"19\", \"6\", \"x\"], [\"16\", \"17\", \"16\", \"x\", \"12\", \"x\", \"2\", \"18\", \"9\", \"7\", \"x\", \"13\", \"x\", \"x\"], [\"18\", \"11\", \"x\", \"x\", \"19\", \"5\", \"x\", \"x\", \"18\", \"4\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"2\", \"5\", \"4\", \"12\", \"3\", \"x\", \"4\", \"14\", \"7\", \"19\"], [\"18\", \"x\", \"x\", \"x\", \"7\", \"17\", \"x\", \"x\", \"3\", \"15\", \"x\", \"16\", \"x\", \"10\"], [\"x\", \"11\", \"15\", \"x\", \"x\", \"x\", \"x\", \"x\", \"2\", \"13\", \"x\", \"x\", \"x\", \"3\"], [\"4\", \"8\", \"x\", \"x\", \"x\", \"x\", \"12\", \"13\", \"x\", \"x\", \"19\", \"x\", \"6\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"x\", \"16\", \"11\", \"12\", \"x\", \"x\", \"17\", \"3\", \"x\", \"x\", \"4\", \"6\"], [\"4\", \"17\", \"x\", \"x\", \"3\", \"x\", \"x\", \"1\", \"9\", \"11\", \"12\", \"4\", \"x\", \"x\"], [\"5\", \"x\", \"x\", \"7\", \"14\", \"4\", \"5\", \"7\", \"13\", \"4\", \"7\", \"x\", \"x\", \"x\"], [\"6\", \"6\", \"19\", \"3\", \"15\", \"x\", \"x\", \"x\", \"x\", \"4\", \"10\", \"19\", \"2\", \"4\"], [\"3\", \"16\", \"8\", \"x\", \"5\", \"x\", \"12\", \"17\", \"16\", \"x\", \"9\", \"5\", \"6\", \"x\"], [\"17\", \"2\", \"x\", \"x\", \"16\", \"x\", \"5\", \"x\", \"x\", \"5\", \"17\", \"7\", \"2\", \"5\"], [\"19\", \"x\", \"x\", \"x\", \"x\", \"2\", \"15\", \"15\", \"x\", \"3\", \"11\", \"x\", \"4\", \"x\"], [\"x\", \"x\", \"11\", \"x\", \"x\", \"17\", \"5\", \"x\", \"5\", \"x\", \"x\", \"19\", \"6\", \"x\"], [\"16\", \"17\", \"16\", \"x\", \"12\", \"x\", \"2\", \"18\", \"9\", \"7\", \"x\", \"13\", \"x\", \"x\"], [\"18\", \"11\", \"x\", \"x\", \"19\", \"5\", \"x\", \"x\", \"18\", \"4\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"2\", \"5\", \"4\", \"12\", \"3\", \"x\", \"4\", \"14\", \"7\", \"19\"], [\"18\", \"x\", \"x\", \"x\", \"7\", \"17\", \"x\", \"x\", \"3\", \"15\", \"x\", \"16\", \"x\", \"10\"], [\"x\", \"11\", \"15\", \"x\", \"x\", \"x\", \"x\", \"x\", \"2\", \"13\", \"x\", \"x\", \"x\", \"3\"], [\"4\", \"8\", \"x\", \"x\", \"x\", \"x\", \"12\", \"13\", \"x\", \"x\", \"19\", \"x\", \"6\", \"x\"]], [7, 12], [2, 0], 2, 6]", "A*_args": "[\"[['x', 'x', 'x', '16', '11', '12', 'x', 'x', '17', '3', 'x', 'x', '4', '6'], ['4', '17', 'x', 'x', '3', 'x', 'x', '1', '9', '11', '12', '4', 'x', 'x'], ['5', 'x', 'x', '7', '14', '4', '5', '7', '13', '4', '7', 'x', 'x', 'x'], ['6', '6', '19', '3', '15', 'x', 'x', 'x', 'x', '4', '10', '19', '2', '4'], ['3', '16', '8', 'x', '5', 'x', '12', '17', '16', 'x', '9', '5', '6', 'x'], ['17', '2', 'x', 'x', '16', 'x', '5', 'x', 'x', '5', '17', '7', '2', '5'], ['19', 'x', 'x', 'x', 'x', '2', '15', '15', 'x', '3', '11', 'x', '4', 'x'], ['x', 'x', '11', 'x', 'x', '17', '5', 'x', '5', 'x', 'x', '19', '6', 'x'], ['16', '17', '16', 'x', '12', 'x', '2', '18', '9', '7', 'x', '13', 'x', 'x'], ['18', '11', 'x', 'x', '19', '5', 'x', 'x', '18', '4', 'x', 'x', 'x', 'x'], ['x', 'x', 'x', 'x', '2', '5', '4', '12', '3', 'x', '4', '14', '7', '19'], ['18', 'x', 'x', 'x', '7', '17', 'x', 'x', '3', '15', 'x', '16', 'x', '10'], ['x', '11', '15', 'x', 'x', 'x', 'x', 'x', '2', '13', 'x', 'x', 'x', '3'], ['4', '8', 'x', 'x', 'x', 'x', '12', '13', 'x', 'x', '19', 'x', '6', 'x']]\", \"(7, 12)\", \"(2, 0)\", \"2\", \"6\"]"}
{"diff_sorted_id": "78", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 14x14. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (10, 12) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (1, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 0 0 1 0 1 1 1 1 1 1 1 1\n1 0 0 0 0 0 0 0 0 1 0 1 1 0\n1 0 1 0 0 0 0 1 0 1 0 1 0 1\n0 0 0 0 0 1 0 0 0 0 1 1 1 0\n1 1 1 0 0 0 0 0 0 0 1 0 0 1\n0 0 1 1 1 1 1 1 0 0 1 1 0 0\n1 0 0 0 0 1 1 0 0 0 0 0 0 1\n1 1 1 0 1 1 1 1 0 0 0 0 0 1\n0 1 1 0 1 0 0 0 0 0 0 0 1 1\n0 1 1 1 1 1 1 1 1 0 0 0 0 0\n1 1 0 1 1 1 1 0 0 1 1 0 0 1\n1 1 1 0 1 0 1 1 1 0 0 1 1 1\n0 1 0 0 1 0 0 1 1 1 0 1 0 0\n1 1 1 1 1 1 0 1 0 1 1 1 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[[10, 12], [9, 11], [8, 10], [7, 9], [6, 8], [5, 8], [4, 8], [4, 7], [4, 6], [4, 5], [4, 4], [3, 4], [3, 3], [2, 3], [1, 3], [1, 2], [1, 1]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.030817031860351562", "solution_depth": "17", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0], [1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1], [0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1]]\", 4]", "is_correct_args": "[\"[[1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0], [1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1], [0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1]]\", [10, 12], [1, 1], 4]", "A*_args": "[\"[[1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0], [1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0], [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1], [0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1]]\", \"(10, 12)\", \"(1, 1)\", \"4\"]"}
{"diff_sorted_id": "78", "problem_statement": "Given 7 labeled water jugs with capacities 58, 18, 19, 47, 86, 75, 119, 34 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 234, 331, 343, 379 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 19, 4], [\"+\", 119, 4], [\"+\", 119, 4], [\"+\", 47, 4], [\"+\", 75, 4], [\"+\", 19, 3], [\"+\", 119, 3], [\"+\", 119, 3], [\"+\", 86, 3], [\"+\", 75, 2], [\"+\", 119, 2], [\"+\", 18, 2], [\"+\", 119, 2], [\"+\", 47, 1], [\"+\", 119, 1], [\"-\", 18, 1], [\"+\", 86, 1]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.05347609519958496", "solution_depth": "17", "max_successor_states": "64", "num_vars_per_state": "3", "is_feasible_args": "[[58, 18, 19, 47, 86, 75, 119, 34], [234, 331, 343, 379]]", "is_correct_args": "[[58, 18, 19, 47, 86, 75, 119, 34], [234, 331, 343, 379]]", "A*_args": "[\"[58, 18, 19, 47, 86, 75, 119, 34]\", \"[234, 331, 343, 379]\"]"}
{"diff_sorted_id": "79", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[42, 89, 21, 58, 67], [54, 32, 99, 69, 38], [77, 33, '_', 39, 16]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "7", "opt_solution": "[99, 32, 89, 42, 54, 77, 33, 99, 32, 21, 42, 54, 77, 89, 99, 32, 21, 42, 58, 69, 42, 58, 54, 77, 89, 99, 58, 54, 77, 89, 99, 58, 54, 42, 39, 16]", "opt_solution_cost": "36", "opt_solution_compute_t": "5.105415344238281", "solution_depth": "36", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[42, 89, 21, 58, 67], [54, 32, 99, 69, 38], [77, 33, \"_\", 39, 16]]]", "is_correct_args": "[[[42, 89, 21, 58, 67], [54, 32, 99, 69, 38], [77, 33, \"_\", 39, 16]]]", "A*_args": "[\"[[42, 89, 21, 58, 67], [54, 32, 99, 69, 38], [77, 33, '_', 39, 16]]\"]"}
{"diff_sorted_id": "79", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: siva, bryce, birny, pugil, linne   The initial board: [['r', 's', 'c', 'v', 'a'], ['b', 'b', 'y', 'r', 'e'], ['u', 'i', '_', 'n', 'i'], ['p', 'n', 'g', 'i', 'l'], ['l', 'i', 'y', 'n', 'e']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.3119840621948242", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"r\", \"s\", \"c\", \"v\", \"a\"], [\"b\", \"b\", \"y\", \"r\", \"e\"], [\"u\", \"i\", \"_\", \"n\", \"i\"], [\"p\", \"n\", \"g\", \"i\", \"l\"], [\"l\", \"i\", \"y\", \"n\", \"e\"]]]", "is_correct_args": "[[[\"r\", \"s\", \"c\", \"v\", \"a\"], [\"b\", \"b\", \"y\", \"r\", \"e\"], [\"u\", \"i\", \"_\", \"n\", \"i\"], [\"p\", \"n\", \"g\", \"i\", \"l\"], [\"l\", \"i\", \"y\", \"n\", \"e\"]], [\"siva\", \"bryce\", \"birny\", \"pugil\", \"linne\"]]", "A*_args": "[\"[['r', 's', 'c', 'v', 'a'], ['b', 'b', 'y', 'r', 'e'], ['u', 'i', '_', 'n', 'i'], ['p', 'n', 'g', 'i', 'l'], ['l', 'i', 'y', 'n', 'e']]\", \"['siva', 'bryce', 'birny', 'pugil', 'linne']\"]"}
{"diff_sorted_id": "79", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'I'. Our task is to visit city S and city W excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from W and S, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  Z G K N S X I F E C R V L W \nZ 0 0 0 1 0 0 0 1 0 0 0 0 0 0 \nG 0 0 0 0 0 0 0 0 1 0 1 0 0 1 \nK 0 0 0 1 1 0 0 0 0 0 0 1 0 1 \nN 0 0 0 0 1 1 0 0 0 0 0 0 0 0 \nS 0 0 0 0 0 1 0 0 1 0 0 0 0 0 \nX 0 1 0 0 0 0 1 1 0 1 0 0 1 0 \nI 0 0 0 0 0 0 0 0 0 0 0 1 0 0 \nF 0 0 0 1 1 0 0 0 0 1 0 0 0 1 \nE 1 0 1 0 0 1 1 0 0 1 1 0 0 0 \nC 0 1 0 1 0 0 0 0 0 0 0 0 0 1 \nR 0 0 1 0 0 0 0 0 0 1 0 0 0 0 \nV 0 1 1 0 1 0 1 0 1 0 1 0 0 0 \nL 0 1 0 0 0 0 1 1 0 0 0 0 0 0 \nW 1 0 0 0 0 1 0 0 0 1 0 1 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[\"I\", \"V\", \"S\", \"E\", \"K\", \"W\", \"C\", \"W\", \"L\", \"F\", \"S\"]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.06302189826965332", "solution_depth": "11", "max_successor_states": "14", "num_vars_per_state": "17", "is_feasible_args": "[[[0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0]], [\"Z\", \"G\", \"K\", \"N\", \"S\", \"X\", \"I\", \"F\", \"E\", \"C\", \"R\", \"V\", \"L\", \"W\"], \"S\", \"W\"]", "is_correct_args": "[[[0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0]], [\"Z\", \"G\", \"K\", \"N\", \"S\", \"X\", \"I\", \"F\", \"E\", \"C\", \"R\", \"V\", \"L\", \"W\"], \"I\", \"S\", \"W\"]", "A*_args": "[\"[[0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0]]\", \"['Z', 'G', 'K', 'N', 'S', 'X', 'I', 'F', 'E', 'C', 'R', 'V', 'L', 'W']\", \"['I']\", \"['S', 'W']\"]"}
{"diff_sorted_id": "79", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [33, 4, 5, 9, 31, 26, 25, 19, 31, 33, 24, 6, 13, 17, 15, 37, 7, 21, 3, 23, 22, 7, 3, 11, 19, 28, 24, 32, 27, 31, 24, 12, 23, 22, 16, 6, 33, 8, 19, 13, 5, 11, 10, 4, 8, 16, 14, 17, 13, 9, 25, 17], such that the sum of the chosen coins adds up to 389. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {3: 3, 19: 1, 5: 2, 9: 4, 17: 4, 24: 11, 8: 5, 22: 10, 4: 2, 32: 10, 16: 1, 37: 5, 23: 12, 26: 18, 12: 1, 27: 9, 14: 5, 25: 13, 15: 8, 6: 6, 21: 13, 10: 3, 31: 17, 7: 3, 33: 10, 11: 2, 28: 10, 13: 10}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "30", "opt_solution": "[11, 19, 19, 16, 19, 37, 16, 17, 17, 17, 27, 33, 10, 11, 33, 14, 33, 28, 12]", "opt_solution_cost": "84", "opt_solution_compute_t": "0.06765866279602051", "solution_depth": "19", "max_successor_states": "52", "num_vars_per_state": "52", "is_feasible_args": "[[33, 4, 5, 9, 31, 26, 25, 19, 31, 33, 24, 6, 13, 17, 15, 37, 7, 21, 3, 23, 22, 7, 3, 11, 19, 28, 24, 32, 27, 31, 24, 12, 23, 22, 16, 6, 33, 8, 19, 13, 5, 11, 10, 4, 8, 16, 14, 17, 13, 9, 25, 17]]", "is_correct_args": "[[33, 4, 5, 9, 31, 26, 25, 19, 31, 33, 24, 6, 13, 17, 15, 37, 7, 21, 3, 23, 22, 7, 3, 11, 19, 28, 24, 32, 27, 31, 24, 12, 23, 22, 16, 6, 33, 8, 19, 13, 5, 11, 10, 4, 8, 16, 14, 17, 13, 9, 25, 17], {\"3\": 3, \"19\": 1, \"5\": 2, \"9\": 4, \"17\": 4, \"24\": 11, \"8\": 5, \"22\": 10, \"4\": 2, \"32\": 10, \"16\": 1, \"37\": 5, \"23\": 12, \"26\": 18, \"12\": 1, \"27\": 9, \"14\": 5, \"25\": 13, \"15\": 8, \"6\": 6, \"21\": 13, \"10\": 3, \"31\": 17, \"7\": 3, \"33\": 10, \"11\": 2, \"28\": 10, \"13\": 10}, 389]", "A*_args": "[\"[33, 4, 5, 9, 31, 26, 25, 19, 31, 33, 24, 6, 13, 17, 15, 37, 7, 21, 3, 23, 22, 7, 3, 11, 19, 28, 24, 32, 27, 31, 24, 12, 23, 22, 16, 6, 33, 8, 19, 13, 5, 11, 10, 4, 8, 16, 14, 17, 13, 9, 25, 17]\", \"{3: 3, 19: 1, 5: 2, 9: 4, 17: 4, 24: 11, 8: 5, 22: 10, 4: 2, 32: 10, 16: 1, 37: 5, 23: 12, 26: 18, 12: 1, 27: 9, 14: 5, 25: 13, 15: 8, 6: 6, 21: 13, 10: 3, 31: 17, 7: 3, 33: 10, 11: 2, 28: 10, 13: 10}\", \"389\"]"}
{"diff_sorted_id": "79", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Red', 'Blue', 'Blue', 'Green'], ['Green', 'Green', 'Red', 'Red', 'Blue', 'Blue'], ['Blue', 'Red', 'Green', 'Blue', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[2, 0], [1, 2], [1, 2], [0, 2], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [2, 0], [2, 1], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [0, 1], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0], [1, 2], [1, 0], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1]]", "opt_solution_cost": "30", "opt_solution_compute_t": "487.9078462123871", "solution_depth": "30", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Red\", \"Green\", \"Red\", \"Blue\", \"Blue\", \"Green\"], [\"Green\", \"Green\", \"Red\", \"Red\", \"Blue\", \"Blue\"], [\"Blue\", \"Red\", \"Green\", \"Blue\", \"Green\", \"Red\"]], 9]", "is_correct_args": "[[[\"Red\", \"Green\", \"Red\", \"Blue\", \"Blue\", \"Green\"], [\"Green\", \"Green\", \"Red\", \"Red\", \"Blue\", \"Blue\"], [\"Blue\", \"Red\", \"Green\", \"Blue\", \"Green\", \"Red\"]], 9]", "A*_args": "[\"[['Red', 'Green', 'Red', 'Blue', 'Blue', 'Green'], ['Green', 'Green', 'Red', 'Red', 'Blue', 'Blue'], ['Blue', 'Red', 'Green', 'Blue', 'Green', 'Red']]\", \"9\"]"}
{"diff_sorted_id": "79", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 14 to 64 (14 included in the range but 64 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' '53' '62']\n ['x' '27' 'x' 'x']\n ['21' '22' 'x' '50']\n ['x' '20' '25' '44']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "12", "opt_solution": "[[0, 0, 37], [0, 2, 24], [0, 3, 23], [1, 3, 39], [2, 1, 40], [2, 3, 44], [3, 0, 25], [3, 1, 41]]", "opt_solution_cost": "447", "opt_solution_compute_t": "2.1435494422912598", "solution_depth": "8", "max_successor_states": "50", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '35', '', ''], ['34', '36', '38', ''], ['29', '', '43', ''], ['', '', '49', '53']]\", 23, 73]", "is_correct_args": "[\"[['', '35', '', ''], ['34', '36', '38', ''], ['29', '', '43', ''], ['', '', '49', '53']]\", 23, 73]", "A*_args": "[\"[['', '35', '', ''], ['34', '36', '38', ''], ['29', '', '43', ''], ['', '', '49', '53']]\", \"23\", \"73\"]"}
{"diff_sorted_id": "79", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 13 to 54. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 146, 168, None for columns 1 to 2 respectively, and the sums of rows must be None, 118, 120, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 91. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '46' 'x' '22']\n ['x' 'x' '36' '15']\n ['47' 'x' 'x' '25']\n ['x' 'x' '53' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 13], [0, 2, 50], [1, 0, 16], [1, 1, 51], [2, 1, 19], [2, 2, 29], [3, 0, 14], [3, 1, 30], [3, 3, 17]]", "opt_solution_cost": "483", "opt_solution_compute_t": "56.54647707939148", "solution_depth": "9", "max_successor_states": "31", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '46', '', '22'], ['', '', '36', '15'], ['47', '', '', '25'], ['', '', '53', '']]\", 4, 13, 54]", "is_correct_args": "[\"[['', '46', '', '22'], ['', '', '36', '15'], ['47', '', '', '25'], ['', '', '53', '']]\", 13, 54, [1, 3], [1, 3], [146, 168], [118, 120], 91]", "A*_args": "[\"[['', '46', '', '22'], ['', '', '36', '15'], ['47', '', '', '25'], ['', '', '53', '']]\", \"13\", \"54\", \"[None, 146, 168, None]\", \"[None, 118, 120, None]\", \"91\"]"}
{"diff_sorted_id": "79", "problem_statement": "In 'Restricted Sorting', there are 12 stacks each with a capacity of 7 blocks, with 6 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 6 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 10, 1: 4, 2: 5, 3: 4, 4: 7, 5: 3, 6: 11, 7: 5, 8: 9, 9: 3, 10: 11, 11: 2}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Red', 'Pink', 'Pink', 'Pink', 'Red', 'Black', 'Pink'], [], ['Green', 'Green', 'Blue', 'White', 'Yellow', 'Blue', 'Blue'], [], ['Green', 'Blue', 'White', 'Red', 'Blue', 'Black', 'Red'], ['Pink', 'White', 'Yellow', 'Black', 'Yellow', 'Green', 'White'], [], ['Red', 'Green', 'Black', 'White', 'Green', 'Red', 'Black'], [], [], ['Yellow', 'White', 'Yellow', 'Blue', 'Black', 'Yellow', 'Pink'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "4", "opt_solution": "[[0, 11], [7, 11], [2, 9], [2, 9], [4, 9], [7, 9], [7, 1], [7, 3], [7, 9], [7, 11], [7, 1], [4, 7], [4, 3], [4, 11], [4, 7], [4, 1], [4, 11], [5, 4], [5, 3], [2, 7], [2, 3], [2, 8], [2, 7], [2, 7], [5, 2], [5, 1], [5, 2], [5, 9], [10, 2], [10, 3], [10, 2], [10, 7], [10, 1], [10, 2], [5, 3], [0, 5], [0, 5], [0, 5], [0, 11], [0, 1], [8, 2], [0, 5], [4, 5], [10, 5]]", "opt_solution_cost": "172", "opt_solution_compute_t": "1.1443188190460205", "solution_depth": "44", "max_successor_states": "132", "num_vars_per_state": "42", "is_feasible_args": "[[[\"Red\", \"Pink\", \"Pink\", \"Pink\", \"Red\", \"Black\", \"Pink\"], [], [\"Green\", \"Green\", \"Blue\", \"White\", \"Yellow\", \"Blue\", \"Blue\"], [], [\"Green\", \"Blue\", \"White\", \"Red\", \"Blue\", \"Black\", \"Red\"], [\"Pink\", \"White\", \"Yellow\", \"Black\", \"Yellow\", \"Green\", \"White\"], [], [\"Red\", \"Green\", \"Black\", \"White\", \"Green\", \"Red\", \"Black\"], [], [], [\"Yellow\", \"White\", \"Yellow\", \"Blue\", \"Black\", \"Yellow\", \"Pink\"], []], 7, {\"0\": 10, \"1\": 4, \"2\": 5, \"3\": 4, \"4\": 7, \"5\": 3, \"6\": 11, \"7\": 5, \"8\": 9, \"9\": 3, \"10\": 11, \"11\": 2}]", "is_correct_args": "[[[\"Red\", \"Pink\", \"Pink\", \"Pink\", \"Red\", \"Black\", \"Pink\"], [], [\"Green\", \"Green\", \"Blue\", \"White\", \"Yellow\", \"Blue\", \"Blue\"], [], [\"Green\", \"Blue\", \"White\", \"Red\", \"Blue\", \"Black\", \"Red\"], [\"Pink\", \"White\", \"Yellow\", \"Black\", \"Yellow\", \"Green\", \"White\"], [], [\"Red\", \"Green\", \"Black\", \"White\", \"Green\", \"Red\", \"Black\"], [], [], [\"Yellow\", \"White\", \"Yellow\", \"Blue\", \"Black\", \"Yellow\", \"Pink\"], []], 7, {\"0\": 10, \"1\": 4, \"2\": 5, \"3\": 4, \"4\": 7, \"5\": 3, \"6\": 11, \"7\": 5, \"8\": 9, \"9\": 3, \"10\": 11, \"11\": 2}, 6]", "A*_args": "[\"[['Red', 'Pink', 'Pink', 'Pink', 'Red', 'Black', 'Pink'], [], ['Green', 'Green', 'Blue', 'White', 'Yellow', 'Blue', 'Blue'], [], ['Green', 'Blue', 'White', 'Red', 'Blue', 'Black', 'Red'], ['Pink', 'White', 'Yellow', 'Black', 'Yellow', 'Green', 'White'], [], ['Red', 'Green', 'Black', 'White', 'Green', 'Red', 'Black'], [], [], ['Yellow', 'White', 'Yellow', 'Blue', 'Black', 'Yellow', 'Pink'], []]\", \"{0: 10, 1: 4, 2: 5, 3: 4, 4: 7, 5: 3, 6: 11, 7: 5, 8: 9, 9: 3, 10: 11, 11: 2}\", \"7\", \"6\"]"}
{"diff_sorted_id": "79", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (4, 12) to his destination workshop at index (7, 0), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 4, district 2 covering rows 5 to 6, and district 3 covering rows 7 to 13. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x 17 7 x x 11 4 5 15 17 6 6 2]\n[17 x x 6 x x x x 1 8 x x x 7]\n[x x x 17 4 10 6 4 x 8 16 11 x x]\n[x 4 x x 10 x 8 10 x 11 x x 1 x]\n[x x 11 9 4 x 8 8 x x x 16 13 8]\n[x 12 3 15 13 13 x 15 19 x 2 2 6 x]\n[15 1 x x x x 5 4 x 5 12 2 5 x]\n[20 13 7 18 8 18 5 2 17 7 11 x 15 13]\n[4 11 x x 10 9 x 18 14 x 19 x x x]\n[19 x 2 x 18 17 10 x x x 13 15 x 10]\n[16 5 2 3 13 x x x x x x x x 3]\n[x x x x 17 9 x x x x x 6 x x]\n[11 x x 9 14 x x 16 x 15 13 13 15 1]\n[9 x x 10 14 x x x x x x x 1 19]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "6", "opt_solution": "[[4, 12], [5, 12], [5, 11], [5, 10], [6, 10], [6, 9], [7, 9], [7, 8], [7, 7], [7, 6], [7, 5], [7, 4], [7, 3], [7, 2], [7, 1], [7, 0]]", "opt_solution_cost": "142", "opt_solution_compute_t": "0.02055048942565918", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"17\", \"7\", \"x\", \"x\", \"11\", \"4\", \"5\", \"15\", \"17\", \"6\", \"6\", \"2\"], [\"17\", \"x\", \"x\", \"6\", \"x\", \"x\", \"x\", \"x\", \"1\", \"8\", \"x\", \"x\", \"x\", \"7\"], [\"x\", \"x\", \"x\", \"17\", \"4\", \"10\", \"6\", \"4\", \"x\", \"8\", \"16\", \"11\", \"x\", \"x\"], [\"x\", \"4\", \"x\", \"x\", \"10\", \"x\", \"8\", \"10\", \"x\", \"11\", \"x\", \"x\", \"1\", \"x\"], [\"x\", \"x\", \"11\", \"9\", \"4\", \"x\", \"8\", \"8\", \"x\", \"x\", \"x\", \"16\", \"13\", \"8\"], [\"x\", \"12\", \"3\", \"15\", \"13\", \"13\", \"x\", \"15\", \"19\", \"x\", \"2\", \"2\", \"6\", \"x\"], [\"15\", \"1\", \"x\", \"x\", \"x\", \"x\", \"5\", \"4\", \"x\", \"5\", \"12\", \"2\", \"5\", \"x\"], [\"20\", \"13\", \"7\", \"18\", \"8\", \"18\", \"5\", \"2\", \"17\", \"7\", \"11\", \"x\", \"15\", \"13\"], [\"4\", \"11\", \"x\", \"x\", \"10\", \"9\", \"x\", \"18\", \"14\", \"x\", \"19\", \"x\", \"x\", \"x\"], [\"19\", \"x\", \"2\", \"x\", \"18\", \"17\", \"10\", \"x\", \"x\", \"x\", \"13\", \"15\", \"x\", \"10\"], [\"16\", \"5\", \"2\", \"3\", \"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"3\"], [\"x\", \"x\", \"x\", \"x\", \"17\", \"9\", \"x\", \"x\", \"x\", \"x\", \"x\", \"6\", \"x\", \"x\"], [\"11\", \"x\", \"x\", \"9\", \"14\", \"x\", \"x\", \"16\", \"x\", \"15\", \"13\", \"13\", \"15\", \"1\"], [\"9\", \"x\", \"x\", \"10\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"1\", \"19\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"17\", \"7\", \"x\", \"x\", \"11\", \"4\", \"5\", \"15\", \"17\", \"6\", \"6\", \"2\"], [\"17\", \"x\", \"x\", \"6\", \"x\", \"x\", \"x\", \"x\", \"1\", \"8\", \"x\", \"x\", \"x\", \"7\"], [\"x\", \"x\", \"x\", \"17\", \"4\", \"10\", \"6\", \"4\", \"x\", \"8\", \"16\", \"11\", \"x\", \"x\"], [\"x\", \"4\", \"x\", \"x\", \"10\", \"x\", \"8\", \"10\", \"x\", \"11\", \"x\", \"x\", \"1\", \"x\"], [\"x\", \"x\", \"11\", \"9\", \"4\", \"x\", \"8\", \"8\", \"x\", \"x\", \"x\", \"16\", \"13\", \"8\"], [\"x\", \"12\", \"3\", \"15\", \"13\", \"13\", \"x\", \"15\", \"19\", \"x\", \"2\", \"2\", \"6\", \"x\"], [\"15\", \"1\", \"x\", \"x\", \"x\", \"x\", \"5\", \"4\", \"x\", \"5\", \"12\", \"2\", \"5\", \"x\"], [\"20\", \"13\", \"7\", \"18\", \"8\", \"18\", \"5\", \"2\", \"17\", \"7\", \"11\", \"x\", \"15\", \"13\"], [\"4\", \"11\", \"x\", \"x\", \"10\", \"9\", \"x\", \"18\", \"14\", \"x\", \"19\", \"x\", \"x\", \"x\"], [\"19\", \"x\", \"2\", \"x\", \"18\", \"17\", \"10\", \"x\", \"x\", \"x\", \"13\", \"15\", \"x\", \"10\"], [\"16\", \"5\", \"2\", \"3\", \"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"3\"], [\"x\", \"x\", \"x\", \"x\", \"17\", \"9\", \"x\", \"x\", \"x\", \"x\", \"x\", \"6\", \"x\", \"x\"], [\"11\", \"x\", \"x\", \"9\", \"14\", \"x\", \"x\", \"16\", \"x\", \"15\", \"13\", \"13\", \"15\", \"1\"], [\"9\", \"x\", \"x\", \"10\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"1\", \"19\"]], [4, 12], [7, 0], 4, 6]", "A*_args": "[\"[['x', 'x', '17', '7', 'x', 'x', '11', '4', '5', '15', '17', '6', '6', '2'], ['17', 'x', 'x', '6', 'x', 'x', 'x', 'x', '1', '8', 'x', 'x', 'x', '7'], ['x', 'x', 'x', '17', '4', '10', '6', '4', 'x', '8', '16', '11', 'x', 'x'], ['x', '4', 'x', 'x', '10', 'x', '8', '10', 'x', '11', 'x', 'x', '1', 'x'], ['x', 'x', '11', '9', '4', 'x', '8', '8', 'x', 'x', 'x', '16', '13', '8'], ['x', '12', '3', '15', '13', '13', 'x', '15', '19', 'x', '2', '2', '6', 'x'], ['15', '1', 'x', 'x', 'x', 'x', '5', '4', 'x', '5', '12', '2', '5', 'x'], ['20', '13', '7', '18', '8', '18', '5', '2', '17', '7', '11', 'x', '15', '13'], ['4', '11', 'x', 'x', '10', '9', 'x', '18', '14', 'x', '19', 'x', 'x', 'x'], ['19', 'x', '2', 'x', '18', '17', '10', 'x', 'x', 'x', '13', '15', 'x', '10'], ['16', '5', '2', '3', '13', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', '3'], ['x', 'x', 'x', 'x', '17', '9', 'x', 'x', 'x', 'x', 'x', '6', 'x', 'x'], ['11', 'x', 'x', '9', '14', 'x', 'x', '16', 'x', '15', '13', '13', '15', '1'], ['9', 'x', 'x', '10', '14', 'x', 'x', 'x', 'x', 'x', 'x', 'x', '1', '19']]\", \"(4, 12)\", \"(7, 0)\", \"4\", \"6\"]"}
{"diff_sorted_id": "79", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 14x14. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (10, 10) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (1, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 0 0 0 1 1 0 1 0 0 1 1 1\n0 0 0 0 0 1 1 0 0 0 1 1 1 0\n0 0 0 1 0 0 0 0 0 0 1 0 0 1\n0 1 1 1 0 0 1 1 0 0 0 0 1 0\n1 1 0 0 1 1 1 1 0 0 0 0 1 0\n1 0 1 1 1 1 1 0 1 1 0 0 0 1\n0 0 1 1 1 1 0 0 0 0 0 1 0 0\n0 0 1 1 1 1 1 1 1 1 0 0 0 0\n0 1 1 1 0 1 1 1 0 0 0 1 0 1\n0 1 1 1 0 1 1 1 0 1 0 1 1 0\n0 1 0 1 1 1 0 1 1 1 0 0 1 1\n0 1 1 0 1 1 1 1 1 0 1 0 1 0\n1 1 1 0 0 1 1 0 1 1 1 0 0 1\n1 1 1 1 0 0 1 0 1 1 1 1 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[[10, 10], [9, 10], [8, 10], [7, 10], [6, 10], [5, 10], [4, 9], [3, 8], [2, 7], [2, 6], [2, 5], [1, 4], [1, 3], [1, 2], [1, 1], [1, 0]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.03317451477050781", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0], [0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1], [0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1], [1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1]]\", 4]", "is_correct_args": "[\"[[0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0], [0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1], [0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1], [1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1]]\", [10, 10], [1, 0], 4]", "A*_args": "[\"[[0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1], [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1], [0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0], [0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1], [0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1], [1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1]]\", \"(10, 10)\", \"(1, 0)\", \"4\"]"}
{"diff_sorted_id": "79", "problem_statement": "Given 7 labeled water jugs with capacities 99, 47, 122, 123, 72, 136, 51, 71 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 274, 292, 361, 438 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 122, 4], [\"+\", 122, 4], [\"+\", 71, 4], [\"+\", 123, 4], [\"+\", 51, 3], [\"+\", 51, 3], [\"+\", 123, 3], [\"+\", 136, 3], [\"+\", 122, 2], [\"+\", 123, 2], [\"+\", 47, 2], [\"+\", 99, 1], [\"+\", 99, 1], [\"-\", 47, 1], [\"+\", 123, 1]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.051012516021728516", "solution_depth": "15", "max_successor_states": "64", "num_vars_per_state": "3", "is_feasible_args": "[[99, 47, 122, 123, 72, 136, 51, 71], [274, 292, 361, 438]]", "is_correct_args": "[[99, 47, 122, 123, 72, 136, 51, 71], [274, 292, 361, 438]]", "A*_args": "[\"[99, 47, 122, 123, 72, 136, 51, 71]\", \"[274, 292, 361, 438]\"]"}
{"diff_sorted_id": "80", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[97, 78, '_', 9, 67], [18, 65, 52, 27, 66], [38, 92, 50, 14, 6]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "7", "opt_solution": "[9, 67, 66, 27, 14, 50, 92, 38, 18, 65, 52, 92, 38, 52, 92, 14, 50, 38, 14, 9, 78, 92, 52, 14, 9, 50, 38, 6]", "opt_solution_cost": "28", "opt_solution_compute_t": "0.24241900444030762", "solution_depth": "28", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[97, 78, \"_\", 9, 67], [18, 65, 52, 27, 66], [38, 92, 50, 14, 6]]]", "is_correct_args": "[[[97, 78, \"_\", 9, 67], [18, 65, 52, 27, 66], [38, 92, 50, 14, 6]]]", "A*_args": "[\"[[97, 78, '_', 9, 67], [18, 65, 52, 27, 66], [38, 92, 50, 14, 6]]\"]"}
{"diff_sorted_id": "80", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: welt, eddic, equip, macer, yurta   The initial board: [['d', 'w', 'p', 'l', 't'], ['e', 'i', 'd', 'e', 'c'], ['_', 'q', 'e', 'i', 'r'], ['m', 'e', 'c', 'u', 'r'], ['y', 'u', 'a', 't', 'a']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-right\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.22876906394958496", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"d\", \"w\", \"p\", \"l\", \"t\"], [\"e\", \"i\", \"d\", \"e\", \"c\"], [\"_\", \"q\", \"e\", \"i\", \"r\"], [\"m\", \"e\", \"c\", \"u\", \"r\"], [\"y\", \"u\", \"a\", \"t\", \"a\"]]]", "is_correct_args": "[[[\"d\", \"w\", \"p\", \"l\", \"t\"], [\"e\", \"i\", \"d\", \"e\", \"c\"], [\"_\", \"q\", \"e\", \"i\", \"r\"], [\"m\", \"e\", \"c\", \"u\", \"r\"], [\"y\", \"u\", \"a\", \"t\", \"a\"]], [\"welt\", \"eddic\", \"equip\", \"macer\", \"yurta\"]]", "A*_args": "[\"[['d', 'w', 'p', 'l', 't'], ['e', 'i', 'd', 'e', 'c'], ['_', 'q', 'e', 'i', 'r'], ['m', 'e', 'c', 'u', 'r'], ['y', 'u', 'a', 't', 'a']]\", \"['welt', 'eddic', 'equip', 'macer', 'yurta']\"]"}
{"diff_sorted_id": "80", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'Y'. Our task is to visit city M and city B excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from B and M, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  S X G E P B O C L J M Y T W \nS 0 0 0 1 1 0 0 0 0 0 1 0 0 0 \nX 0 0 0 1 0 0 0 1 0 0 0 0 1 1 \nG 1 0 0 0 0 0 0 1 0 0 0 1 0 0 \nE 0 1 0 0 0 1 1 0 1 0 0 0 0 0 \nP 0 0 1 0 0 0 0 1 1 1 1 0 0 0 \nB 1 0 0 0 0 0 0 1 1 0 0 0 0 0 \nO 0 1 0 0 0 0 0 0 0 0 0 0 0 0 \nC 0 0 0 0 0 0 1 0 1 1 0 0 0 0 \nL 0 1 0 0 1 0 0 0 0 1 0 0 0 0 \nJ 0 1 1 0 0 1 0 1 0 0 0 1 1 0 \nM 0 1 1 0 0 0 1 1 0 0 0 0 1 1 \nY 0 0 0 0 1 0 0 0 0 0 0 0 0 1 \nT 1 0 1 1 0 1 0 1 0 0 0 0 0 0 \nW 0 0 1 0 0 1 0 0 0 0 0 1 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[\"Y\", \"P\", \"M\", \"T\", \"B\", \"S\", \"M\", \"W\", \"B\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.04214882850646973", "solution_depth": "9", "max_successor_states": "14", "num_vars_per_state": "17", "is_feasible_args": "[[[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0]], [\"S\", \"X\", \"G\", \"E\", \"P\", \"B\", \"O\", \"C\", \"L\", \"J\", \"M\", \"Y\", \"T\", \"W\"], \"M\", \"B\"]", "is_correct_args": "[[[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0]], [\"S\", \"X\", \"G\", \"E\", \"P\", \"B\", \"O\", \"C\", \"L\", \"J\", \"M\", \"Y\", \"T\", \"W\"], \"Y\", \"M\", \"B\"]", "A*_args": "[\"[[0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0]]\", \"['S', 'X', 'G', 'E', 'P', 'B', 'O', 'C', 'L', 'J', 'M', 'Y', 'T', 'W']\", \"['Y']\", \"['M', 'B']\"]"}
{"diff_sorted_id": "80", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [8, 7, 5, 24, 3, 18, 36, 39, 36, 25, 25, 33, 16, 20, 34, 9, 1, 22, 25, 13, 8, 37, 35, 39, 11, 26, 36, 25, 25, 27, 2, 4, 35, 2, 16, 22, 12, 15, 19, 2, 17, 25, 28, 12, 26, 17, 33, 5, 30, 3, 21, 3], such that the sum of the chosen coins adds up to 397. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {13: 7, 39: 4, 20: 18, 5: 1, 12: 7, 9: 5, 28: 20, 24: 11, 3: 3, 17: 3, 21: 9, 37: 6, 16: 8, 15: 1, 26: 10, 36: 6, 22: 9, 2: 2, 8: 1, 25: 20, 4: 3, 7: 5, 19: 7, 30: 6, 27: 12, 1: 1, 34: 7, 35: 5, 11: 6, 18: 12, 33: 4}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "31", "opt_solution": "[5, 33, 33, 39, 8, 39, 36, 8, 15, 35, 35, 37, 36, 34, 4]", "opt_solution_cost": "58", "opt_solution_compute_t": "0.06058311462402344", "solution_depth": "15", "max_successor_states": "52", "num_vars_per_state": "52", "is_feasible_args": "[[8, 7, 5, 24, 3, 18, 36, 39, 36, 25, 25, 33, 16, 20, 34, 9, 1, 22, 25, 13, 8, 37, 35, 39, 11, 26, 36, 25, 25, 27, 2, 4, 35, 2, 16, 22, 12, 15, 19, 2, 17, 25, 28, 12, 26, 17, 33, 5, 30, 3, 21, 3]]", "is_correct_args": "[[8, 7, 5, 24, 3, 18, 36, 39, 36, 25, 25, 33, 16, 20, 34, 9, 1, 22, 25, 13, 8, 37, 35, 39, 11, 26, 36, 25, 25, 27, 2, 4, 35, 2, 16, 22, 12, 15, 19, 2, 17, 25, 28, 12, 26, 17, 33, 5, 30, 3, 21, 3], {\"13\": 7, \"39\": 4, \"20\": 18, \"5\": 1, \"12\": 7, \"9\": 5, \"28\": 20, \"24\": 11, \"3\": 3, \"17\": 3, \"21\": 9, \"37\": 6, \"16\": 8, \"15\": 1, \"26\": 10, \"36\": 6, \"22\": 9, \"2\": 2, \"8\": 1, \"25\": 20, \"4\": 3, \"7\": 5, \"19\": 7, \"30\": 6, \"27\": 12, \"1\": 1, \"34\": 7, \"35\": 5, \"11\": 6, \"18\": 12, \"33\": 4}, 397]", "A*_args": "[\"[8, 7, 5, 24, 3, 18, 36, 39, 36, 25, 25, 33, 16, 20, 34, 9, 1, 22, 25, 13, 8, 37, 35, 39, 11, 26, 36, 25, 25, 27, 2, 4, 35, 2, 16, 22, 12, 15, 19, 2, 17, 25, 28, 12, 26, 17, 33, 5, 30, 3, 21, 3]\", \"{13: 7, 39: 4, 20: 18, 5: 1, 12: 7, 9: 5, 28: 20, 24: 11, 3: 3, 17: 3, 21: 9, 37: 6, 16: 8, 15: 1, 26: 10, 36: 6, 22: 9, 2: 2, 8: 1, 25: 20, 4: 3, 7: 5, 19: 7, 30: 6, 27: 12, 1: 1, 34: 7, 35: 5, 11: 6, 18: 12, 33: 4}\", \"397\"]"}
{"diff_sorted_id": "80", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Red', 'Blue', 'Green', 'Blue', 'Green'], ['Green', 'Green', 'Green', 'Blue', 'Blue', 'Red'], ['Green', 'Blue', 'Red', 'Red', 'Red', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[0, 1], [2, 1], [2, 1], [0, 2], [0, 2], [1, 2], [0, 1], [0, 2], [1, 0], [1, 0], [1, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [2, 1], [0, 2], [0, 1], [0, 1]]", "opt_solution_cost": "24", "opt_solution_compute_t": "30.166829586029053", "solution_depth": "24", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Blue\", \"Red\", \"Blue\", \"Green\", \"Blue\", \"Green\"], [\"Green\", \"Green\", \"Green\", \"Blue\", \"Blue\", \"Red\"], [\"Green\", \"Blue\", \"Red\", \"Red\", \"Red\", \"Red\"]], 9]", "is_correct_args": "[[[\"Blue\", \"Red\", \"Blue\", \"Green\", \"Blue\", \"Green\"], [\"Green\", \"Green\", \"Green\", \"Blue\", \"Blue\", \"Red\"], [\"Green\", \"Blue\", \"Red\", \"Red\", \"Red\", \"Red\"]], 9]", "A*_args": "[\"[['Blue', 'Red', 'Blue', 'Green', 'Blue', 'Green'], ['Green', 'Green', 'Green', 'Blue', 'Blue', 'Red'], ['Green', 'Blue', 'Red', 'Red', 'Red', 'Red']]\", \"9\"]"}
{"diff_sorted_id": "80", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 22 to 72 (22 included in the range but 72 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['37' '50' 'x' '70']\n ['x' '46' 'x' '65']\n ['41' '43' 'x' '49']\n ['x' '30' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "12", "opt_solution": "[[0, 0, 10], [1, 0, 11], [1, 1, 16], [1, 2, 19], [2, 0, 12], [2, 1, 15], [2, 2, 18], [3, 0, 13], [3, 1, 14], [3, 2, 17]]", "opt_solution_cost": "423", "opt_solution_compute_t": "58.67084217071533", "solution_depth": "10", "max_successor_states": "50", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '33', '34', '47'], ['', '', '', '50'], ['', '', '', '52'], ['', '', '', '53']]\", 10, 60]", "is_correct_args": "[\"[['', '33', '34', '47'], ['', '', '', '50'], ['', '', '', '52'], ['', '', '', '53']]\", 10, 60]", "A*_args": "[\"[['', '33', '34', '47'], ['', '', '', '50'], ['', '', '', '52'], ['', '', '', '53']]\", \"10\", \"60\"]"}
{"diff_sorted_id": "80", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 35 to 76. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 247, 236, None for columns 1 to 2 respectively, and the sums of rows must be None, 231, 259, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 234. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x' '60']\n ['72' 'x' 'x' 'x']\n ['63' '70' 'x' 'x']\n ['61' '75' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 35], [0, 1, 36], [0, 2, 46], [1, 1, 66], [1, 2, 43], [1, 3, 50], [2, 2, 74], [2, 3, 52], [3, 2, 73], [3, 3, 37]]", "opt_solution_cost": "913", "opt_solution_compute_t": "48.18892478942871", "solution_depth": "10", "max_successor_states": "31", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '', '60'], ['72', '', '', ''], ['63', '70', '', ''], ['61', '75', '', '']]\", 4, 35, 76]", "is_correct_args": "[\"[['', '', '', '60'], ['72', '', '', ''], ['63', '70', '', ''], ['61', '75', '', '']]\", 35, 76, [1, 3], [1, 3], [247, 236], [231, 259], 234]", "A*_args": "[\"[['', '', '', '60'], ['72', '', '', ''], ['63', '70', '', ''], ['61', '75', '', '']]\", \"35\", \"76\", \"[None, 247, 236, None]\", \"[None, 231, 259, None]\", \"234\"]"}
{"diff_sorted_id": "80", "problem_statement": "In 'Restricted Sorting', there are 12 stacks each with a capacity of 7 blocks, with 6 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 6 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 12, 1: 11, 2: 5, 3: 11, 4: 10, 5: 9, 6: 5, 7: 5, 8: 3, 9: 10, 10: 5, 11: 5}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Yellow', 'Yellow', 'Pink', 'Black', 'Green', 'Green', 'Yellow'], ['Pink', 'Yellow', 'White', 'Red', 'Black', 'Blue', 'Blue'], [], [], ['Pink', 'Green', 'Pink', 'Pink', 'Blue', 'Red', 'Red'], ['Black', 'Black', 'Black', 'Blue', 'Yellow', 'Red', 'White'], [], [], [], [], ['Green', 'Blue', 'Red', 'Red', 'Green', 'White', 'Black'], ['White', 'White', 'Green', 'Yellow', 'Blue', 'White', 'Pink']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "4", "opt_solution": "[[1, 8], [1, 2], [1, 6], [10, 7], [4, 8], [4, 7], [4, 8], [4, 8], [0, 2], [0, 2], [0, 8], [11, 6], [11, 6], [11, 7], [11, 2], [0, 9], [0, 7], [0, 7], [1, 3], [1, 9], [4, 1], [10, 1], [11, 1], [11, 6], [11, 8], [10, 11], [10, 11], [10, 7], [10, 6], [5, 10], [5, 10], [5, 10], [5, 1], [5, 2], [5, 11], [0, 2], [3, 11], [4, 11], [4, 11], [5, 6], [9, 10], [9, 10]]", "opt_solution_cost": "238", "opt_solution_compute_t": "2.470271110534668", "solution_depth": "42", "max_successor_states": "132", "num_vars_per_state": "42", "is_feasible_args": "[[[\"Yellow\", \"Yellow\", \"Pink\", \"Black\", \"Green\", \"Green\", \"Yellow\"], [\"Pink\", \"Yellow\", \"White\", \"Red\", \"Black\", \"Blue\", \"Blue\"], [], [], [\"Pink\", \"Green\", \"Pink\", \"Pink\", \"Blue\", \"Red\", \"Red\"], [\"Black\", \"Black\", \"Black\", \"Blue\", \"Yellow\", \"Red\", \"White\"], [], [], [], [], [\"Green\", \"Blue\", \"Red\", \"Red\", \"Green\", \"White\", \"Black\"], [\"White\", \"White\", \"Green\", \"Yellow\", \"Blue\", \"White\", \"Pink\"]], 7, {\"0\": 12, \"1\": 11, \"2\": 5, \"3\": 11, \"4\": 10, \"5\": 9, \"6\": 5, \"7\": 5, \"8\": 3, \"9\": 10, \"10\": 5, \"11\": 5}]", "is_correct_args": "[[[\"Yellow\", \"Yellow\", \"Pink\", \"Black\", \"Green\", \"Green\", \"Yellow\"], [\"Pink\", \"Yellow\", \"White\", \"Red\", \"Black\", \"Blue\", \"Blue\"], [], [], [\"Pink\", \"Green\", \"Pink\", \"Pink\", \"Blue\", \"Red\", \"Red\"], [\"Black\", \"Black\", \"Black\", \"Blue\", \"Yellow\", \"Red\", \"White\"], [], [], [], [], [\"Green\", \"Blue\", \"Red\", \"Red\", \"Green\", \"White\", \"Black\"], [\"White\", \"White\", \"Green\", \"Yellow\", \"Blue\", \"White\", \"Pink\"]], 7, {\"0\": 12, \"1\": 11, \"2\": 5, \"3\": 11, \"4\": 10, \"5\": 9, \"6\": 5, \"7\": 5, \"8\": 3, \"9\": 10, \"10\": 5, \"11\": 5}, 6]", "A*_args": "[\"[['Yellow', 'Yellow', 'Pink', 'Black', 'Green', 'Green', 'Yellow'], ['Pink', 'Yellow', 'White', 'Red', 'Black', 'Blue', 'Blue'], [], [], ['Pink', 'Green', 'Pink', 'Pink', 'Blue', 'Red', 'Red'], ['Black', 'Black', 'Black', 'Blue', 'Yellow', 'Red', 'White'], [], [], [], [], ['Green', 'Blue', 'Red', 'Red', 'Green', 'White', 'Black'], ['White', 'White', 'Green', 'Yellow', 'Blue', 'White', 'Pink']]\", \"{0: 12, 1: 11, 2: 5, 3: 11, 4: 10, 5: 9, 6: 5, 7: 5, 8: 3, 9: 10, 10: 5, 11: 5}\", \"7\", \"6\"]"}
{"diff_sorted_id": "80", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (1, 10) to his destination workshop at index (7, 2), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 6, and district 3 covering rows 7 to 13. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x 8 16 3 x 15 17 2 x x 5 x x]\n[x x 17 x 13 x 4 x 13 3 3 6 11 x]\n[x x 8 x 14 1 15 11 x 18 12 x x x]\n[x 13 19 4 13 2 13 3 x 1 20 18 x 15]\n[13 x 1 x 11 x 8 14 4 11 3 x x x]\n[12 11 16 1 1 x 5 1 x 9 x x 1 x]\n[8 x 6 15 x 7 19 13 2 x 3 3 x 2]\n[18 x 19 15 2 x x 18 2 x 10 x x 1]\n[3 4 x 19 x 6 x 7 x x x x 15 x]\n[x x x 16 7 17 11 x 7 x x x x 15]\n[x 9 x x x 19 19 7 3 12 14 11 16 7]\n[8 19 15 1 x 14 x 1 x x x x x x]\n[x 14 x x x x x 18 x x 2 11 7 x]\n[x x x x x 3 11 12 x x x 2 6 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "6", "opt_solution": "[[1, 10], [1, 9], [2, 9], [3, 9], [4, 9], [4, 8], [4, 7], [3, 7], [3, 6], [3, 5], [3, 4], [4, 4], [5, 4], [5, 3], [6, 3], [6, 2], [7, 2]]", "opt_solution_cost": "135", "opt_solution_compute_t": "0.02765035629272461", "solution_depth": "17", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"8\", \"16\", \"3\", \"x\", \"15\", \"17\", \"2\", \"x\", \"x\", \"5\", \"x\", \"x\"], [\"x\", \"x\", \"17\", \"x\", \"13\", \"x\", \"4\", \"x\", \"13\", \"3\", \"3\", \"6\", \"11\", \"x\"], [\"x\", \"x\", \"8\", \"x\", \"14\", \"1\", \"15\", \"11\", \"x\", \"18\", \"12\", \"x\", \"x\", \"x\"], [\"x\", \"13\", \"19\", \"4\", \"13\", \"2\", \"13\", \"3\", \"x\", \"1\", \"20\", \"18\", \"x\", \"15\"], [\"13\", \"x\", \"1\", \"x\", \"11\", \"x\", \"8\", \"14\", \"4\", \"11\", \"3\", \"x\", \"x\", \"x\"], [\"12\", \"11\", \"16\", \"1\", \"1\", \"x\", \"5\", \"1\", \"x\", \"9\", \"x\", \"x\", \"1\", \"x\"], [\"8\", \"x\", \"6\", \"15\", \"x\", \"7\", \"19\", \"13\", \"2\", \"x\", \"3\", \"3\", \"x\", \"2\"], [\"18\", \"x\", \"19\", \"15\", \"2\", \"x\", \"x\", \"18\", \"2\", \"x\", \"10\", \"x\", \"x\", \"1\"], [\"3\", \"4\", \"x\", \"19\", \"x\", \"6\", \"x\", \"7\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\"], [\"x\", \"x\", \"x\", \"16\", \"7\", \"17\", \"11\", \"x\", \"7\", \"x\", \"x\", \"x\", \"x\", \"15\"], [\"x\", \"9\", \"x\", \"x\", \"x\", \"19\", \"19\", \"7\", \"3\", \"12\", \"14\", \"11\", \"16\", \"7\"], [\"8\", \"19\", \"15\", \"1\", \"x\", \"14\", \"x\", \"1\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\", \"2\", \"11\", \"7\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"3\", \"11\", \"12\", \"x\", \"x\", \"x\", \"2\", \"6\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"8\", \"16\", \"3\", \"x\", \"15\", \"17\", \"2\", \"x\", \"x\", \"5\", \"x\", \"x\"], [\"x\", \"x\", \"17\", \"x\", \"13\", \"x\", \"4\", \"x\", \"13\", \"3\", \"3\", \"6\", \"11\", \"x\"], [\"x\", \"x\", \"8\", \"x\", \"14\", \"1\", \"15\", \"11\", \"x\", \"18\", \"12\", \"x\", \"x\", \"x\"], [\"x\", \"13\", \"19\", \"4\", \"13\", \"2\", \"13\", \"3\", \"x\", \"1\", \"20\", \"18\", \"x\", \"15\"], [\"13\", \"x\", \"1\", \"x\", \"11\", \"x\", \"8\", \"14\", \"4\", \"11\", \"3\", \"x\", \"x\", \"x\"], [\"12\", \"11\", \"16\", \"1\", \"1\", \"x\", \"5\", \"1\", \"x\", \"9\", \"x\", \"x\", \"1\", \"x\"], [\"8\", \"x\", \"6\", \"15\", \"x\", \"7\", \"19\", \"13\", \"2\", \"x\", \"3\", \"3\", \"x\", \"2\"], [\"18\", \"x\", \"19\", \"15\", \"2\", \"x\", \"x\", \"18\", \"2\", \"x\", \"10\", \"x\", \"x\", \"1\"], [\"3\", \"4\", \"x\", \"19\", \"x\", \"6\", \"x\", \"7\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\"], [\"x\", \"x\", \"x\", \"16\", \"7\", \"17\", \"11\", \"x\", \"7\", \"x\", \"x\", \"x\", \"x\", \"15\"], [\"x\", \"9\", \"x\", \"x\", \"x\", \"19\", \"19\", \"7\", \"3\", \"12\", \"14\", \"11\", \"16\", \"7\"], [\"8\", \"19\", \"15\", \"1\", \"x\", \"14\", \"x\", \"1\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\", \"2\", \"11\", \"7\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"3\", \"11\", \"12\", \"x\", \"x\", \"x\", \"2\", \"6\", \"x\"]], [1, 10], [7, 2], 1, 6]", "A*_args": "[\"[['x', 'x', '8', '16', '3', 'x', '15', '17', '2', 'x', 'x', '5', 'x', 'x'], ['x', 'x', '17', 'x', '13', 'x', '4', 'x', '13', '3', '3', '6', '11', 'x'], ['x', 'x', '8', 'x', '14', '1', '15', '11', 'x', '18', '12', 'x', 'x', 'x'], ['x', '13', '19', '4', '13', '2', '13', '3', 'x', '1', '20', '18', 'x', '15'], ['13', 'x', '1', 'x', '11', 'x', '8', '14', '4', '11', '3', 'x', 'x', 'x'], ['12', '11', '16', '1', '1', 'x', '5', '1', 'x', '9', 'x', 'x', '1', 'x'], ['8', 'x', '6', '15', 'x', '7', '19', '13', '2', 'x', '3', '3', 'x', '2'], ['18', 'x', '19', '15', '2', 'x', 'x', '18', '2', 'x', '10', 'x', 'x', '1'], ['3', '4', 'x', '19', 'x', '6', 'x', '7', 'x', 'x', 'x', 'x', '15', 'x'], ['x', 'x', 'x', '16', '7', '17', '11', 'x', '7', 'x', 'x', 'x', 'x', '15'], ['x', '9', 'x', 'x', 'x', '19', '19', '7', '3', '12', '14', '11', '16', '7'], ['8', '19', '15', '1', 'x', '14', 'x', '1', 'x', 'x', 'x', 'x', 'x', 'x'], ['x', '14', 'x', 'x', 'x', 'x', 'x', '18', 'x', 'x', '2', '11', '7', 'x'], ['x', 'x', 'x', 'x', 'x', '3', '11', '12', 'x', 'x', 'x', '2', '6', 'x']]\", \"(1, 10)\", \"(7, 2)\", \"1\", \"6\"]"}
{"diff_sorted_id": "80", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 14x14. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (7, 13) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (13, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 0 1 0 0 1 0 1 0 0 0 1\n0 1 1 1 1 1 1 1 0 0 1 1 1 0\n1 0 0 1 1 1 0 1 1 1 1 1 0 0\n1 1 1 1 0 1 1 1 1 0 1 1 1 0\n0 1 0 0 1 1 0 1 1 0 0 0 0 1\n0 1 0 1 1 1 0 0 1 0 1 1 1 0\n1 1 0 0 1 0 1 0 0 0 1 0 1 1\n0 1 1 1 1 1 1 0 1 0 1 1 0 0\n0 1 0 1 1 1 1 1 1 1 1 1 0 0\n1 0 1 1 1 1 0 1 1 0 1 0 0 0\n0 0 1 1 0 0 1 1 0 0 1 1 0 0\n0 1 0 1 1 1 1 0 0 1 1 0 0 0\n1 1 1 1 0 0 1 1 1 0 0 1 1 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[[7, 13], [8, 12], [9, 12], [10, 12], [11, 11], [12, 10], [12, 9], [13, 8], [13, 7], [13, 6], [13, 5], [13, 4], [13, 3], [13, 2], [13, 1], [13, 0]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.029587268829345703", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1], [0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0], [1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0], [1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0], [0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1], [0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0], [1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]]\", 4]", "is_correct_args": "[\"[[1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1], [0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0], [1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0], [1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0], [0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1], [0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0], [1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]]\", [7, 13], [13, 0], 4]", "A*_args": "[\"[[1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1], [0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0], [1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0], [1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0], [0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1], [0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0], [1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]]\", \"(7, 13)\", \"(13, 0)\", \"4\"]"}
{"diff_sorted_id": "80", "problem_statement": "Given 7 labeled water jugs with capacities 110, 146, 117, 118, 148, 104, 79, 103 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 278, 378, 457, 462 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 117, 4], [\"+\", 118, 4], [\"+\", 79, 4], [\"+\", 148, 4], [\"+\", 103, 3], [\"+\", 103, 3], [\"+\", 103, 3], [\"+\", 148, 3], [\"+\", 79, 2], [\"+\", 79, 2], [\"+\", 103, 2], [\"+\", 117, 2], [\"+\", 103, 1], [\"+\", 146, 1], [\"-\", 117, 1], [\"+\", 146, 1]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.0686345100402832", "solution_depth": "16", "max_successor_states": "64", "num_vars_per_state": "3", "is_feasible_args": "[[110, 146, 117, 118, 148, 104, 79, 103], [278, 378, 457, 462]]", "is_correct_args": "[[110, 146, 117, 118, 148, 104, 79, 103], [278, 378, 457, 462]]", "A*_args": "[\"[110, 146, 117, 118, 148, 104, 79, 103]\", \"[278, 378, 457, 462]\"]"}
{"diff_sorted_id": "81", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[12, 76, '_', 72, 53], [61, 97, 49, 65, 52], [89, 64, 22, 26, 13]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "7", "opt_solution": "[72, 65, 49, 22, 26, 13, 52, 53, 65, 72, 76, 12, 61, 89, 64, 26, 22, 76, 12, 61, 89, 97, 61, 89, 97, 64, 26, 22, 13, 49, 53, 65, 72, 12, 76, 53, 12, 72, 65, 52, 49, 12, 52, 49]", "opt_solution_cost": "44", "opt_solution_compute_t": "85.10252380371094", "solution_depth": "44", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[12, 76, \"_\", 72, 53], [61, 97, 49, 65, 52], [89, 64, 22, 26, 13]]]", "is_correct_args": "[[[12, 76, \"_\", 72, 53], [61, 97, 49, 65, 52], [89, 64, 22, 26, 13]]]", "A*_args": "[\"[[12, 76, '_', 72, 53], [61, 97, 49, 65, 52], [89, 64, 22, 26, 13]]\"]"}
{"diff_sorted_id": "81", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: core, reuel, rinch, kizil, iztle   The initial board: [['e', 'c', 'o', 'r', 'e'], ['r', 'e', 'u', 't', 'l'], ['r', 'i', 'i', 'c', 'i'], ['k', 'n', 'z', 'e', 'l'], ['i', 'z', 'h', 'l', '_']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"up-left\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "24", "opt_solution_compute_t": "1.593846082687378", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"e\", \"c\", \"o\", \"r\", \"e\"], [\"r\", \"e\", \"u\", \"t\", \"l\"], [\"r\", \"i\", \"i\", \"c\", \"i\"], [\"k\", \"n\", \"z\", \"e\", \"l\"], [\"i\", \"z\", \"h\", \"l\", \"_\"]]]", "is_correct_args": "[[[\"e\", \"c\", \"o\", \"r\", \"e\"], [\"r\", \"e\", \"u\", \"t\", \"l\"], [\"r\", \"i\", \"i\", \"c\", \"i\"], [\"k\", \"n\", \"z\", \"e\", \"l\"], [\"i\", \"z\", \"h\", \"l\", \"_\"]], [\"core\", \"reuel\", \"rinch\", \"kizil\", \"iztle\"]]", "A*_args": "[\"[['e', 'c', 'o', 'r', 'e'], ['r', 'e', 'u', 't', 'l'], ['r', 'i', 'i', 'c', 'i'], ['k', 'n', 'z', 'e', 'l'], ['i', 'z', 'h', 'l', '_']]\", \"['core', 'reuel', 'rinch', 'kizil', 'iztle']\"]"}
{"diff_sorted_id": "81", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'U'. Our task is to visit city H and city L excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from L and H, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  T J X U L S C H Z O D Q G W \nT 0 0 0 0 1 1 0 1 0 0 1 0 0 1 \nJ 0 0 0 0 1 0 0 0 0 0 0 0 0 0 \nX 0 1 0 1 0 0 0 1 0 0 0 1 0 1 \nU 0 0 0 0 0 0 1 0 1 0 0 0 0 0 \nL 0 0 0 1 0 0 0 0 0 0 0 0 1 0 \nS 0 0 0 1 0 0 0 1 0 0 1 0 0 0 \nC 0 1 1 0 0 0 0 0 0 1 0 0 0 0 \nH 1 1 1 0 0 0 1 0 1 0 1 0 0 0 \nZ 0 1 0 0 0 1 1 0 0 0 1 0 0 0 \nO 0 0 0 0 0 1 0 0 0 0 1 1 0 0 \nD 0 1 0 1 1 1 1 0 1 0 0 0 0 0 \nQ 0 1 0 1 1 1 0 0 0 0 0 0 0 0 \nG 1 0 1 0 0 0 1 1 1 1 0 0 0 0 \nW 0 1 0 0 1 1 0 0 0 1 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[\"U\", \"C\", \"J\", \"L\", \"G\", \"H\", \"T\", \"H\", \"D\", \"L\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.050522565841674805", "solution_depth": "10", "max_successor_states": "14", "num_vars_per_state": "17", "is_feasible_args": "[[[0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0]], [\"T\", \"J\", \"X\", \"U\", \"L\", \"S\", \"C\", \"H\", \"Z\", \"O\", \"D\", \"Q\", \"G\", \"W\"], \"H\", \"L\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0]], [\"T\", \"J\", \"X\", \"U\", \"L\", \"S\", \"C\", \"H\", \"Z\", \"O\", \"D\", \"Q\", \"G\", \"W\"], \"U\", \"H\", \"L\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0]]\", \"['T', 'J', 'X', 'U', 'L', 'S', 'C', 'H', 'Z', 'O', 'D', 'Q', 'G', 'W']\", \"['U']\", \"['H', 'L']\"]"}
{"diff_sorted_id": "81", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [13, 30, 19, 13, 34, 12, 16, 21, 24, 39, 37, 32, 3, 5, 30, 37, 29, 20, 15, 23, 30, 24, 12, 21, 19, 10, 26, 29, 3, 23, 20, 40, 22, 13, 2, 36, 8, 40, 6, 24, 24, 11, 26, 37, 16, 57, 39, 21, 17], such that the sum of the chosen coins adds up to 412. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {2: 2, 21: 6, 24: 9, 26: 2, 5: 3, 29: 10, 10: 7, 13: 13, 30: 17, 36: 15, 3: 1, 32: 7, 8: 5, 20: 2, 22: 3, 57: 19, 40: 8, 6: 4, 23: 8, 39: 3, 16: 5, 37: 6, 12: 9, 11: 11, 34: 6, 17: 2, 15: 10, 19: 17}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "32", "opt_solution": "[17, 39, 26, 20, 39, 22, 20, 21, 37, 37, 37, 34, 32, 26, 2, 3]", "opt_solution_cost": "59", "opt_solution_compute_t": "0.06411933898925781", "solution_depth": "16", "max_successor_states": "49", "num_vars_per_state": "49", "is_feasible_args": "[[13, 30, 19, 13, 34, 12, 16, 21, 24, 39, 37, 32, 3, 5, 30, 37, 29, 20, 15, 23, 30, 24, 12, 21, 19, 10, 26, 29, 3, 23, 20, 40, 22, 13, 2, 36, 8, 40, 6, 24, 24, 11, 26, 37, 16, 57, 39, 21, 17]]", "is_correct_args": "[[13, 30, 19, 13, 34, 12, 16, 21, 24, 39, 37, 32, 3, 5, 30, 37, 29, 20, 15, 23, 30, 24, 12, 21, 19, 10, 26, 29, 3, 23, 20, 40, 22, 13, 2, 36, 8, 40, 6, 24, 24, 11, 26, 37, 16, 57, 39, 21, 17], {\"2\": 2, \"21\": 6, \"24\": 9, \"26\": 2, \"5\": 3, \"29\": 10, \"10\": 7, \"13\": 13, \"30\": 17, \"36\": 15, \"3\": 1, \"32\": 7, \"8\": 5, \"20\": 2, \"22\": 3, \"57\": 19, \"40\": 8, \"6\": 4, \"23\": 8, \"39\": 3, \"16\": 5, \"37\": 6, \"12\": 9, \"11\": 11, \"34\": 6, \"17\": 2, \"15\": 10, \"19\": 17}, 412]", "A*_args": "[\"[13, 30, 19, 13, 34, 12, 16, 21, 24, 39, 37, 32, 3, 5, 30, 37, 29, 20, 15, 23, 30, 24, 12, 21, 19, 10, 26, 29, 3, 23, 20, 40, 22, 13, 2, 36, 8, 40, 6, 24, 24, 11, 26, 37, 16, 57, 39, 21, 17]\", \"{2: 2, 21: 6, 24: 9, 26: 2, 5: 3, 29: 10, 10: 7, 13: 13, 30: 17, 36: 15, 3: 1, 32: 7, 8: 5, 20: 2, 22: 3, 57: 19, 40: 8, 6: 4, 23: 8, 39: 3, 16: 5, 37: 6, 12: 9, 11: 11, 34: 6, 17: 2, 15: 10, 19: 17}\", \"412\"]"}
{"diff_sorted_id": "81", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Red', 'Red', 'Red', 'Green', 'Green'], ['Green', 'Red', 'Red', 'Blue', 'Red', 'Blue'], ['Blue', 'Blue', 'Blue', 'Green', 'Blue', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[0, 1], [2, 0], [2, 0], [2, 0], [2, 1], [2, 0], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 2], [1, 0], [1, 2], [1, 0], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [0, 2], [0, 2], [0, 1]]", "opt_solution_cost": "31", "opt_solution_compute_t": "517.1900751590729", "solution_depth": "31", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Green\", \"Red\", \"Red\", \"Red\", \"Green\", \"Green\"], [\"Green\", \"Red\", \"Red\", \"Blue\", \"Red\", \"Blue\"], [\"Blue\", \"Blue\", \"Blue\", \"Green\", \"Blue\", \"Green\"]], 9]", "is_correct_args": "[[[\"Green\", \"Red\", \"Red\", \"Red\", \"Green\", \"Green\"], [\"Green\", \"Red\", \"Red\", \"Blue\", \"Red\", \"Blue\"], [\"Blue\", \"Blue\", \"Blue\", \"Green\", \"Blue\", \"Green\"]], 9]", "A*_args": "[\"[['Green', 'Red', 'Red', 'Red', 'Green', 'Green'], ['Green', 'Red', 'Red', 'Blue', 'Red', 'Blue'], ['Blue', 'Blue', 'Blue', 'Green', 'Blue', 'Green']]\", \"9\"]"}
{"diff_sorted_id": "81", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 37 to 87 (37 included in the range but 87 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['47' '51' 'x' '64']\n ['50' '53' 'x' 'x']\n ['x' '55' '68' '74']\n ['x' 'x' '72' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "12", "opt_solution": "[[0, 0, 10], [0, 2, 34], [0, 3, 52], [1, 2, 32], [2, 2, 30], [2, 3, 31]]", "opt_solution_cost": "342", "opt_solution_compute_t": "11.79056978225708", "solution_depth": "6", "max_successor_states": "50", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '21', '', ''], ['18', '27', '', '51'], ['24', '29', '', ''], ['54', '33', '25', '12']]\", 10, 65]", "is_correct_args": "[\"[['', '21', '', ''], ['18', '27', '', '51'], ['24', '29', '', ''], ['54', '33', '25', '12']]\", 10, 65]", "A*_args": "[\"[['', '21', '', ''], ['18', '27', '', '51'], ['24', '29', '', ''], ['54', '33', '25', '12']]\", \"10\", \"65\"]"}
{"diff_sorted_id": "81", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 35 to 76. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 188, 234, None for columns 1 to 2 respectively, and the sums of rows must be None, 247, 238, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 215. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['61' 'x' '50' 'x']\n ['x' 'x' 'x' 'x']\n ['68' '40' '57' 'x']\n ['x' '42' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 1, 35], [0, 3, 37], [1, 0, 39], [1, 1, 71], [1, 2, 75], [1, 3, 62], [2, 3, 73], [3, 0, 63], [3, 2, 52], [3, 3, 36]]", "opt_solution_cost": "861", "opt_solution_compute_t": "137.55204916000366", "solution_depth": "10", "max_successor_states": "31", "num_vars_per_state": "16", "is_feasible_args": "[\"[['61', '', '50', ''], ['', '', '', ''], ['68', '40', '57', ''], ['', '42', '', '']]\", 4, 35, 76]", "is_correct_args": "[\"[['61', '', '50', ''], ['', '', '', ''], ['68', '40', '57', ''], ['', '42', '', '']]\", 35, 76, [1, 3], [1, 3], [188, 234], [247, 238], 215]", "A*_args": "[\"[['61', '', '50', ''], ['', '', '', ''], ['68', '40', '57', ''], ['', '42', '', '']]\", \"35\", \"76\", \"[None, 188, 234, None]\", \"[None, 247, 238, None]\", \"215\"]"}
{"diff_sorted_id": "81", "problem_statement": "In 'Restricted Sorting', there are 12 stacks each with a capacity of 7 blocks, with 6 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 6 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 5, 1: 3, 2: 3, 3: 4, 4: 2, 5: 2, 6: 12, 7: 9, 8: 5, 9: 11, 10: 11, 11: 10}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['White', 'Black', 'Yellow', 'Black', 'Green', 'Blue', 'Pink'], ['Black', 'Red', 'Yellow', 'White', 'Yellow', 'Black', 'Green'], ['Yellow', 'White', 'Green', 'White', 'White', 'Black', 'Blue'], ['Blue', 'Pink', 'Red', 'Pink', 'Green', 'Yellow', 'Black'], ['White', 'Red', 'Pink', 'Blue', 'Blue', 'Pink', 'Green'], [], [], [], ['Red', 'Pink', 'Red', 'Blue', 'Red', 'Green', 'Yellow'], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "4", "opt_solution": "[[1, 0], [2, 8], [5, 0], [2, 7], [5, 7], [3, 11], [4, 10], [1, 8], [1, 11], [1, 8], [1, 6], [1, 10], [5, 1], [4, 1], [4, 7], [4, 1], [2, 11], [2, 0], [2, 11], [2, 8], [3, 0], [3, 2], [3, 0], [3, 0], [3, 8], [5, 3], [5, 3], [5, 1], [4, 5], [4, 11], [9, 7], [9, 1], [9, 7], [9, 3], [9, 7], [9, 2], [9, 11], [4, 8], [10, 3], [10, 3], [5, 2], [5, 2], [6, 2]]", "opt_solution_cost": "260", "opt_solution_compute_t": "34.757015228271484", "solution_depth": "43", "max_successor_states": "132", "num_vars_per_state": "42", "is_feasible_args": "[[[], [\"White\", \"Black\", \"Yellow\", \"Black\", \"Green\", \"Blue\", \"Pink\"], [\"Black\", \"Red\", \"Yellow\", \"White\", \"Yellow\", \"Black\", \"Green\"], [\"Yellow\", \"White\", \"Green\", \"White\", \"White\", \"Black\", \"Blue\"], [\"Blue\", \"Pink\", \"Red\", \"Pink\", \"Green\", \"Yellow\", \"Black\"], [\"White\", \"Red\", \"Pink\", \"Blue\", \"Blue\", \"Pink\", \"Green\"], [], [], [], [\"Red\", \"Pink\", \"Red\", \"Blue\", \"Red\", \"Green\", \"Yellow\"], [], []], 7, {\"0\": 5, \"1\": 3, \"2\": 3, \"3\": 4, \"4\": 2, \"5\": 2, \"6\": 12, \"7\": 9, \"8\": 5, \"9\": 11, \"10\": 11, \"11\": 10}]", "is_correct_args": "[[[], [\"White\", \"Black\", \"Yellow\", \"Black\", \"Green\", \"Blue\", \"Pink\"], [\"Black\", \"Red\", \"Yellow\", \"White\", \"Yellow\", \"Black\", \"Green\"], [\"Yellow\", \"White\", \"Green\", \"White\", \"White\", \"Black\", \"Blue\"], [\"Blue\", \"Pink\", \"Red\", \"Pink\", \"Green\", \"Yellow\", \"Black\"], [\"White\", \"Red\", \"Pink\", \"Blue\", \"Blue\", \"Pink\", \"Green\"], [], [], [], [\"Red\", \"Pink\", \"Red\", \"Blue\", \"Red\", \"Green\", \"Yellow\"], [], []], 7, {\"0\": 5, \"1\": 3, \"2\": 3, \"3\": 4, \"4\": 2, \"5\": 2, \"6\": 12, \"7\": 9, \"8\": 5, \"9\": 11, \"10\": 11, \"11\": 10}, 6]", "A*_args": "[\"[[], ['White', 'Black', 'Yellow', 'Black', 'Green', 'Blue', 'Pink'], ['Black', 'Red', 'Yellow', 'White', 'Yellow', 'Black', 'Green'], ['Yellow', 'White', 'Green', 'White', 'White', 'Black', 'Blue'], ['Blue', 'Pink', 'Red', 'Pink', 'Green', 'Yellow', 'Black'], ['White', 'Red', 'Pink', 'Blue', 'Blue', 'Pink', 'Green'], [], [], [], ['Red', 'Pink', 'Red', 'Blue', 'Red', 'Green', 'Yellow'], [], []]\", \"{0: 5, 1: 3, 2: 3, 3: 4, 4: 2, 5: 2, 6: 12, 7: 9, 8: 5, 9: 11, 10: 11, 11: 10}\", \"7\", \"6\"]"}
{"diff_sorted_id": "81", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (2, 0) to his destination workshop at index (6, 11), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 5, and district 3 covering rows 6 to 13. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[8 15 3 10 6 15 x 4 x x x x x 4]\n[3 x 14 8 16 19 x 18 4 x 2 x 6 x]\n[18 18 x 4 x 17 11 10 17 9 x 4 1 5]\n[x 2 x 12 1 x 13 17 14 15 17 x 15 x]\n[x x x 15 x 2 2 11 7 x 5 7 4 18]\n[16 x 5 x 19 12 5 9 13 16 9 x 3 x]\n[x x x x 14 18 x 16 13 x 1 5 10 x]\n[3 11 x 1 8 x x x 18 8 11 x x 6]\n[19 2 x 19 5 x x x 9 x 6 x x 4]\n[x 2 x 10 9 15 x x x 16 x 8 x x]\n[18 8 10 x 3 x 11 x 17 x 17 x x x]\n[14 12 x 2 x 19 2 19 14 x x x 3 x]\n[7 x x x x x x 9 8 7 x 15 2 x]\n[x x 15 x x 15 16 x x x 19 x 13 1]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "6", "opt_solution": "[[2, 0], [1, 0], [0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [1, 5], [2, 5], [2, 6], [3, 6], [4, 6], [5, 6], [5, 7], [5, 8], [5, 9], [5, 10], [6, 10], [6, 11]]", "opt_solution_cost": "180", "opt_solution_compute_t": "0.027744293212890625", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"8\", \"15\", \"3\", \"10\", \"6\", \"15\", \"x\", \"4\", \"x\", \"x\", \"x\", \"x\", \"x\", \"4\"], [\"3\", \"x\", \"14\", \"8\", \"16\", \"19\", \"x\", \"18\", \"4\", \"x\", \"2\", \"x\", \"6\", \"x\"], [\"18\", \"18\", \"x\", \"4\", \"x\", \"17\", \"11\", \"10\", \"17\", \"9\", \"x\", \"4\", \"1\", \"5\"], [\"x\", \"2\", \"x\", \"12\", \"1\", \"x\", \"13\", \"17\", \"14\", \"15\", \"17\", \"x\", \"15\", \"x\"], [\"x\", \"x\", \"x\", \"15\", \"x\", \"2\", \"2\", \"11\", \"7\", \"x\", \"5\", \"7\", \"4\", \"18\"], [\"16\", \"x\", \"5\", \"x\", \"19\", \"12\", \"5\", \"9\", \"13\", \"16\", \"9\", \"x\", \"3\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"14\", \"18\", \"x\", \"16\", \"13\", \"x\", \"1\", \"5\", \"10\", \"x\"], [\"3\", \"11\", \"x\", \"1\", \"8\", \"x\", \"x\", \"x\", \"18\", \"8\", \"11\", \"x\", \"x\", \"6\"], [\"19\", \"2\", \"x\", \"19\", \"5\", \"x\", \"x\", \"x\", \"9\", \"x\", \"6\", \"x\", \"x\", \"4\"], [\"x\", \"2\", \"x\", \"10\", \"9\", \"15\", \"x\", \"x\", \"x\", \"16\", \"x\", \"8\", \"x\", \"x\"], [\"18\", \"8\", \"10\", \"x\", \"3\", \"x\", \"11\", \"x\", \"17\", \"x\", \"17\", \"x\", \"x\", \"x\"], [\"14\", \"12\", \"x\", \"2\", \"x\", \"19\", \"2\", \"19\", \"14\", \"x\", \"x\", \"x\", \"3\", \"x\"], [\"7\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"9\", \"8\", \"7\", \"x\", \"15\", \"2\", \"x\"], [\"x\", \"x\", \"15\", \"x\", \"x\", \"15\", \"16\", \"x\", \"x\", \"x\", \"19\", \"x\", \"13\", \"1\"]]]", "is_correct_args": "[[[\"8\", \"15\", \"3\", \"10\", \"6\", \"15\", \"x\", \"4\", \"x\", \"x\", \"x\", \"x\", \"x\", \"4\"], [\"3\", \"x\", \"14\", \"8\", \"16\", \"19\", \"x\", \"18\", \"4\", \"x\", \"2\", \"x\", \"6\", \"x\"], [\"18\", \"18\", \"x\", \"4\", \"x\", \"17\", \"11\", \"10\", \"17\", \"9\", \"x\", \"4\", \"1\", \"5\"], [\"x\", \"2\", \"x\", \"12\", \"1\", \"x\", \"13\", \"17\", \"14\", \"15\", \"17\", \"x\", \"15\", \"x\"], [\"x\", \"x\", \"x\", \"15\", \"x\", \"2\", \"2\", \"11\", \"7\", \"x\", \"5\", \"7\", \"4\", \"18\"], [\"16\", \"x\", \"5\", \"x\", \"19\", \"12\", \"5\", \"9\", \"13\", \"16\", \"9\", \"x\", \"3\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"14\", \"18\", \"x\", \"16\", \"13\", \"x\", \"1\", \"5\", \"10\", \"x\"], [\"3\", \"11\", \"x\", \"1\", \"8\", \"x\", \"x\", \"x\", \"18\", \"8\", \"11\", \"x\", \"x\", \"6\"], [\"19\", \"2\", \"x\", \"19\", \"5\", \"x\", \"x\", \"x\", \"9\", \"x\", \"6\", \"x\", \"x\", \"4\"], [\"x\", \"2\", \"x\", \"10\", \"9\", \"15\", \"x\", \"x\", \"x\", \"16\", \"x\", \"8\", \"x\", \"x\"], [\"18\", \"8\", \"10\", \"x\", \"3\", \"x\", \"11\", \"x\", \"17\", \"x\", \"17\", \"x\", \"x\", \"x\"], [\"14\", \"12\", \"x\", \"2\", \"x\", \"19\", \"2\", \"19\", \"14\", \"x\", \"x\", \"x\", \"3\", \"x\"], [\"7\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"9\", \"8\", \"7\", \"x\", \"15\", \"2\", \"x\"], [\"x\", \"x\", \"15\", \"x\", \"x\", \"15\", \"16\", \"x\", \"x\", \"x\", \"19\", \"x\", \"13\", \"1\"]], [2, 0], [6, 11], 2, 5]", "A*_args": "[\"[['8', '15', '3', '10', '6', '15', 'x', '4', 'x', 'x', 'x', 'x', 'x', '4'], ['3', 'x', '14', '8', '16', '19', 'x', '18', '4', 'x', '2', 'x', '6', 'x'], ['18', '18', 'x', '4', 'x', '17', '11', '10', '17', '9', 'x', '4', '1', '5'], ['x', '2', 'x', '12', '1', 'x', '13', '17', '14', '15', '17', 'x', '15', 'x'], ['x', 'x', 'x', '15', 'x', '2', '2', '11', '7', 'x', '5', '7', '4', '18'], ['16', 'x', '5', 'x', '19', '12', '5', '9', '13', '16', '9', 'x', '3', 'x'], ['x', 'x', 'x', 'x', '14', '18', 'x', '16', '13', 'x', '1', '5', '10', 'x'], ['3', '11', 'x', '1', '8', 'x', 'x', 'x', '18', '8', '11', 'x', 'x', '6'], ['19', '2', 'x', '19', '5', 'x', 'x', 'x', '9', 'x', '6', 'x', 'x', '4'], ['x', '2', 'x', '10', '9', '15', 'x', 'x', 'x', '16', 'x', '8', 'x', 'x'], ['18', '8', '10', 'x', '3', 'x', '11', 'x', '17', 'x', '17', 'x', 'x', 'x'], ['14', '12', 'x', '2', 'x', '19', '2', '19', '14', 'x', 'x', 'x', '3', 'x'], ['7', 'x', 'x', 'x', 'x', 'x', 'x', '9', '8', '7', 'x', '15', '2', 'x'], ['x', 'x', '15', 'x', 'x', '15', '16', 'x', 'x', 'x', '19', 'x', '13', '1']]\", \"(2, 0)\", \"(6, 11)\", \"2\", \"5\"]"}
{"diff_sorted_id": "81", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 14x14. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (11, 12) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (3, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 1 0 1 1 0 1 1 0 0 0 1 1\n0 0 0 0 1 1 0 1 1 1 0 1 1 0\n1 0 1 1 1 1 1 0 1 1 1 0 1 1\n0 0 0 1 1 1 1 0 1 1 1 0 1 1\n1 1 0 0 1 0 0 1 1 1 1 0 0 0\n0 1 0 0 0 0 1 1 1 1 1 0 1 0\n0 1 0 0 0 0 1 1 1 1 1 1 1 1\n0 0 0 0 0 0 0 0 1 0 0 0 0 0\n1 1 0 1 1 0 1 0 0 0 0 1 1 1\n0 0 1 1 0 0 1 0 0 1 1 0 1 1\n1 1 1 1 1 0 1 0 0 0 1 0 0 1\n1 0 0 0 1 1 1 1 1 0 0 0 0 0\n1 1 0 1 1 1 1 1 1 1 0 0 0 1\n1 0 1 1 1 1 0 1 1 0 1 1 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[[11, 12], [11, 11], [11, 10], [10, 9], [9, 8], [8, 7], [7, 6], [7, 5], [6, 5], [6, 4], [5, 4], [5, 3], [4, 3], [4, 2], [3, 2], [3, 1]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.025336027145385742", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0], [0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1], [0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1], [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0]]\", 4]", "is_correct_args": "[\"[[0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0], [0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1], [0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1], [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0]]\", [11, 12], [3, 1], 4]", "A*_args": "[\"[[0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1], [1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0], [0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1], [0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1], [1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1], [1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0]]\", \"(11, 12)\", \"(3, 1)\", \"4\"]"}
{"diff_sorted_id": "81", "problem_statement": "Given 7 labeled water jugs with capacities 127, 96, 108, 126, 132, 139, 146, 14 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 273, 349, 435, 503 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 96, 4], [\"+\", 108, 4], [\"+\", 139, 4], [\"+\", 146, 4], [\"+\", 14, 4], [\"+\", 139, 3], [\"+\", 146, 3], [\"+\", 126, 3], [\"-\", 108, 3], [\"+\", 132, 3], [\"+\", 96, 2], [\"+\", 126, 2], [\"+\", 127, 2], [\"+\", 127, 1], [\"+\", 146, 1]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.04054760932922363", "solution_depth": "15", "max_successor_states": "64", "num_vars_per_state": "3", "is_feasible_args": "[[127, 96, 108, 126, 132, 139, 146, 14], [273, 349, 435, 503]]", "is_correct_args": "[[127, 96, 108, 126, 132, 139, 146, 14], [273, 349, 435, 503]]", "A*_args": "[\"[127, 96, 108, 126, 132, 139, 146, 14]\", \"[273, 349, 435, 503]\"]"}
{"diff_sorted_id": "82", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[60, 70, 88, 51, 72], [87, 43, 39, 85, 30], ['_', 64, 27, 84, 47]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "7", "opt_solution": "[87, 60, 70, 88, 51, 85, 84, 27, 64, 43, 60, 87, 43, 64, 39, 51, 85, 84, 30, 47, 27, 30, 51, 60, 87, 70, 88, 87, 64, 39, 30, 27]", "opt_solution_cost": "32", "opt_solution_compute_t": "0.7831065654754639", "solution_depth": "32", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[60, 70, 88, 51, 72], [87, 43, 39, 85, 30], [\"_\", 64, 27, 84, 47]]]", "is_correct_args": "[[[60, 70, 88, 51, 72], [87, 43, 39, 85, 30], [\"_\", 64, 27, 84, 47]]]", "A*_args": "[\"[[60, 70, 88, 51, 72], [87, 43, 39, 85, 30], ['_', 64, 27, 84, 47]]\"]"}
{"diff_sorted_id": "82", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: ekka, bifer, magma, dinka, brett   The initial board: [['i', 'e', 'k', 'k', 'a'], ['b', 'e', 'f', 'a', 'r'], ['g', 'a', '_', 'm', 'e'], ['d', 'i', 'n', 'k', 'a'], ['b', 'r', 'm', 't', 't']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.7136387825012207", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"i\", \"e\", \"k\", \"k\", \"a\"], [\"b\", \"e\", \"f\", \"a\", \"r\"], [\"g\", \"a\", \"_\", \"m\", \"e\"], [\"d\", \"i\", \"n\", \"k\", \"a\"], [\"b\", \"r\", \"m\", \"t\", \"t\"]]]", "is_correct_args": "[[[\"i\", \"e\", \"k\", \"k\", \"a\"], [\"b\", \"e\", \"f\", \"a\", \"r\"], [\"g\", \"a\", \"_\", \"m\", \"e\"], [\"d\", \"i\", \"n\", \"k\", \"a\"], [\"b\", \"r\", \"m\", \"t\", \"t\"]], [\"ekka\", \"bifer\", \"magma\", \"dinka\", \"brett\"]]", "A*_args": "[\"[['i', 'e', 'k', 'k', 'a'], ['b', 'e', 'f', 'a', 'r'], ['g', 'a', '_', 'm', 'e'], ['d', 'i', 'n', 'k', 'a'], ['b', 'r', 'm', 't', 't']]\", \"['ekka', 'bifer', 'magma', 'dinka', 'brett']\"]"}
{"diff_sorted_id": "82", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'J'. Our task is to visit city F and city L excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from L and F, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  C K U F Q B N W H J T X R L \nC 0 0 1 1 0 1 0 0 0 0 1 1 0 1 \nK 1 0 0 1 0 1 1 0 1 0 0 0 0 0 \nU 0 0 0 1 0 0 0 0 0 0 1 0 0 1 \nF 0 1 0 0 0 1 0 0 0 0 1 0 1 0 \nQ 0 1 1 1 0 0 0 0 0 0 1 0 1 1 \nB 1 0 0 0 1 0 0 0 0 0 0 1 0 0 \nN 1 0 0 1 0 0 0 1 1 0 0 0 0 0 \nW 0 0 1 0 0 0 0 0 0 0 0 0 0 1 \nH 0 0 0 0 1 0 0 0 0 0 0 1 1 0 \nJ 1 1 0 0 1 1 0 0 0 0 0 0 0 0 \nT 0 0 0 1 0 0 1 0 0 0 0 0 1 0 \nX 0 1 0 1 1 0 0 1 0 1 0 0 0 0 \nR 0 0 1 0 0 1 0 1 0 0 0 0 0 0 \nL 0 0 1 0 0 0 1 1 1 0 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[\"J\", \"C\", \"L\", \"U\", \"L\", \"N\", \"F\", \"K\", \"F\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.11440420150756836", "solution_depth": "9", "max_successor_states": "14", "num_vars_per_state": "17", "is_feasible_args": "[[[0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0]], [\"C\", \"K\", \"U\", \"F\", \"Q\", \"B\", \"N\", \"W\", \"H\", \"J\", \"T\", \"X\", \"R\", \"L\"], \"F\", \"L\"]", "is_correct_args": "[[[0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0]], [\"C\", \"K\", \"U\", \"F\", \"Q\", \"B\", \"N\", \"W\", \"H\", \"J\", \"T\", \"X\", \"R\", \"L\"], \"J\", \"F\", \"L\"]", "A*_args": "[\"[[0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0]]\", \"['C', 'K', 'U', 'F', 'Q', 'B', 'N', 'W', 'H', 'J', 'T', 'X', 'R', 'L']\", \"['J']\", \"['F', 'L']\"]"}
{"diff_sorted_id": "82", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [7, 2, 20, 24, 9, 24, 29, 6, 32, 26, 17, 61, 33, 14, 12, 20, 15, 34, 60, 18, 18, 37, 25, 9, 9, 21, 24, 30, 28, 3, 21, 32, 13, 10, 4, 2, 33, 36, 13, 24, 27, 7, 21, 4, 8, 17, 22, 3, 21, 12], such that the sum of the chosen coins adds up to 389. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {28: 10, 36: 13, 18: 13, 17: 8, 24: 3, 37: 19, 60: 16, 13: 5, 14: 8, 30: 18, 20: 5, 27: 16, 26: 11, 2: 2, 21: 3, 7: 7, 8: 6, 3: 3, 25: 20, 22: 8, 15: 12, 12: 4, 32: 11, 9: 5, 34: 15, 4: 2, 29: 5, 33: 6, 6: 6, 10: 3, 61: 10}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "33", "opt_solution": "[24, 10, 21, 21, 21, 29, 24, 33, 24, 33, 24, 61, 60, 4]", "opt_solution_cost": "69", "opt_solution_compute_t": "0.05933260917663574", "solution_depth": "14", "max_successor_states": "50", "num_vars_per_state": "50", "is_feasible_args": "[[7, 2, 20, 24, 9, 24, 29, 6, 32, 26, 17, 61, 33, 14, 12, 20, 15, 34, 60, 18, 18, 37, 25, 9, 9, 21, 24, 30, 28, 3, 21, 32, 13, 10, 4, 2, 33, 36, 13, 24, 27, 7, 21, 4, 8, 17, 22, 3, 21, 12]]", "is_correct_args": "[[7, 2, 20, 24, 9, 24, 29, 6, 32, 26, 17, 61, 33, 14, 12, 20, 15, 34, 60, 18, 18, 37, 25, 9, 9, 21, 24, 30, 28, 3, 21, 32, 13, 10, 4, 2, 33, 36, 13, 24, 27, 7, 21, 4, 8, 17, 22, 3, 21, 12], {\"28\": 10, \"36\": 13, \"18\": 13, \"17\": 8, \"24\": 3, \"37\": 19, \"60\": 16, \"13\": 5, \"14\": 8, \"30\": 18, \"20\": 5, \"27\": 16, \"26\": 11, \"2\": 2, \"21\": 3, \"7\": 7, \"8\": 6, \"3\": 3, \"25\": 20, \"22\": 8, \"15\": 12, \"12\": 4, \"32\": 11, \"9\": 5, \"34\": 15, \"4\": 2, \"29\": 5, \"33\": 6, \"6\": 6, \"10\": 3, \"61\": 10}, 389]", "A*_args": "[\"[7, 2, 20, 24, 9, 24, 29, 6, 32, 26, 17, 61, 33, 14, 12, 20, 15, 34, 60, 18, 18, 37, 25, 9, 9, 21, 24, 30, 28, 3, 21, 32, 13, 10, 4, 2, 33, 36, 13, 24, 27, 7, 21, 4, 8, 17, 22, 3, 21, 12]\", \"{28: 10, 36: 13, 18: 13, 17: 8, 24: 3, 37: 19, 60: 16, 13: 5, 14: 8, 30: 18, 20: 5, 27: 16, 26: 11, 2: 2, 21: 3, 7: 7, 8: 6, 3: 3, 25: 20, 22: 8, 15: 12, 12: 4, 32: 11, 9: 5, 34: 15, 4: 2, 29: 5, 33: 6, 6: 6, 10: 3, 61: 10}\", \"389\"]"}
{"diff_sorted_id": "82", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Red', 'Blue', 'Blue', 'Green'], ['Green', 'Green', 'Red', 'Red', 'Blue', 'Blue'], ['Blue', 'Red', 'Green', 'Blue', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[2, 0], [1, 2], [1, 2], [0, 2], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [2, 0], [2, 1], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [0, 1], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0], [1, 2], [1, 0], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1]]", "opt_solution_cost": "30", "opt_solution_compute_t": "488.8873255252838", "solution_depth": "30", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Red\", \"Green\", \"Red\", \"Blue\", \"Blue\", \"Green\"], [\"Green\", \"Green\", \"Red\", \"Red\", \"Blue\", \"Blue\"], [\"Blue\", \"Red\", \"Green\", \"Blue\", \"Green\", \"Red\"]], 9]", "is_correct_args": "[[[\"Red\", \"Green\", \"Red\", \"Blue\", \"Blue\", \"Green\"], [\"Green\", \"Green\", \"Red\", \"Red\", \"Blue\", \"Blue\"], [\"Blue\", \"Red\", \"Green\", \"Blue\", \"Green\", \"Red\"]], 9]", "A*_args": "[\"[['Red', 'Green', 'Red', 'Blue', 'Blue', 'Green'], ['Green', 'Green', 'Red', 'Red', 'Blue', 'Blue'], ['Blue', 'Red', 'Green', 'Blue', 'Green', 'Red']]\", \"9\"]"}
{"diff_sorted_id": "82", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 14 to 64 (14 included in the range but 64 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['20' '21' '33' '60']\n ['x' 'x' 'x' '49']\n ['x' '38' 'x' 'x']\n ['36' 'x' '46' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "13", "opt_solution": "[[0, 3, 31], [1, 0, 43], [1, 1, 60], [2, 0, 42], [2, 2, 67], [2, 3, 71]]", "opt_solution_cost": "796", "opt_solution_compute_t": "63.96863031387329", "solution_depth": "6", "max_successor_states": "50", "num_vars_per_state": "16", "is_feasible_args": "[\"[['85', '73', '59', ''], ['', '', '66', '70'], ['', '59', '', ''], ['40', '41', '79', '82']]\", 31, 86]", "is_correct_args": "[\"[['85', '73', '59', ''], ['', '', '66', '70'], ['', '59', '', ''], ['40', '41', '79', '82']]\", 31, 86]", "A*_args": "[\"[['85', '73', '59', ''], ['', '', '66', '70'], ['', '59', '', ''], ['40', '41', '79', '82']]\", \"31\", \"86\"]"}
{"diff_sorted_id": "82", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 35 to 76. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 188, 234, None for columns 1 to 2 respectively, and the sums of rows must be None, 247, 238, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 215. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['61' 'x' '50' 'x']\n ['x' 'x' 'x' 'x']\n ['68' '40' '57' 'x']\n ['x' '42' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 1, 35], [0, 3, 37], [1, 0, 39], [1, 1, 71], [1, 2, 75], [1, 3, 62], [2, 3, 73], [3, 0, 63], [3, 2, 52], [3, 3, 36]]", "opt_solution_cost": "861", "opt_solution_compute_t": "137.55204916000366", "solution_depth": "10", "max_successor_states": "31", "num_vars_per_state": "16", "is_feasible_args": "[\"[['61', '', '50', ''], ['', '', '', ''], ['68', '40', '57', ''], ['', '42', '', '']]\", 4, 35, 76]", "is_correct_args": "[\"[['61', '', '50', ''], ['', '', '', ''], ['68', '40', '57', ''], ['', '42', '', '']]\", 35, 76, [1, 3], [1, 3], [188, 234], [247, 238], 215]", "A*_args": "[\"[['61', '', '50', ''], ['', '', '', ''], ['68', '40', '57', ''], ['', '42', '', '']]\", \"35\", \"76\", \"[None, 188, 234, None]\", \"[None, 247, 238, None]\", \"215\"]"}
{"diff_sorted_id": "82", "problem_statement": "In 'Restricted Sorting', there are 12 stacks each with a capacity of 7 blocks, with 6 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 6 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 7, 1: 13, 2: 10, 3: 12, 4: 4, 5: 13, 6: 2, 7: 11, 8: 11, 9: 10, 10: 8, 11: 9}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Red', 'Black', 'Yellow', 'Black', 'White', 'Blue', 'White'], [], ['White', 'Blue', 'Green', 'Yellow', 'Blue', 'Yellow', 'Pink'], ['Yellow', 'Red', 'Pink', 'Green', 'Black', 'Red', 'White'], [], ['Pink', 'Red', 'Green', 'Green', 'Green', 'Black', 'Blue'], ['Pink', 'Blue', 'Blue', 'Black', 'Red', 'Pink', 'Black'], ['Yellow', 'Red', 'Pink', 'White', 'White', 'Yellow', 'Green'], [], [], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "4", "opt_solution": "[[3, 4], [7, 4], [0, 10], [7, 10], [0, 11], [0, 4], [0, 11], [5, 9], [5, 10], [6, 9], [7, 9], [6, 8], [6, 8], [6, 11], [6, 10], [6, 9], [6, 11], [2, 6], [7, 6], [7, 6], [7, 4], [2, 8], [2, 7], [3, 10], [3, 9], [3, 7], [3, 11], [2, 4], [2, 8], [2, 4], [3, 1], [5, 7], [5, 7], [5, 7], [5, 11], [0, 6], [0, 8], [5, 8], [2, 9], [1, 10], [0, 6], [3, 6]]", "opt_solution_cost": "332", "opt_solution_compute_t": "7.222944021224976", "solution_depth": "42", "max_successor_states": "132", "num_vars_per_state": "42", "is_feasible_args": "[[[\"Red\", \"Black\", \"Yellow\", \"Black\", \"White\", \"Blue\", \"White\"], [], [\"White\", \"Blue\", \"Green\", \"Yellow\", \"Blue\", \"Yellow\", \"Pink\"], [\"Yellow\", \"Red\", \"Pink\", \"Green\", \"Black\", \"Red\", \"White\"], [], [\"Pink\", \"Red\", \"Green\", \"Green\", \"Green\", \"Black\", \"Blue\"], [\"Pink\", \"Blue\", \"Blue\", \"Black\", \"Red\", \"Pink\", \"Black\"], [\"Yellow\", \"Red\", \"Pink\", \"White\", \"White\", \"Yellow\", \"Green\"], [], [], [], []], 7, {\"0\": 7, \"1\": 13, \"2\": 10, \"3\": 12, \"4\": 4, \"5\": 13, \"6\": 2, \"7\": 11, \"8\": 11, \"9\": 10, \"10\": 8, \"11\": 9}]", "is_correct_args": "[[[\"Red\", \"Black\", \"Yellow\", \"Black\", \"White\", \"Blue\", \"White\"], [], [\"White\", \"Blue\", \"Green\", \"Yellow\", \"Blue\", \"Yellow\", \"Pink\"], [\"Yellow\", \"Red\", \"Pink\", \"Green\", \"Black\", \"Red\", \"White\"], [], [\"Pink\", \"Red\", \"Green\", \"Green\", \"Green\", \"Black\", \"Blue\"], [\"Pink\", \"Blue\", \"Blue\", \"Black\", \"Red\", \"Pink\", \"Black\"], [\"Yellow\", \"Red\", \"Pink\", \"White\", \"White\", \"Yellow\", \"Green\"], [], [], [], []], 7, {\"0\": 7, \"1\": 13, \"2\": 10, \"3\": 12, \"4\": 4, \"5\": 13, \"6\": 2, \"7\": 11, \"8\": 11, \"9\": 10, \"10\": 8, \"11\": 9}, 6]", "A*_args": "[\"[['Red', 'Black', 'Yellow', 'Black', 'White', 'Blue', 'White'], [], ['White', 'Blue', 'Green', 'Yellow', 'Blue', 'Yellow', 'Pink'], ['Yellow', 'Red', 'Pink', 'Green', 'Black', 'Red', 'White'], [], ['Pink', 'Red', 'Green', 'Green', 'Green', 'Black', 'Blue'], ['Pink', 'Blue', 'Blue', 'Black', 'Red', 'Pink', 'Black'], ['Yellow', 'Red', 'Pink', 'White', 'White', 'Yellow', 'Green'], [], [], [], []]\", \"{0: 7, 1: 13, 2: 10, 3: 12, 4: 4, 5: 13, 6: 2, 7: 11, 8: 11, 9: 10, 10: 8, 11: 9}\", \"7\", \"6\"]"}
{"diff_sorted_id": "82", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (1, 13) to his destination workshop at index (7, 4), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 6, and district 3 covering rows 7 to 13. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[15 19 13 4 x x 13 7 16 6 x x 17 x]\n[2 2 x 7 x 12 12 x 19 x 10 4 14 2]\n[11 x x 3 7 x 7 x x 6 x 19 x 1]\n[x x 11 x 3 x 17 x 1 20 17 8 15 1]\n[x x 13 x 12 17 5 4 x 16 9 x 19 14]\n[x 16 x x 13 17 14 6 2 17 19 6 13 6]\n[x 1 x x 3 10 2 18 7 8 x 8 x x]\n[12 2 1 6 11 7 10 x x x 4 2 8 x]\n[x x x 13 16 2 x 6 9 2 11 7 14 6]\n[x x x x x 11 x 16 x x x x x 3]\n[x x x x 10 x 3 x 18 9 x x x 15]\n[x x 11 9 3 x x 16 x 5 x 4 10 x]\n[18 1 13 x 7 x 7 5 x 11 10 2 x 2]\n[x x x x x x x 11 x 10 x x 14 6]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "6", "opt_solution": "[[1, 13], [2, 13], [3, 13], [4, 13], [5, 13], [5, 12], [5, 11], [5, 10], [5, 9], [5, 8], [5, 7], [5, 6], [6, 6], [6, 5], [6, 4], [7, 4]]", "opt_solution_cost": "125", "opt_solution_compute_t": "0.027818918228149414", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"15\", \"19\", \"13\", \"4\", \"x\", \"x\", \"13\", \"7\", \"16\", \"6\", \"x\", \"x\", \"17\", \"x\"], [\"2\", \"2\", \"x\", \"7\", \"x\", \"12\", \"12\", \"x\", \"19\", \"x\", \"10\", \"4\", \"14\", \"2\"], [\"11\", \"x\", \"x\", \"3\", \"7\", \"x\", \"7\", \"x\", \"x\", \"6\", \"x\", \"19\", \"x\", \"1\"], [\"x\", \"x\", \"11\", \"x\", \"3\", \"x\", \"17\", \"x\", \"1\", \"20\", \"17\", \"8\", \"15\", \"1\"], [\"x\", \"x\", \"13\", \"x\", \"12\", \"17\", \"5\", \"4\", \"x\", \"16\", \"9\", \"x\", \"19\", \"14\"], [\"x\", \"16\", \"x\", \"x\", \"13\", \"17\", \"14\", \"6\", \"2\", \"17\", \"19\", \"6\", \"13\", \"6\"], [\"x\", \"1\", \"x\", \"x\", \"3\", \"10\", \"2\", \"18\", \"7\", \"8\", \"x\", \"8\", \"x\", \"x\"], [\"12\", \"2\", \"1\", \"6\", \"11\", \"7\", \"10\", \"x\", \"x\", \"x\", \"4\", \"2\", \"8\", \"x\"], [\"x\", \"x\", \"x\", \"13\", \"16\", \"2\", \"x\", \"6\", \"9\", \"2\", \"11\", \"7\", \"14\", \"6\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"11\", \"x\", \"16\", \"x\", \"x\", \"x\", \"x\", \"x\", \"3\"], [\"x\", \"x\", \"x\", \"x\", \"10\", \"x\", \"3\", \"x\", \"18\", \"9\", \"x\", \"x\", \"x\", \"15\"], [\"x\", \"x\", \"11\", \"9\", \"3\", \"x\", \"x\", \"16\", \"x\", \"5\", \"x\", \"4\", \"10\", \"x\"], [\"18\", \"1\", \"13\", \"x\", \"7\", \"x\", \"7\", \"5\", \"x\", \"11\", \"10\", \"2\", \"x\", \"2\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"11\", \"x\", \"10\", \"x\", \"x\", \"14\", \"6\"]]]", "is_correct_args": "[[[\"15\", \"19\", \"13\", \"4\", \"x\", \"x\", \"13\", \"7\", \"16\", \"6\", \"x\", \"x\", \"17\", \"x\"], [\"2\", \"2\", \"x\", \"7\", \"x\", \"12\", \"12\", \"x\", \"19\", \"x\", \"10\", \"4\", \"14\", \"2\"], [\"11\", \"x\", \"x\", \"3\", \"7\", \"x\", \"7\", \"x\", \"x\", \"6\", \"x\", \"19\", \"x\", \"1\"], [\"x\", \"x\", \"11\", \"x\", \"3\", \"x\", \"17\", \"x\", \"1\", \"20\", \"17\", \"8\", \"15\", \"1\"], [\"x\", \"x\", \"13\", \"x\", \"12\", \"17\", \"5\", \"4\", \"x\", \"16\", \"9\", \"x\", \"19\", \"14\"], [\"x\", \"16\", \"x\", \"x\", \"13\", \"17\", \"14\", \"6\", \"2\", \"17\", \"19\", \"6\", \"13\", \"6\"], [\"x\", \"1\", \"x\", \"x\", \"3\", \"10\", \"2\", \"18\", \"7\", \"8\", \"x\", \"8\", \"x\", \"x\"], [\"12\", \"2\", \"1\", \"6\", \"11\", \"7\", \"10\", \"x\", \"x\", \"x\", \"4\", \"2\", \"8\", \"x\"], [\"x\", \"x\", \"x\", \"13\", \"16\", \"2\", \"x\", \"6\", \"9\", \"2\", \"11\", \"7\", \"14\", \"6\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"11\", \"x\", \"16\", \"x\", \"x\", \"x\", \"x\", \"x\", \"3\"], [\"x\", \"x\", \"x\", \"x\", \"10\", \"x\", \"3\", \"x\", \"18\", \"9\", \"x\", \"x\", \"x\", \"15\"], [\"x\", \"x\", \"11\", \"9\", \"3\", \"x\", \"x\", \"16\", \"x\", \"5\", \"x\", \"4\", \"10\", \"x\"], [\"18\", \"1\", \"13\", \"x\", \"7\", \"x\", \"7\", \"5\", \"x\", \"11\", \"10\", \"2\", \"x\", \"2\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"11\", \"x\", \"10\", \"x\", \"x\", \"14\", \"6\"]], [1, 13], [7, 4], 1, 6]", "A*_args": "[\"[['15', '19', '13', '4', 'x', 'x', '13', '7', '16', '6', 'x', 'x', '17', 'x'], ['2', '2', 'x', '7', 'x', '12', '12', 'x', '19', 'x', '10', '4', '14', '2'], ['11', 'x', 'x', '3', '7', 'x', '7', 'x', 'x', '6', 'x', '19', 'x', '1'], ['x', 'x', '11', 'x', '3', 'x', '17', 'x', '1', '20', '17', '8', '15', '1'], ['x', 'x', '13', 'x', '12', '17', '5', '4', 'x', '16', '9', 'x', '19', '14'], ['x', '16', 'x', 'x', '13', '17', '14', '6', '2', '17', '19', '6', '13', '6'], ['x', '1', 'x', 'x', '3', '10', '2', '18', '7', '8', 'x', '8', 'x', 'x'], ['12', '2', '1', '6', '11', '7', '10', 'x', 'x', 'x', '4', '2', '8', 'x'], ['x', 'x', 'x', '13', '16', '2', 'x', '6', '9', '2', '11', '7', '14', '6'], ['x', 'x', 'x', 'x', 'x', '11', 'x', '16', 'x', 'x', 'x', 'x', 'x', '3'], ['x', 'x', 'x', 'x', '10', 'x', '3', 'x', '18', '9', 'x', 'x', 'x', '15'], ['x', 'x', '11', '9', '3', 'x', 'x', '16', 'x', '5', 'x', '4', '10', 'x'], ['18', '1', '13', 'x', '7', 'x', '7', '5', 'x', '11', '10', '2', 'x', '2'], ['x', 'x', 'x', 'x', 'x', 'x', 'x', '11', 'x', '10', 'x', 'x', '14', '6']]\", \"(1, 13)\", \"(7, 4)\", \"1\", \"6\"]"}
{"diff_sorted_id": "82", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 14x14. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (2, 13) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (8, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 1 1 1 1 1 1 1 1 1 1 0 1\n1 1 1 0 0 1 1 1 1 1 0 1 0 1\n0 0 0 1 0 1 1 0 0 1 0 0 0 0\n0 1 0 1 1 1 1 1 1 0 1 1 0 0\n1 1 1 0 1 1 0 1 1 1 1 0 0 1\n1 0 1 1 0 1 0 1 1 1 1 0 1 0\n0 1 1 0 0 1 1 1 0 1 1 1 0 0\n1 1 0 1 0 0 1 1 0 1 1 0 0 1\n0 0 0 0 0 1 1 1 1 0 1 0 0 1\n1 0 1 1 0 0 0 0 0 0 0 0 0 1\n1 0 1 0 1 0 0 1 0 1 1 1 0 1\n0 1 1 1 0 1 0 1 0 0 0 0 1 1\n1 1 1 1 1 1 0 0 0 1 0 0 0 1\n1 1 1 0 1 0 1 0 0 0 1 0 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[[2, 13], [2, 12], [3, 12], [4, 11], [5, 11], [6, 12], [7, 11], [8, 11], [9, 10], [9, 9], [9, 8], [9, 7], [9, 6], [9, 5], [9, 4], [8, 4], [8, 3], [8, 2], [8, 1], [8, 0]]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.03277468681335449", "solution_depth": "20", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1], [1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1], [0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0], [1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1], [1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0], [0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0], [1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1], [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1], [0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0]]\", 4]", "is_correct_args": "[\"[[1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1], [1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1], [0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0], [1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1], [1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0], [0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0], [1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1], [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1], [0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0]]\", [2, 13], [8, 0], 4]", "A*_args": "[\"[[1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1], [1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1], [0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0], [0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0], [1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1], [1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0], [0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0], [1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1], [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1], [1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1], [0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0]]\", \"(2, 13)\", \"(8, 0)\", \"4\"]"}
{"diff_sorted_id": "82", "problem_statement": "Given 7 labeled water jugs with capacities 52, 55, 84, 135, 136, 47, 139, 76 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 292, 325, 496, 516 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 52, 4], [\"+\", 139, 4], [\"+\", 139, 4], [\"+\", 139, 4], [\"+\", 47, 4], [\"+\", 135, 3], [\"+\", 135, 3], [\"+\", 139, 3], [\"-\", 52, 3], [\"+\", 139, 3], [\"+\", 139, 2], [\"+\", 139, 2], [\"+\", 47, 2], [\"+\", 135, 1], [\"+\", 136, 1], [\"-\", 55, 1], [\"+\", 76, 1]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.049492597579956055", "solution_depth": "17", "max_successor_states": "64", "num_vars_per_state": "3", "is_feasible_args": "[[52, 55, 84, 135, 136, 47, 139, 76], [292, 325, 496, 516]]", "is_correct_args": "[[52, 55, 84, 135, 136, 47, 139, 76], [292, 325, 496, 516]]", "A*_args": "[\"[52, 55, 84, 135, 136, 47, 139, 76]\", \"[292, 325, 496, 516]\"]"}
{"diff_sorted_id": "83", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[79, 82, 80, 67, 45], [51, '_', 63, 41, 5], [39, 99, 31, 16, 50]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "7", "opt_solution": "[82, 79, 51, 82, 63, 80, 79, 51, 82, 63, 99, 39, 63, 99, 51, 82, 99, 63, 39, 31, 16, 50, 5, 41, 50, 5, 41, 45, 67, 79, 80, 50, 45, 41]", "opt_solution_cost": "34", "opt_solution_compute_t": "4.1595001220703125", "solution_depth": "34", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[79, 82, 80, 67, 45], [51, \"_\", 63, 41, 5], [39, 99, 31, 16, 50]]]", "is_correct_args": "[[[79, 82, 80, 67, 45], [51, \"_\", 63, 41, 5], [39, 99, 31, 16, 50]]]", "A*_args": "[\"[[79, 82, 80, 67, 45], [51, '_', 63, 41, 5], [39, 99, 31, 16, 50]]\"]"}
{"diff_sorted_id": "83", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: rane, sures, liber, bikol, skaff   The initial board: [['u', 'r', 'a', 'n', 'e'], ['s', 'l', 'r', 'i', 's'], ['a', 'i', '_', 'e', 'e'], ['b', 'o', 'k', 'b', 'l'], ['s', 'k', 'r', 'f', 'f']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"down-right\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\", \"up-left\"]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.2462632656097412", "solution_depth": "14", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"u\", \"r\", \"a\", \"n\", \"e\"], [\"s\", \"l\", \"r\", \"i\", \"s\"], [\"a\", \"i\", \"_\", \"e\", \"e\"], [\"b\", \"o\", \"k\", \"b\", \"l\"], [\"s\", \"k\", \"r\", \"f\", \"f\"]]]", "is_correct_args": "[[[\"u\", \"r\", \"a\", \"n\", \"e\"], [\"s\", \"l\", \"r\", \"i\", \"s\"], [\"a\", \"i\", \"_\", \"e\", \"e\"], [\"b\", \"o\", \"k\", \"b\", \"l\"], [\"s\", \"k\", \"r\", \"f\", \"f\"]], [\"rane\", \"sures\", \"liber\", \"bikol\", \"skaff\"]]", "A*_args": "[\"[['u', 'r', 'a', 'n', 'e'], ['s', 'l', 'r', 'i', 's'], ['a', 'i', '_', 'e', 'e'], ['b', 'o', 'k', 'b', 'l'], ['s', 'k', 'r', 'f', 'f']]\", \"['rane', 'sures', 'liber', 'bikol', 'skaff']\"]"}
{"diff_sorted_id": "83", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'X'. Our task is to visit city K and city N excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from N and K, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  J H X L F A P M D R T Z N K \nJ 0 1 0 1 1 0 1 0 1 0 0 1 0 0 \nH 1 0 0 0 0 0 0 0 0 0 0 0 0 0 \nX 0 1 0 0 0 0 0 0 1 0 0 0 0 0 \nL 0 0 1 0 0 0 0 0 0 1 1 0 1 0 \nF 0 0 0 0 0 0 0 0 0 1 0 1 0 0 \nA 1 0 0 1 1 0 0 0 1 0 0 0 0 0 \nP 0 1 0 0 0 0 0 1 0 0 0 0 0 1 \nM 0 0 0 1 0 1 0 0 1 0 1 1 0 0 \nD 0 0 0 1 0 0 1 1 0 1 0 0 1 0 \nR 0 1 0 1 0 0 0 1 0 0 0 0 0 1 \nT 1 1 1 0 1 0 1 1 0 1 0 0 1 0 \nZ 0 1 0 1 0 0 1 0 1 1 0 0 1 0 \nN 0 0 0 1 1 0 1 0 1 1 0 1 0 0 \nK 1 1 1 0 1 1 0 1 0 0 1 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[\"X\", \"D\", \"N\", \"P\", \"K\", \"T\", \"N\", \"R\", \"K\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.12111306190490723", "solution_depth": "9", "max_successor_states": "14", "num_vars_per_state": "17", "is_feasible_args": "[[[0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0], [0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0], [0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0], [0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0], [1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0]], [\"J\", \"H\", \"X\", \"L\", \"F\", \"A\", \"P\", \"M\", \"D\", \"R\", \"T\", \"Z\", \"N\", \"K\"], \"K\", \"N\"]", "is_correct_args": "[[[0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0], [0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0], [0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0], [0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0], [1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0]], [\"J\", \"H\", \"X\", \"L\", \"F\", \"A\", \"P\", \"M\", \"D\", \"R\", \"T\", \"Z\", \"N\", \"K\"], \"X\", \"K\", \"N\"]", "A*_args": "[\"[[0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0], [0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0], [0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0], [0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0], [1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0]]\", \"['J', 'H', 'X', 'L', 'F', 'A', 'P', 'M', 'D', 'R', 'T', 'Z', 'N', 'K']\", \"['X']\", \"['K', 'N']\"]"}
{"diff_sorted_id": "83", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [12, 5, 22, 10, 4, 26, 26, 31, 13, 30, 37, 14, 14, 38, 9, 30, 7, 16, 21, 37, 4, 24, 10, 41, 13, 16, 3, 40, 24, 117, 34, 7, 11, 14, 28, 37, 21, 32, 2, 15, 5, 13, 3, 28, 31, 22, 30, 32, 38, 25, 10, 4, 30], such that the sum of the chosen coins adds up to 411. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {10: 7, 2: 2, 14: 12, 15: 8, 13: 10, 9: 1, 38: 17, 117: 2, 16: 13, 25: 11, 31: 3, 32: 2, 22: 10, 7: 4, 12: 3, 4: 1, 40: 2, 34: 4, 41: 9, 30: 8, 11: 10, 26: 13, 28: 6, 3: 2, 37: 17, 5: 5, 21: 3, 24: 13}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "34", "opt_solution": "[40, 32, 4, 31, 4, 117, 34, 32, 4, 21, 21, 31, 28, 12]", "opt_solution_cost": "36", "opt_solution_compute_t": "0.06167340278625488", "solution_depth": "14", "max_successor_states": "53", "num_vars_per_state": "53", "is_feasible_args": "[[12, 5, 22, 10, 4, 26, 26, 31, 13, 30, 37, 14, 14, 38, 9, 30, 7, 16, 21, 37, 4, 24, 10, 41, 13, 16, 3, 40, 24, 117, 34, 7, 11, 14, 28, 37, 21, 32, 2, 15, 5, 13, 3, 28, 31, 22, 30, 32, 38, 25, 10, 4, 30]]", "is_correct_args": "[[12, 5, 22, 10, 4, 26, 26, 31, 13, 30, 37, 14, 14, 38, 9, 30, 7, 16, 21, 37, 4, 24, 10, 41, 13, 16, 3, 40, 24, 117, 34, 7, 11, 14, 28, 37, 21, 32, 2, 15, 5, 13, 3, 28, 31, 22, 30, 32, 38, 25, 10, 4, 30], {\"10\": 7, \"2\": 2, \"14\": 12, \"15\": 8, \"13\": 10, \"9\": 1, \"38\": 17, \"117\": 2, \"16\": 13, \"25\": 11, \"31\": 3, \"32\": 2, \"22\": 10, \"7\": 4, \"12\": 3, \"4\": 1, \"40\": 2, \"34\": 4, \"41\": 9, \"30\": 8, \"11\": 10, \"26\": 13, \"28\": 6, \"3\": 2, \"37\": 17, \"5\": 5, \"21\": 3, \"24\": 13}, 411]", "A*_args": "[\"[12, 5, 22, 10, 4, 26, 26, 31, 13, 30, 37, 14, 14, 38, 9, 30, 7, 16, 21, 37, 4, 24, 10, 41, 13, 16, 3, 40, 24, 117, 34, 7, 11, 14, 28, 37, 21, 32, 2, 15, 5, 13, 3, 28, 31, 22, 30, 32, 38, 25, 10, 4, 30]\", \"{10: 7, 2: 2, 14: 12, 15: 8, 13: 10, 9: 1, 38: 17, 117: 2, 16: 13, 25: 11, 31: 3, 32: 2, 22: 10, 7: 4, 12: 3, 4: 1, 40: 2, 34: 4, 41: 9, 30: 8, 11: 10, 26: 13, 28: 6, 3: 2, 37: 17, 5: 5, 21: 3, 24: 13}\", \"411\"]"}
{"diff_sorted_id": "83", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Blue', 'Blue', 'Blue', 'Red'], ['Red', 'Red', 'Green', 'Blue', 'Green', 'Blue'], ['Red', 'Red', 'Green', 'Green', 'Blue', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[0, 1], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 2], [1, 0], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [2, 0], [1, 2], [1, 2], [1, 2], [0, 1], [0, 2], [0, 2]]", "opt_solution_cost": "29", "opt_solution_compute_t": "281.29705452919006", "solution_depth": "29", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Red\", \"Green\", \"Blue\", \"Blue\", \"Blue\", \"Red\"], [\"Red\", \"Red\", \"Green\", \"Blue\", \"Green\", \"Blue\"], [\"Red\", \"Red\", \"Green\", \"Green\", \"Blue\", \"Green\"]], 9]", "is_correct_args": "[[[\"Red\", \"Green\", \"Blue\", \"Blue\", \"Blue\", \"Red\"], [\"Red\", \"Red\", \"Green\", \"Blue\", \"Green\", \"Blue\"], [\"Red\", \"Red\", \"Green\", \"Green\", \"Blue\", \"Green\"]], 9]", "A*_args": "[\"[['Red', 'Green', 'Blue', 'Blue', 'Blue', 'Red'], ['Red', 'Red', 'Green', 'Blue', 'Green', 'Blue'], ['Red', 'Red', 'Green', 'Green', 'Blue', 'Green']]\", \"9\"]"}
{"diff_sorted_id": "83", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 36 to 86 (36 included in the range but 86 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' '58' 'x']\n ['44' '54' '59' 'x']\n ['43' 'x' '63' '75']\n ['x' 'x' 'x' '84']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "13", "opt_solution": "[[0, 1, 39], [0, 3, 51], [1, 0, 40], [1, 1, 41], [2, 1, 55], [3, 0, 56]]", "opt_solution_cost": "705", "opt_solution_compute_t": "0.23045659065246582", "solution_depth": "6", "max_successor_states": "50", "num_vars_per_state": "16", "is_feasible_args": "[\"[['38', '', '50', ''], ['', '', '64', '67'], ['54', '', '71', '79'], ['', '59', '89', '90']]\", 36, 91]", "is_correct_args": "[\"[['38', '', '50', ''], ['', '', '64', '67'], ['54', '', '71', '79'], ['', '59', '89', '90']]\", 36, 91]", "A*_args": "[\"[['38', '', '50', ''], ['', '', '64', '67'], ['54', '', '71', '79'], ['', '59', '89', '90']]\", \"36\", \"91\"]"}
{"diff_sorted_id": "83", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 43 to 84. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 240, 226, None for columns 1 to 2 respectively, and the sums of rows must be None, 255, 268, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 264. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '51' 'x' '65']\n ['x' 'x' 'x' '68']\n ['x' 'x' '64' '75']\n ['x' 'x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 0, 43], [0, 2, 44], [1, 0, 52], [1, 1, 62], [1, 2, 73], [2, 0, 49], [2, 1, 80], [3, 0, 46], [3, 1, 47], [3, 2, 45], [3, 3, 48]]", "opt_solution_cost": "912", "opt_solution_compute_t": "105.51012396812439", "solution_depth": "11", "max_successor_states": "31", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '51', '', '65'], ['', '', '', '68'], ['', '', '64', '75'], ['', '', '', '']]\", 4, 43, 84]", "is_correct_args": "[\"[['', '51', '', '65'], ['', '', '', '68'], ['', '', '64', '75'], ['', '', '', '']]\", 43, 84, [1, 3], [1, 3], [240, 226], [255, 268], 264]", "A*_args": "[\"[['', '51', '', '65'], ['', '', '', '68'], ['', '', '64', '75'], ['', '', '', '']]\", \"43\", \"84\", \"[None, 240, 226, None]\", \"[None, 255, 268, None]\", \"264\"]"}
{"diff_sorted_id": "83", "problem_statement": "In 'Restricted Sorting', there are 12 stacks each with a capacity of 7 blocks, with 6 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 6 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 10, 1: 8, 2: 12, 3: 3, 4: 5, 5: 11, 6: 5, 7: 12, 8: 3, 9: 3, 10: 11, 11: 6}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Black', 'Green', 'White', 'Pink', 'Yellow', 'Blue', 'Red'], [], ['Green', 'Red', 'Red', 'Red', 'White', 'Black', 'Black'], [], ['Blue', 'Blue', 'Pink', 'Yellow', 'Pink', 'Green', 'Red'], ['Blue', 'Black', 'White', 'Green', 'White', 'Yellow', 'Yellow'], ['White', 'Blue', 'Pink', 'Green', 'Yellow', 'Green', 'Pink'], [], ['Yellow', 'Black', 'White', 'Red', 'Blue', 'Black', 'Pink'], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "4", "opt_solution": "[[5, 8], [5, 8], [6, 8], [1, 4], [6, 4], [6, 11], [7, 11], [7, 8], [1, 0], [1, 11], [3, 0], [6, 0], [6, 11], [9, 6], [9, 4], [9, 11], [1, 10], [1, 6], [1, 8], [9, 1], [9, 8], [9, 4], [7, 9], [5, 9], [5, 6], [5, 9], [5, 0], [3, 1], [3, 1], [3, 1], [3, 11], [3, 4], [3, 4], [7, 3], [7, 6], [7, 3], [5, 1], [0, 3], [0, 3], [0, 3], [0, 3], [7, 9], [10, 9]]", "opt_solution_cost": "228", "opt_solution_compute_t": "0.21515893936157227", "solution_depth": "43", "max_successor_states": "132", "num_vars_per_state": "42", "is_feasible_args": "[[[], [\"Black\", \"Green\", \"White\", \"Pink\", \"Yellow\", \"Blue\", \"Red\"], [], [\"Green\", \"Red\", \"Red\", \"Red\", \"White\", \"Black\", \"Black\"], [], [\"Blue\", \"Blue\", \"Pink\", \"Yellow\", \"Pink\", \"Green\", \"Red\"], [\"Blue\", \"Black\", \"White\", \"Green\", \"White\", \"Yellow\", \"Yellow\"], [\"White\", \"Blue\", \"Pink\", \"Green\", \"Yellow\", \"Green\", \"Pink\"], [], [\"Yellow\", \"Black\", \"White\", \"Red\", \"Blue\", \"Black\", \"Pink\"], [], []], 7, {\"0\": 10, \"1\": 8, \"2\": 12, \"3\": 3, \"4\": 5, \"5\": 11, \"6\": 5, \"7\": 12, \"8\": 3, \"9\": 3, \"10\": 11, \"11\": 6}]", "is_correct_args": "[[[], [\"Black\", \"Green\", \"White\", \"Pink\", \"Yellow\", \"Blue\", \"Red\"], [], [\"Green\", \"Red\", \"Red\", \"Red\", \"White\", \"Black\", \"Black\"], [], [\"Blue\", \"Blue\", \"Pink\", \"Yellow\", \"Pink\", \"Green\", \"Red\"], [\"Blue\", \"Black\", \"White\", \"Green\", \"White\", \"Yellow\", \"Yellow\"], [\"White\", \"Blue\", \"Pink\", \"Green\", \"Yellow\", \"Green\", \"Pink\"], [], [\"Yellow\", \"Black\", \"White\", \"Red\", \"Blue\", \"Black\", \"Pink\"], [], []], 7, {\"0\": 10, \"1\": 8, \"2\": 12, \"3\": 3, \"4\": 5, \"5\": 11, \"6\": 5, \"7\": 12, \"8\": 3, \"9\": 3, \"10\": 11, \"11\": 6}, 6]", "A*_args": "[\"[[], ['Black', 'Green', 'White', 'Pink', 'Yellow', 'Blue', 'Red'], [], ['Green', 'Red', 'Red', 'Red', 'White', 'Black', 'Black'], [], ['Blue', 'Blue', 'Pink', 'Yellow', 'Pink', 'Green', 'Red'], ['Blue', 'Black', 'White', 'Green', 'White', 'Yellow', 'Yellow'], ['White', 'Blue', 'Pink', 'Green', 'Yellow', 'Green', 'Pink'], [], ['Yellow', 'Black', 'White', 'Red', 'Blue', 'Black', 'Pink'], [], []]\", \"{0: 10, 1: 8, 2: 12, 3: 3, 4: 5, 5: 11, 6: 5, 7: 12, 8: 3, 9: 3, 10: 11, 11: 6}\", \"7\", \"6\"]"}
{"diff_sorted_id": "83", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (2, 13) to his destination workshop at index (5, 1), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 5, and district 3 covering rows 6 to 13. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x 14 x 3 x 18 x 4 4 x x 16 x]\n[x x 1 15 x 18 x 18 x x x x 14 x]\n[x x 7 14 x x 16 x x x x 5 19 15]\n[x 13 18 x 17 x 6 8 x 8 x x 13 x]\n[12 x 15 x x x x 18 x x x 8 6 7]\n[5 11 14 14 11 5 13 7 x x 10 12 17 17]\n[14 x 3 15 3 x x 17 12 7 19 15 4 5]\n[x 2 14 x 8 x 9 19 16 14 17 12 x 13]\n[x x 2 15 x x x 2 14 17 3 4 x 12]\n[2 x 11 x x 14 x x 16 x 11 13 x x]\n[17 x x 2 9 14 8 x 11 5 x 10 5 x]\n[4 x 8 8 11 x 16 x x x 15 x 2 16]\n[x 16 x x 9 x x x x 19 6 9 x x]\n[x 14 9 x 6 1 7 x 10 4 x x x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "6", "opt_solution": "[[2, 13], [2, 12], [3, 12], [4, 12], [4, 11], [5, 11], [5, 10], [6, 10], [6, 9], [6, 8], [6, 7], [5, 7], [5, 6], [5, 5], [5, 4], [5, 3], [5, 2], [5, 1]]", "opt_solution_cost": "198", "opt_solution_compute_t": "0.028166532516479492", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"14\", \"x\", \"3\", \"x\", \"18\", \"x\", \"4\", \"4\", \"x\", \"x\", \"16\", \"x\"], [\"x\", \"x\", \"1\", \"15\", \"x\", \"18\", \"x\", \"18\", \"x\", \"x\", \"x\", \"x\", \"14\", \"x\"], [\"x\", \"x\", \"7\", \"14\", \"x\", \"x\", \"16\", \"x\", \"x\", \"x\", \"x\", \"5\", \"19\", \"15\"], [\"x\", \"13\", \"18\", \"x\", \"17\", \"x\", \"6\", \"8\", \"x\", \"8\", \"x\", \"x\", \"13\", \"x\"], [\"12\", \"x\", \"15\", \"x\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\", \"x\", \"8\", \"6\", \"7\"], [\"5\", \"11\", \"14\", \"14\", \"11\", \"5\", \"13\", \"7\", \"x\", \"x\", \"10\", \"12\", \"17\", \"17\"], [\"14\", \"x\", \"3\", \"15\", \"3\", \"x\", \"x\", \"17\", \"12\", \"7\", \"19\", \"15\", \"4\", \"5\"], [\"x\", \"2\", \"14\", \"x\", \"8\", \"x\", \"9\", \"19\", \"16\", \"14\", \"17\", \"12\", \"x\", \"13\"], [\"x\", \"x\", \"2\", \"15\", \"x\", \"x\", \"x\", \"2\", \"14\", \"17\", \"3\", \"4\", \"x\", \"12\"], [\"2\", \"x\", \"11\", \"x\", \"x\", \"14\", \"x\", \"x\", \"16\", \"x\", \"11\", \"13\", \"x\", \"x\"], [\"17\", \"x\", \"x\", \"2\", \"9\", \"14\", \"8\", \"x\", \"11\", \"5\", \"x\", \"10\", \"5\", \"x\"], [\"4\", \"x\", \"8\", \"8\", \"11\", \"x\", \"16\", \"x\", \"x\", \"x\", \"15\", \"x\", \"2\", \"16\"], [\"x\", \"16\", \"x\", \"x\", \"9\", \"x\", \"x\", \"x\", \"x\", \"19\", \"6\", \"9\", \"x\", \"x\"], [\"x\", \"14\", \"9\", \"x\", \"6\", \"1\", \"7\", \"x\", \"10\", \"4\", \"x\", \"x\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"14\", \"x\", \"3\", \"x\", \"18\", \"x\", \"4\", \"4\", \"x\", \"x\", \"16\", \"x\"], [\"x\", \"x\", \"1\", \"15\", \"x\", \"18\", \"x\", \"18\", \"x\", \"x\", \"x\", \"x\", \"14\", \"x\"], [\"x\", \"x\", \"7\", \"14\", \"x\", \"x\", \"16\", \"x\", \"x\", \"x\", \"x\", \"5\", \"19\", \"15\"], [\"x\", \"13\", \"18\", \"x\", \"17\", \"x\", \"6\", \"8\", \"x\", \"8\", \"x\", \"x\", \"13\", \"x\"], [\"12\", \"x\", \"15\", \"x\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\", \"x\", \"8\", \"6\", \"7\"], [\"5\", \"11\", \"14\", \"14\", \"11\", \"5\", \"13\", \"7\", \"x\", \"x\", \"10\", \"12\", \"17\", \"17\"], [\"14\", \"x\", \"3\", \"15\", \"3\", \"x\", \"x\", \"17\", \"12\", \"7\", \"19\", \"15\", \"4\", \"5\"], [\"x\", \"2\", \"14\", \"x\", \"8\", \"x\", \"9\", \"19\", \"16\", \"14\", \"17\", \"12\", \"x\", \"13\"], [\"x\", \"x\", \"2\", \"15\", \"x\", \"x\", \"x\", \"2\", \"14\", \"17\", \"3\", \"4\", \"x\", \"12\"], [\"2\", \"x\", \"11\", \"x\", \"x\", \"14\", \"x\", \"x\", \"16\", \"x\", \"11\", \"13\", \"x\", \"x\"], [\"17\", \"x\", \"x\", \"2\", \"9\", \"14\", \"8\", \"x\", \"11\", \"5\", \"x\", \"10\", \"5\", \"x\"], [\"4\", \"x\", \"8\", \"8\", \"11\", \"x\", \"16\", \"x\", \"x\", \"x\", \"15\", \"x\", \"2\", \"16\"], [\"x\", \"16\", \"x\", \"x\", \"9\", \"x\", \"x\", \"x\", \"x\", \"19\", \"6\", \"9\", \"x\", \"x\"], [\"x\", \"14\", \"9\", \"x\", \"6\", \"1\", \"7\", \"x\", \"10\", \"4\", \"x\", \"x\", \"x\", \"x\"]], [2, 13], [5, 1], 2, 5]", "A*_args": "[\"[['x', 'x', '14', 'x', '3', 'x', '18', 'x', '4', '4', 'x', 'x', '16', 'x'], ['x', 'x', '1', '15', 'x', '18', 'x', '18', 'x', 'x', 'x', 'x', '14', 'x'], ['x', 'x', '7', '14', 'x', 'x', '16', 'x', 'x', 'x', 'x', '5', '19', '15'], ['x', '13', '18', 'x', '17', 'x', '6', '8', 'x', '8', 'x', 'x', '13', 'x'], ['12', 'x', '15', 'x', 'x', 'x', 'x', '18', 'x', 'x', 'x', '8', '6', '7'], ['5', '11', '14', '14', '11', '5', '13', '7', 'x', 'x', '10', '12', '17', '17'], ['14', 'x', '3', '15', '3', 'x', 'x', '17', '12', '7', '19', '15', '4', '5'], ['x', '2', '14', 'x', '8', 'x', '9', '19', '16', '14', '17', '12', 'x', '13'], ['x', 'x', '2', '15', 'x', 'x', 'x', '2', '14', '17', '3', '4', 'x', '12'], ['2', 'x', '11', 'x', 'x', '14', 'x', 'x', '16', 'x', '11', '13', 'x', 'x'], ['17', 'x', 'x', '2', '9', '14', '8', 'x', '11', '5', 'x', '10', '5', 'x'], ['4', 'x', '8', '8', '11', 'x', '16', 'x', 'x', 'x', '15', 'x', '2', '16'], ['x', '16', 'x', 'x', '9', 'x', 'x', 'x', 'x', '19', '6', '9', 'x', 'x'], ['x', '14', '9', 'x', '6', '1', '7', 'x', '10', '4', 'x', 'x', 'x', 'x']]\", \"(2, 13)\", \"(5, 1)\", \"2\", \"5\"]"}
{"diff_sorted_id": "83", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 14x14. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (13, 10) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (4, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 1 1 0 1 0 0 1 0 1 0 1 1\n1 1 1 1 1 0 0 0 1 0 0 0 0 1\n1 0 0 0 1 0 1 1 1 1 1 0 1 1\n1 0 1 1 1 0 1 1 1 1 1 1 1 0\n0 1 1 1 1 1 0 1 1 1 0 1 1 1\n0 0 0 1 1 0 0 1 1 0 0 1 0 1\n0 0 1 1 1 1 1 0 1 0 1 0 0 1\n0 1 1 1 1 1 0 1 1 0 0 1 0 0\n0 0 0 0 0 0 1 0 1 0 1 0 1 1\n0 0 1 1 0 0 0 0 1 0 0 1 0 1\n1 1 1 0 1 0 0 0 1 1 0 1 0 1\n1 1 0 1 0 1 0 0 0 0 1 1 0 0\n1 0 1 1 1 1 1 1 0 0 0 0 1 1\n1 1 1 1 0 1 1 1 1 1 0 0 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[[13, 10], [12, 9], [11, 8], [10, 7], [9, 6], [9, 5], [8, 5], [8, 4], [8, 3], [8, 2], [8, 1], [8, 0], [7, 0], [6, 0], [5, 0], [4, 0]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.0652778148651123", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1], [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1], [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1], [0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1], [0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1], [1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0]]\", 4]", "is_correct_args": "[\"[[0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1], [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1], [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1], [0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1], [0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1], [1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0]]\", [13, 10], [4, 0], 4]", "A*_args": "[\"[[0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1], [1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1], [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1], [0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1], [0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1], [1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0]]\", \"(13, 10)\", \"(4, 0)\", \"4\"]"}
{"diff_sorted_id": "83", "problem_statement": "Given 7 labeled water jugs with capacities 19, 42, 18, 127, 106, 32, 22, 137 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 245, 252, 264, 314 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 22, 4], [\"+\", 137, 4], [\"+\", 18, 4], [\"+\", 137, 4], [\"+\", 127, 3], [\"+\", 137, 3], [\"+\", 106, 2], [\"+\", 127, 2], [\"+\", 19, 2], [\"+\", 127, 1], [\"-\", 19, 1], [\"+\", 137, 1]]", "opt_solution_cost": "12", "opt_solution_compute_t": "0.036943674087524414", "solution_depth": "12", "max_successor_states": "64", "num_vars_per_state": "3", "is_feasible_args": "[[19, 42, 18, 127, 106, 32, 22, 137], [245, 252, 264, 314]]", "is_correct_args": "[[19, 42, 18, 127, 106, 32, 22, 137], [245, 252, 264, 314]]", "A*_args": "[\"[19, 42, 18, 127, 106, 32, 22, 137]\", \"[245, 252, 264, 314]\"]"}
{"diff_sorted_id": "84", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[85, 96, 29, 80, 12], [60, '_', 76, 42, 82], [27, 89, 72, 37, 55]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "7", "opt_solution": "[96, 85, 60, 96, 76, 29, 85, 60, 96, 76, 89, 72, 37, 42, 82, 12, 80, 85, 60, 89, 72, 27, 76, 72, 27, 37, 29, 27, 72, 76, 37, 29, 27, 60, 85, 82, 12, 55, 42, 12, 55, 42]", "opt_solution_cost": "42", "opt_solution_compute_t": "31.574211835861206", "solution_depth": "42", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[85, 96, 29, 80, 12], [60, \"_\", 76, 42, 82], [27, 89, 72, 37, 55]]]", "is_correct_args": "[[[85, 96, 29, 80, 12], [60, \"_\", 76, 42, 82], [27, 89, 72, 37, 55]]]", "A*_args": "[\"[[85, 96, 29, 80, 12], [60, '_', 76, 42, 82], [27, 89, 72, 37, 55]]\"]"}
{"diff_sorted_id": "84", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: roto, serer, tapas, dinka, desex   The initial board: [['e', 'r', 'p', 't', 'o'], ['s', 't', 'r', 'k', 'r'], ['e', 'a', '_', 'a', 'i'], ['d', 'o', 'n', 's', 'a'], ['d', 'e', 's', 'e', 'x']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.3263390064239502", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"e\", \"r\", \"p\", \"t\", \"o\"], [\"s\", \"t\", \"r\", \"k\", \"r\"], [\"e\", \"a\", \"_\", \"a\", \"i\"], [\"d\", \"o\", \"n\", \"s\", \"a\"], [\"d\", \"e\", \"s\", \"e\", \"x\"]]]", "is_correct_args": "[[[\"e\", \"r\", \"p\", \"t\", \"o\"], [\"s\", \"t\", \"r\", \"k\", \"r\"], [\"e\", \"a\", \"_\", \"a\", \"i\"], [\"d\", \"o\", \"n\", \"s\", \"a\"], [\"d\", \"e\", \"s\", \"e\", \"x\"]], [\"roto\", \"serer\", \"tapas\", \"dinka\", \"desex\"]]", "A*_args": "[\"[['e', 'r', 'p', 't', 'o'], ['s', 't', 'r', 'k', 'r'], ['e', 'a', '_', 'a', 'i'], ['d', 'o', 'n', 's', 'a'], ['d', 'e', 's', 'e', 'x']]\", \"['roto', 'serer', 'tapas', 'dinka', 'desex']\"]"}
{"diff_sorted_id": "84", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'T'. Our task is to visit city H and city K excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from K and H, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  F O L P Y R Q B T V A K S H \nF 0 0 0 1 1 0 0 1 0 0 0 0 0 0 \nO 0 0 1 0 1 0 1 0 1 0 0 1 0 0 \nL 1 0 0 0 0 1 1 0 0 0 1 1 1 0 \nP 0 0 1 0 1 0 0 1 0 1 1 0 0 0 \nY 0 0 0 0 0 0 0 1 0 0 1 0 1 0 \nR 0 0 0 0 1 0 1 1 0 0 0 0 1 0 \nQ 0 0 0 1 0 0 0 0 0 0 0 1 0 1 \nB 0 1 1 0 0 0 1 0 0 1 0 0 1 1 \nT 1 0 0 0 0 0 1 0 0 1 0 0 0 0 \nV 0 0 0 0 0 0 0 0 1 0 0 1 1 1 \nA 1 1 0 0 0 0 0 1 1 1 0 0 0 1 \nK 1 0 0 1 1 0 0 0 1 0 1 0 0 0 \nS 0 1 0 0 0 0 1 0 1 1 1 1 0 0 \nH 1 0 0 1 0 1 0 0 0 0 0 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[\"T\", \"Q\", \"H\", \"S\", \"K\", \"P\", \"L\", \"K\", \"A\", \"H\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.10328006744384766", "solution_depth": "10", "max_successor_states": "14", "num_vars_per_state": "17", "is_feasible_args": "[[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0], [0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1], [1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1], [1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0]], [\"F\", \"O\", \"L\", \"P\", \"Y\", \"R\", \"Q\", \"B\", \"T\", \"V\", \"A\", \"K\", \"S\", \"H\"], \"H\", \"K\"]", "is_correct_args": "[[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0], [0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1], [1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1], [1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0]], [\"F\", \"O\", \"L\", \"P\", \"Y\", \"R\", \"Q\", \"B\", \"T\", \"V\", \"A\", \"K\", \"S\", \"H\"], \"T\", \"H\", \"K\"]", "A*_args": "[\"[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0], [0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1], [1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1], [1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0]]\", \"['F', 'O', 'L', 'P', 'Y', 'R', 'Q', 'B', 'T', 'V', 'A', 'K', 'S', 'H']\", \"['T']\", \"['H', 'K']\"]"}
{"diff_sorted_id": "84", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [17, 4, 35, 10, 42, 11, 10, 11, 2, 14, 29, 31, 33, 3, 38, 4, 32, 9, 19, 14, 4, 39, 6, 36, 31, 25, 40, 8, 33, 31, 11, 34, 18, 2, 32, 40, 4, 16, 1, 36, 37, 3, 33, 20, 10, 8, 9, 20, 14, 35, 36, 22, 35, 4], such that the sum of the chosen coins adds up to 426. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {37: 11, 10: 3, 36: 8, 32: 3, 3: 1, 18: 16, 14: 5, 35: 5, 16: 15, 8: 5, 42: 20, 29: 4, 6: 1, 25: 9, 11: 4, 20: 15, 39: 6, 38: 14, 34: 6, 40: 11, 9: 2, 17: 6, 19: 8, 4: 4, 22: 20, 31: 3, 1: 1, 33: 18, 2: 2}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "35", "opt_solution": "[29, 31, 31, 31, 35, 32, 35, 35, 32, 6, 9, 9, 39, 36, 34, 2]", "opt_solution_cost": "61", "opt_solution_compute_t": "0.06626677513122559", "solution_depth": "16", "max_successor_states": "54", "num_vars_per_state": "54", "is_feasible_args": "[[17, 4, 35, 10, 42, 11, 10, 11, 2, 14, 29, 31, 33, 3, 38, 4, 32, 9, 19, 14, 4, 39, 6, 36, 31, 25, 40, 8, 33, 31, 11, 34, 18, 2, 32, 40, 4, 16, 1, 36, 37, 3, 33, 20, 10, 8, 9, 20, 14, 35, 36, 22, 35, 4]]", "is_correct_args": "[[17, 4, 35, 10, 42, 11, 10, 11, 2, 14, 29, 31, 33, 3, 38, 4, 32, 9, 19, 14, 4, 39, 6, 36, 31, 25, 40, 8, 33, 31, 11, 34, 18, 2, 32, 40, 4, 16, 1, 36, 37, 3, 33, 20, 10, 8, 9, 20, 14, 35, 36, 22, 35, 4], {\"37\": 11, \"10\": 3, \"36\": 8, \"32\": 3, \"3\": 1, \"18\": 16, \"14\": 5, \"35\": 5, \"16\": 15, \"8\": 5, \"42\": 20, \"29\": 4, \"6\": 1, \"25\": 9, \"11\": 4, \"20\": 15, \"39\": 6, \"38\": 14, \"34\": 6, \"40\": 11, \"9\": 2, \"17\": 6, \"19\": 8, \"4\": 4, \"22\": 20, \"31\": 3, \"1\": 1, \"33\": 18, \"2\": 2}, 426]", "A*_args": "[\"[17, 4, 35, 10, 42, 11, 10, 11, 2, 14, 29, 31, 33, 3, 38, 4, 32, 9, 19, 14, 4, 39, 6, 36, 31, 25, 40, 8, 33, 31, 11, 34, 18, 2, 32, 40, 4, 16, 1, 36, 37, 3, 33, 20, 10, 8, 9, 20, 14, 35, 36, 22, 35, 4]\", \"{37: 11, 10: 3, 36: 8, 32: 3, 3: 1, 18: 16, 14: 5, 35: 5, 16: 15, 8: 5, 42: 20, 29: 4, 6: 1, 25: 9, 11: 4, 20: 15, 39: 6, 38: 14, 34: 6, 40: 11, 9: 2, 17: 6, 19: 8, 4: 4, 22: 20, 31: 3, 1: 1, 33: 18, 2: 2}\", \"426\"]"}
{"diff_sorted_id": "84", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Red', 'Green', 'Green', 'Blue', 'Green'], ['Blue', 'Blue', 'Blue', 'Red', 'Red', 'Green'], ['Blue', 'Red', 'Blue', 'Red', 'Red', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[2, 1], [2, 0], [2, 1], [2, 0], [2, 0], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [0, 2], [0, 2], [0, 2], [1, 2], [0, 1], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [2, 1], [2, 0], [2, 1], [0, 2], [0, 2], [0, 2]]", "opt_solution_cost": "33", "opt_solution_compute_t": "137.44458413124084", "solution_depth": "33", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Green\", \"Red\", \"Green\", \"Green\", \"Blue\", \"Green\"], [\"Blue\", \"Blue\", \"Blue\", \"Red\", \"Red\", \"Green\"], [\"Blue\", \"Red\", \"Blue\", \"Red\", \"Red\", \"Green\"]], 9]", "is_correct_args": "[[[\"Green\", \"Red\", \"Green\", \"Green\", \"Blue\", \"Green\"], [\"Blue\", \"Blue\", \"Blue\", \"Red\", \"Red\", \"Green\"], [\"Blue\", \"Red\", \"Blue\", \"Red\", \"Red\", \"Green\"]], 9]", "A*_args": "[\"[['Green', 'Red', 'Green', 'Green', 'Blue', 'Green'], ['Blue', 'Blue', 'Blue', 'Red', 'Red', 'Green'], ['Blue', 'Red', 'Blue', 'Red', 'Red', 'Green']]\", \"9\"]"}
{"diff_sorted_id": "84", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 23 to 73 (23 included in the range but 73 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '35' 'x' 'x']\n ['34' '36' '38' 'x']\n ['29' 'x' '43' 'x']\n ['x' 'x' '49' '53']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "13", "opt_solution": "[[0, 2, 51], [1, 2, 50], [1, 3, 52], [2, 0, 40], [2, 1, 48], [2, 3, 53], [3, 0, 39]]", "opt_solution_cost": "729", "opt_solution_compute_t": "0.5444209575653076", "solution_depth": "7", "max_successor_states": "50", "num_vars_per_state": "16", "is_feasible_args": "[\"[['91', '57', '', '45'], ['41', '49', '', ''], ['', '', '49', ''], ['', '46', '47', '73']]\", 39, 94]", "is_correct_args": "[\"[['91', '57', '', '45'], ['41', '49', '', ''], ['', '', '49', ''], ['', '46', '47', '73']]\", 39, 94]", "A*_args": "[\"[['91', '57', '', '45'], ['41', '49', '', ''], ['', '', '49', ''], ['', '46', '47', '73']]\", \"39\", \"94\"]"}
{"diff_sorted_id": "84", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 37 to 83. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 277, 204, None for columns 1 to 2 respectively, and the sums of rows must be None, 253, 221, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 252. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['42' '53' '43' '72']\n ['x' '82' '54' 'x']\n ['x' '62' '44' 'x']\n ['x' 'x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[1, 0, 38], [1, 3, 79], [2, 0, 39], [2, 3, 76], [3, 0, 64], [3, 1, 80], [3, 2, 63], [3, 3, 37]]", "opt_solution_cost": "928", "opt_solution_compute_t": "1.0334880352020264", "solution_depth": "8", "max_successor_states": "31", "num_vars_per_state": "16", "is_feasible_args": "[\"[['42', '53', '43', '72'], ['', '82', '54', ''], ['', '62', '44', ''], ['', '', '', '']]\", 4, 37, 83]", "is_correct_args": "[\"[['42', '53', '43', '72'], ['', '82', '54', ''], ['', '62', '44', ''], ['', '', '', '']]\", 37, 83, [1, 3], [1, 3], [277, 204], [253, 221], 252]", "A*_args": "[\"[['42', '53', '43', '72'], ['', '82', '54', ''], ['', '62', '44', ''], ['', '', '', '']]\", \"37\", \"83\", \"[None, 277, 204, None]\", \"[None, 253, 221, None]\", \"252\"]"}
{"diff_sorted_id": "84", "problem_statement": "In 'Restricted Sorting', there are 12 stacks each with a capacity of 7 blocks, with 6 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 6 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 12, 1: 3, 2: 11, 3: 5, 4: 11, 5: 13, 6: 2, 7: 2, 8: 12, 9: 4, 10: 2, 11: 10}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], [], [], [], ['Pink', 'Red', 'Green', 'Pink', 'White', 'Blue', 'Yellow'], [], ['Yellow', 'White', 'Yellow', 'Blue', 'Yellow', 'Black', 'White'], ['Black', 'Green', 'Pink', 'Pink', 'Green', 'Yellow', 'Green'], ['White', 'Blue', 'Red', 'Red', 'Red', 'Yellow', 'Black'], ['Black', 'Blue', 'Blue', 'Pink', 'Red', 'White', 'Green'], [], ['Blue', 'Black', 'Black', 'White', 'Red', 'Green', 'Pink']]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "4", "opt_solution": "[[7, 10], [9, 10], [8, 1], [8, 3], [11, 3], [11, 10], [11, 10], [11, 1], [11, 2], [11, 0], [9, 3], [9, 3], [9, 11], [9, 2], [9, 1], [7, 9], [7, 11], [7, 11], [4, 11], [4, 2], [4, 9], [4, 11], [4, 1], [4, 3], [7, 9], [7, 4], [7, 9], [6, 7], [6, 1], [6, 7], [6, 3], [6, 7], [6, 10], [0, 9], [6, 1], [8, 6], [8, 6], [8, 6], [8, 7], [2, 6], [2, 6], [2, 6], [4, 7], [4, 7], [8, 10]]", "opt_solution_cost": "210", "opt_solution_compute_t": "3.1606807708740234", "solution_depth": "45", "max_successor_states": "132", "num_vars_per_state": "42", "is_feasible_args": "[[[], [], [], [], [\"Pink\", \"Red\", \"Green\", \"Pink\", \"White\", \"Blue\", \"Yellow\"], [], [\"Yellow\", \"White\", \"Yellow\", \"Blue\", \"Yellow\", \"Black\", \"White\"], [\"Black\", \"Green\", \"Pink\", \"Pink\", \"Green\", \"Yellow\", \"Green\"], [\"White\", \"Blue\", \"Red\", \"Red\", \"Red\", \"Yellow\", \"Black\"], [\"Black\", \"Blue\", \"Blue\", \"Pink\", \"Red\", \"White\", \"Green\"], [], [\"Blue\", \"Black\", \"Black\", \"White\", \"Red\", \"Green\", \"Pink\"]], 7, {\"0\": 12, \"1\": 3, \"2\": 11, \"3\": 5, \"4\": 11, \"5\": 13, \"6\": 2, \"7\": 2, \"8\": 12, \"9\": 4, \"10\": 2, \"11\": 10}]", "is_correct_args": "[[[], [], [], [], [\"Pink\", \"Red\", \"Green\", \"Pink\", \"White\", \"Blue\", \"Yellow\"], [], [\"Yellow\", \"White\", \"Yellow\", \"Blue\", \"Yellow\", \"Black\", \"White\"], [\"Black\", \"Green\", \"Pink\", \"Pink\", \"Green\", \"Yellow\", \"Green\"], [\"White\", \"Blue\", \"Red\", \"Red\", \"Red\", \"Yellow\", \"Black\"], [\"Black\", \"Blue\", \"Blue\", \"Pink\", \"Red\", \"White\", \"Green\"], [], [\"Blue\", \"Black\", \"Black\", \"White\", \"Red\", \"Green\", \"Pink\"]], 7, {\"0\": 12, \"1\": 3, \"2\": 11, \"3\": 5, \"4\": 11, \"5\": 13, \"6\": 2, \"7\": 2, \"8\": 12, \"9\": 4, \"10\": 2, \"11\": 10}, 6]", "A*_args": "[\"[[], [], [], [], ['Pink', 'Red', 'Green', 'Pink', 'White', 'Blue', 'Yellow'], [], ['Yellow', 'White', 'Yellow', 'Blue', 'Yellow', 'Black', 'White'], ['Black', 'Green', 'Pink', 'Pink', 'Green', 'Yellow', 'Green'], ['White', 'Blue', 'Red', 'Red', 'Red', 'Yellow', 'Black'], ['Black', 'Blue', 'Blue', 'Pink', 'Red', 'White', 'Green'], [], ['Blue', 'Black', 'Black', 'White', 'Red', 'Green', 'Pink']]\", \"{0: 12, 1: 3, 2: 11, 3: 5, 4: 11, 5: 13, 6: 2, 7: 2, 8: 12, 9: 4, 10: 2, 11: 10}\", \"7\", \"6\"]"}
{"diff_sorted_id": "84", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (9, 10) to his destination workshop at index (2, 3), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 8, and district 3 covering rows 9 to 13. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 10 16 12 x x x x 18 18 10 x x 19]\n[7 x x 11 5 13 6 x x x x x 8 14]\n[x 15 6 20 4 9 16 9 16 x 11 x x 9]\n[1 16 x x x 6 15 1 10 10 9 4 x 4]\n[x x x 1 12 x 12 17 x x 13 x x 2]\n[x x 9 x x x x 17 x x x x 10 11]\n[7 x 7 12 x x x 2 2 8 10 8 x x]\n[3 3 x 16 11 x 4 6 x x 4 17 13 16]\n[4 15 x x x x x x 11 19 16 x x x]\n[10 5 17 x 2 x x 3 10 3 12 x 8 x]\n[x 17 12 x x x 6 2 13 x x x x x]\n[x 10 x x 15 x x x 8 x 3 x x 19]\n[1 7 x x 16 x x x 3 15 10 12 6 8]\n[x x x x 9 x x x 7 x x x x 8]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "6", "opt_solution": "[[9, 10], [8, 10], [7, 10], [6, 10], [6, 9], [6, 8], [6, 7], [5, 7], [4, 7], [3, 7], [3, 6], [3, 5], [2, 5], [2, 4], [2, 3]]", "opt_solution_cost": "131", "opt_solution_compute_t": "0.028569698333740234", "solution_depth": "15", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"10\", \"16\", \"12\", \"x\", \"x\", \"x\", \"x\", \"18\", \"18\", \"10\", \"x\", \"x\", \"19\"], [\"7\", \"x\", \"x\", \"11\", \"5\", \"13\", \"6\", \"x\", \"x\", \"x\", \"x\", \"x\", \"8\", \"14\"], [\"x\", \"15\", \"6\", \"20\", \"4\", \"9\", \"16\", \"9\", \"16\", \"x\", \"11\", \"x\", \"x\", \"9\"], [\"1\", \"16\", \"x\", \"x\", \"x\", \"6\", \"15\", \"1\", \"10\", \"10\", \"9\", \"4\", \"x\", \"4\"], [\"x\", \"x\", \"x\", \"1\", \"12\", \"x\", \"12\", \"17\", \"x\", \"x\", \"13\", \"x\", \"x\", \"2\"], [\"x\", \"x\", \"9\", \"x\", \"x\", \"x\", \"x\", \"17\", \"x\", \"x\", \"x\", \"x\", \"10\", \"11\"], [\"7\", \"x\", \"7\", \"12\", \"x\", \"x\", \"x\", \"2\", \"2\", \"8\", \"10\", \"8\", \"x\", \"x\"], [\"3\", \"3\", \"x\", \"16\", \"11\", \"x\", \"4\", \"6\", \"x\", \"x\", \"4\", \"17\", \"13\", \"16\"], [\"4\", \"15\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"11\", \"19\", \"16\", \"x\", \"x\", \"x\"], [\"10\", \"5\", \"17\", \"x\", \"2\", \"x\", \"x\", \"3\", \"10\", \"3\", \"12\", \"x\", \"8\", \"x\"], [\"x\", \"17\", \"12\", \"x\", \"x\", \"x\", \"6\", \"2\", \"13\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"10\", \"x\", \"x\", \"15\", \"x\", \"x\", \"x\", \"8\", \"x\", \"3\", \"x\", \"x\", \"19\"], [\"1\", \"7\", \"x\", \"x\", \"16\", \"x\", \"x\", \"x\", \"3\", \"15\", \"10\", \"12\", \"6\", \"8\"], [\"x\", \"x\", \"x\", \"x\", \"9\", \"x\", \"x\", \"x\", \"7\", \"x\", \"x\", \"x\", \"x\", \"8\"]]]", "is_correct_args": "[[[\"x\", \"10\", \"16\", \"12\", \"x\", \"x\", \"x\", \"x\", \"18\", \"18\", \"10\", \"x\", \"x\", \"19\"], [\"7\", \"x\", \"x\", \"11\", \"5\", \"13\", \"6\", \"x\", \"x\", \"x\", \"x\", \"x\", \"8\", \"14\"], [\"x\", \"15\", \"6\", \"20\", \"4\", \"9\", \"16\", \"9\", \"16\", \"x\", \"11\", \"x\", \"x\", \"9\"], [\"1\", \"16\", \"x\", \"x\", \"x\", \"6\", \"15\", \"1\", \"10\", \"10\", \"9\", \"4\", \"x\", \"4\"], [\"x\", \"x\", \"x\", \"1\", \"12\", \"x\", \"12\", \"17\", \"x\", \"x\", \"13\", \"x\", \"x\", \"2\"], [\"x\", \"x\", \"9\", \"x\", \"x\", \"x\", \"x\", \"17\", \"x\", \"x\", \"x\", \"x\", \"10\", \"11\"], [\"7\", \"x\", \"7\", \"12\", \"x\", \"x\", \"x\", \"2\", \"2\", \"8\", \"10\", \"8\", \"x\", \"x\"], [\"3\", \"3\", \"x\", \"16\", \"11\", \"x\", \"4\", \"6\", \"x\", \"x\", \"4\", \"17\", \"13\", \"16\"], [\"4\", \"15\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"11\", \"19\", \"16\", \"x\", \"x\", \"x\"], [\"10\", \"5\", \"17\", \"x\", \"2\", \"x\", \"x\", \"3\", \"10\", \"3\", \"12\", \"x\", \"8\", \"x\"], [\"x\", \"17\", \"12\", \"x\", \"x\", \"x\", \"6\", \"2\", \"13\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"10\", \"x\", \"x\", \"15\", \"x\", \"x\", \"x\", \"8\", \"x\", \"3\", \"x\", \"x\", \"19\"], [\"1\", \"7\", \"x\", \"x\", \"16\", \"x\", \"x\", \"x\", \"3\", \"15\", \"10\", \"12\", \"6\", \"8\"], [\"x\", \"x\", \"x\", \"x\", \"9\", \"x\", \"x\", \"x\", \"7\", \"x\", \"x\", \"x\", \"x\", \"8\"]], [9, 10], [2, 3], 2, 8]", "A*_args": "[\"[['x', '10', '16', '12', 'x', 'x', 'x', 'x', '18', '18', '10', 'x', 'x', '19'], ['7', 'x', 'x', '11', '5', '13', '6', 'x', 'x', 'x', 'x', 'x', '8', '14'], ['x', '15', '6', '20', '4', '9', '16', '9', '16', 'x', '11', 'x', 'x', '9'], ['1', '16', 'x', 'x', 'x', '6', '15', '1', '10', '10', '9', '4', 'x', '4'], ['x', 'x', 'x', '1', '12', 'x', '12', '17', 'x', 'x', '13', 'x', 'x', '2'], ['x', 'x', '9', 'x', 'x', 'x', 'x', '17', 'x', 'x', 'x', 'x', '10', '11'], ['7', 'x', '7', '12', 'x', 'x', 'x', '2', '2', '8', '10', '8', 'x', 'x'], ['3', '3', 'x', '16', '11', 'x', '4', '6', 'x', 'x', '4', '17', '13', '16'], ['4', '15', 'x', 'x', 'x', 'x', 'x', 'x', '11', '19', '16', 'x', 'x', 'x'], ['10', '5', '17', 'x', '2', 'x', 'x', '3', '10', '3', '12', 'x', '8', 'x'], ['x', '17', '12', 'x', 'x', 'x', '6', '2', '13', 'x', 'x', 'x', 'x', 'x'], ['x', '10', 'x', 'x', '15', 'x', 'x', 'x', '8', 'x', '3', 'x', 'x', '19'], ['1', '7', 'x', 'x', '16', 'x', 'x', 'x', '3', '15', '10', '12', '6', '8'], ['x', 'x', 'x', 'x', '9', 'x', 'x', 'x', '7', 'x', 'x', 'x', 'x', '8']]\", \"(9, 10)\", \"(2, 3)\", \"2\", \"8\"]"}
{"diff_sorted_id": "84", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 14x14. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (9, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (3, 13). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 0 1 1 1 1 0 1 0 1 0 1 1\n0 0 0 0 0 1 1 0 0 0 1 0 0 0\n1 0 0 1 0 0 1 1 0 1 1 0 1 1\n1 0 1 0 0 0 0 0 0 0 1 0 1 0\n0 0 1 1 0 0 0 1 0 0 0 0 0 0\n1 0 0 1 0 0 0 1 0 0 1 1 0 1\n0 0 0 0 0 0 1 0 0 1 0 1 1 1\n0 0 0 0 0 1 0 1 1 0 1 1 1 1\n1 0 0 1 1 0 1 0 1 1 0 0 0 0\n0 0 1 0 1 0 1 1 1 0 0 1 0 1\n1 0 0 1 1 1 1 0 1 1 0 0 0 0\n1 0 0 0 1 0 0 1 1 1 1 0 0 1\n1 1 1 1 1 0 0 1 1 0 0 0 1 1\n1 0 0 0 0 0 0 0 1 1 1 0 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[[9, 0], [8, 1], [7, 2], [6, 3], [5, 4], [5, 5], [5, 6], [4, 6], [3, 6], [3, 7], [3, 8], [3, 9], [4, 9], [4, 10], [4, 11], [4, 12], [4, 13], [3, 13]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.028172016143798828", "solution_depth": "18", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1], [1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1], [1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1], [1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1]]\", 4]", "is_correct_args": "[\"[[0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1], [1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1], [1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1], [1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1]]\", [9, 0], [3, 13], 4]", "A*_args": "[\"[[0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1], [1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1], [1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1], [1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1]]\", \"(9, 0)\", \"(3, 13)\", \"4\"]"}
{"diff_sorted_id": "84", "problem_statement": "Given 7 labeled water jugs with capacities 82, 91, 135, 11, 12, 19, 143, 60 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 231, 288, 342, 410 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 82, 4], [\"+\", 91, 4], [\"+\", 91, 4], [\"+\", 135, 4], [\"+\", 11, 4], [\"+\", 60, 3], [\"+\", 135, 3], [\"+\", 12, 3], [\"+\", 135, 3], [\"+\", 60, 2], [\"+\", 82, 2], [\"+\", 11, 2], [\"+\", 135, 2], [\"+\", 91, 1], [\"-\", 11, 1], [\"+\", 60, 1], [\"+\", 91, 1]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.05072736740112305", "solution_depth": "17", "max_successor_states": "64", "num_vars_per_state": "3", "is_feasible_args": "[[82, 91, 135, 11, 12, 19, 143, 60], [231, 288, 342, 410]]", "is_correct_args": "[[82, 91, 135, 11, 12, 19, 143, 60], [231, 288, 342, 410]]", "A*_args": "[\"[82, 91, 135, 11, 12, 19, 143, 60]\", \"[231, 288, 342, 410]\"]"}
{"diff_sorted_id": "85", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[93, 26, 39, 51, 69], [27, '_', 43, 7, 89], [63, 91, 23, 68, 17]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "8", "opt_solution": "[26, 39, 51, 7, 43, 23, 91, 26, 27, 63, 26, 91, 23, 27, 91, 23, 27, 51, 39, 91, 51, 43, 89, 17, 68, 27, 43, 89, 17, 68, 27, 17, 7, 39, 89, 43, 17, 7, 39, 69, 68, 27]", "opt_solution_cost": "42", "opt_solution_compute_t": "43.326194763183594", "solution_depth": "42", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[93, 26, 39, 51, 69], [27, \"_\", 43, 7, 89], [63, 91, 23, 68, 17]]]", "is_correct_args": "[[[93, 26, 39, 51, 69], [27, \"_\", 43, 7, 89], [63, 91, 23, 68, 17]]]", "A*_args": "[\"[[93, 26, 39, 51, 69], [27, '_', 43, 7, 89], [63, 91, 23, 68, 17]]\"]"}
{"diff_sorted_id": "85", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: snip, scoon, cuber, artie, penta   The initial board: [['c', 's', 'n', 'i', 'p'], ['s', 'o', 'o', 'r', 'n'], ['c', 'u', 'i', 'e', '_'], ['a', 'n', 't', 'b', 'e'], ['p', 'e', 'r', 't', 'a']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "22", "opt_solution_compute_t": "1.548938512802124", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"c\", \"s\", \"n\", \"i\", \"p\"], [\"s\", \"o\", \"o\", \"r\", \"n\"], [\"c\", \"u\", \"i\", \"e\", \"_\"], [\"a\", \"n\", \"t\", \"b\", \"e\"], [\"p\", \"e\", \"r\", \"t\", \"a\"]]]", "is_correct_args": "[[[\"c\", \"s\", \"n\", \"i\", \"p\"], [\"s\", \"o\", \"o\", \"r\", \"n\"], [\"c\", \"u\", \"i\", \"e\", \"_\"], [\"a\", \"n\", \"t\", \"b\", \"e\"], [\"p\", \"e\", \"r\", \"t\", \"a\"]], [\"snip\", \"scoon\", \"cuber\", \"artie\", \"penta\"]]", "A*_args": "[\"[['c', 's', 'n', 'i', 'p'], ['s', 'o', 'o', 'r', 'n'], ['c', 'u', 'i', 'e', '_'], ['a', 'n', 't', 'b', 'e'], ['p', 'e', 'r', 't', 'a']]\", \"['snip', 'scoon', 'cuber', 'artie', 'penta']\"]"}
{"diff_sorted_id": "85", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'Y'. Our task is to visit city H and city X excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from X and H, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  I P G S Y A D U E W V H Z X \nI 0 0 0 1 0 0 0 0 0 0 0 0 0 0 \nP 0 0 1 1 0 1 1 0 1 0 0 0 1 0 \nG 1 1 0 0 0 0 0 0 0 1 0 1 0 1 \nS 0 0 0 0 0 0 1 0 0 0 1 0 0 0 \nY 1 0 0 0 0 0 0 0 0 0 0 0 0 0 \nA 1 0 0 0 1 0 0 0 0 0 0 1 0 0 \nD 0 0 0 0 0 1 0 0 0 0 0 1 0 0 \nU 0 0 1 1 0 0 0 0 1 1 0 0 0 0 \nE 0 0 0 0 0 1 0 1 0 0 0 0 0 0 \nW 0 0 0 0 0 0 1 0 0 0 0 0 0 1 \nV 1 1 1 0 0 1 0 0 0 0 0 0 0 1 \nH 0 0 0 0 1 1 0 0 1 1 1 0 0 0 \nZ 1 0 0 0 0 1 0 1 1 0 0 0 0 0 \nX 1 1 1 0 0 0 0 0 1 1 0 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[\"Y\", \"I\", \"S\", \"D\", \"H\", \"V\", \"X\", \"W\", \"X\", \"G\", \"H\"]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.025726318359375", "solution_depth": "11", "max_successor_states": "14", "num_vars_per_state": "17", "is_feasible_args": "[[[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0]], [\"I\", \"P\", \"G\", \"S\", \"Y\", \"A\", \"D\", \"U\", \"E\", \"W\", \"V\", \"H\", \"Z\", \"X\"], \"H\", \"X\"]", "is_correct_args": "[[[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0]], [\"I\", \"P\", \"G\", \"S\", \"Y\", \"A\", \"D\", \"U\", \"E\", \"W\", \"V\", \"H\", \"Z\", \"X\"], \"Y\", \"H\", \"X\"]", "A*_args": "[\"[[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0], [1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0]]\", \"['I', 'P', 'G', 'S', 'Y', 'A', 'D', 'U', 'E', 'W', 'V', 'H', 'Z', 'X']\", \"['Y']\", \"['H', 'X']\"]"}
{"diff_sorted_id": "85", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [38, 36, 40, 31, 39, 29, 36, 31, 16, 14, 16, 45, 40, 45, 257, 8, 39, 16, 2, 41, 9, 26, 22, 24], such that the sum of the chosen coins adds up to 452. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {9: 6, 14: 9, 24: 8, 26: 12, 16: 6, 45: 14, 8: 3, 22: 8, 38: 9, 40: 14, 31: 9, 257: 11, 36: 2, 2: 1, 41: 6, 29: 6, 39: 4}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "15", "opt_solution": "[29, 39, 36, 39, 36, 257, 16]", "opt_solution_cost": "35", "opt_solution_compute_t": "0.03696179389953613", "solution_depth": "7", "max_successor_states": "24", "num_vars_per_state": "24", "is_feasible_args": "[[38, 36, 40, 31, 39, 29, 36, 31, 16, 14, 16, 45, 40, 45, 257, 8, 39, 16, 2, 41, 9, 26, 22, 24]]", "is_correct_args": "[[38, 36, 40, 31, 39, 29, 36, 31, 16, 14, 16, 45, 40, 45, 257, 8, 39, 16, 2, 41, 9, 26, 22, 24], {\"9\": 6, \"14\": 9, \"24\": 8, \"26\": 12, \"16\": 6, \"45\": 14, \"8\": 3, \"22\": 8, \"38\": 9, \"40\": 14, \"31\": 9, \"257\": 11, \"36\": 2, \"2\": 1, \"41\": 6, \"29\": 6, \"39\": 4}, 452]", "A*_args": "[\"[38, 36, 40, 31, 39, 29, 36, 31, 16, 14, 16, 45, 40, 45, 257, 8, 39, 16, 2, 41, 9, 26, 22, 24]\", \"{9: 6, 14: 9, 24: 8, 26: 12, 16: 6, 45: 14, 8: 3, 22: 8, 38: 9, 40: 14, 31: 9, 257: 11, 36: 2, 2: 1, 41: 6, 29: 6, 39: 4}\", \"452\"]"}
{"diff_sorted_id": "85", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Red', 'Red', 'Blue', 'Red'], ['Green', 'Blue', 'Green', 'Blue', 'Red', 'Green'], ['Blue', 'Red', 'Green', 'Green', 'Blue', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[1, 0], [1, 2], [1, 0], [1, 2], [1, 2], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [2, 1], [0, 2], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [1, 2], [1, 2], [1, 2], [1, 2], [1, 0], [1, 2], [0, 1], [0, 2], [0, 1], [0, 1], [0, 1], [2, 0], [2, 0], [1, 2]]", "opt_solution_cost": "36", "opt_solution_compute_t": "402.36865186691284", "solution_depth": "36", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Red\", \"Red\", \"Blue\", \"Red\"], [\"Green\", \"Blue\", \"Green\", \"Blue\", \"Red\", \"Green\"], [\"Blue\", \"Red\", \"Green\", \"Green\", \"Blue\", \"Red\"]], 9]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Red\", \"Red\", \"Blue\", \"Red\"], [\"Green\", \"Blue\", \"Green\", \"Blue\", \"Red\", \"Green\"], [\"Blue\", \"Red\", \"Green\", \"Green\", \"Blue\", \"Red\"]], 9]", "A*_args": "[\"[['Blue', 'Green', 'Red', 'Red', 'Blue', 'Red'], ['Green', 'Blue', 'Green', 'Blue', 'Red', 'Green'], ['Blue', 'Red', 'Green', 'Green', 'Blue', 'Red']]\", \"9\"]"}
{"diff_sorted_id": "85", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 17 to 67 (17 included in the range but 67 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['42' '56' '64' 'x']\n ['x' 'x' '55' 'x']\n ['30' 'x' 'x' 'x']\n ['24' 'x' '45' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "14", "opt_solution": "[[0, 1, 58], [0, 3, 39], [1, 2, 69], [2, 1, 70], [2, 3, 76], [3, 1, 74], [3, 3, 77]]", "opt_solution_cost": "778", "opt_solution_compute_t": "30.918853044509888", "solution_depth": "7", "max_successor_states": "50", "num_vars_per_state": "16", "is_feasible_args": "[\"[['71', '', '57', ''], ['67', '68', '', '73'], ['51', '', '72', ''], ['50', '', '75', '']]\", 39, 94]", "is_correct_args": "[\"[['71', '', '57', ''], ['67', '68', '', '73'], ['51', '', '72', ''], ['50', '', '75', '']]\", 39, 94]", "A*_args": "[\"[['71', '', '57', ''], ['67', '68', '', '73'], ['51', '', '72', ''], ['50', '', '75', '']]\", \"39\", \"94\"]"}
{"diff_sorted_id": "85", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 37 to 83. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 252, 238, None for columns 1 to 2 respectively, and the sums of rows must be None, 221, 257, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 221. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' '80' '72']\n ['44' 'x' '39' 'x']\n ['x' '70' '64' 'x']\n ['x' '67' 'x' '42']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 0, 37], [0, 1, 38], [1, 1, 77], [1, 3, 61], [2, 0, 41], [2, 3, 82], [3, 0, 40], [3, 2, 55]]", "opt_solution_cost": "909", "opt_solution_compute_t": "0.9668257236480713", "solution_depth": "8", "max_successor_states": "31", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '80', '72'], ['44', '', '39', ''], ['', '70', '64', ''], ['', '67', '', '42']]\", 4, 37, 83]", "is_correct_args": "[\"[['', '', '80', '72'], ['44', '', '39', ''], ['', '70', '64', ''], ['', '67', '', '42']]\", 37, 83, [1, 3], [1, 3], [252, 238], [221, 257], 221]", "A*_args": "[\"[['', '', '80', '72'], ['44', '', '39', ''], ['', '70', '64', ''], ['', '67', '', '42']]\", \"37\", \"83\", \"[None, 252, 238, None]\", \"[None, 221, 257, None]\", \"221\"]"}
{"diff_sorted_id": "85", "problem_statement": "In 'Restricted Sorting', there are 12 stacks each with a capacity of 7 blocks, with 6 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 6 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 8, 1: 5, 2: 4, 3: 12, 4: 9, 5: 9, 6: 3, 7: 2, 8: 11, 9: 9, 10: 3, 11: 2}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Pink', 'Red', 'Black', 'Green', 'Yellow', 'Yellow', 'Pink'], [], [], ['Pink', 'White', 'Yellow', 'Blue', 'Green', 'Blue', 'Black'], ['Black', 'Blue', 'Red', 'Pink', 'Yellow', 'Yellow', 'Blue'], [], ['White', 'Black', 'Yellow', 'Green', 'Red', 'Green', 'Green'], [], [], ['Pink', 'Red', 'Black', 'White', 'White', 'Red', 'White'], ['Blue', 'Green', 'Pink', 'Blue', 'White', 'Red', 'Black'], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "4", "opt_solution": "[[0, 7], [0, 11], [3, 7], [9, 7], [9, 11], [0, 2], [4, 2], [9, 2], [3, 1], [6, 1], [6, 2], [4, 5], [4, 11], [4, 7], [0, 8], [9, 1], [9, 1], [9, 11], [9, 1], [3, 9], [6, 9], [0, 9], [0, 9], [10, 5], [0, 7], [10, 0], [10, 7], [10, 5], [10, 1], [10, 11], [3, 5], [3, 0], [3, 5], [4, 9], [4, 9], [4, 5], [3, 2], [10, 2], [6, 10], [6, 11], [0, 6], [0, 6], [8, 6], [10, 6]]", "opt_solution_cost": "228", "opt_solution_compute_t": "6.149892091751099", "solution_depth": "44", "max_successor_states": "132", "num_vars_per_state": "42", "is_feasible_args": "[[[\"Pink\", \"Red\", \"Black\", \"Green\", \"Yellow\", \"Yellow\", \"Pink\"], [], [], [\"Pink\", \"White\", \"Yellow\", \"Blue\", \"Green\", \"Blue\", \"Black\"], [\"Black\", \"Blue\", \"Red\", \"Pink\", \"Yellow\", \"Yellow\", \"Blue\"], [], [\"White\", \"Black\", \"Yellow\", \"Green\", \"Red\", \"Green\", \"Green\"], [], [], [\"Pink\", \"Red\", \"Black\", \"White\", \"White\", \"Red\", \"White\"], [\"Blue\", \"Green\", \"Pink\", \"Blue\", \"White\", \"Red\", \"Black\"], []], 7, {\"0\": 8, \"1\": 5, \"2\": 4, \"3\": 12, \"4\": 9, \"5\": 9, \"6\": 3, \"7\": 2, \"8\": 11, \"9\": 9, \"10\": 3, \"11\": 2}]", "is_correct_args": "[[[\"Pink\", \"Red\", \"Black\", \"Green\", \"Yellow\", \"Yellow\", \"Pink\"], [], [], [\"Pink\", \"White\", \"Yellow\", \"Blue\", \"Green\", \"Blue\", \"Black\"], [\"Black\", \"Blue\", \"Red\", \"Pink\", \"Yellow\", \"Yellow\", \"Blue\"], [], [\"White\", \"Black\", \"Yellow\", \"Green\", \"Red\", \"Green\", \"Green\"], [], [], [\"Pink\", \"Red\", \"Black\", \"White\", \"White\", \"Red\", \"White\"], [\"Blue\", \"Green\", \"Pink\", \"Blue\", \"White\", \"Red\", \"Black\"], []], 7, {\"0\": 8, \"1\": 5, \"2\": 4, \"3\": 12, \"4\": 9, \"5\": 9, \"6\": 3, \"7\": 2, \"8\": 11, \"9\": 9, \"10\": 3, \"11\": 2}, 6]", "A*_args": "[\"[['Pink', 'Red', 'Black', 'Green', 'Yellow', 'Yellow', 'Pink'], [], [], ['Pink', 'White', 'Yellow', 'Blue', 'Green', 'Blue', 'Black'], ['Black', 'Blue', 'Red', 'Pink', 'Yellow', 'Yellow', 'Blue'], [], ['White', 'Black', 'Yellow', 'Green', 'Red', 'Green', 'Green'], [], [], ['Pink', 'Red', 'Black', 'White', 'White', 'Red', 'White'], ['Blue', 'Green', 'Pink', 'Blue', 'White', 'Red', 'Black'], []]\", \"{0: 8, 1: 5, 2: 4, 3: 12, 4: 9, 5: 9, 6: 3, 7: 2, 8: 11, 9: 9, 10: 3, 11: 2}\", \"7\", \"6\"]"}
{"diff_sorted_id": "85", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (10, 12) to his destination workshop at index (4, 3), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 4, district 2 covering rows 5 to 9, and district 3 covering rows 10 to 13. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[5 10 x x x 16 x x x 16 x 10 8 x]\n[1 x 13 x 7 x x x 10 3 3 13 18 11]\n[14 x x x 9 16 16 15 x x 15 x 4 4]\n[15 x 3 x x 17 x 16 10 9 x 6 16 17]\n[12 8 x 10 x x 13 10 x x 6 3 x 1]\n[x x x 5 8 9 6 14 1 x x 2 12 x]\n[13 x x x 16 6 x 17 12 18 x 17 8 x]\n[10 x 14 15 x x x 20 x 17 18 8 x 4]\n[x 11 3 x x x x 7 x 4 x x 11 2]\n[7 x x 10 x 19 x 7 17 x x 14 x 15]\n[12 11 x x 9 7 x 15 1 5 5 11 15 x]\n[x 9 9 x x x x 8 x 8 19 11 12 12]\n[x 17 5 x x 17 x x 12 x 15 12 10 x]\n[18 x x x 3 x 7 x 8 5 12 8 10 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "6", "opt_solution": "[[10, 12], [10, 11], [10, 10], [10, 9], [10, 8], [10, 7], [9, 7], [8, 7], [7, 7], [6, 7], [5, 7], [5, 6], [5, 5], [5, 4], [5, 3], [4, 3]]", "opt_solution_cost": "140", "opt_solution_compute_t": "0.026478052139282227", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"5\", \"10\", \"x\", \"x\", \"x\", \"16\", \"x\", \"x\", \"x\", \"16\", \"x\", \"10\", \"8\", \"x\"], [\"1\", \"x\", \"13\", \"x\", \"7\", \"x\", \"x\", \"x\", \"10\", \"3\", \"3\", \"13\", \"18\", \"11\"], [\"14\", \"x\", \"x\", \"x\", \"9\", \"16\", \"16\", \"15\", \"x\", \"x\", \"15\", \"x\", \"4\", \"4\"], [\"15\", \"x\", \"3\", \"x\", \"x\", \"17\", \"x\", \"16\", \"10\", \"9\", \"x\", \"6\", \"16\", \"17\"], [\"12\", \"8\", \"x\", \"10\", \"x\", \"x\", \"13\", \"10\", \"x\", \"x\", \"6\", \"3\", \"x\", \"1\"], [\"x\", \"x\", \"x\", \"5\", \"8\", \"9\", \"6\", \"14\", \"1\", \"x\", \"x\", \"2\", \"12\", \"x\"], [\"13\", \"x\", \"x\", \"x\", \"16\", \"6\", \"x\", \"17\", \"12\", \"18\", \"x\", \"17\", \"8\", \"x\"], [\"10\", \"x\", \"14\", \"15\", \"x\", \"x\", \"x\", \"20\", \"x\", \"17\", \"18\", \"8\", \"x\", \"4\"], [\"x\", \"11\", \"3\", \"x\", \"x\", \"x\", \"x\", \"7\", \"x\", \"4\", \"x\", \"x\", \"11\", \"2\"], [\"7\", \"x\", \"x\", \"10\", \"x\", \"19\", \"x\", \"7\", \"17\", \"x\", \"x\", \"14\", \"x\", \"15\"], [\"12\", \"11\", \"x\", \"x\", \"9\", \"7\", \"x\", \"15\", \"1\", \"5\", \"5\", \"11\", \"15\", \"x\"], [\"x\", \"9\", \"9\", \"x\", \"x\", \"x\", \"x\", \"8\", \"x\", \"8\", \"19\", \"11\", \"12\", \"12\"], [\"x\", \"17\", \"5\", \"x\", \"x\", \"17\", \"x\", \"x\", \"12\", \"x\", \"15\", \"12\", \"10\", \"x\"], [\"18\", \"x\", \"x\", \"x\", \"3\", \"x\", \"7\", \"x\", \"8\", \"5\", \"12\", \"8\", \"10\", \"x\"]]]", "is_correct_args": "[[[\"5\", \"10\", \"x\", \"x\", \"x\", \"16\", \"x\", \"x\", \"x\", \"16\", \"x\", \"10\", \"8\", \"x\"], [\"1\", \"x\", \"13\", \"x\", \"7\", \"x\", \"x\", \"x\", \"10\", \"3\", \"3\", \"13\", \"18\", \"11\"], [\"14\", \"x\", \"x\", \"x\", \"9\", \"16\", \"16\", \"15\", \"x\", \"x\", \"15\", \"x\", \"4\", \"4\"], [\"15\", \"x\", \"3\", \"x\", \"x\", \"17\", \"x\", \"16\", \"10\", \"9\", \"x\", \"6\", \"16\", \"17\"], [\"12\", \"8\", \"x\", \"10\", \"x\", \"x\", \"13\", \"10\", \"x\", \"x\", \"6\", \"3\", \"x\", \"1\"], [\"x\", \"x\", \"x\", \"5\", \"8\", \"9\", \"6\", \"14\", \"1\", \"x\", \"x\", \"2\", \"12\", \"x\"], [\"13\", \"x\", \"x\", \"x\", \"16\", \"6\", \"x\", \"17\", \"12\", \"18\", \"x\", \"17\", \"8\", \"x\"], [\"10\", \"x\", \"14\", \"15\", \"x\", \"x\", \"x\", \"20\", \"x\", \"17\", \"18\", \"8\", \"x\", \"4\"], [\"x\", \"11\", \"3\", \"x\", \"x\", \"x\", \"x\", \"7\", \"x\", \"4\", \"x\", \"x\", \"11\", \"2\"], [\"7\", \"x\", \"x\", \"10\", \"x\", \"19\", \"x\", \"7\", \"17\", \"x\", \"x\", \"14\", \"x\", \"15\"], [\"12\", \"11\", \"x\", \"x\", \"9\", \"7\", \"x\", \"15\", \"1\", \"5\", \"5\", \"11\", \"15\", \"x\"], [\"x\", \"9\", \"9\", \"x\", \"x\", \"x\", \"x\", \"8\", \"x\", \"8\", \"19\", \"11\", \"12\", \"12\"], [\"x\", \"17\", \"5\", \"x\", \"x\", \"17\", \"x\", \"x\", \"12\", \"x\", \"15\", \"12\", \"10\", \"x\"], [\"18\", \"x\", \"x\", \"x\", \"3\", \"x\", \"7\", \"x\", \"8\", \"5\", \"12\", \"8\", \"10\", \"x\"]], [10, 12], [4, 3], 4, 9]", "A*_args": "[\"[['5', '10', 'x', 'x', 'x', '16', 'x', 'x', 'x', '16', 'x', '10', '8', 'x'], ['1', 'x', '13', 'x', '7', 'x', 'x', 'x', '10', '3', '3', '13', '18', '11'], ['14', 'x', 'x', 'x', '9', '16', '16', '15', 'x', 'x', '15', 'x', '4', '4'], ['15', 'x', '3', 'x', 'x', '17', 'x', '16', '10', '9', 'x', '6', '16', '17'], ['12', '8', 'x', '10', 'x', 'x', '13', '10', 'x', 'x', '6', '3', 'x', '1'], ['x', 'x', 'x', '5', '8', '9', '6', '14', '1', 'x', 'x', '2', '12', 'x'], ['13', 'x', 'x', 'x', '16', '6', 'x', '17', '12', '18', 'x', '17', '8', 'x'], ['10', 'x', '14', '15', 'x', 'x', 'x', '20', 'x', '17', '18', '8', 'x', '4'], ['x', '11', '3', 'x', 'x', 'x', 'x', '7', 'x', '4', 'x', 'x', '11', '2'], ['7', 'x', 'x', '10', 'x', '19', 'x', '7', '17', 'x', 'x', '14', 'x', '15'], ['12', '11', 'x', 'x', '9', '7', 'x', '15', '1', '5', '5', '11', '15', 'x'], ['x', '9', '9', 'x', 'x', 'x', 'x', '8', 'x', '8', '19', '11', '12', '12'], ['x', '17', '5', 'x', 'x', '17', 'x', 'x', '12', 'x', '15', '12', '10', 'x'], ['18', 'x', 'x', 'x', '3', 'x', '7', 'x', '8', '5', '12', '8', '10', 'x']]\", \"(10, 12)\", \"(4, 3)\", \"4\", \"9\"]"}
{"diff_sorted_id": "85", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 14x14. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 3) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (12, 11). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 0 0 1 0 0 1 0 0 1 1 0 0\n0 0 0 0 0 1 0 0 0 0 1 0 1 1\n0 0 0 0 0 0 0 0 0 0 1 0 0 1\n0 0 0 0 1 0 0 0 1 1 0 1 0 1\n0 1 1 1 0 0 1 0 0 0 0 1 0 1\n1 0 0 1 0 0 0 0 1 0 0 1 1 0\n1 0 0 1 1 1 0 1 0 0 0 1 1 0\n1 1 0 1 1 0 1 1 1 1 0 1 1 0\n1 1 0 0 0 1 1 1 0 0 0 1 1 0\n0 0 1 1 0 1 1 1 0 0 0 0 0 1\n1 1 1 1 1 1 1 1 0 1 0 0 1 1\n1 1 0 0 1 1 0 0 1 1 1 0 1 0\n0 1 0 0 0 1 1 0 1 0 1 0 0 1\n1 1 0 1 0 0 0 1 1 1 1 0 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[[1, 3], [2, 3], [3, 3], [4, 4], [5, 4], [5, 5], [5, 6], [5, 7], [6, 8], [6, 9], [7, 10], [8, 10], [9, 10], [10, 10], [11, 11], [12, 11]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.030063152313232422", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1], [0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0], [1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0], [1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0], [0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0], [0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1]]\", 4]", "is_correct_args": "[\"[[0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1], [0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0], [1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0], [1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0], [0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0], [0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1]]\", [1, 3], [12, 11], 4]", "A*_args": "[\"[[0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1], [0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0], [1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0], [1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0], [1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0], [0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1], [1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0], [0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1]]\", \"(1, 3)\", \"(12, 11)\", \"4\"]"}
{"diff_sorted_id": "85", "problem_statement": "Given 7 labeled water jugs with capacities 67, 98, 66, 59, 37, 61, 128, 92 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 308, 309, 387, 433 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 59, 4], [\"+\", 128, 4], [\"+\", 128, 4], [\"+\", 59, 4], [\"+\", 59, 4], [\"+\", 98, 3], [\"+\", 128, 3], [\"+\", 128, 3], [\"-\", 59, 3], [\"+\", 92, 3], [\"+\", 59, 2], [\"+\", 92, 2], [\"+\", 92, 2], [\"+\", 66, 2], [\"+\", 59, 1], [\"+\", 92, 1], [\"+\", 98, 1], [\"+\", 59, 1]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.08887290954589844", "solution_depth": "18", "max_successor_states": "64", "num_vars_per_state": "3", "is_feasible_args": "[[67, 98, 66, 59, 37, 61, 128, 92], [308, 309, 387, 433]]", "is_correct_args": "[[67, 98, 66, 59, 37, 61, 128, 92], [308, 309, 387, 433]]", "A*_args": "[\"[67, 98, 66, 59, 37, 61, 128, 92]\", \"[308, 309, 387, 433]\"]"}
{"diff_sorted_id": "86", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[88, 71, 83, 72, 37], [98, 43, 53, '_', 82], [24, 20, 54, 14, 21]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "8", "opt_solution": "[82, 21, 14, 82, 21, 37, 72, 83, 53, 43, 20, 54, 43, 21, 82, 43, 21, 20, 71, 88, 98, 71, 54, 21, 20, 53, 83, 82, 43, 14]", "opt_solution_cost": "30", "opt_solution_compute_t": "1.5921499729156494", "solution_depth": "30", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[88, 71, 83, 72, 37], [98, 43, 53, \"_\", 82], [24, 20, 54, 14, 21]]]", "is_correct_args": "[[[88, 71, 83, 72, 37], [98, 43, 53, \"_\", 82], [24, 20, 54, 14, 21]]]", "A*_args": "[\"[[88, 71, 83, 72, 37], [98, 43, 53, '_', 82], [24, 20, 54, 14, 21]]\"]"}
{"diff_sorted_id": "86", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: card, sylva, shune, solum, bichy   The initial board: [['y', 'c', 'a', 'r', 'd'], ['s', 'u', 'l', 'c', 'a'], ['v', 'h', '_', 'n', 'o'], ['s', 'e', 'l', 's', 'm'], ['b', 'i', 'u', 'h', 'y']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.686600923538208", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"y\", \"c\", \"a\", \"r\", \"d\"], [\"s\", \"u\", \"l\", \"c\", \"a\"], [\"v\", \"h\", \"_\", \"n\", \"o\"], [\"s\", \"e\", \"l\", \"s\", \"m\"], [\"b\", \"i\", \"u\", \"h\", \"y\"]]]", "is_correct_args": "[[[\"y\", \"c\", \"a\", \"r\", \"d\"], [\"s\", \"u\", \"l\", \"c\", \"a\"], [\"v\", \"h\", \"_\", \"n\", \"o\"], [\"s\", \"e\", \"l\", \"s\", \"m\"], [\"b\", \"i\", \"u\", \"h\", \"y\"]], [\"card\", \"sylva\", \"shune\", \"solum\", \"bichy\"]]", "A*_args": "[\"[['y', 'c', 'a', 'r', 'd'], ['s', 'u', 'l', 'c', 'a'], ['v', 'h', '_', 'n', 'o'], ['s', 'e', 'l', 's', 'm'], ['b', 'i', 'u', 'h', 'y']]\", \"['card', 'sylva', 'shune', 'solum', 'bichy']\"]"}
{"diff_sorted_id": "86", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'G'. Our task is to visit city P and city Y excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from Y and P, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  P U Q G E K M J N T Y R Z X O \nP 0 0 0 0 0 0 0 1 1 1 0 1 0 1 0 \nU 1 0 0 0 1 0 0 1 0 0 1 1 0 1 0 \nQ 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \nG 0 0 0 0 0 1 0 0 0 0 0 0 1 0 1 \nE 0 0 1 1 0 0 0 0 0 0 0 0 0 0 1 \nK 0 1 1 0 0 0 0 0 0 0 0 0 1 0 0 \nM 0 0 1 0 0 1 0 1 0 0 0 0 1 0 1 \nJ 0 0 1 0 1 0 0 0 0 0 0 1 0 0 0 \nN 0 1 0 1 0 1 0 0 0 0 1 0 1 0 0 \nT 0 0 0 1 0 1 0 0 0 0 1 0 1 0 0 \nY 0 0 0 1 1 0 1 0 0 0 0 0 1 0 0 \nR 0 0 1 0 0 0 0 0 1 1 0 0 0 0 1 \nZ 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 \nX 1 0 0 1 1 0 0 1 0 0 1 1 1 0 0 \nO 1 0 0 0 0 0 0 0 1 1 0 0 1 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[\"G\", \"O\", \"P\", \"N\", \"Y\", \"Z\", \"P\", \"T\", \"Y\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.05178332328796387", "solution_depth": "9", "max_successor_states": "15", "num_vars_per_state": "18", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0], [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0]], [\"P\", \"U\", \"Q\", \"G\", \"E\", \"K\", \"M\", \"J\", \"N\", \"T\", \"Y\", \"R\", \"Z\", \"X\", \"O\"], \"P\", \"Y\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0], [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0]], [\"P\", \"U\", \"Q\", \"G\", \"E\", \"K\", \"M\", \"J\", \"N\", \"T\", \"Y\", \"R\", \"Z\", \"X\", \"O\"], \"G\", \"P\", \"Y\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0], [1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0]]\", \"['P', 'U', 'Q', 'G', 'E', 'K', 'M', 'J', 'N', 'T', 'Y', 'R', 'Z', 'X', 'O']\", \"['G']\", \"['P', 'Y']\"]"}
{"diff_sorted_id": "86", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [31, 8, 22, 27, 2, 25, 2, 8, 49, 26, 65, 6, 37, 49, 15, 21, 27, 5, 34, 28, 47, 15, 7, 42, 32, 20, 34, 48, 39, 7, 13], such that the sum of the chosen coins adds up to 490. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {7: 1, 65: 16, 21: 18, 25: 18, 15: 14, 31: 15, 6: 2, 37: 2, 5: 1, 22: 1, 8: 7, 26: 2, 2: 1, 32: 8, 27: 2, 13: 8, 39: 17, 28: 11, 47: 6, 42: 10, 34: 15, 20: 8, 48: 11, 49: 13}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "16", "opt_solution": "[7, 7, 27, 37, 22, 27, 2, 5, 47, 42, 26, 2, 65, 48, 49, 49, 28]", "opt_solution_cost": "94", "opt_solution_compute_t": "0.05118918418884277", "solution_depth": "17", "max_successor_states": "31", "num_vars_per_state": "31", "is_feasible_args": "[[31, 8, 22, 27, 2, 25, 2, 8, 49, 26, 65, 6, 37, 49, 15, 21, 27, 5, 34, 28, 47, 15, 7, 42, 32, 20, 34, 48, 39, 7, 13]]", "is_correct_args": "[[31, 8, 22, 27, 2, 25, 2, 8, 49, 26, 65, 6, 37, 49, 15, 21, 27, 5, 34, 28, 47, 15, 7, 42, 32, 20, 34, 48, 39, 7, 13], {\"7\": 1, \"65\": 16, \"21\": 18, \"25\": 18, \"15\": 14, \"31\": 15, \"6\": 2, \"37\": 2, \"5\": 1, \"22\": 1, \"8\": 7, \"26\": 2, \"2\": 1, \"32\": 8, \"27\": 2, \"13\": 8, \"39\": 17, \"28\": 11, \"47\": 6, \"42\": 10, \"34\": 15, \"20\": 8, \"48\": 11, \"49\": 13}, 490]", "A*_args": "[\"[31, 8, 22, 27, 2, 25, 2, 8, 49, 26, 65, 6, 37, 49, 15, 21, 27, 5, 34, 28, 47, 15, 7, 42, 32, 20, 34, 48, 39, 7, 13]\", \"{7: 1, 65: 16, 21: 18, 25: 18, 15: 14, 31: 15, 6: 2, 37: 2, 5: 1, 22: 1, 8: 7, 26: 2, 2: 1, 32: 8, 27: 2, 13: 8, 39: 17, 28: 11, 47: 6, 42: 10, 34: 15, 20: 8, 48: 11, 49: 13}\", \"490\"]"}
{"diff_sorted_id": "86", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Red', 'Blue', 'Red', 'Blue', 'Green'], ['Green', 'Red', 'Green', 'Green', 'Blue', 'Blue'], ['Red', 'Green', 'Blue', 'Red', 'Blue', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[0, 1], [0, 1], [0, 2], [0, 1], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [2, 0], [2, 1], [2, 1], [2, 1], [2, 0], [2, 1], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [0, 1], [0, 2], [1, 0], [1, 2], [1, 0], [1, 2], [1, 0], [2, 1], [2, 1]]", "opt_solution_cost": "34", "opt_solution_compute_t": "154.73638343811035", "solution_depth": "34", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Red\", \"Red\", \"Blue\", \"Red\", \"Blue\", \"Green\"], [\"Green\", \"Red\", \"Green\", \"Green\", \"Blue\", \"Blue\"], [\"Red\", \"Green\", \"Blue\", \"Red\", \"Blue\", \"Green\"]], 9]", "is_correct_args": "[[[\"Red\", \"Red\", \"Blue\", \"Red\", \"Blue\", \"Green\"], [\"Green\", \"Red\", \"Green\", \"Green\", \"Blue\", \"Blue\"], [\"Red\", \"Green\", \"Blue\", \"Red\", \"Blue\", \"Green\"]], 9]", "A*_args": "[\"[['Red', 'Red', 'Blue', 'Red', 'Blue', 'Green'], ['Green', 'Red', 'Green', 'Green', 'Blue', 'Blue'], ['Red', 'Green', 'Blue', 'Red', 'Blue', 'Green']]\", \"9\"]"}
{"diff_sorted_id": "86", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 6 to 56 (6 included in the range but 56 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' 'x' '54']\n ['x' 'x' '44' '53']\n ['x' '17' 'x' 'x']\n ['18' '22' '36' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "14", "opt_solution": "[[0, 2, 29], [0, 3, 28], [1, 0, 43], [1, 3, 55], [2, 1, 44], [3, 0, 30], [3, 1, 31]]", "opt_solution_cost": "686", "opt_solution_compute_t": "0.6507663726806641", "solution_depth": "7", "max_successor_states": "50", "num_vars_per_state": "16", "is_feasible_args": "[\"[['81', '52', '', ''], ['', '50', '53', ''], ['42', '', '54', '74'], ['', '', '56', '77']]\", 28, 83]", "is_correct_args": "[\"[['81', '52', '', ''], ['', '50', '53', ''], ['42', '', '54', '74'], ['', '', '56', '77']]\", 28, 83]", "A*_args": "[\"[['81', '52', '', ''], ['', '50', '53', ''], ['42', '', '54', '74'], ['', '', '56', '77']]\", \"28\", \"83\"]"}
{"diff_sorted_id": "86", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 37 to 83. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 214, 240, None for columns 1 to 2 respectively, and the sums of rows must be None, 213, 197, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 215. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '48' '64' '67']\n ['x' '50' '61' 'x']\n ['42' 'x' 'x' '74']\n ['x' 'x' '72' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 0, 37], [1, 0, 40], [1, 3, 62], [2, 1, 38], [2, 2, 43], [3, 0, 49], [3, 1, 78], [3, 3, 39]]", "opt_solution_cost": "864", "opt_solution_compute_t": "4.137092590332031", "solution_depth": "8", "max_successor_states": "31", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '48', '64', '67'], ['', '50', '61', ''], ['42', '', '', '74'], ['', '', '72', '']]\", 4, 37, 83]", "is_correct_args": "[\"[['', '48', '64', '67'], ['', '50', '61', ''], ['42', '', '', '74'], ['', '', '72', '']]\", 37, 83, [1, 3], [1, 3], [214, 240], [213, 197], 215]", "A*_args": "[\"[['', '48', '64', '67'], ['', '50', '61', ''], ['42', '', '', '74'], ['', '', '72', '']]\", \"37\", \"83\", \"[None, 214, 240, None]\", \"[None, 213, 197, None]\", \"215\"]"}
{"diff_sorted_id": "86", "problem_statement": "In 'Restricted Sorting', there are 12 stacks each with a capacity of 7 blocks, with 6 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 6 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 10, 1: 7, 2: 7, 3: 7, 4: 9, 5: 3, 6: 8, 7: 5, 8: 4, 9: 10, 10: 7, 11: 7}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Black', 'Black', 'Yellow', 'Blue', 'Black', 'Black', 'Green'], [], ['Blue', 'Yellow', 'Green', 'Black', 'White', 'White', 'Blue'], ['Red', 'White', 'Pink', 'White', 'Pink', 'Green', 'Pink'], ['Green', 'Blue', 'Black', 'Green', 'Red', 'Green', 'Yellow'], [], [], ['Red', 'White', 'Blue', 'Yellow', 'Blue', 'White', 'Red'], ['Yellow', 'Yellow', 'Red', 'Pink', 'Red', 'Pink', 'Pink'], [], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "4", "opt_solution": "[[3, 5], [7, 5], [2, 1], [2, 10], [2, 11], [8, 10], [8, 10], [8, 5], [3, 6], [7, 6], [2, 9], [4, 11], [4, 1], [4, 9], [4, 11], [4, 5], [4, 11], [7, 1], [7, 10], [7, 1], [7, 6], [7, 5], [8, 7], [8, 5], [3, 8], [3, 6], [7, 8], [0, 7], [0, 7], [0, 10], [0, 1], [0, 7], [0, 7], [3, 8], [3, 11], [2, 6], [2, 6], [0, 11], [2, 1], [4, 10], [9, 7], [9, 7], [3, 8]]", "opt_solution_cost": "263", "opt_solution_compute_t": "3.3329944610595703", "solution_depth": "43", "max_successor_states": "132", "num_vars_per_state": "42", "is_feasible_args": "[[[\"Black\", \"Black\", \"Yellow\", \"Blue\", \"Black\", \"Black\", \"Green\"], [], [\"Blue\", \"Yellow\", \"Green\", \"Black\", \"White\", \"White\", \"Blue\"], [\"Red\", \"White\", \"Pink\", \"White\", \"Pink\", \"Green\", \"Pink\"], [\"Green\", \"Blue\", \"Black\", \"Green\", \"Red\", \"Green\", \"Yellow\"], [], [], [\"Red\", \"White\", \"Blue\", \"Yellow\", \"Blue\", \"White\", \"Red\"], [\"Yellow\", \"Yellow\", \"Red\", \"Pink\", \"Red\", \"Pink\", \"Pink\"], [], [], []], 7, {\"0\": 10, \"1\": 7, \"2\": 7, \"3\": 7, \"4\": 9, \"5\": 3, \"6\": 8, \"7\": 5, \"8\": 4, \"9\": 10, \"10\": 7, \"11\": 7}]", "is_correct_args": "[[[\"Black\", \"Black\", \"Yellow\", \"Blue\", \"Black\", \"Black\", \"Green\"], [], [\"Blue\", \"Yellow\", \"Green\", \"Black\", \"White\", \"White\", \"Blue\"], [\"Red\", \"White\", \"Pink\", \"White\", \"Pink\", \"Green\", \"Pink\"], [\"Green\", \"Blue\", \"Black\", \"Green\", \"Red\", \"Green\", \"Yellow\"], [], [], [\"Red\", \"White\", \"Blue\", \"Yellow\", \"Blue\", \"White\", \"Red\"], [\"Yellow\", \"Yellow\", \"Red\", \"Pink\", \"Red\", \"Pink\", \"Pink\"], [], [], []], 7, {\"0\": 10, \"1\": 7, \"2\": 7, \"3\": 7, \"4\": 9, \"5\": 3, \"6\": 8, \"7\": 5, \"8\": 4, \"9\": 10, \"10\": 7, \"11\": 7}, 6]", "A*_args": "[\"[['Black', 'Black', 'Yellow', 'Blue', 'Black', 'Black', 'Green'], [], ['Blue', 'Yellow', 'Green', 'Black', 'White', 'White', 'Blue'], ['Red', 'White', 'Pink', 'White', 'Pink', 'Green', 'Pink'], ['Green', 'Blue', 'Black', 'Green', 'Red', 'Green', 'Yellow'], [], [], ['Red', 'White', 'Blue', 'Yellow', 'Blue', 'White', 'Red'], ['Yellow', 'Yellow', 'Red', 'Pink', 'Red', 'Pink', 'Pink'], [], [], []]\", \"{0: 10, 1: 7, 2: 7, 3: 7, 4: 9, 5: 3, 6: 8, 7: 5, 8: 4, 9: 10, 10: 7, 11: 7}\", \"7\", \"6\"]"}
{"diff_sorted_id": "86", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 0) to his destination workshop at index (5, 12), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 6, and district 3 covering rows 7 to 13. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x 11 16 x x x x 4 x 14 5 x x]\n[3 1 13 x x 14 11 x x 15 12 15 x x]\n[17 15 17 10 11 x 7 1 1 14 x 9 x x]\n[8 x x 13 2 12 x 8 x x 9 13 19 5]\n[4 x 2 3 8 x x 17 x x 16 10 x x]\n[x x x x 3 13 14 16 18 11 4 19 20 x]\n[x 11 x x 3 10 8 9 18 7 1 14 x 6]\n[11 x 12 11 x 11 10 3 10 12 15 x 11 x]\n[x x 4 18 x x 13 x 14 10 x 8 x 17]\n[x x x x x x x 7 7 x x 18 19 18]\n[19 4 x 2 14 2 x 9 x 10 7 17 4 12]\n[13 2 x x 18 5 x 11 x x x 18 x x]\n[x x 13 1 13 x 2 x x x x x x 14]\n[x 12 x x x x x x x 19 x x 9 1]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "6", "opt_solution": "[[3, 0], [2, 0], [2, 1], [2, 2], [2, 3], [2, 4], [3, 4], [4, 4], [5, 4], [6, 4], [6, 5], [6, 6], [6, 7], [7, 7], [7, 8], [7, 9], [6, 9], [6, 10], [5, 10], [5, 11], [5, 12]]", "opt_solution_cost": "189", "opt_solution_compute_t": "0.02854442596435547", "solution_depth": "21", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"11\", \"16\", \"x\", \"x\", \"x\", \"x\", \"4\", \"x\", \"14\", \"5\", \"x\", \"x\"], [\"3\", \"1\", \"13\", \"x\", \"x\", \"14\", \"11\", \"x\", \"x\", \"15\", \"12\", \"15\", \"x\", \"x\"], [\"17\", \"15\", \"17\", \"10\", \"11\", \"x\", \"7\", \"1\", \"1\", \"14\", \"x\", \"9\", \"x\", \"x\"], [\"8\", \"x\", \"x\", \"13\", \"2\", \"12\", \"x\", \"8\", \"x\", \"x\", \"9\", \"13\", \"19\", \"5\"], [\"4\", \"x\", \"2\", \"3\", \"8\", \"x\", \"x\", \"17\", \"x\", \"x\", \"16\", \"10\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"3\", \"13\", \"14\", \"16\", \"18\", \"11\", \"4\", \"19\", \"20\", \"x\"], [\"x\", \"11\", \"x\", \"x\", \"3\", \"10\", \"8\", \"9\", \"18\", \"7\", \"1\", \"14\", \"x\", \"6\"], [\"11\", \"x\", \"12\", \"11\", \"x\", \"11\", \"10\", \"3\", \"10\", \"12\", \"15\", \"x\", \"11\", \"x\"], [\"x\", \"x\", \"4\", \"18\", \"x\", \"x\", \"13\", \"x\", \"14\", \"10\", \"x\", \"8\", \"x\", \"17\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"7\", \"7\", \"x\", \"x\", \"18\", \"19\", \"18\"], [\"19\", \"4\", \"x\", \"2\", \"14\", \"2\", \"x\", \"9\", \"x\", \"10\", \"7\", \"17\", \"4\", \"12\"], [\"13\", \"2\", \"x\", \"x\", \"18\", \"5\", \"x\", \"11\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\"], [\"x\", \"x\", \"13\", \"1\", \"13\", \"x\", \"2\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"14\"], [\"x\", \"12\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"19\", \"x\", \"x\", \"9\", \"1\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"11\", \"16\", \"x\", \"x\", \"x\", \"x\", \"4\", \"x\", \"14\", \"5\", \"x\", \"x\"], [\"3\", \"1\", \"13\", \"x\", \"x\", \"14\", \"11\", \"x\", \"x\", \"15\", \"12\", \"15\", \"x\", \"x\"], [\"17\", \"15\", \"17\", \"10\", \"11\", \"x\", \"7\", \"1\", \"1\", \"14\", \"x\", \"9\", \"x\", \"x\"], [\"8\", \"x\", \"x\", \"13\", \"2\", \"12\", \"x\", \"8\", \"x\", \"x\", \"9\", \"13\", \"19\", \"5\"], [\"4\", \"x\", \"2\", \"3\", \"8\", \"x\", \"x\", \"17\", \"x\", \"x\", \"16\", \"10\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"3\", \"13\", \"14\", \"16\", \"18\", \"11\", \"4\", \"19\", \"20\", \"x\"], [\"x\", \"11\", \"x\", \"x\", \"3\", \"10\", \"8\", \"9\", \"18\", \"7\", \"1\", \"14\", \"x\", \"6\"], [\"11\", \"x\", \"12\", \"11\", \"x\", \"11\", \"10\", \"3\", \"10\", \"12\", \"15\", \"x\", \"11\", \"x\"], [\"x\", \"x\", \"4\", \"18\", \"x\", \"x\", \"13\", \"x\", \"14\", \"10\", \"x\", \"8\", \"x\", \"17\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"7\", \"7\", \"x\", \"x\", \"18\", \"19\", \"18\"], [\"19\", \"4\", \"x\", \"2\", \"14\", \"2\", \"x\", \"9\", \"x\", \"10\", \"7\", \"17\", \"4\", \"12\"], [\"13\", \"2\", \"x\", \"x\", \"18\", \"5\", \"x\", \"11\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\"], [\"x\", \"x\", \"13\", \"1\", \"13\", \"x\", \"2\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"14\"], [\"x\", \"12\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"19\", \"x\", \"x\", \"9\", \"1\"]], [3, 0], [5, 12], 3, 6]", "A*_args": "[\"[['x', 'x', '11', '16', 'x', 'x', 'x', 'x', '4', 'x', '14', '5', 'x', 'x'], ['3', '1', '13', 'x', 'x', '14', '11', 'x', 'x', '15', '12', '15', 'x', 'x'], ['17', '15', '17', '10', '11', 'x', '7', '1', '1', '14', 'x', '9', 'x', 'x'], ['8', 'x', 'x', '13', '2', '12', 'x', '8', 'x', 'x', '9', '13', '19', '5'], ['4', 'x', '2', '3', '8', 'x', 'x', '17', 'x', 'x', '16', '10', 'x', 'x'], ['x', 'x', 'x', 'x', '3', '13', '14', '16', '18', '11', '4', '19', '20', 'x'], ['x', '11', 'x', 'x', '3', '10', '8', '9', '18', '7', '1', '14', 'x', '6'], ['11', 'x', '12', '11', 'x', '11', '10', '3', '10', '12', '15', 'x', '11', 'x'], ['x', 'x', '4', '18', 'x', 'x', '13', 'x', '14', '10', 'x', '8', 'x', '17'], ['x', 'x', 'x', 'x', 'x', 'x', 'x', '7', '7', 'x', 'x', '18', '19', '18'], ['19', '4', 'x', '2', '14', '2', 'x', '9', 'x', '10', '7', '17', '4', '12'], ['13', '2', 'x', 'x', '18', '5', 'x', '11', 'x', 'x', 'x', '18', 'x', 'x'], ['x', 'x', '13', '1', '13', 'x', '2', 'x', 'x', 'x', 'x', 'x', 'x', '14'], ['x', '12', 'x', 'x', 'x', 'x', 'x', 'x', 'x', '19', 'x', 'x', '9', '1']]\", \"(3, 0)\", \"(5, 12)\", \"3\", \"6\"]"}
{"diff_sorted_id": "86", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 14x14. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 4) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (13, 12). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 1 1 0 0 0 0 0 0 1 1 0 1\n0 1 1 0 1 1 1 0 0 0 1 0 0 1\n0 0 1 1 0 1 1 0 1 0 0 0 1 1\n1 1 0 1 1 1 1 0 0 0 1 0 0 1\n1 0 1 0 1 1 1 0 0 1 1 0 0 1\n1 1 1 1 0 1 0 1 0 0 0 1 0 0\n0 1 1 1 1 1 1 0 0 1 1 1 0 0\n1 0 1 1 0 1 1 0 1 0 0 1 1 0\n1 1 0 1 0 0 1 1 1 1 0 1 0 0\n1 0 1 0 1 1 0 0 1 0 1 1 0 0\n1 0 0 0 1 1 1 1 1 1 1 0 0 0\n1 0 0 1 1 1 0 0 1 1 1 0 0 0\n1 1 0 0 0 0 1 1 1 0 1 1 0 0\n0 1 0 0 1 1 1 1 0 1 0 0 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[[0, 4], [0, 5], [0, 6], [0, 7], [1, 7], [1, 8], [1, 9], [2, 9], [2, 10], [3, 11], [4, 11], [5, 12], [6, 12], [7, 13], [8, 13], [9, 13], [10, 13], [11, 13], [12, 13], [13, 12]]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.022798776626586914", "solution_depth": "20", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1], [0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1], [0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1], [1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1], [1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0], [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0], [1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0], [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0], [0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0]]\", 4]", "is_correct_args": "[\"[[0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1], [0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1], [0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1], [1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1], [1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0], [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0], [1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0], [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0], [0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0]]\", [0, 4], [13, 12], 4]", "A*_args": "[\"[[0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1], [0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1], [0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1], [1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1], [1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0], [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0], [1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0], [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0], [0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0]]\", \"(0, 4)\", \"(13, 12)\", \"4\"]"}
{"diff_sorted_id": "86", "problem_statement": "Given 7 labeled water jugs with capacities 87, 13, 27, 106, 18, 91, 17, 138 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 205, 365, 391, 414 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 138, 4], [\"+\", 138, 4], [\"+\", 138, 4], [\"+\", 106, 3], [\"+\", 138, 3], [\"+\", 138, 3], [\"-\", 18, 3], [\"+\", 27, 3], [\"+\", 138, 2], [\"+\", 138, 2], [\"-\", 17, 2], [\"+\", 106, 2], [\"+\", 87, 1], [\"+\", 91, 1], [\"+\", 27, 1]]", "opt_solution_cost": "15", "opt_solution_compute_t": "0.04750704765319824", "solution_depth": "15", "max_successor_states": "64", "num_vars_per_state": "3", "is_feasible_args": "[[87, 13, 27, 106, 18, 91, 17, 138], [205, 365, 391, 414]]", "is_correct_args": "[[87, 13, 27, 106, 18, 91, 17, 138], [205, 365, 391, 414]]", "A*_args": "[\"[87, 13, 27, 106, 18, 91, 17, 138]\", \"[205, 365, 391, 414]\"]"}
{"diff_sorted_id": "87", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [['_', 94, 43, 58, 77], [96, 100, 75, 84, 52], [50, 29, 60, 27, 74]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "8", "opt_solution": "[96, 100, 75, 43, 58, 84, 27, 74, 52, 77, 84, 58, 94, 96, 100, 75, 43, 60, 74, 27, 60, 74, 29, 43, 74, 60, 58, 84, 77, 52]", "opt_solution_cost": "30", "opt_solution_compute_t": "0.9509561061859131", "solution_depth": "30", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[\"_\", 94, 43, 58, 77], [96, 100, 75, 84, 52], [50, 29, 60, 27, 74]]]", "is_correct_args": "[[[\"_\", 94, 43, 58, 77], [96, 100, 75, 84, 52], [50, 29, 60, 27, 74]]]", "A*_args": "[\"[['_', 94, 43, 58, 77], [96, 100, 75, 84, 52], [50, 29, 60, 27, 74]]\"]"}
{"diff_sorted_id": "87", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: echo, metin, perch, tulip, mulga   The initial board: [['e', 'e', 'l', 'h', 'o'], ['m', 'r', 't', 'u', 'n'], ['p', 'e', '_', 'c', 'i'], ['t', 'c', 'l', 'h', 'p'], ['m', 'u', 'i', 'g', 'a']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-left\", \"up-left\"]", "opt_solution_cost": "26", "opt_solution_compute_t": "3.2265894412994385", "solution_depth": "26", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"e\", \"e\", \"l\", \"h\", \"o\"], [\"m\", \"r\", \"t\", \"u\", \"n\"], [\"p\", \"e\", \"_\", \"c\", \"i\"], [\"t\", \"c\", \"l\", \"h\", \"p\"], [\"m\", \"u\", \"i\", \"g\", \"a\"]]]", "is_correct_args": "[[[\"e\", \"e\", \"l\", \"h\", \"o\"], [\"m\", \"r\", \"t\", \"u\", \"n\"], [\"p\", \"e\", \"_\", \"c\", \"i\"], [\"t\", \"c\", \"l\", \"h\", \"p\"], [\"m\", \"u\", \"i\", \"g\", \"a\"]], [\"echo\", \"metin\", \"perch\", \"tulip\", \"mulga\"]]", "A*_args": "[\"[['e', 'e', 'l', 'h', 'o'], ['m', 'r', 't', 'u', 'n'], ['p', 'e', '_', 'c', 'i'], ['t', 'c', 'l', 'h', 'p'], ['m', 'u', 'i', 'g', 'a']]\", \"['echo', 'metin', 'perch', 'tulip', 'mulga']\"]"}
{"diff_sorted_id": "87", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'E'. Our task is to visit city A and city P excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from P and A, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  A P Z O R I L X E T W D S G Q \nA 0 0 1 1 0 0 0 0 1 1 0 0 0 1 0 \nP 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 \nZ 0 0 0 0 0 0 1 1 0 0 0 1 0 0 0 \nO 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0 \nR 0 1 1 0 0 0 0 1 0 1 1 0 0 0 0 \nI 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 \nL 1 1 0 1 1 0 0 0 0 0 0 0 1 0 0 \nX 0 0 0 0 0 0 0 0 1 0 0 0 1 0 0 \nE 0 0 0 1 0 0 1 0 0 0 0 0 0 1 0 \nT 0 0 0 0 0 1 1 0 1 0 0 0 0 0 0 \nW 0 0 1 0 0 0 1 0 1 0 0 1 0 0 1 \nD 1 0 0 1 0 1 1 0 0 1 0 0 0 0 1 \nS 1 1 1 0 0 1 0 0 1 0 0 1 0 0 0 \nG 0 1 0 0 0 0 0 1 1 0 1 0 0 0 0 \nQ 1 0 1 1 0 0 0 1 0 1 0 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[\"E\", \"L\", \"P\", \"A\", \"G\", \"P\", \"A\"]", "opt_solution_cost": "7", "opt_solution_compute_t": "0.03984355926513672", "solution_depth": "7", "max_successor_states": "15", "num_vars_per_state": "18", "is_feasible_args": "[[[0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0]], [\"A\", \"P\", \"Z\", \"O\", \"R\", \"I\", \"L\", \"X\", \"E\", \"T\", \"W\", \"D\", \"S\", \"G\", \"Q\"], \"A\", \"P\"]", "is_correct_args": "[[[0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0]], [\"A\", \"P\", \"Z\", \"O\", \"R\", \"I\", \"L\", \"X\", \"E\", \"T\", \"W\", \"D\", \"S\", \"G\", \"Q\"], \"E\", \"A\", \"P\"]", "A*_args": "[\"[[0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1], [1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0]]\", \"['A', 'P', 'Z', 'O', 'R', 'I', 'L', 'X', 'E', 'T', 'W', 'D', 'S', 'G', 'Q']\", \"['E']\", \"['A', 'P']\"]"}
{"diff_sorted_id": "87", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [25, 41, 34, 19, 19, 36, 37, 13, 28, 26, 181, 7, 14, 6, 29, 36, 33, 7, 8, 43, 19, 9, 3, 2, 18, 40, 43, 22, 23, 21], such that the sum of the chosen coins adds up to 449. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {21: 5, 26: 13, 36: 8, 28: 8, 34: 12, 3: 2, 6: 2, 23: 10, 2: 2, 9: 5, 41: 4, 29: 19, 7: 6, 18: 18, 43: 2, 8: 7, 181: 9, 25: 10, 33: 8, 14: 13, 13: 1, 22: 13, 40: 7, 37: 11, 19: 11}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "17", "opt_solution": "[13, 21, 41, 43, 181, 40, 43, 6, 33, 28]", "opt_solution_cost": "48", "opt_solution_compute_t": "0.04537367820739746", "solution_depth": "10", "max_successor_states": "30", "num_vars_per_state": "30", "is_feasible_args": "[[25, 41, 34, 19, 19, 36, 37, 13, 28, 26, 181, 7, 14, 6, 29, 36, 33, 7, 8, 43, 19, 9, 3, 2, 18, 40, 43, 22, 23, 21]]", "is_correct_args": "[[25, 41, 34, 19, 19, 36, 37, 13, 28, 26, 181, 7, 14, 6, 29, 36, 33, 7, 8, 43, 19, 9, 3, 2, 18, 40, 43, 22, 23, 21], {\"21\": 5, \"26\": 13, \"36\": 8, \"28\": 8, \"34\": 12, \"3\": 2, \"6\": 2, \"23\": 10, \"2\": 2, \"9\": 5, \"41\": 4, \"29\": 19, \"7\": 6, \"18\": 18, \"43\": 2, \"8\": 7, \"181\": 9, \"25\": 10, \"33\": 8, \"14\": 13, \"13\": 1, \"22\": 13, \"40\": 7, \"37\": 11, \"19\": 11}, 449]", "A*_args": "[\"[25, 41, 34, 19, 19, 36, 37, 13, 28, 26, 181, 7, 14, 6, 29, 36, 33, 7, 8, 43, 19, 9, 3, 2, 18, 40, 43, 22, 23, 21]\", \"{21: 5, 26: 13, 36: 8, 28: 8, 34: 12, 3: 2, 6: 2, 23: 10, 2: 2, 9: 5, 41: 4, 29: 19, 7: 6, 18: 18, 43: 2, 8: 7, 181: 9, 25: 10, 33: 8, 14: 13, 13: 1, 22: 13, 40: 7, 37: 11, 19: 11}\", \"449\"]"}
{"diff_sorted_id": "87", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Red', 'Red', 'Blue', 'Green'], ['Blue', 'Red', 'Green', 'Green', 'Green', 'Red'], ['Blue', 'Blue', 'Blue', 'Red', 'Red', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[0, 2], [1, 2], [0, 2], [0, 1], [0, 1], [2, 1], [0, 2], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [1, 2], [1, 2], [1, 0], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [0, 1], [0, 1], [0, 1], [2, 0], [2, 0], [2, 0], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2]]", "opt_solution_cost": "35", "opt_solution_compute_t": "125.82809782028198", "solution_depth": "35", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Red\", \"Red\", \"Blue\", \"Green\"], [\"Blue\", \"Red\", \"Green\", \"Green\", \"Green\", \"Red\"], [\"Blue\", \"Blue\", \"Blue\", \"Red\", \"Red\", \"Green\"]], 9]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Red\", \"Red\", \"Blue\", \"Green\"], [\"Blue\", \"Red\", \"Green\", \"Green\", \"Green\", \"Red\"], [\"Blue\", \"Blue\", \"Blue\", \"Red\", \"Red\", \"Green\"]], 9]", "A*_args": "[\"[['Blue', 'Green', 'Red', 'Red', 'Blue', 'Green'], ['Blue', 'Red', 'Green', 'Green', 'Green', 'Red'], ['Blue', 'Blue', 'Blue', 'Red', 'Red', 'Green']]\", \"9\"]"}
{"diff_sorted_id": "87", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 14 to 64 (14 included in the range but 64 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '33' 'x' '54']\n ['x' '39' '51' '58']\n ['41' '48' 'x' 'x']\n ['x' 'x' 'x' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "14", "opt_solution": "[[0, 0, 17], [0, 2, 39], [1, 0, 18], [1, 1, 40], [1, 3, 57], [2, 0, 19], [2, 1, 41], [3, 0, 20]]", "opt_solution_cost": "580", "opt_solution_compute_t": "30.668219327926636", "solution_depth": "8", "max_successor_states": "50", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '38', '', '56'], ['', '', '55', ''], ['', '', '61', '65'], ['', '59', '64', '67']]\", 17, 72]", "is_correct_args": "[\"[['', '38', '', '56'], ['', '', '55', ''], ['', '', '61', '65'], ['', '59', '64', '67']]\", 17, 72]", "A*_args": "[\"[['', '38', '', '56'], ['', '', '55', ''], ['', '', '61', '65'], ['', '59', '64', '67']]\", \"17\", \"72\"]"}
{"diff_sorted_id": "87", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 37 to 83. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 258, 247, None for columns 1 to 2 respectively, and the sums of rows must be None, 233, 237, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 242. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['72' '76' '68' '69']\n ['56' 'x' 'x' 'x']\n ['49' 'x' 'x' '43']\n ['x' 'x' '61' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[1, 1, 64], [1, 2, 53], [1, 3, 60], [2, 1, 80], [2, 2, 65], [3, 0, 40], [3, 1, 38], [3, 3, 37]]", "opt_solution_cost": "931", "opt_solution_compute_t": "4.630835771560669", "solution_depth": "8", "max_successor_states": "31", "num_vars_per_state": "16", "is_feasible_args": "[\"[['72', '76', '68', '69'], ['56', '', '', ''], ['49', '', '', '43'], ['', '', '61', '']]\", 4, 37, 83]", "is_correct_args": "[\"[['72', '76', '68', '69'], ['56', '', '', ''], ['49', '', '', '43'], ['', '', '61', '']]\", 37, 83, [1, 3], [1, 3], [258, 247], [233, 237], 242]", "A*_args": "[\"[['72', '76', '68', '69'], ['56', '', '', ''], ['49', '', '', '43'], ['', '', '61', '']]\", \"37\", \"83\", \"[None, 258, 247, None]\", \"[None, 233, 237, None]\", \"242\"]"}
{"diff_sorted_id": "87", "problem_statement": "In 'Restricted Sorting', there are 12 stacks each with a capacity of 7 blocks, with 6 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 6 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 11, 1: 13, 2: 4, 3: 4, 4: 13, 5: 7, 6: 12, 7: 6, 8: 4, 9: 6, 10: 11, 11: 4}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Black', 'Blue', 'Pink', 'Green', 'Blue', 'Red', 'Red'], ['Yellow', 'White', 'White', 'Black', 'Yellow', 'Green', 'Green'], ['Yellow', 'Pink', 'White', 'Pink', 'Black', 'Red', 'Black'], [], ['Pink', 'Red', 'Blue', 'White', 'Blue', 'Blue', 'Red'], ['Blue', 'Yellow', 'White', 'Pink', 'Pink', 'Green', 'Green'], [], [], ['Yellow', 'Black', 'Yellow', 'White', 'Red', 'Black', 'Green'], [], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "4", "opt_solution": "[[0, 3], [0, 11], [5, 11], [0, 7], [0, 9], [0, 11], [4, 7], [1, 10], [2, 10], [2, 7], [4, 0], [5, 10], [8, 10], [1, 6], [1, 6], [1, 3], [1, 10], [2, 6], [2, 7], [5, 6], [5, 7], [5, 7], [9, 5], [2, 3], [2, 9], [2, 3], [4, 11], [4, 2], [4, 11], [4, 11], [8, 3], [8, 10], [8, 2], [8, 0], [1, 5], [1, 5], [8, 1], [4, 0], [9, 0], [8, 5], [1, 3], [6, 2], [6, 2], [6, 2], [6, 2]]", "opt_solution_cost": "319", "opt_solution_compute_t": "183.4848072528839", "solution_depth": "45", "max_successor_states": "132", "num_vars_per_state": "42", "is_feasible_args": "[[[\"Black\", \"Blue\", \"Pink\", \"Green\", \"Blue\", \"Red\", \"Red\"], [\"Yellow\", \"White\", \"White\", \"Black\", \"Yellow\", \"Green\", \"Green\"], [\"Yellow\", \"Pink\", \"White\", \"Pink\", \"Black\", \"Red\", \"Black\"], [], [\"Pink\", \"Red\", \"Blue\", \"White\", \"Blue\", \"Blue\", \"Red\"], [\"Blue\", \"Yellow\", \"White\", \"Pink\", \"Pink\", \"Green\", \"Green\"], [], [], [\"Yellow\", \"Black\", \"Yellow\", \"White\", \"Red\", \"Black\", \"Green\"], [], [], []], 7, {\"0\": 11, \"1\": 13, \"2\": 4, \"3\": 4, \"4\": 13, \"5\": 7, \"6\": 12, \"7\": 6, \"8\": 4, \"9\": 6, \"10\": 11, \"11\": 4}]", "is_correct_args": "[[[\"Black\", \"Blue\", \"Pink\", \"Green\", \"Blue\", \"Red\", \"Red\"], [\"Yellow\", \"White\", \"White\", \"Black\", \"Yellow\", \"Green\", \"Green\"], [\"Yellow\", \"Pink\", \"White\", \"Pink\", \"Black\", \"Red\", \"Black\"], [], [\"Pink\", \"Red\", \"Blue\", \"White\", \"Blue\", \"Blue\", \"Red\"], [\"Blue\", \"Yellow\", \"White\", \"Pink\", \"Pink\", \"Green\", \"Green\"], [], [], [\"Yellow\", \"Black\", \"Yellow\", \"White\", \"Red\", \"Black\", \"Green\"], [], [], []], 7, {\"0\": 11, \"1\": 13, \"2\": 4, \"3\": 4, \"4\": 13, \"5\": 7, \"6\": 12, \"7\": 6, \"8\": 4, \"9\": 6, \"10\": 11, \"11\": 4}, 6]", "A*_args": "[\"[['Black', 'Blue', 'Pink', 'Green', 'Blue', 'Red', 'Red'], ['Yellow', 'White', 'White', 'Black', 'Yellow', 'Green', 'Green'], ['Yellow', 'Pink', 'White', 'Pink', 'Black', 'Red', 'Black'], [], ['Pink', 'Red', 'Blue', 'White', 'Blue', 'Blue', 'Red'], ['Blue', 'Yellow', 'White', 'Pink', 'Pink', 'Green', 'Green'], [], [], ['Yellow', 'Black', 'Yellow', 'White', 'Red', 'Black', 'Green'], [], [], []]\", \"{0: 11, 1: 13, 2: 4, 3: 4, 4: 13, 5: 7, 6: 12, 7: 6, 8: 4, 9: 6, 10: 11, 11: 4}\", \"7\", \"6\"]"}
{"diff_sorted_id": "87", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 0) to his destination workshop at index (6, 12), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 5, and district 3 covering rows 6 to 13. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 6 19 13 x 16 11 6 14 15 7 x x x]\n[x 6 16 15 x 19 16 18 x 8 10 x x x]\n[x 5 10 14 2 x x x 11 x 11 x x x]\n[6 13 15 10 x x x x 19 x x x 2 x]\n[x 15 10 6 6 8 10 9 11 x x x 16 x]\n[x x x 8 15 12 10 19 1 18 19 4 x 10]\n[1 17 x x 6 8 4 x 15 8 10 6 4 x]\n[x x x x 13 x 5 x 9 10 x x x x]\n[12 x 11 x 13 x 11 7 5 13 x x 6 15]\n[x 18 19 x x x 3 x 16 11 x 15 x x]\n[x x x x x x 2 15 x x 8 x x x]\n[11 x 6 13 12 x 12 x x 9 x 17 x x]\n[x 1 x 18 18 3 x 11 13 1 13 x x x]\n[x x x x x 6 x x 8 x x x 4 11]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "6", "opt_solution": "[[3, 0], [3, 1], [2, 1], [2, 2], [2, 3], [3, 3], [4, 3], [4, 4], [4, 5], [4, 6], [4, 7], [4, 8], [5, 8], [6, 8], [6, 9], [6, 10], [6, 11], [6, 12]]", "opt_solution_cost": "146", "opt_solution_compute_t": "0.027922391891479492", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"6\", \"19\", \"13\", \"x\", \"16\", \"11\", \"6\", \"14\", \"15\", \"7\", \"x\", \"x\", \"x\"], [\"x\", \"6\", \"16\", \"15\", \"x\", \"19\", \"16\", \"18\", \"x\", \"8\", \"10\", \"x\", \"x\", \"x\"], [\"x\", \"5\", \"10\", \"14\", \"2\", \"x\", \"x\", \"x\", \"11\", \"x\", \"11\", \"x\", \"x\", \"x\"], [\"6\", \"13\", \"15\", \"10\", \"x\", \"x\", \"x\", \"x\", \"19\", \"x\", \"x\", \"x\", \"2\", \"x\"], [\"x\", \"15\", \"10\", \"6\", \"6\", \"8\", \"10\", \"9\", \"11\", \"x\", \"x\", \"x\", \"16\", \"x\"], [\"x\", \"x\", \"x\", \"8\", \"15\", \"12\", \"10\", \"19\", \"1\", \"18\", \"19\", \"4\", \"x\", \"10\"], [\"1\", \"17\", \"x\", \"x\", \"6\", \"8\", \"4\", \"x\", \"15\", \"8\", \"10\", \"6\", \"4\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"13\", \"x\", \"5\", \"x\", \"9\", \"10\", \"x\", \"x\", \"x\", \"x\"], [\"12\", \"x\", \"11\", \"x\", \"13\", \"x\", \"11\", \"7\", \"5\", \"13\", \"x\", \"x\", \"6\", \"15\"], [\"x\", \"18\", \"19\", \"x\", \"x\", \"x\", \"3\", \"x\", \"16\", \"11\", \"x\", \"15\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"2\", \"15\", \"x\", \"x\", \"8\", \"x\", \"x\", \"x\"], [\"11\", \"x\", \"6\", \"13\", \"12\", \"x\", \"12\", \"x\", \"x\", \"9\", \"x\", \"17\", \"x\", \"x\"], [\"x\", \"1\", \"x\", \"18\", \"18\", \"3\", \"x\", \"11\", \"13\", \"1\", \"13\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"6\", \"x\", \"x\", \"8\", \"x\", \"x\", \"x\", \"4\", \"11\"]]]", "is_correct_args": "[[[\"x\", \"6\", \"19\", \"13\", \"x\", \"16\", \"11\", \"6\", \"14\", \"15\", \"7\", \"x\", \"x\", \"x\"], [\"x\", \"6\", \"16\", \"15\", \"x\", \"19\", \"16\", \"18\", \"x\", \"8\", \"10\", \"x\", \"x\", \"x\"], [\"x\", \"5\", \"10\", \"14\", \"2\", \"x\", \"x\", \"x\", \"11\", \"x\", \"11\", \"x\", \"x\", \"x\"], [\"6\", \"13\", \"15\", \"10\", \"x\", \"x\", \"x\", \"x\", \"19\", \"x\", \"x\", \"x\", \"2\", \"x\"], [\"x\", \"15\", \"10\", \"6\", \"6\", \"8\", \"10\", \"9\", \"11\", \"x\", \"x\", \"x\", \"16\", \"x\"], [\"x\", \"x\", \"x\", \"8\", \"15\", \"12\", \"10\", \"19\", \"1\", \"18\", \"19\", \"4\", \"x\", \"10\"], [\"1\", \"17\", \"x\", \"x\", \"6\", \"8\", \"4\", \"x\", \"15\", \"8\", \"10\", \"6\", \"4\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"13\", \"x\", \"5\", \"x\", \"9\", \"10\", \"x\", \"x\", \"x\", \"x\"], [\"12\", \"x\", \"11\", \"x\", \"13\", \"x\", \"11\", \"7\", \"5\", \"13\", \"x\", \"x\", \"6\", \"15\"], [\"x\", \"18\", \"19\", \"x\", \"x\", \"x\", \"3\", \"x\", \"16\", \"11\", \"x\", \"15\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"2\", \"15\", \"x\", \"x\", \"8\", \"x\", \"x\", \"x\"], [\"11\", \"x\", \"6\", \"13\", \"12\", \"x\", \"12\", \"x\", \"x\", \"9\", \"x\", \"17\", \"x\", \"x\"], [\"x\", \"1\", \"x\", \"18\", \"18\", \"3\", \"x\", \"11\", \"13\", \"1\", \"13\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"6\", \"x\", \"x\", \"8\", \"x\", \"x\", \"x\", \"4\", \"11\"]], [3, 0], [6, 12], 2, 5]", "A*_args": "[\"[['x', '6', '19', '13', 'x', '16', '11', '6', '14', '15', '7', 'x', 'x', 'x'], ['x', '6', '16', '15', 'x', '19', '16', '18', 'x', '8', '10', 'x', 'x', 'x'], ['x', '5', '10', '14', '2', 'x', 'x', 'x', '11', 'x', '11', 'x', 'x', 'x'], ['6', '13', '15', '10', 'x', 'x', 'x', 'x', '19', 'x', 'x', 'x', '2', 'x'], ['x', '15', '10', '6', '6', '8', '10', '9', '11', 'x', 'x', 'x', '16', 'x'], ['x', 'x', 'x', '8', '15', '12', '10', '19', '1', '18', '19', '4', 'x', '10'], ['1', '17', 'x', 'x', '6', '8', '4', 'x', '15', '8', '10', '6', '4', 'x'], ['x', 'x', 'x', 'x', '13', 'x', '5', 'x', '9', '10', 'x', 'x', 'x', 'x'], ['12', 'x', '11', 'x', '13', 'x', '11', '7', '5', '13', 'x', 'x', '6', '15'], ['x', '18', '19', 'x', 'x', 'x', '3', 'x', '16', '11', 'x', '15', 'x', 'x'], ['x', 'x', 'x', 'x', 'x', 'x', '2', '15', 'x', 'x', '8', 'x', 'x', 'x'], ['11', 'x', '6', '13', '12', 'x', '12', 'x', 'x', '9', 'x', '17', 'x', 'x'], ['x', '1', 'x', '18', '18', '3', 'x', '11', '13', '1', '13', 'x', 'x', 'x'], ['x', 'x', 'x', 'x', 'x', '6', 'x', 'x', '8', 'x', 'x', 'x', '4', '11']]\", \"(3, 0)\", \"(6, 12)\", \"2\", \"5\"]"}
{"diff_sorted_id": "87", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 14x14. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 11) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (12, 2). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 1 0 1 1 0 1 0 0 0 1 1\n1 1 0 1 1 0 1 1 0 0 0 0 1 1\n1 1 1 0 0 0 0 1 0 0 0 0 1 1\n0 1 1 1 1 1 1 0 0 0 1 0 1 1\n1 1 0 0 0 1 0 0 0 0 1 1 1 1\n1 1 1 0 1 0 0 1 1 1 1 1 1 1\n1 1 0 1 0 0 0 1 1 1 1 0 1 1\n0 1 1 1 1 1 0 1 0 0 0 0 0 1\n0 1 1 1 0 0 0 0 0 0 0 0 0 1\n1 1 1 0 1 0 0 0 1 0 0 1 1 1\n1 0 0 0 0 0 0 1 0 1 1 1 0 0\n0 1 0 1 0 0 0 1 1 0 1 1 0 0\n1 1 0 1 1 1 0 0 0 0 1 0 1 0\n1 1 1 1 0 1 1 1 1 1 1 0 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[[0, 11], [1, 10], [2, 9], [3, 8], [4, 7], [4, 6], [5, 6], [6, 6], [7, 6], [8, 6], [8, 5], [9, 5], [10, 5], [10, 4], [10, 3], [10, 2], [11, 2], [12, 2]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.022104978561401367", "solution_depth": "18", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1], [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1], [0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1]]\", 4]", "is_correct_args": "[\"[[1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1], [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1], [0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1]]\", [0, 11], [12, 2], 4]", "A*_args": "[\"[[1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1], [1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1], [0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1], [0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0], [1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1]]\", \"(0, 11)\", \"(12, 2)\", \"4\"]"}
{"diff_sorted_id": "87", "problem_statement": "Given 7 labeled water jugs with capacities 36, 95, 47, 149, 58, 96, 81, 148 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 252, 307, 412, 431 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 58, 4], [\"+\", 96, 4], [\"+\", 149, 4], [\"+\", 81, 4], [\"+\", 47, 4], [\"+\", 148, 3], [\"+\", 148, 3], [\"+\", 58, 3], [\"+\", 58, 3], [\"+\", 148, 2], [\"+\", 148, 2], [\"-\", 36, 2], [\"+\", 47, 2], [\"+\", 81, 1], [\"+\", 148, 1], [\"-\", 58, 1], [\"+\", 81, 1]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.04282355308532715", "solution_depth": "17", "max_successor_states": "64", "num_vars_per_state": "3", "is_feasible_args": "[[36, 95, 47, 149, 58, 96, 81, 148], [252, 307, 412, 431]]", "is_correct_args": "[[36, 95, 47, 149, 58, 96, 81, 148], [252, 307, 412, 431]]", "A*_args": "[\"[36, 95, 47, 149, 58, 96, 81, 148]\", \"[252, 307, 412, 431]\"]"}
{"diff_sorted_id": "88", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[98, 74, 70, 26, 65], [91, 55, 12, '_', 68], [27, 18, 67, 40, 54]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "8", "opt_solution": "[12, 55, 91, 27, 18, 67, 55, 12, 26, 65, 68, 54, 40, 55, 12, 26, 65, 70, 74, 91, 67, 18, 27, 67, 26, 65, 55, 12, 18, 26, 65, 55, 54, 40]", "opt_solution_cost": "34", "opt_solution_compute_t": "2.9298317432403564", "solution_depth": "34", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[98, 74, 70, 26, 65], [91, 55, 12, \"_\", 68], [27, 18, 67, 40, 54]]]", "is_correct_args": "[[[98, 74, 70, 26, 65], [91, 55, 12, \"_\", 68], [27, 18, 67, 40, 54]]]", "A*_args": "[\"[[98, 74, 70, 26, 65], [91, 55, 12, '_', 68], [27, 18, 67, 40, 54]]\"]"}
{"diff_sorted_id": "88", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: frim, agate, askip, floey, zonar   The initial board: [['g', 'f', 't', 'i', 'm'], ['a', 'l', 'a', 'a', 'e'], ['n', 's', '_', 'i', 'e'], ['f', 'p', 'o', 'k', 'y'], ['z', 'o', 'r', 'a', 'r']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.5754249095916748", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"g\", \"f\", \"t\", \"i\", \"m\"], [\"a\", \"l\", \"a\", \"a\", \"e\"], [\"n\", \"s\", \"_\", \"i\", \"e\"], [\"f\", \"p\", \"o\", \"k\", \"y\"], [\"z\", \"o\", \"r\", \"a\", \"r\"]]]", "is_correct_args": "[[[\"g\", \"f\", \"t\", \"i\", \"m\"], [\"a\", \"l\", \"a\", \"a\", \"e\"], [\"n\", \"s\", \"_\", \"i\", \"e\"], [\"f\", \"p\", \"o\", \"k\", \"y\"], [\"z\", \"o\", \"r\", \"a\", \"r\"]], [\"frim\", \"agate\", \"askip\", \"floey\", \"zonar\"]]", "A*_args": "[\"[['g', 'f', 't', 'i', 'm'], ['a', 'l', 'a', 'a', 'e'], ['n', 's', '_', 'i', 'e'], ['f', 'p', 'o', 'k', 'y'], ['z', 'o', 'r', 'a', 'r']]\", \"['frim', 'agate', 'askip', 'floey', 'zonar']\"]"}
{"diff_sorted_id": "88", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'A'. Our task is to visit city M and city J excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from J and M, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  T W Y B I J R O P A V X M K F \nT 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 \nW 0 0 1 1 0 0 1 0 0 0 0 1 0 0 0 \nY 1 0 0 1 0 0 1 1 0 1 0 0 1 0 0 \nB 0 0 0 0 0 0 1 0 0 0 0 0 0 1 0 \nI 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 \nJ 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 \nR 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 \nO 0 1 0 0 0 0 0 0 1 0 0 1 0 1 0 \nP 0 1 0 0 0 0 0 0 0 0 1 0 0 0 1 \nA 0 1 0 1 0 0 0 1 1 0 0 0 0 1 0 \nV 1 0 0 0 0 1 1 0 0 1 0 0 0 0 0 \nX 0 0 1 0 0 1 1 0 1 1 0 0 1 0 0 \nM 1 0 0 0 0 1 0 0 1 1 1 0 0 0 1 \nK 0 1 0 1 0 1 0 0 1 0 0 0 0 0 0 \nF 0 1 1 0 1 0 0 1 0 0 1 0 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[\"A\", \"O\", \"X\", \"M\", \"J\", \"F\", \"Y\", \"M\", \"J\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.0450282096862793", "solution_depth": "9", "max_successor_states": "15", "num_vars_per_state": "18", "is_feasible_args": "[[[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1], [0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]], [\"T\", \"W\", \"Y\", \"B\", \"I\", \"J\", \"R\", \"O\", \"P\", \"A\", \"V\", \"X\", \"M\", \"K\", \"F\"], \"M\", \"J\"]", "is_correct_args": "[[[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1], [0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]], [\"T\", \"W\", \"Y\", \"B\", \"I\", \"J\", \"R\", \"O\", \"P\", \"A\", \"V\", \"X\", \"M\", \"K\", \"F\"], \"A\", \"M\", \"J\"]", "A*_args": "[\"[[0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1], [0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]]\", \"['T', 'W', 'Y', 'B', 'I', 'J', 'R', 'O', 'P', 'A', 'V', 'X', 'M', 'K', 'F']\", \"['A']\", \"['M', 'J']\"]"}
{"diff_sorted_id": "88", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [21, 31, 30, 31, 10, 17, 13, 35, 12, 2, 16, 40, 23, 10, 29, 13, 23, 2, 9, 5, 107, 46, 23, 11, 42, 9, 46, 28, 44, 22, 106, 10], such that the sum of the chosen coins adds up to 465. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {13: 9, 106: 19, 28: 20, 44: 14, 9: 6, 35: 6, 22: 19, 46: 17, 11: 7, 40: 12, 17: 15, 10: 4, 12: 6, 30: 20, 2: 2, 23: 11, 42: 10, 16: 1, 107: 11, 21: 12, 5: 3, 31: 13, 29: 20}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "18", "opt_solution": "[10, 35, 10, 107, 106, 46, 44, 42, 40, 16, 2, 5, 2]", "opt_solution_cost": "105", "opt_solution_compute_t": "0.05189323425292969", "solution_depth": "13", "max_successor_states": "32", "num_vars_per_state": "32", "is_feasible_args": "[[21, 31, 30, 31, 10, 17, 13, 35, 12, 2, 16, 40, 23, 10, 29, 13, 23, 2, 9, 5, 107, 46, 23, 11, 42, 9, 46, 28, 44, 22, 106, 10]]", "is_correct_args": "[[21, 31, 30, 31, 10, 17, 13, 35, 12, 2, 16, 40, 23, 10, 29, 13, 23, 2, 9, 5, 107, 46, 23, 11, 42, 9, 46, 28, 44, 22, 106, 10], {\"13\": 9, \"106\": 19, \"28\": 20, \"44\": 14, \"9\": 6, \"35\": 6, \"22\": 19, \"46\": 17, \"11\": 7, \"40\": 12, \"17\": 15, \"10\": 4, \"12\": 6, \"30\": 20, \"2\": 2, \"23\": 11, \"42\": 10, \"16\": 1, \"107\": 11, \"21\": 12, \"5\": 3, \"31\": 13, \"29\": 20}, 465]", "A*_args": "[\"[21, 31, 30, 31, 10, 17, 13, 35, 12, 2, 16, 40, 23, 10, 29, 13, 23, 2, 9, 5, 107, 46, 23, 11, 42, 9, 46, 28, 44, 22, 106, 10]\", \"{13: 9, 106: 19, 28: 20, 44: 14, 9: 6, 35: 6, 22: 19, 46: 17, 11: 7, 40: 12, 17: 15, 10: 4, 12: 6, 30: 20, 2: 2, 23: 11, 42: 10, 16: 1, 107: 11, 21: 12, 5: 3, 31: 13, 29: 20}\", \"465\"]"}
{"diff_sorted_id": "88", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Red', 'Green', 'Green', 'Red'], ['Green', 'Blue', 'Red', 'Blue', 'Blue', 'Red'], ['Red', 'Green', 'Blue', 'Blue', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[0, 2], [0, 1], [0, 2], [0, 1], [0, 1], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [2, 1], [2, 1], [2, 0], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0], [1, 2], [1, 2], [0, 2], [1, 2], [0, 1], [0, 1], [0, 1], [2, 0], [2, 0], [1, 2]]", "opt_solution_cost": "38", "opt_solution_compute_t": "564.8052530288696", "solution_depth": "38", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Red\", \"Green\", \"Green\", \"Red\"], [\"Green\", \"Blue\", \"Red\", \"Blue\", \"Blue\", \"Red\"], [\"Red\", \"Green\", \"Blue\", \"Blue\", \"Green\", \"Red\"]], 9]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Red\", \"Green\", \"Green\", \"Red\"], [\"Green\", \"Blue\", \"Red\", \"Blue\", \"Blue\", \"Red\"], [\"Red\", \"Green\", \"Blue\", \"Blue\", \"Green\", \"Red\"]], 9]", "A*_args": "[\"[['Blue', 'Green', 'Red', 'Green', 'Green', 'Red'], ['Green', 'Blue', 'Red', 'Blue', 'Blue', 'Red'], ['Red', 'Green', 'Blue', 'Blue', 'Green', 'Red']]\", \"9\"]"}
{"diff_sorted_id": "88", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 30 to 80 (30 included in the range but 80 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' 'x' 'x' '68']\n ['x' '58' 'x' 'x']\n ['41' 'x' 'x' 'x']\n ['x' '66' '67' '79']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "15", "opt_solution": "[[0, 1, 52], [0, 3, 71], [1, 3, 72], [2, 0, 28], [2, 1, 55], [2, 3, 73], [3, 0, 27], [3, 1, 56]]", "opt_solution_cost": "787", "opt_solution_compute_t": "19.980714321136475", "solution_depth": "8", "max_successor_states": "50", "num_vars_per_state": "16", "is_feasible_args": "[\"[['51', '', '68', ''], ['50', '54', '69', ''], ['', '', '70', ''], ['', '', '76', '77']]\", 27, 82]", "is_correct_args": "[\"[['51', '', '68', ''], ['50', '54', '69', ''], ['', '', '70', ''], ['', '', '76', '77']]\", 27, 82]", "A*_args": "[\"[['51', '', '68', ''], ['50', '54', '69', ''], ['', '', '70', ''], ['', '', '76', '77']]\", \"27\", \"82\"]"}
{"diff_sorted_id": "88", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 22 to 68. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 183, 202, None for columns 1 to 2 respectively, and the sums of rows must be None, 190, 154, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 183. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['27' '48' 'x' 'x']\n ['x' 'x' '63' 'x']\n ['28' 'x' '33' '26']\n ['x' 'x' 'x' '39']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 2, 40], [0, 3, 23], [1, 0, 24], [1, 1, 46], [1, 3, 57], [2, 1, 67], [3, 0, 30], [3, 1, 22], [3, 2, 66]]", "opt_solution_cost": "639", "opt_solution_compute_t": "497.1962370872498", "solution_depth": "9", "max_successor_states": "31", "num_vars_per_state": "16", "is_feasible_args": "[\"[['27', '48', '', ''], ['', '', '63', ''], ['28', '', '33', '26'], ['', '', '', '39']]\", 4, 22, 68]", "is_correct_args": "[\"[['27', '48', '', ''], ['', '', '63', ''], ['28', '', '33', '26'], ['', '', '', '39']]\", 22, 68, [1, 3], [1, 3], [183, 202], [190, 154], 183]", "A*_args": "[\"[['27', '48', '', ''], ['', '', '63', ''], ['28', '', '33', '26'], ['', '', '', '39']]\", \"22\", \"68\", \"[None, 183, 202, None]\", \"[None, 190, 154, None]\", \"183\"]"}
{"diff_sorted_id": "88", "problem_statement": "In 'Restricted Sorting', there are 12 stacks each with a capacity of 7 blocks, with 6 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 6 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 11, 1: 11, 2: 12, 3: 4, 4: 12, 5: 2, 6: 10, 7: 8, 8: 6, 9: 10, 10: 8, 11: 3}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Yellow', 'Green', 'White', 'Pink', 'Black', 'Pink', 'Pink'], ['Pink', 'Red', 'White', 'Black', 'Green', 'White', 'Pink'], ['Red', 'Black', 'Green', 'Blue', 'Red', 'Black', 'Yellow'], ['Blue', 'White', 'Blue', 'Blue', 'Black', 'White', 'Blue'], ['Yellow', 'Blue', 'Green', 'Green', 'Red', 'Red', 'Yellow'], [], [], [], ['Black', 'Yellow', 'Red', 'Green', 'Yellow', 'Pink', 'White'], [], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "4", "opt_solution": "[[0, 5], [4, 5], [0, 11], [0, 7], [4, 10], [4, 11], [4, 11], [2, 6], [8, 9], [8, 5], [8, 6], [8, 11], [8, 5], [2, 9], [2, 11], [2, 10], [2, 6], [2, 9], [3, 10], [3, 7], [3, 10], [3, 10], [3, 9], [3, 7], [3, 10], [1, 3], [8, 3], [1, 6], [1, 7], [1, 9], [1, 11], [1, 7], [4, 6], [4, 6], [0, 3], [0, 9], [8, 7], [0, 3], [0, 3], [1, 3], [2, 5], [4, 5]]", "opt_solution_cost": "270", "opt_solution_compute_t": "1.9822285175323486", "solution_depth": "42", "max_successor_states": "132", "num_vars_per_state": "42", "is_feasible_args": "[[[\"Yellow\", \"Green\", \"White\", \"Pink\", \"Black\", \"Pink\", \"Pink\"], [\"Pink\", \"Red\", \"White\", \"Black\", \"Green\", \"White\", \"Pink\"], [\"Red\", \"Black\", \"Green\", \"Blue\", \"Red\", \"Black\", \"Yellow\"], [\"Blue\", \"White\", \"Blue\", \"Blue\", \"Black\", \"White\", \"Blue\"], [\"Yellow\", \"Blue\", \"Green\", \"Green\", \"Red\", \"Red\", \"Yellow\"], [], [], [], [\"Black\", \"Yellow\", \"Red\", \"Green\", \"Yellow\", \"Pink\", \"White\"], [], [], []], 7, {\"0\": 11, \"1\": 11, \"2\": 12, \"3\": 4, \"4\": 12, \"5\": 2, \"6\": 10, \"7\": 8, \"8\": 6, \"9\": 10, \"10\": 8, \"11\": 3}]", "is_correct_args": "[[[\"Yellow\", \"Green\", \"White\", \"Pink\", \"Black\", \"Pink\", \"Pink\"], [\"Pink\", \"Red\", \"White\", \"Black\", \"Green\", \"White\", \"Pink\"], [\"Red\", \"Black\", \"Green\", \"Blue\", \"Red\", \"Black\", \"Yellow\"], [\"Blue\", \"White\", \"Blue\", \"Blue\", \"Black\", \"White\", \"Blue\"], [\"Yellow\", \"Blue\", \"Green\", \"Green\", \"Red\", \"Red\", \"Yellow\"], [], [], [], [\"Black\", \"Yellow\", \"Red\", \"Green\", \"Yellow\", \"Pink\", \"White\"], [], [], []], 7, {\"0\": 11, \"1\": 11, \"2\": 12, \"3\": 4, \"4\": 12, \"5\": 2, \"6\": 10, \"7\": 8, \"8\": 6, \"9\": 10, \"10\": 8, \"11\": 3}, 6]", "A*_args": "[\"[['Yellow', 'Green', 'White', 'Pink', 'Black', 'Pink', 'Pink'], ['Pink', 'Red', 'White', 'Black', 'Green', 'White', 'Pink'], ['Red', 'Black', 'Green', 'Blue', 'Red', 'Black', 'Yellow'], ['Blue', 'White', 'Blue', 'Blue', 'Black', 'White', 'Blue'], ['Yellow', 'Blue', 'Green', 'Green', 'Red', 'Red', 'Yellow'], [], [], [], ['Black', 'Yellow', 'Red', 'Green', 'Yellow', 'Pink', 'White'], [], [], []]\", \"{0: 11, 1: 11, 2: 12, 3: 4, 4: 12, 5: 2, 6: 10, 7: 8, 8: 6, 9: 10, 10: 8, 11: 3}\", \"7\", \"6\"]"}
{"diff_sorted_id": "88", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 1) to his destination workshop at index (5, 13), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 5, and district 3 covering rows 6 to 13. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 7 x 13 8 2 15 2 5 15 6 4 7 x]\n[x 6 19 17 5 13 15 2 11 5 x x 9 8]\n[16 12 10 7 8 19 19 9 5 10 2 x x 12]\n[x 1 19 20 x 3 4 18 x x 10 1 12 2]\n[x 1 4 1 1 10 4 x 12 x 5 10 3 8]\n[x x x 7 x x 16 12 x x x 13 6 10]\n[x x 11 12 13 15 8 x 12 1 16 14 8 15]\n[x 11 x 15 x x x x x x 5 x x 14]\n[1 x x 8 x 13 17 x 3 12 x x x x]\n[14 3 x 4 x x x 12 x 7 x x x x]\n[x 5 15 x 10 17 x x 6 9 2 x x x]\n[1 7 17 1 x x x x 11 x x x x 12]\n[x x 14 18 8 19 19 16 x 6 5 16 17 7]\n[x x x x x x 19 17 x x 2 12 x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "6", "opt_solution": "[[3, 1], [4, 1], [4, 2], [4, 3], [4, 4], [4, 5], [3, 5], [3, 6], [3, 7], [2, 7], [2, 8], [2, 9], [2, 10], [3, 10], [3, 11], [4, 11], [4, 12], [5, 12], [6, 12], [5, 12], [5, 13]]", "opt_solution_cost": "122", "opt_solution_compute_t": "0.027570009231567383", "solution_depth": "21", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"7\", \"x\", \"13\", \"8\", \"2\", \"15\", \"2\", \"5\", \"15\", \"6\", \"4\", \"7\", \"x\"], [\"x\", \"6\", \"19\", \"17\", \"5\", \"13\", \"15\", \"2\", \"11\", \"5\", \"x\", \"x\", \"9\", \"8\"], [\"16\", \"12\", \"10\", \"7\", \"8\", \"19\", \"19\", \"9\", \"5\", \"10\", \"2\", \"x\", \"x\", \"12\"], [\"x\", \"1\", \"19\", \"20\", \"x\", \"3\", \"4\", \"18\", \"x\", \"x\", \"10\", \"1\", \"12\", \"2\"], [\"x\", \"1\", \"4\", \"1\", \"1\", \"10\", \"4\", \"x\", \"12\", \"x\", \"5\", \"10\", \"3\", \"8\"], [\"x\", \"x\", \"x\", \"7\", \"x\", \"x\", \"16\", \"12\", \"x\", \"x\", \"x\", \"13\", \"6\", \"10\"], [\"x\", \"x\", \"11\", \"12\", \"13\", \"15\", \"8\", \"x\", \"12\", \"1\", \"16\", \"14\", \"8\", \"15\"], [\"x\", \"11\", \"x\", \"15\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"5\", \"x\", \"x\", \"14\"], [\"1\", \"x\", \"x\", \"8\", \"x\", \"13\", \"17\", \"x\", \"3\", \"12\", \"x\", \"x\", \"x\", \"x\"], [\"14\", \"3\", \"x\", \"4\", \"x\", \"x\", \"x\", \"12\", \"x\", \"7\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"5\", \"15\", \"x\", \"10\", \"17\", \"x\", \"x\", \"6\", \"9\", \"2\", \"x\", \"x\", \"x\"], [\"1\", \"7\", \"17\", \"1\", \"x\", \"x\", \"x\", \"x\", \"11\", \"x\", \"x\", \"x\", \"x\", \"12\"], [\"x\", \"x\", \"14\", \"18\", \"8\", \"19\", \"19\", \"16\", \"x\", \"6\", \"5\", \"16\", \"17\", \"7\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"19\", \"17\", \"x\", \"x\", \"2\", \"12\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"7\", \"x\", \"13\", \"8\", \"2\", \"15\", \"2\", \"5\", \"15\", \"6\", \"4\", \"7\", \"x\"], [\"x\", \"6\", \"19\", \"17\", \"5\", \"13\", \"15\", \"2\", \"11\", \"5\", \"x\", \"x\", \"9\", \"8\"], [\"16\", \"12\", \"10\", \"7\", \"8\", \"19\", \"19\", \"9\", \"5\", \"10\", \"2\", \"x\", \"x\", \"12\"], [\"x\", \"1\", \"19\", \"20\", \"x\", \"3\", \"4\", \"18\", \"x\", \"x\", \"10\", \"1\", \"12\", \"2\"], [\"x\", \"1\", \"4\", \"1\", \"1\", \"10\", \"4\", \"x\", \"12\", \"x\", \"5\", \"10\", \"3\", \"8\"], [\"x\", \"x\", \"x\", \"7\", \"x\", \"x\", \"16\", \"12\", \"x\", \"x\", \"x\", \"13\", \"6\", \"10\"], [\"x\", \"x\", \"11\", \"12\", \"13\", \"15\", \"8\", \"x\", \"12\", \"1\", \"16\", \"14\", \"8\", \"15\"], [\"x\", \"11\", \"x\", \"15\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"5\", \"x\", \"x\", \"14\"], [\"1\", \"x\", \"x\", \"8\", \"x\", \"13\", \"17\", \"x\", \"3\", \"12\", \"x\", \"x\", \"x\", \"x\"], [\"14\", \"3\", \"x\", \"4\", \"x\", \"x\", \"x\", \"12\", \"x\", \"7\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"5\", \"15\", \"x\", \"10\", \"17\", \"x\", \"x\", \"6\", \"9\", \"2\", \"x\", \"x\", \"x\"], [\"1\", \"7\", \"17\", \"1\", \"x\", \"x\", \"x\", \"x\", \"11\", \"x\", \"x\", \"x\", \"x\", \"12\"], [\"x\", \"x\", \"14\", \"18\", \"8\", \"19\", \"19\", \"16\", \"x\", \"6\", \"5\", \"16\", \"17\", \"7\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"19\", \"17\", \"x\", \"x\", \"2\", \"12\", \"x\", \"x\"]], [3, 1], [5, 13], 3, 5]", "A*_args": "[\"[['x', '7', 'x', '13', '8', '2', '15', '2', '5', '15', '6', '4', '7', 'x'], ['x', '6', '19', '17', '5', '13', '15', '2', '11', '5', 'x', 'x', '9', '8'], ['16', '12', '10', '7', '8', '19', '19', '9', '5', '10', '2', 'x', 'x', '12'], ['x', '1', '19', '20', 'x', '3', '4', '18', 'x', 'x', '10', '1', '12', '2'], ['x', '1', '4', '1', '1', '10', '4', 'x', '12', 'x', '5', '10', '3', '8'], ['x', 'x', 'x', '7', 'x', 'x', '16', '12', 'x', 'x', 'x', '13', '6', '10'], ['x', 'x', '11', '12', '13', '15', '8', 'x', '12', '1', '16', '14', '8', '15'], ['x', '11', 'x', '15', 'x', 'x', 'x', 'x', 'x', 'x', '5', 'x', 'x', '14'], ['1', 'x', 'x', '8', 'x', '13', '17', 'x', '3', '12', 'x', 'x', 'x', 'x'], ['14', '3', 'x', '4', 'x', 'x', 'x', '12', 'x', '7', 'x', 'x', 'x', 'x'], ['x', '5', '15', 'x', '10', '17', 'x', 'x', '6', '9', '2', 'x', 'x', 'x'], ['1', '7', '17', '1', 'x', 'x', 'x', 'x', '11', 'x', 'x', 'x', 'x', '12'], ['x', 'x', '14', '18', '8', '19', '19', '16', 'x', '6', '5', '16', '17', '7'], ['x', 'x', 'x', 'x', 'x', 'x', '19', '17', 'x', 'x', '2', '12', 'x', 'x']]\", \"(3, 1)\", \"(5, 13)\", \"3\", \"5\"]"}
{"diff_sorted_id": "88", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 14x14. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 11) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (9, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 1 0 0 0 0 0 0 0 1 0 1 0\n1 1 1 1 0 0 0 0 1 1 0 0 1 0\n1 1 0 0 0 0 0 1 1 0 1 0 1 0\n1 0 0 1 0 1 1 1 1 1 0 0 0 1\n1 1 1 1 0 0 0 0 0 0 1 0 0 1\n0 0 0 0 1 0 1 1 0 0 1 1 1 1\n0 0 0 1 0 0 1 1 0 0 0 0 0 1\n0 1 1 0 0 0 1 1 1 1 1 1 1 0\n1 1 1 0 0 0 1 1 0 1 1 1 1 1\n0 0 0 0 0 0 1 1 1 1 1 1 1 0\n1 1 0 0 0 1 0 1 1 0 0 1 0 1\n0 1 1 1 1 1 0 0 0 1 0 1 1 1\n1 0 1 0 1 1 0 1 1 1 1 1 1 1\n1 0 0 1 1 1 1 0 1 0 1 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[[0, 11], [1, 11], [2, 11], [3, 10], [4, 9], [4, 8], [4, 7], [4, 6], [4, 5], [5, 5], [6, 4], [7, 3], [8, 3], [9, 3], [9, 2], [9, 1]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.023496627807617188", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0], [1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1], [0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1], [0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1]]\", 4]", "is_correct_args": "[\"[[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0], [1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1], [0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1], [0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1]]\", [0, 11], [9, 1], 4]", "A*_args": "[\"[[1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0], [1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0], [1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1], [0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1], [0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1], [1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1]]\", \"(0, 11)\", \"(9, 1)\", \"4\"]"}
{"diff_sorted_id": "88", "problem_statement": "Given 7 labeled water jugs with capacities 95, 111, 144, 57, 13, 58, 12 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 226, 271, 331, 394 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 95, 4], [\"+\", 144, 4], [\"+\", 57, 4], [\"-\", 13, 4], [\"+\", 111, 4], [\"+\", 58, 3], [\"+\", 144, 3], [\"+\", 13, 3], [\"+\", 58, 3], [\"+\", 58, 3], [\"+\", 57, 2], [\"+\", 58, 2], [\"+\", 144, 2], [\"+\", 12, 2], [\"+\", 57, 1], [\"+\", 58, 1], [\"+\", 111, 1]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.051752328872680664", "solution_depth": "17", "max_successor_states": "56", "num_vars_per_state": "3", "is_feasible_args": "[[95, 111, 144, 57, 13, 58, 12], [226, 271, 331, 394]]", "is_correct_args": "[[95, 111, 144, 57, 13, 58, 12], [226, 271, 331, 394]]", "A*_args": "[\"[95, 111, 144, 57, 13, 58, 12]\", \"[226, 271, 331, 394]\"]"}
{"diff_sorted_id": "89", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[71, 36, 63, 32, 15], [20, 21, 65, '_', 54], [45, 96, 29, 31, 55]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "8", "opt_solution": "[54, 55, 31, 54, 32, 15, 55, 32, 15, 63, 65, 21, 20, 45, 96, 29, 54, 15, 63, 65, 36, 71, 45, 96, 29, 20, 21, 54, 20, 21, 54, 36, 71, 45, 96, 54, 45, 71, 65, 63, 32, 31]", "opt_solution_cost": "42", "opt_solution_compute_t": "37.91888380050659", "solution_depth": "42", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[71, 36, 63, 32, 15], [20, 21, 65, \"_\", 54], [45, 96, 29, 31, 55]]]", "is_correct_args": "[[[71, 36, 63, 32, 15], [20, 21, 65, \"_\", 54], [45, 96, 29, 31, 55]]]", "A*_args": "[\"[[71, 36, 63, 32, 15], [20, 21, 65, '_', 54], [45, 96, 29, 31, 55]]\"]"}
{"diff_sorted_id": "89", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: fage, palay, mowra, gemot, puffy   The initial board: [['a', 'f', 'w', 'g', 'e'], ['p', 'f', 'l', 'm', 'y'], ['o', 'o', 'a', 'r', 'a'], ['g', 'a', 'm', 'e', 't'], ['p', 'u', '_', 'f', 'y']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"up-right\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "24", "opt_solution_compute_t": "1.2028648853302002", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"a\", \"f\", \"w\", \"g\", \"e\"], [\"p\", \"f\", \"l\", \"m\", \"y\"], [\"o\", \"o\", \"a\", \"r\", \"a\"], [\"g\", \"a\", \"m\", \"e\", \"t\"], [\"p\", \"u\", \"_\", \"f\", \"y\"]]]", "is_correct_args": "[[[\"a\", \"f\", \"w\", \"g\", \"e\"], [\"p\", \"f\", \"l\", \"m\", \"y\"], [\"o\", \"o\", \"a\", \"r\", \"a\"], [\"g\", \"a\", \"m\", \"e\", \"t\"], [\"p\", \"u\", \"_\", \"f\", \"y\"]], [\"fage\", \"palay\", \"mowra\", \"gemot\", \"puffy\"]]", "A*_args": "[\"[['a', 'f', 'w', 'g', 'e'], ['p', 'f', 'l', 'm', 'y'], ['o', 'o', 'a', 'r', 'a'], ['g', 'a', 'm', 'e', 't'], ['p', 'u', '_', 'f', 'y']]\", \"['fage', 'palay', 'mowra', 'gemot', 'puffy']\"]"}
{"diff_sorted_id": "89", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'B'. Our task is to visit city Q and city I excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from I and Q, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  K P O U Q D G R C B J X S E I \nK 0 1 1 1 0 0 0 0 0 0 0 0 0 0 1 \nP 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 \nO 1 0 0 0 1 0 0 0 0 1 0 0 1 0 1 \nU 0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 \nQ 1 1 0 0 0 0 1 1 1 0 0 0 0 0 0 \nD 0 0 1 0 0 0 1 0 0 0 0 1 1 0 0 \nG 1 0 0 1 0 0 0 0 0 0 0 1 1 0 0 \nR 0 0 1 0 0 1 0 0 0 1 1 0 0 0 0 \nC 1 1 1 1 0 0 1 1 0 0 1 0 0 0 0 \nB 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 \nJ 0 1 0 0 0 0 1 0 0 0 0 0 1 0 1 \nX 0 0 1 1 0 0 1 0 0 0 0 0 0 0 0 \nS 0 0 0 1 1 0 0 0 0 0 0 1 0 0 0 \nE 0 0 0 0 1 0 1 0 1 0 1 1 0 0 0 \nI 0 0 0 0 1 1 0 1 1 1 0 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[\"B\", \"E\", \"J\", \"I\", \"Q\", \"K\", \"I\", \"Q\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.2261185646057129", "solution_depth": "8", "max_successor_states": "15", "num_vars_per_state": "18", "is_feasible_args": "[[[0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0]], [\"K\", \"P\", \"O\", \"U\", \"Q\", \"D\", \"G\", \"R\", \"C\", \"B\", \"J\", \"X\", \"S\", \"E\", \"I\"], \"Q\", \"I\"]", "is_correct_args": "[[[0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0]], [\"K\", \"P\", \"O\", \"U\", \"Q\", \"D\", \"G\", \"R\", \"C\", \"B\", \"J\", \"X\", \"S\", \"E\", \"I\"], \"B\", \"Q\", \"I\"]", "A*_args": "[\"[[0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0]]\", \"['K', 'P', 'O', 'U', 'Q', 'D', 'G', 'R', 'C', 'B', 'J', 'X', 'S', 'E', 'I']\", \"['B']\", \"['Q', 'I']\"]"}
{"diff_sorted_id": "89", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [27, 23, 11, 23, 6, 197, 7, 21, 2, 22, 12, 38, 15, 32, 5, 19, 6, 28, 31, 31, 10, 10, 28, 24, 41, 6, 39, 16, 11, 37, 23, 7, 2], such that the sum of the chosen coins adds up to 445. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {41: 14, 23: 15, 31: 19, 21: 18, 22: 2, 6: 3, 11: 5, 12: 11, 37: 10, 7: 2, 32: 19, 28: 10, 16: 12, 2: 2, 197: 7, 39: 18, 19: 18, 15: 4, 10: 9, 5: 4, 27: 10, 38: 3, 24: 5}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "19", "opt_solution": "[38, 24, 22, 2, 7, 15, 37, 28, 197, 28, 41, 6]", "opt_solution_cost": "72", "opt_solution_compute_t": "0.04321479797363281", "solution_depth": "12", "max_successor_states": "33", "num_vars_per_state": "33", "is_feasible_args": "[[27, 23, 11, 23, 6, 197, 7, 21, 2, 22, 12, 38, 15, 32, 5, 19, 6, 28, 31, 31, 10, 10, 28, 24, 41, 6, 39, 16, 11, 37, 23, 7, 2]]", "is_correct_args": "[[27, 23, 11, 23, 6, 197, 7, 21, 2, 22, 12, 38, 15, 32, 5, 19, 6, 28, 31, 31, 10, 10, 28, 24, 41, 6, 39, 16, 11, 37, 23, 7, 2], {\"41\": 14, \"23\": 15, \"31\": 19, \"21\": 18, \"22\": 2, \"6\": 3, \"11\": 5, \"12\": 11, \"37\": 10, \"7\": 2, \"32\": 19, \"28\": 10, \"16\": 12, \"2\": 2, \"197\": 7, \"39\": 18, \"19\": 18, \"15\": 4, \"10\": 9, \"5\": 4, \"27\": 10, \"38\": 3, \"24\": 5}, 445]", "A*_args": "[\"[27, 23, 11, 23, 6, 197, 7, 21, 2, 22, 12, 38, 15, 32, 5, 19, 6, 28, 31, 31, 10, 10, 28, 24, 41, 6, 39, 16, 11, 37, 23, 7, 2]\", \"{41: 14, 23: 15, 31: 19, 21: 18, 22: 2, 6: 3, 11: 5, 12: 11, 37: 10, 7: 2, 32: 19, 28: 10, 16: 12, 2: 2, 197: 7, 39: 18, 19: 18, 15: 4, 10: 9, 5: 4, 27: 10, 38: 3, 24: 5}\", \"445\"]"}
{"diff_sorted_id": "89", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Blue', 'Red', 'Red', 'Green'], ['Blue', 'Green', 'Blue', 'Blue', 'Red', 'Green'], ['Blue', 'Green', 'Red', 'Red', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[1, 2], [1, 0], [1, 2], [1, 2], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 1], [0, 2], [0, 1], [0, 1], [0, 1], [2, 0], [2, 0], [2, 1], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [1, 2], [0, 1], [0, 2], [0, 2], [1, 0], [1, 2], [1, 2]]", "opt_solution_cost": "33", "opt_solution_compute_t": "59.62572884559631", "solution_depth": "33", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Blue\", \"Red\", \"Red\", \"Green\"], [\"Blue\", \"Green\", \"Blue\", \"Blue\", \"Red\", \"Green\"], [\"Blue\", \"Green\", \"Red\", \"Red\", \"Green\", \"Red\"]], 9]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Blue\", \"Red\", \"Red\", \"Green\"], [\"Blue\", \"Green\", \"Blue\", \"Blue\", \"Red\", \"Green\"], [\"Blue\", \"Green\", \"Red\", \"Red\", \"Green\", \"Red\"]], 9]", "A*_args": "[\"[['Blue', 'Green', 'Blue', 'Red', 'Red', 'Green'], ['Blue', 'Green', 'Blue', 'Blue', 'Red', 'Green'], ['Blue', 'Green', 'Red', 'Red', 'Green', 'Red']]\", \"9\"]"}
{"diff_sorted_id": "89", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 10 to 60 (10 included in the range but 60 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '33' '34' '47']\n ['x' 'x' 'x' '50']\n ['x' 'x' 'x' '52']\n ['x' 'x' 'x' '53']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "15", "opt_solution": "[[0, 2, 31], [0, 3, 30], [1, 2, 59], [1, 3, 60], [2, 1, 51], [2, 2, 61], [3, 1, 49], [3, 2, 63]]", "opt_solution_cost": "681", "opt_solution_compute_t": "21.286011219024658", "solution_depth": "8", "max_successor_states": "50", "num_vars_per_state": "16", "is_feasible_args": "[\"[['62', '58', '', ''], ['56', '57', '', ''], ['50', '', '', '74'], ['48', '', '', '78']]\", 30, 85]", "is_correct_args": "[\"[['62', '58', '', ''], ['56', '57', '', ''], ['50', '', '', '74'], ['48', '', '', '78']]\", 30, 85]", "A*_args": "[\"[['62', '58', '', ''], ['56', '57', '', ''], ['50', '', '', '74'], ['48', '', '', '78']]\", \"30\", \"85\"]"}
{"diff_sorted_id": "89", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 22 to 68. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 187, 186, None for columns 1 to 2 respectively, and the sums of rows must be None, 139, 178, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 160. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x' 'x']\n ['24' 'x' '27' '41']\n ['22' '37' 'x' 'x']\n ['29' 'x' 'x' '46']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 23], [0, 1, 38], [0, 2, 30], [0, 3, 67], [1, 1, 47], [2, 2, 66], [2, 3, 53], [3, 1, 65], [3, 2, 63]]", "opt_solution_cost": "678", "opt_solution_compute_t": "413.0599796772003", "solution_depth": "9", "max_successor_states": "36", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '', ''], ['24', '', '27', '41'], ['22', '37', '', ''], ['29', '', '', '46']]\", 4, 22, 68]", "is_correct_args": "[\"[['', '', '', ''], ['24', '', '27', '41'], ['22', '37', '', ''], ['29', '', '', '46']]\", 22, 68, [1, 3], [1, 3], [187, 186], [139, 178], 160]", "A*_args": "[\"[['', '', '', ''], ['24', '', '27', '41'], ['22', '37', '', ''], ['29', '', '', '46']]\", \"22\", \"68\", \"[None, 187, 186, None]\", \"[None, 139, 178, None]\", \"160\"]"}
{"diff_sorted_id": "89", "problem_statement": "In 'Restricted Sorting', there are 12 stacks each with a capacity of 7 blocks, with 6 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 6 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 10, 1: 8, 2: 6, 3: 4, 4: 11, 5: 5, 6: 11, 7: 5, 8: 7, 9: 7, 10: 10, 11: 10}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [[], ['Blue', 'Yellow', 'Pink', 'Green', 'Pink', 'Red', 'Red'], [], ['Pink', 'White', 'Pink', 'Black', 'White', 'Black', 'Pink'], ['Yellow', 'Green', 'White', 'Red', 'Yellow', 'Yellow', 'Red'], ['Green', 'Pink', 'White', 'Blue', 'Red', 'White', 'Red'], [], [], ['Blue', 'Blue', 'Yellow', 'Blue', 'Black', 'Blue', 'Green'], ['Yellow', 'Black', 'Black', 'White', 'Green', 'Green', 'Black'], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "4", "opt_solution": "[[1, 7], [1, 2], [9, 2], [1, 0], [1, 10], [1, 0], [5, 10], [5, 0], [5, 11], [5, 7], [8, 7], [8, 7], [8, 2], [4, 2], [4, 10], [4, 11], [4, 1], [4, 2], [4, 2], [5, 1], [5, 11], [5, 1], [8, 7], [8, 5], [8, 7], [9, 5], [9, 5], [9, 11], [9, 8], [9, 8], [9, 5], [3, 9], [3, 11], [3, 9], [3, 5], [3, 11], [3, 5], [4, 1], [10, 8], [10, 8], [10, 8], [0, 3], [0, 3], [0, 3], [9, 3], [9, 3]]", "opt_solution_cost": "317", "opt_solution_compute_t": "39.28877377510071", "solution_depth": "46", "max_successor_states": "132", "num_vars_per_state": "42", "is_feasible_args": "[[[], [\"Blue\", \"Yellow\", \"Pink\", \"Green\", \"Pink\", \"Red\", \"Red\"], [], [\"Pink\", \"White\", \"Pink\", \"Black\", \"White\", \"Black\", \"Pink\"], [\"Yellow\", \"Green\", \"White\", \"Red\", \"Yellow\", \"Yellow\", \"Red\"], [\"Green\", \"Pink\", \"White\", \"Blue\", \"Red\", \"White\", \"Red\"], [], [], [\"Blue\", \"Blue\", \"Yellow\", \"Blue\", \"Black\", \"Blue\", \"Green\"], [\"Yellow\", \"Black\", \"Black\", \"White\", \"Green\", \"Green\", \"Black\"], [], []], 7, {\"0\": 10, \"1\": 8, \"2\": 6, \"3\": 4, \"4\": 11, \"5\": 5, \"6\": 11, \"7\": 5, \"8\": 7, \"9\": 7, \"10\": 10, \"11\": 10}]", "is_correct_args": "[[[], [\"Blue\", \"Yellow\", \"Pink\", \"Green\", \"Pink\", \"Red\", \"Red\"], [], [\"Pink\", \"White\", \"Pink\", \"Black\", \"White\", \"Black\", \"Pink\"], [\"Yellow\", \"Green\", \"White\", \"Red\", \"Yellow\", \"Yellow\", \"Red\"], [\"Green\", \"Pink\", \"White\", \"Blue\", \"Red\", \"White\", \"Red\"], [], [], [\"Blue\", \"Blue\", \"Yellow\", \"Blue\", \"Black\", \"Blue\", \"Green\"], [\"Yellow\", \"Black\", \"Black\", \"White\", \"Green\", \"Green\", \"Black\"], [], []], 7, {\"0\": 10, \"1\": 8, \"2\": 6, \"3\": 4, \"4\": 11, \"5\": 5, \"6\": 11, \"7\": 5, \"8\": 7, \"9\": 7, \"10\": 10, \"11\": 10}, 6]", "A*_args": "[\"[[], ['Blue', 'Yellow', 'Pink', 'Green', 'Pink', 'Red', 'Red'], [], ['Pink', 'White', 'Pink', 'Black', 'White', 'Black', 'Pink'], ['Yellow', 'Green', 'White', 'Red', 'Yellow', 'Yellow', 'Red'], ['Green', 'Pink', 'White', 'Blue', 'Red', 'White', 'Red'], [], [], ['Blue', 'Blue', 'Yellow', 'Blue', 'Black', 'Blue', 'Green'], ['Yellow', 'Black', 'Black', 'White', 'Green', 'Green', 'Black'], [], []]\", \"{0: 10, 1: 8, 2: 6, 3: 4, 4: 11, 5: 5, 6: 11, 7: 5, 8: 7, 9: 7, 10: 10, 11: 10}\", \"7\", \"6\"]"}
{"diff_sorted_id": "89", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 13) to his destination workshop at index (4, 0), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 5, and district 3 covering rows 6 to 13. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x x 7 11 16 13 19 15 x 19 x x 16]\n[9 x 14 x 7 3 x x 17 9 x x x 19]\n[x 11 6 18 x 19 4 x x x 19 12 4 17]\n[5 12 15 3 x x x x 7 x 11 17 20 20]\n[6 x 11 15 11 17 16 5 x 3 4 20 x 14]\n[x 11 x 6 x 16 2 18 5 11 x 14 4 7]\n[x 6 x 17 x x 15 7 x 2 3 16 7 15]\n[7 x x 8 1 x x x 14 x x 18 x 19]\n[13 x x x x 2 9 19 x 16 11 5 x 11]\n[x 17 15 18 x 7 x 15 13 x 14 2 x 19]\n[x x x 14 7 19 x x 9 9 x x x x]\n[x 3 13 15 18 17 x x 9 4 x 12 10 14]\n[15 x 6 19 19 19 x 1 8 4 17 14 x x]\n[8 x 14 7 12 6 8 x 5 x 11 11 x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "6", "opt_solution": "[[3, 13], [4, 13], [5, 13], [5, 12], [6, 12], [6, 11], [6, 10], [6, 9], [5, 9], [5, 8], [5, 7], [5, 6], [4, 6], [4, 5], [4, 4], [4, 3], [3, 3], [3, 2], [3, 1], [3, 0], [4, 0]]", "opt_solution_cost": "189", "opt_solution_compute_t": "0.029392480850219727", "solution_depth": "21", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"x\", \"7\", \"11\", \"16\", \"13\", \"19\", \"15\", \"x\", \"19\", \"x\", \"x\", \"16\"], [\"9\", \"x\", \"14\", \"x\", \"7\", \"3\", \"x\", \"x\", \"17\", \"9\", \"x\", \"x\", \"x\", \"19\"], [\"x\", \"11\", \"6\", \"18\", \"x\", \"19\", \"4\", \"x\", \"x\", \"x\", \"19\", \"12\", \"4\", \"17\"], [\"5\", \"12\", \"15\", \"3\", \"x\", \"x\", \"x\", \"x\", \"7\", \"x\", \"11\", \"17\", \"20\", \"20\"], [\"6\", \"x\", \"11\", \"15\", \"11\", \"17\", \"16\", \"5\", \"x\", \"3\", \"4\", \"20\", \"x\", \"14\"], [\"x\", \"11\", \"x\", \"6\", \"x\", \"16\", \"2\", \"18\", \"5\", \"11\", \"x\", \"14\", \"4\", \"7\"], [\"x\", \"6\", \"x\", \"17\", \"x\", \"x\", \"15\", \"7\", \"x\", \"2\", \"3\", \"16\", \"7\", \"15\"], [\"7\", \"x\", \"x\", \"8\", \"1\", \"x\", \"x\", \"x\", \"14\", \"x\", \"x\", \"18\", \"x\", \"19\"], [\"13\", \"x\", \"x\", \"x\", \"x\", \"2\", \"9\", \"19\", \"x\", \"16\", \"11\", \"5\", \"x\", \"11\"], [\"x\", \"17\", \"15\", \"18\", \"x\", \"7\", \"x\", \"15\", \"13\", \"x\", \"14\", \"2\", \"x\", \"19\"], [\"x\", \"x\", \"x\", \"14\", \"7\", \"19\", \"x\", \"x\", \"9\", \"9\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"3\", \"13\", \"15\", \"18\", \"17\", \"x\", \"x\", \"9\", \"4\", \"x\", \"12\", \"10\", \"14\"], [\"15\", \"x\", \"6\", \"19\", \"19\", \"19\", \"x\", \"1\", \"8\", \"4\", \"17\", \"14\", \"x\", \"x\"], [\"8\", \"x\", \"14\", \"7\", \"12\", \"6\", \"8\", \"x\", \"5\", \"x\", \"11\", \"11\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"x\", \"7\", \"11\", \"16\", \"13\", \"19\", \"15\", \"x\", \"19\", \"x\", \"x\", \"16\"], [\"9\", \"x\", \"14\", \"x\", \"7\", \"3\", \"x\", \"x\", \"17\", \"9\", \"x\", \"x\", \"x\", \"19\"], [\"x\", \"11\", \"6\", \"18\", \"x\", \"19\", \"4\", \"x\", \"x\", \"x\", \"19\", \"12\", \"4\", \"17\"], [\"5\", \"12\", \"15\", \"3\", \"x\", \"x\", \"x\", \"x\", \"7\", \"x\", \"11\", \"17\", \"20\", \"20\"], [\"6\", \"x\", \"11\", \"15\", \"11\", \"17\", \"16\", \"5\", \"x\", \"3\", \"4\", \"20\", \"x\", \"14\"], [\"x\", \"11\", \"x\", \"6\", \"x\", \"16\", \"2\", \"18\", \"5\", \"11\", \"x\", \"14\", \"4\", \"7\"], [\"x\", \"6\", \"x\", \"17\", \"x\", \"x\", \"15\", \"7\", \"x\", \"2\", \"3\", \"16\", \"7\", \"15\"], [\"7\", \"x\", \"x\", \"8\", \"1\", \"x\", \"x\", \"x\", \"14\", \"x\", \"x\", \"18\", \"x\", \"19\"], [\"13\", \"x\", \"x\", \"x\", \"x\", \"2\", \"9\", \"19\", \"x\", \"16\", \"11\", \"5\", \"x\", \"11\"], [\"x\", \"17\", \"15\", \"18\", \"x\", \"7\", \"x\", \"15\", \"13\", \"x\", \"14\", \"2\", \"x\", \"19\"], [\"x\", \"x\", \"x\", \"14\", \"7\", \"19\", \"x\", \"x\", \"9\", \"9\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"3\", \"13\", \"15\", \"18\", \"17\", \"x\", \"x\", \"9\", \"4\", \"x\", \"12\", \"10\", \"14\"], [\"15\", \"x\", \"6\", \"19\", \"19\", \"19\", \"x\", \"1\", \"8\", \"4\", \"17\", \"14\", \"x\", \"x\"], [\"8\", \"x\", \"14\", \"7\", \"12\", \"6\", \"8\", \"x\", \"5\", \"x\", \"11\", \"11\", \"x\", \"x\"]], [3, 13], [4, 0], 3, 5]", "A*_args": "[\"[['x', 'x', 'x', '7', '11', '16', '13', '19', '15', 'x', '19', 'x', 'x', '16'], ['9', 'x', '14', 'x', '7', '3', 'x', 'x', '17', '9', 'x', 'x', 'x', '19'], ['x', '11', '6', '18', 'x', '19', '4', 'x', 'x', 'x', '19', '12', '4', '17'], ['5', '12', '15', '3', 'x', 'x', 'x', 'x', '7', 'x', '11', '17', '20', '20'], ['6', 'x', '11', '15', '11', '17', '16', '5', 'x', '3', '4', '20', 'x', '14'], ['x', '11', 'x', '6', 'x', '16', '2', '18', '5', '11', 'x', '14', '4', '7'], ['x', '6', 'x', '17', 'x', 'x', '15', '7', 'x', '2', '3', '16', '7', '15'], ['7', 'x', 'x', '8', '1', 'x', 'x', 'x', '14', 'x', 'x', '18', 'x', '19'], ['13', 'x', 'x', 'x', 'x', '2', '9', '19', 'x', '16', '11', '5', 'x', '11'], ['x', '17', '15', '18', 'x', '7', 'x', '15', '13', 'x', '14', '2', 'x', '19'], ['x', 'x', 'x', '14', '7', '19', 'x', 'x', '9', '9', 'x', 'x', 'x', 'x'], ['x', '3', '13', '15', '18', '17', 'x', 'x', '9', '4', 'x', '12', '10', '14'], ['15', 'x', '6', '19', '19', '19', 'x', '1', '8', '4', '17', '14', 'x', 'x'], ['8', 'x', '14', '7', '12', '6', '8', 'x', '5', 'x', '11', '11', 'x', 'x']]\", \"(3, 13)\", \"(4, 0)\", \"3\", \"5\"]"}
{"diff_sorted_id": "89", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 14x14. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (13, 7) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (0, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 0 0 1 1 1 1 1 1 0 0 0 1 0\n0 0 0 0 1 1 1 1 0 1 0 1 1 1\n0 0 1 1 1 1 1 1 1 0 0 1 0 0\n0 0 0 1 1 0 1 1 0 1 0 1 0 0\n0 0 1 0 1 0 1 1 1 0 0 0 1 0\n1 0 1 0 0 1 1 0 1 0 1 1 1 0\n1 0 1 0 1 1 1 0 1 0 1 1 1 0\n1 0 1 1 0 0 1 1 0 1 0 1 0 0\n0 0 0 0 0 1 1 0 1 0 0 1 1 1\n0 0 0 0 0 0 0 1 1 1 0 1 1 1\n1 1 1 0 0 1 1 0 1 1 1 0 0 1\n1 0 1 0 0 0 0 0 1 1 1 1 0 0\n0 0 0 1 0 0 0 1 1 1 1 1 0 0\n1 0 1 1 1 1 0 0 1 0 0 0 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[[13, 7], [12, 6], [11, 5], [11, 4], [10, 4], [9, 4], [8, 4], [7, 4], [6, 3], [5, 3], [4, 3], [3, 2], [3, 1], [2, 1], [1, 1], [0, 1], [0, 0]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.02617049217224121", "solution_depth": "17", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0], [1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0], [1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0]]\", 4]", "is_correct_args": "[\"[[0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0], [1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0], [1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0]]\", [13, 7], [0, 0], 4]", "A*_args": "[\"[[0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0], [0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0], [1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0], [1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0]]\", \"(13, 7)\", \"(0, 0)\", \"4\"]"}
{"diff_sorted_id": "89", "problem_statement": "Given 7 labeled water jugs with capacities 30, 26, 116, 76, 98, 48, 46, 45 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 201, 269, 315, 333 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 76, 4], [\"+\", 116, 4], [\"+\", 45, 4], [\"+\", 48, 4], [\"+\", 48, 4], [\"+\", 76, 3], [\"+\", 98, 3], [\"+\", 45, 3], [\"+\", 48, 3], [\"+\", 48, 3], [\"+\", 76, 2], [\"+\", 76, 2], [\"+\", 98, 2], [\"-\", 26, 2], [\"+\", 45, 2], [\"+\", 116, 1], [\"-\", 76, 1], [\"+\", 45, 1], [\"+\", 116, 1]]", "opt_solution_cost": "19", "opt_solution_compute_t": "0.04046440124511719", "solution_depth": "19", "max_successor_states": "64", "num_vars_per_state": "3", "is_feasible_args": "[[30, 26, 116, 76, 98, 48, 46, 45], [201, 269, 315, 333]]", "is_correct_args": "[[30, 26, 116, 76, 98, 48, 46, 45], [201, 269, 315, 333]]", "A*_args": "[\"[30, 26, 116, 76, 98, 48, 46, 45]\", \"[201, 269, 315, 333]\"]"}
{"diff_sorted_id": "90", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[88, 59, 84, 71, 80], [72, 79, 74, 96, 51], ['_', 28, 25, 24, 19]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "8", "opt_solution": "[28, 79, 74, 96, 24, 25, 79, 74, 96, 79, 25, 24, 79, 84, 59, 88, 72, 96, 74, 25, 24, 19, 51, 79, 71, 59, 88, 72, 96, 74, 72, 88, 84, 71, 59, 80, 79, 51]", "opt_solution_cost": "38", "opt_solution_compute_t": "19.18411660194397", "solution_depth": "38", "max_successor_states": "4", "num_vars_per_state": "15", "is_feasible_args": "[[[88, 59, 84, 71, 80], [72, 79, 74, 96, 51], [\"_\", 28, 25, 24, 19]]]", "is_correct_args": "[[[88, 59, 84, 71, 80], [72, 79, 74, 96, 51], [\"_\", 28, 25, 24, 19]]]", "A*_args": "[\"[[88, 59, 84, 71, 80], [72, 79, 74, 96, 51], ['_', 28, 25, 24, 19]]\"]"}
{"diff_sorted_id": "90", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: sour, mangy, kizil, logia, urian   The initial board: [['a', 's', 'i', 'u', 'r'], ['m', 'z', 'n', 'k', 'y'], ['g', 'i', 'o', 'i', 'l'], ['l', 'o', 'g', 'i', 'a'], ['u', 'r', '_', 'a', 'n']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "3", "opt_solution": "[\"up-left\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.5282673835754395", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "25", "is_feasible_args": "[[[\"a\", \"s\", \"i\", \"u\", \"r\"], [\"m\", \"z\", \"n\", \"k\", \"y\"], [\"g\", \"i\", \"o\", \"i\", \"l\"], [\"l\", \"o\", \"g\", \"i\", \"a\"], [\"u\", \"r\", \"_\", \"a\", \"n\"]]]", "is_correct_args": "[[[\"a\", \"s\", \"i\", \"u\", \"r\"], [\"m\", \"z\", \"n\", \"k\", \"y\"], [\"g\", \"i\", \"o\", \"i\", \"l\"], [\"l\", \"o\", \"g\", \"i\", \"a\"], [\"u\", \"r\", \"_\", \"a\", \"n\"]], [\"sour\", \"mangy\", \"kizil\", \"logia\", \"urian\"]]", "A*_args": "[\"[['a', 's', 'i', 'u', 'r'], ['m', 'z', 'n', 'k', 'y'], ['g', 'i', 'o', 'i', 'l'], ['l', 'o', 'g', 'i', 'a'], ['u', 'r', '_', 'a', 'n']]\", \"['sour', 'mangy', 'kizil', 'logia', 'urian']\"]"}
{"diff_sorted_id": "90", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'F'. Our task is to visit city G and city R excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from R and G, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  C Z F U W T H Y P O A R I G B \nC 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 \nZ 0 0 0 0 0 0 0 1 0 0 0 1 1 0 0 \nF 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 \nU 1 0 1 0 0 0 1 1 0 1 1 0 0 0 1 \nW 1 1 1 0 0 0 0 1 0 0 0 1 0 1 0 \nT 0 0 0 0 0 0 0 1 0 0 1 1 0 1 0 \nH 0 0 1 0 1 1 0 0 1 1 0 1 1 1 0 \nY 0 1 1 0 0 0 0 0 0 0 0 0 0 1 0 \nP 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 \nO 0 0 1 0 0 0 0 0 0 0 1 1 0 1 0 \nA 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 \nR 1 1 0 1 0 0 0 0 1 0 0 0 1 1 1 \nI 1 0 0 1 0 0 0 1 0 1 0 0 0 0 0 \nG 1 0 0 1 0 1 1 0 0 0 0 0 1 0 0 \nB 0 0 0 0 0 1 0 0 0 0 0 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[\"F\", \"B\", \"T\", \"R\", \"G\", \"C\", \"R\", \"G\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.05848503112792969", "solution_depth": "8", "max_successor_states": "15", "num_vars_per_state": "18", "is_feasible_args": "[[[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0], [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0]], [\"C\", \"Z\", \"F\", \"U\", \"W\", \"T\", \"H\", \"Y\", \"P\", \"O\", \"A\", \"R\", \"I\", \"G\", \"B\"], \"G\", \"R\"]", "is_correct_args": "[[[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0], [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0]], [\"C\", \"Z\", \"F\", \"U\", \"W\", \"T\", \"H\", \"Y\", \"P\", \"O\", \"A\", \"R\", \"I\", \"G\", \"B\"], \"F\", \"G\", \"R\"]", "A*_args": "[\"[[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0], [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1], [1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0]]\", \"['C', 'Z', 'F', 'U', 'W', 'T', 'H', 'Y', 'P', 'O', 'A', 'R', 'I', 'G', 'B']\", \"['F']\", \"['G', 'R']\"]"}
{"diff_sorted_id": "90", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [45, 45, 40, 38, 26, 3, 3, 21, 3, 35, 24, 9, 43, 10, 19, 5, 21, 36, 15, 18, 13, 33, 42, 34, 6, 20, 38, 25, 42, 19, 32, 9, 31, 4, 4, 25, 30, 8], such that the sum of the chosen coins adds up to 453. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {13: 7, 9: 1, 38: 9, 19: 4, 31: 18, 25: 18, 40: 13, 4: 2, 15: 8, 45: 2, 10: 10, 20: 18, 5: 3, 35: 12, 30: 8, 8: 5, 21: 5, 43: 12, 32: 10, 6: 2, 24: 18, 3: 2, 33: 7, 42: 4, 36: 10, 34: 6, 26: 5, 18: 6}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "20", "opt_solution": "[9, 9, 19, 45, 42, 38, 45, 42, 34, 26, 33, 43, 38, 30]", "opt_solution_cost": "74", "opt_solution_compute_t": "0.07263016700744629", "solution_depth": "14", "max_successor_states": "38", "num_vars_per_state": "38", "is_feasible_args": "[[45, 45, 40, 38, 26, 3, 3, 21, 3, 35, 24, 9, 43, 10, 19, 5, 21, 36, 15, 18, 13, 33, 42, 34, 6, 20, 38, 25, 42, 19, 32, 9, 31, 4, 4, 25, 30, 8]]", "is_correct_args": "[[45, 45, 40, 38, 26, 3, 3, 21, 3, 35, 24, 9, 43, 10, 19, 5, 21, 36, 15, 18, 13, 33, 42, 34, 6, 20, 38, 25, 42, 19, 32, 9, 31, 4, 4, 25, 30, 8], {\"13\": 7, \"9\": 1, \"38\": 9, \"19\": 4, \"31\": 18, \"25\": 18, \"40\": 13, \"4\": 2, \"15\": 8, \"45\": 2, \"10\": 10, \"20\": 18, \"5\": 3, \"35\": 12, \"30\": 8, \"8\": 5, \"21\": 5, \"43\": 12, \"32\": 10, \"6\": 2, \"24\": 18, \"3\": 2, \"33\": 7, \"42\": 4, \"36\": 10, \"34\": 6, \"26\": 5, \"18\": 6}, 453]", "A*_args": "[\"[45, 45, 40, 38, 26, 3, 3, 21, 3, 35, 24, 9, 43, 10, 19, 5, 21, 36, 15, 18, 13, 33, 42, 34, 6, 20, 38, 25, 42, 19, 32, 9, 31, 4, 4, 25, 30, 8]\", \"{13: 7, 9: 1, 38: 9, 19: 4, 31: 18, 25: 18, 40: 13, 4: 2, 15: 8, 45: 2, 10: 10, 20: 18, 5: 3, 35: 12, 30: 8, 8: 5, 21: 5, 43: 12, 32: 10, 6: 2, 24: 18, 3: 2, 33: 7, 42: 4, 36: 10, 34: 6, 26: 5, 18: 6}\", \"453\"]"}
{"diff_sorted_id": "90", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Green', 'Red', 'Green', 'Red', 'Red'], ['Green', 'Red', 'Blue', 'Blue', 'Red', 'Blue'], ['Blue', 'Green', 'Blue', 'Blue', 'Red', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[0, 1], [0, 1], [2, 0], [2, 1], [2, 0], [2, 0], [2, 0], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [0, 2], [1, 0], [1, 0], [1, 2], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [2, 0], [2, 0], [2, 0], [1, 2], [1, 0]]", "opt_solution_cost": "28", "opt_solution_compute_t": "211.78803420066833", "solution_depth": "28", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Green\", \"Green\", \"Red\", \"Green\", \"Red\", \"Red\"], [\"Green\", \"Red\", \"Blue\", \"Blue\", \"Red\", \"Blue\"], [\"Blue\", \"Green\", \"Blue\", \"Blue\", \"Red\", \"Green\"]], 9]", "is_correct_args": "[[[\"Green\", \"Green\", \"Red\", \"Green\", \"Red\", \"Red\"], [\"Green\", \"Red\", \"Blue\", \"Blue\", \"Red\", \"Blue\"], [\"Blue\", \"Green\", \"Blue\", \"Blue\", \"Red\", \"Green\"]], 9]", "A*_args": "[\"[['Green', 'Green', 'Red', 'Green', 'Red', 'Red'], ['Green', 'Red', 'Blue', 'Blue', 'Red', 'Blue'], ['Blue', 'Green', 'Blue', 'Blue', 'Red', 'Green']]\", \"9\"]"}
{"diff_sorted_id": "90", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 18 to 68 (18 included in the range but 68 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['20' 'x' '34' 'x']\n ['x' 'x' '43' 'x']\n ['x' 'x' '48' 'x']\n ['65' 'x' 'x' '48']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "15", "opt_solution": "[[0, 3, 90], [1, 0, 46], [1, 2, 69], [2, 1, 66], [2, 2, 67], [2, 3, 68], [3, 0, 86], [3, 2, 43], [3, 3, 42]]", "opt_solution_cost": "787", "opt_solution_compute_t": "36.04757237434387", "solution_depth": "9", "max_successor_states": "50", "num_vars_per_state": "16", "is_feasible_args": "[\"[['45', '60', '89', ''], ['', '65', '', '84'], ['55', '', '', ''], ['', '85', '', '']]\", 42, 97]", "is_correct_args": "[\"[['45', '60', '89', ''], ['', '65', '', '84'], ['55', '', '', ''], ['', '85', '', '']]\", 42, 97]", "A*_args": "[\"[['45', '60', '89', ''], ['', '65', '', '84'], ['55', '', '', ''], ['', '85', '', '']]\", \"42\", \"97\"]"}
{"diff_sorted_id": "90", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 22 to 68. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 143, 170, None for columns 1 to 2 respectively, and the sums of rows must be None, 211, 161, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 146. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' '32' 'x']\n ['37' '61' 'x' '54']\n ['x' 'x' 'x' '62']\n ['x' '30' 'x' '44']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 22], [0, 1, 23], [0, 3, 27], [1, 2, 59], [2, 0, 24], [2, 1, 29], [2, 2, 46], [3, 0, 31], [3, 2, 33]]", "opt_solution_cost": "614", "opt_solution_compute_t": "16.494971752166748", "solution_depth": "9", "max_successor_states": "36", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '32', ''], ['37', '61', '', '54'], ['', '', '', '62'], ['', '30', '', '44']]\", 4, 22, 68]", "is_correct_args": "[\"[['', '', '32', ''], ['37', '61', '', '54'], ['', '', '', '62'], ['', '30', '', '44']]\", 22, 68, [1, 3], [1, 3], [143, 170], [211, 161], 146]", "A*_args": "[\"[['', '', '32', ''], ['37', '61', '', '54'], ['', '', '', '62'], ['', '30', '', '44']]\", \"22\", \"68\", \"[None, 143, 170, None]\", \"[None, 211, 161, None]\", \"146\"]"}
{"diff_sorted_id": "90", "problem_statement": "In 'Restricted Sorting', there are 12 stacks each with a capacity of 7 blocks, with 6 stacks filled with blocks of varying shades and the remaining are empty. The challenge is to sort the blocks by shade such that if a stack is not empty, it is stacked with 6 blocks of a single shade. The player can only transfer one block at a time from the top of a stack to an empty stack or to a stack that has only blocks of that shade, without exceeding the stacks\u2019 capacity. Transferring blocks to certain stacks is more expensive than others. The cost of moving one block to the top of each stack is: {0: 2, 1: 7, 2: 2, 3: 2, 4: 4, 5: 13, 6: 4, 7: 6, 8: 8, 9: 6, 10: 10, 11: 10}, where the keys are the index of each stack, indexing from 0. The cost of moving a block is always at least 1. The solution should be a list of tuples, each containing, first, the index of the stack from which a block is picked up from and, second, the index of the stack to which it is transferred, indexing from 0. Given the initial state of the stacks, represented by the lists below (with the leftmost item being the shade of the topmost block in each stack)(and the first stack being the stack at index 0), what is the list of transfer pairs (reported in python syntax) with the least possible cost, that will result in all the blocks being correctly sorted? [['Pink', 'Black', 'Red', 'White', 'White', 'Black', 'Pink'], [], [], ['Green', 'Green', 'Blue', 'White', 'Pink', 'Pink', 'White'], [], ['Blue', 'Yellow', 'Yellow', 'Black', 'White', 'Green', 'Red'], ['Blue', 'Yellow', 'Blue', 'White', 'Green', 'Red', 'Pink'], ['Pink', 'Yellow', 'Yellow', 'Green', 'Green', 'Black', 'Blue'], [], ['Blue', 'Red', 'Red', 'Black', 'Black', 'Red', 'Yellow'], [], []]", "problem_type": "restricted_sorting", "problem_category": "sorting", "relative_diff_score": "4", "opt_solution": "[[3, 2], [3, 2], [3, 4], [5, 4], [9, 4], [0, 1], [7, 1], [7, 8], [7, 8], [6, 4], [6, 8], [6, 4], [0, 10], [0, 11], [5, 8], [5, 8], [5, 10], [7, 2], [7, 2], [7, 10], [7, 4], [3, 7], [5, 7], [5, 2], [6, 7], [6, 2], [3, 1], [3, 1], [0, 7], [0, 7], [3, 7], [0, 3], [0, 1], [6, 0], [9, 0], [9, 0], [9, 3], [9, 3], [9, 0], [9, 8], [6, 1], [5, 0], [10, 3], [10, 3], [10, 3], [11, 0]]", "opt_solution_cost": "226", "opt_solution_compute_t": "9.712183237075806", "solution_depth": "46", "max_successor_states": "132", "num_vars_per_state": "42", "is_feasible_args": "[[[\"Pink\", \"Black\", \"Red\", \"White\", \"White\", \"Black\", \"Pink\"], [], [], [\"Green\", \"Green\", \"Blue\", \"White\", \"Pink\", \"Pink\", \"White\"], [], [\"Blue\", \"Yellow\", \"Yellow\", \"Black\", \"White\", \"Green\", \"Red\"], [\"Blue\", \"Yellow\", \"Blue\", \"White\", \"Green\", \"Red\", \"Pink\"], [\"Pink\", \"Yellow\", \"Yellow\", \"Green\", \"Green\", \"Black\", \"Blue\"], [], [\"Blue\", \"Red\", \"Red\", \"Black\", \"Black\", \"Red\", \"Yellow\"], [], []], 7, {\"0\": 2, \"1\": 7, \"2\": 2, \"3\": 2, \"4\": 4, \"5\": 13, \"6\": 4, \"7\": 6, \"8\": 8, \"9\": 6, \"10\": 10, \"11\": 10}]", "is_correct_args": "[[[\"Pink\", \"Black\", \"Red\", \"White\", \"White\", \"Black\", \"Pink\"], [], [], [\"Green\", \"Green\", \"Blue\", \"White\", \"Pink\", \"Pink\", \"White\"], [], [\"Blue\", \"Yellow\", \"Yellow\", \"Black\", \"White\", \"Green\", \"Red\"], [\"Blue\", \"Yellow\", \"Blue\", \"White\", \"Green\", \"Red\", \"Pink\"], [\"Pink\", \"Yellow\", \"Yellow\", \"Green\", \"Green\", \"Black\", \"Blue\"], [], [\"Blue\", \"Red\", \"Red\", \"Black\", \"Black\", \"Red\", \"Yellow\"], [], []], 7, {\"0\": 2, \"1\": 7, \"2\": 2, \"3\": 2, \"4\": 4, \"5\": 13, \"6\": 4, \"7\": 6, \"8\": 8, \"9\": 6, \"10\": 10, \"11\": 10}, 6]", "A*_args": "[\"[['Pink', 'Black', 'Red', 'White', 'White', 'Black', 'Pink'], [], [], ['Green', 'Green', 'Blue', 'White', 'Pink', 'Pink', 'White'], [], ['Blue', 'Yellow', 'Yellow', 'Black', 'White', 'Green', 'Red'], ['Blue', 'Yellow', 'Blue', 'White', 'Green', 'Red', 'Pink'], ['Pink', 'Yellow', 'Yellow', 'Green', 'Green', 'Black', 'Blue'], [], ['Blue', 'Red', 'Red', 'Black', 'Black', 'Red', 'Yellow'], [], []]\", \"{0: 2, 1: 7, 2: 2, 3: 2, 4: 4, 5: 13, 6: 4, 7: 6, 8: 8, 9: 6, 10: 10, 11: 10}\", \"7\", \"6\"]"}
{"diff_sorted_id": "90", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (6, 0) to his destination workshop at index (4, 13), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 4, district 2 covering rows 5 to 6, and district 3 covering rows 7 to 13. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x x x x x x x x 15 x x 19 1]\n[x 12 x 19 x x 13 x 14 13 8 x 1 6]\n[x 17 x 19 5 4 x x 12 x x 10 14 x]\n[x 18 x 1 x 14 x x 12 x 11 4 4 7]\n[2 15 x x x 14 x 16 5 2 4 x 10 2]\n[8 2 15 18 19 6 13 7 6 x x x 1 x]\n[5 x 11 2 8 8 x 1 10 8 13 7 12 18]\n[x 18 8 19 x x 16 11 2 x 9 x 9 8]\n[4 10 x 12 12 13 13 2 13 x x x 8 18]\n[1 x x x 5 12 18 16 5 17 x 16 11 18]\n[19 x x x x 1 x x x x 10 19 x x]\n[x 14 x x x 15 16 9 x x x x x x]\n[6 x 16 18 6 x 18 x 5 x x x 6 1]\n[x x x 17 4 x 6 x x 19 17 x 19 15]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "6", "opt_solution": "[[6, 0], [5, 0], [5, 1], [5, 2], [6, 2], [7, 2], [6, 2], [6, 3], [6, 4], [6, 5], [5, 5], [5, 6], [5, 7], [5, 8], [4, 8], [4, 9], [4, 10], [3, 10], [3, 11], [3, 12], [3, 13], [4, 13]]", "opt_solution_cost": "144", "opt_solution_compute_t": "0.032550811767578125", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\", \"x\", \"19\", \"1\"], [\"x\", \"12\", \"x\", \"19\", \"x\", \"x\", \"13\", \"x\", \"14\", \"13\", \"8\", \"x\", \"1\", \"6\"], [\"x\", \"17\", \"x\", \"19\", \"5\", \"4\", \"x\", \"x\", \"12\", \"x\", \"x\", \"10\", \"14\", \"x\"], [\"x\", \"18\", \"x\", \"1\", \"x\", \"14\", \"x\", \"x\", \"12\", \"x\", \"11\", \"4\", \"4\", \"7\"], [\"2\", \"15\", \"x\", \"x\", \"x\", \"14\", \"x\", \"16\", \"5\", \"2\", \"4\", \"x\", \"10\", \"2\"], [\"8\", \"2\", \"15\", \"18\", \"19\", \"6\", \"13\", \"7\", \"6\", \"x\", \"x\", \"x\", \"1\", \"x\"], [\"5\", \"x\", \"11\", \"2\", \"8\", \"8\", \"x\", \"1\", \"10\", \"8\", \"13\", \"7\", \"12\", \"18\"], [\"x\", \"18\", \"8\", \"19\", \"x\", \"x\", \"16\", \"11\", \"2\", \"x\", \"9\", \"x\", \"9\", \"8\"], [\"4\", \"10\", \"x\", \"12\", \"12\", \"13\", \"13\", \"2\", \"13\", \"x\", \"x\", \"x\", \"8\", \"18\"], [\"1\", \"x\", \"x\", \"x\", \"5\", \"12\", \"18\", \"16\", \"5\", \"17\", \"x\", \"16\", \"11\", \"18\"], [\"19\", \"x\", \"x\", \"x\", \"x\", \"1\", \"x\", \"x\", \"x\", \"x\", \"10\", \"19\", \"x\", \"x\"], [\"x\", \"14\", \"x\", \"x\", \"x\", \"15\", \"16\", \"9\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"6\", \"x\", \"16\", \"18\", \"6\", \"x\", \"18\", \"x\", \"5\", \"x\", \"x\", \"x\", \"6\", \"1\"], [\"x\", \"x\", \"x\", \"17\", \"4\", \"x\", \"6\", \"x\", \"x\", \"19\", \"17\", \"x\", \"19\", \"15\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\", \"x\", \"19\", \"1\"], [\"x\", \"12\", \"x\", \"19\", \"x\", \"x\", \"13\", \"x\", \"14\", \"13\", \"8\", \"x\", \"1\", \"6\"], [\"x\", \"17\", \"x\", \"19\", \"5\", \"4\", \"x\", \"x\", \"12\", \"x\", \"x\", \"10\", \"14\", \"x\"], [\"x\", \"18\", \"x\", \"1\", \"x\", \"14\", \"x\", \"x\", \"12\", \"x\", \"11\", \"4\", \"4\", \"7\"], [\"2\", \"15\", \"x\", \"x\", \"x\", \"14\", \"x\", \"16\", \"5\", \"2\", \"4\", \"x\", \"10\", \"2\"], [\"8\", \"2\", \"15\", \"18\", \"19\", \"6\", \"13\", \"7\", \"6\", \"x\", \"x\", \"x\", \"1\", \"x\"], [\"5\", \"x\", \"11\", \"2\", \"8\", \"8\", \"x\", \"1\", \"10\", \"8\", \"13\", \"7\", \"12\", \"18\"], [\"x\", \"18\", \"8\", \"19\", \"x\", \"x\", \"16\", \"11\", \"2\", \"x\", \"9\", \"x\", \"9\", \"8\"], [\"4\", \"10\", \"x\", \"12\", \"12\", \"13\", \"13\", \"2\", \"13\", \"x\", \"x\", \"x\", \"8\", \"18\"], [\"1\", \"x\", \"x\", \"x\", \"5\", \"12\", \"18\", \"16\", \"5\", \"17\", \"x\", \"16\", \"11\", \"18\"], [\"19\", \"x\", \"x\", \"x\", \"x\", \"1\", \"x\", \"x\", \"x\", \"x\", \"10\", \"19\", \"x\", \"x\"], [\"x\", \"14\", \"x\", \"x\", \"x\", \"15\", \"16\", \"9\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"6\", \"x\", \"16\", \"18\", \"6\", \"x\", \"18\", \"x\", \"5\", \"x\", \"x\", \"x\", \"6\", \"1\"], [\"x\", \"x\", \"x\", \"17\", \"4\", \"x\", \"6\", \"x\", \"x\", \"19\", \"17\", \"x\", \"19\", \"15\"]], [6, 0], [4, 13], 4, 6]", "A*_args": "[\"[['x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', '15', 'x', 'x', '19', '1'], ['x', '12', 'x', '19', 'x', 'x', '13', 'x', '14', '13', '8', 'x', '1', '6'], ['x', '17', 'x', '19', '5', '4', 'x', 'x', '12', 'x', 'x', '10', '14', 'x'], ['x', '18', 'x', '1', 'x', '14', 'x', 'x', '12', 'x', '11', '4', '4', '7'], ['2', '15', 'x', 'x', 'x', '14', 'x', '16', '5', '2', '4', 'x', '10', '2'], ['8', '2', '15', '18', '19', '6', '13', '7', '6', 'x', 'x', 'x', '1', 'x'], ['5', 'x', '11', '2', '8', '8', 'x', '1', '10', '8', '13', '7', '12', '18'], ['x', '18', '8', '19', 'x', 'x', '16', '11', '2', 'x', '9', 'x', '9', '8'], ['4', '10', 'x', '12', '12', '13', '13', '2', '13', 'x', 'x', 'x', '8', '18'], ['1', 'x', 'x', 'x', '5', '12', '18', '16', '5', '17', 'x', '16', '11', '18'], ['19', 'x', 'x', 'x', 'x', '1', 'x', 'x', 'x', 'x', '10', '19', 'x', 'x'], ['x', '14', 'x', 'x', 'x', '15', '16', '9', 'x', 'x', 'x', 'x', 'x', 'x'], ['6', 'x', '16', '18', '6', 'x', '18', 'x', '5', 'x', 'x', 'x', '6', '1'], ['x', 'x', 'x', '17', '4', 'x', '6', 'x', 'x', '19', '17', 'x', '19', '15']]\", \"(6, 0)\", \"(4, 13)\", \"4\", \"6\"]"}
{"diff_sorted_id": "90", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 14x14. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 4 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (12, 11) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (0, 4). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 1 0 0 0 0 0 0 1 0 0 1\n0 1 0 1 1 1 1 0 0 0 0 0 0 0\n1 0 0 0 1 1 1 0 1 1 1 1 0 0\n1 1 1 0 0 1 0 1 0 1 0 0 0 1\n0 1 1 1 1 0 0 1 0 1 1 1 0 0\n0 1 0 0 0 0 0 1 1 0 0 0 0 1\n0 0 1 0 0 1 0 1 0 1 0 0 0 0\n1 1 0 1 1 0 0 1 1 0 1 0 1 1\n0 1 1 0 0 1 1 1 0 0 1 0 1 1\n0 0 0 1 1 0 0 1 1 1 1 0 0 1\n1 0 1 1 1 0 1 0 0 1 0 0 1 0\n1 0 0 1 0 1 0 1 1 0 1 0 0 0\n1 1 0 1 0 1 0 1 0 1 1 0 0 0\n0 0 1 1 1 1 1 1 0 1 0 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "14", "opt_solution": "[[12, 11], [11, 11], [10, 11], [9, 11], [8, 11], [7, 11], [6, 10], [5, 9], [4, 8], [3, 8], [2, 7], [1, 7], [0, 7], [0, 6], [0, 5], [0, 4]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.030002355575561523", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0], [1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1], [0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1], [0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1], [0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0], [1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1]]\", 4]", "is_correct_args": "[\"[[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0], [1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1], [0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1], [0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1], [0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0], [1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1]]\", [12, 11], [0, 4], 4]", "A*_args": "[\"[[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0], [1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1], [0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0], [1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1], [0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1], [0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0], [1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1]]\", \"(12, 11)\", \"(0, 4)\", \"4\"]"}
{"diff_sorted_id": "90", "problem_statement": "Given 7 labeled water jugs with capacities 88, 125, 100, 62, 134, 89, 33, 133 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 306, 407, 457, 518 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "6", "opt_solution": "[[\"+\", 125, 4], [\"+\", 125, 4], [\"+\", 134, 4], [\"+\", 134, 4], [\"+\", 89, 3], [\"+\", 100, 3], [\"+\", 134, 3], [\"+\", 134, 3], [\"+\", 133, 2], [\"+\", 133, 2], [\"+\", 133, 2], [\"-\", 125, 2], [\"+\", 133, 2], [\"+\", 89, 1], [\"+\", 125, 1], [\"-\", 33, 1], [\"+\", 125, 1]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.05500078201293945", "solution_depth": "17", "max_successor_states": "64", "num_vars_per_state": "3", "is_feasible_args": "[[88, 125, 100, 62, 134, 89, 33, 133], [306, 407, 457, 518]]", "is_correct_args": "[[88, 125, 100, 62, 134, 89, 33, 133], [306, 407, 457, 518]]", "A*_args": "[\"[88, 125, 100, 62, 134, 89, 33, 133]\", \"[306, 407, 457, 518]\"]"}
{"diff_sorted_id": "91", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[93, 81, 68, 57, 28, 6], [55, 54, 58, 69, 38, 10], [21, '_', 19, 44, 51, 18]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[19, 44, 51, 18, 10, 6, 28, 57, 68, 58, 69, 68, 58, 69, 44, 51, 18, 10, 6, 28, 57, 58, 68, 44, 51, 18, 10, 6]", "opt_solution_cost": "28", "opt_solution_compute_t": "0.08781838417053223", "solution_depth": "28", "max_successor_states": "4", "num_vars_per_state": "18", "is_feasible_args": "[[[93, 81, 68, 57, 28, 6], [55, 54, 58, 69, 38, 10], [21, \"_\", 19, 44, 51, 18]]]", "is_correct_args": "[[[93, 81, 68, 57, 28, 6], [55, 54, 58, 69, 38, 10], [21, \"_\", 19, 44, 51, 18]]]", "A*_args": "[\"[[93, 81, 68, 57, 28, 6], [55, 54, 58, 69, 38, 10], [21, '_', 19, 44, 51, 18]]\"]"}
{"diff_sorted_id": "91", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: peppy, stocky, pistol, swathe, cancan   The initial board: [['t', 'p', 'c', 'p', 'o', 'y'], ['s', 'e', 'o', 't', 'k', 's'], ['p', 'i', 'w', 't', '_', 'l'], ['s', 'n', 'a', 'y', 'h', 'a'], ['c', 'a', 'e', 'c', 'p', 'n']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[\"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.4025259017944336", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "30", "is_feasible_args": "[[[\"t\", \"p\", \"c\", \"p\", \"o\", \"y\"], [\"s\", \"e\", \"o\", \"t\", \"k\", \"s\"], [\"p\", \"i\", \"w\", \"t\", \"_\", \"l\"], [\"s\", \"n\", \"a\", \"y\", \"h\", \"a\"], [\"c\", \"a\", \"e\", \"c\", \"p\", \"n\"]]]", "is_correct_args": "[[[\"t\", \"p\", \"c\", \"p\", \"o\", \"y\"], [\"s\", \"e\", \"o\", \"t\", \"k\", \"s\"], [\"p\", \"i\", \"w\", \"t\", \"_\", \"l\"], [\"s\", \"n\", \"a\", \"y\", \"h\", \"a\"], [\"c\", \"a\", \"e\", \"c\", \"p\", \"n\"]], [\"peppy\", \"stocky\", \"pistol\", \"swathe\", \"cancan\"]]", "A*_args": "[\"[['t', 'p', 'c', 'p', 'o', 'y'], ['s', 'e', 'o', 't', 'k', 's'], ['p', 'i', 'w', 't', '_', 'l'], ['s', 'n', 'a', 'y', 'h', 'a'], ['c', 'a', 'e', 'c', 'p', 'n']]\", \"['peppy', 'stocky', 'pistol', 'swathe', 'cancan']\"]"}
{"diff_sorted_id": "91", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'A'. Our task is to visit city G and city O excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from O and G, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  O F U W T Y A Z S G X H D M Q \nO 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 \nF 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \nU 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 \nW 0 0 0 0 0 1 0 0 1 1 0 0 0 0 0 \nT 1 0 0 0 0 0 1 0 0 1 0 1 0 0 1 \nY 0 0 1 0 1 0 1 0 1 0 0 1 0 0 0 \nA 0 0 0 0 0 0 0 1 0 0 0 1 0 0 0 \nZ 0 0 0 1 0 0 0 0 0 0 0 0 0 1 0 \nS 0 0 0 0 1 0 1 0 0 0 0 0 1 0 1 \nG 0 1 0 0 1 1 0 1 1 0 1 0 0 0 1 \nX 0 0 0 0 1 1 0 1 0 1 0 0 0 1 0 \nH 0 0 0 0 0 0 0 1 1 0 0 0 1 0 0 \nD 1 1 1 1 1 0 0 0 0 1 0 0 0 0 0 \nM 0 1 0 1 0 0 0 0 1 1 0 0 0 0 0 \nQ 0 0 1 1 0 0 0 1 0 0 0 0 1 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[\"A\", \"H\", \"D\", \"G\", \"T\", \"O\", \"F\", \"O\", \"M\", \"G\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.059241533279418945", "solution_depth": "10", "max_successor_states": "15", "num_vars_per_state": "18", "is_feasible_args": "[[[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [\"O\", \"F\", \"U\", \"W\", \"T\", \"Y\", \"A\", \"Z\", \"S\", \"G\", \"X\", \"H\", \"D\", \"M\", \"Q\"], \"G\", \"O\"]", "is_correct_args": "[[[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]], [\"O\", \"F\", \"U\", \"W\", \"T\", \"Y\", \"A\", \"Z\", \"S\", \"G\", \"X\", \"H\", \"D\", \"M\", \"Q\"], \"A\", \"G\", \"O\"]", "A*_args": "[\"[[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1], [0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0]]\", \"['O', 'F', 'U', 'W', 'T', 'Y', 'A', 'Z', 'S', 'G', 'X', 'H', 'D', 'M', 'Q']\", \"['A']\", \"['G', 'O']\"]"}
{"diff_sorted_id": "91", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [36, 40, 17, 7, 15, 23, 18, 26, 29, 24, 15, 43, 13, 12, 31, 33, 30, 31, 26, 37, 14, 31, 43, 25, 30, 7, 37, 27, 221, 13, 26, 21], such that the sum of the chosen coins adds up to 445. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {36: 14, 27: 19, 21: 6, 13: 8, 23: 17, 26: 17, 15: 6, 25: 7, 31: 20, 30: 5, 18: 14, 12: 6, 37: 2, 221: 18, 14: 13, 24: 10, 33: 4, 43: 11, 29: 18, 40: 1, 7: 6, 17: 2}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "21", "opt_solution": "[17, 33, 37, 37, 30, 221, 40, 30]", "opt_solution_cost": "39", "opt_solution_compute_t": "0.04606795310974121", "solution_depth": "8", "max_successor_states": "32", "num_vars_per_state": "32", "is_feasible_args": "[[36, 40, 17, 7, 15, 23, 18, 26, 29, 24, 15, 43, 13, 12, 31, 33, 30, 31, 26, 37, 14, 31, 43, 25, 30, 7, 37, 27, 221, 13, 26, 21]]", "is_correct_args": "[[36, 40, 17, 7, 15, 23, 18, 26, 29, 24, 15, 43, 13, 12, 31, 33, 30, 31, 26, 37, 14, 31, 43, 25, 30, 7, 37, 27, 221, 13, 26, 21], {\"36\": 14, \"27\": 19, \"21\": 6, \"13\": 8, \"23\": 17, \"26\": 17, \"15\": 6, \"25\": 7, \"31\": 20, \"30\": 5, \"18\": 14, \"12\": 6, \"37\": 2, \"221\": 18, \"14\": 13, \"24\": 10, \"33\": 4, \"43\": 11, \"29\": 18, \"40\": 1, \"7\": 6, \"17\": 2}, 445]", "A*_args": "[\"[36, 40, 17, 7, 15, 23, 18, 26, 29, 24, 15, 43, 13, 12, 31, 33, 30, 31, 26, 37, 14, 31, 43, 25, 30, 7, 37, 27, 221, 13, 26, 21]\", \"{36: 14, 27: 19, 21: 6, 13: 8, 23: 17, 26: 17, 15: 6, 25: 7, 31: 20, 30: 5, 18: 14, 12: 6, 37: 2, 221: 18, 14: 13, 24: 10, 33: 4, 43: 11, 29: 18, 40: 1, 7: 6, 17: 2}\", \"445\"]"}
{"diff_sorted_id": "91", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Blue', 'Red', 'Blue', 'Blue'], ['Red', 'Blue', 'Green', 'Green', 'Blue', 'Red'], ['Green', 'Green', 'Red', 'Blue', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[0, 1], [2, 0], [2, 0], [2, 1], [2, 0], [2, 0], [1, 2], [1, 2], [1, 2], [0, 2], [0, 2], [1, 2], [1, 0], [1, 0], [1, 2], [1, 2], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [2, 1], [0, 2], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [1, 2], [1, 2], [0, 1]]", "opt_solution_cost": "32", "opt_solution_compute_t": "75.25922632217407", "solution_depth": "32", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Red\", \"Green\", \"Blue\", \"Red\", \"Blue\", \"Blue\"], [\"Red\", \"Blue\", \"Green\", \"Green\", \"Blue\", \"Red\"], [\"Green\", \"Green\", \"Red\", \"Blue\", \"Green\", \"Red\"]], 9]", "is_correct_args": "[[[\"Red\", \"Green\", \"Blue\", \"Red\", \"Blue\", \"Blue\"], [\"Red\", \"Blue\", \"Green\", \"Green\", \"Blue\", \"Red\"], [\"Green\", \"Green\", \"Red\", \"Blue\", \"Green\", \"Red\"]], 9]", "A*_args": "[\"[['Red', 'Green', 'Blue', 'Red', 'Blue', 'Blue'], ['Red', 'Blue', 'Green', 'Green', 'Blue', 'Red'], ['Green', 'Green', 'Red', 'Blue', 'Green', 'Red']]\", \"9\"]"}
{"diff_sorted_id": "91", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 10 to 65 (10 included in the range but 65 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['x' '21' 'x' 'x']\n ['18' '27' 'x' '51']\n ['24' '29' 'x' 'x']\n ['54' '33' '25' '12']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "11", "opt_solution": "[[0, 0, 18], [0, 1, 19], [0, 3, 39], [1, 0, 17], [1, 1, 20], [1, 3, 40], [2, 1, 21], [3, 1, 22], [3, 2, 23]]", "opt_solution_cost": "410", "opt_solution_compute_t": "5.110289812088013", "solution_depth": "9", "max_successor_states": "55", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '38', ''], ['', '', '33', ''], ['16', '', '28', '47'], ['14', '', '', '52']]\", 14, 69]", "is_correct_args": "[\"[['', '', '38', ''], ['', '', '33', ''], ['16', '', '28', '47'], ['14', '', '', '52']]\", 14, 69]", "A*_args": "[\"[['', '', '38', ''], ['', '', '33', ''], ['16', '', '28', '47'], ['14', '', '', '52']]\", \"14\", \"69\"]"}
{"diff_sorted_id": "91", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 22 to 68. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 177, 192, None for columns 1 to 2 respectively, and the sums of rows must be None, 217, 193, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 149. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['62' 'x' 'x' 'x']\n ['x' '35' '60' 'x']\n ['x' '39' 'x' '54']\n ['x' '55' '34' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 1, 48], [0, 2, 31], [0, 3, 23], [1, 0, 56], [1, 3, 66], [2, 0, 33], [2, 2, 67], [3, 0, 27], [3, 3, 22]]", "opt_solution_cost": "712", "opt_solution_compute_t": "5.191744089126587", "solution_depth": "9", "max_successor_states": "36", "num_vars_per_state": "16", "is_feasible_args": "[\"[['62', '', '', ''], ['', '35', '60', ''], ['', '39', '', '54'], ['', '55', '34', '']]\", 4, 22, 68]", "is_correct_args": "[\"[['62', '', '', ''], ['', '35', '60', ''], ['', '39', '', '54'], ['', '55', '34', '']]\", 22, 68, [1, 3], [1, 3], [177, 192], [217, 193], 149]", "A*_args": "[\"[['62', '', '', ''], ['', '35', '60', ''], ['', '39', '', '54'], ['', '55', '34', '']]\", \"22\", \"68\", \"[None, 177, 192, None]\", \"[None, 217, 193, None]\", \"149\"]"}
{"diff_sorted_id": "91", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (5, 2) to his destination workshop at index (8, 14), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 5, district 2 covering rows 6 to 7, and district 3 covering rows 8 to 14. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x 12 x 18 3 2 15 6 11 13 x 7 17 x]\n[13 x 20 13 5 2 x x 10 12 19 19 16 x 17]\n[12 12 7 x x x 9 x x 10 10 18 4 x x]\n[x 14 3 13 9 2 19 19 x x x 4 x 2 15]\n[x 14 2 x 3 x 10 11 x 4 x 12 4 x x]\n[x 9 7 16 x x 19 17 17 14 14 12 14 19 12]\n[2 x x 7 15 x x 13 x 8 1 1 x 14 19]\n[16 x 14 x x 6 x x 16 x x 9 10 18 4]\n[3 x x 3 x x x x 9 8 x 9 14 x 14]\n[x x x 4 19 x 4 15 x x x 17 x x x]\n[16 17 x x 13 x 18 5 x 14 x x x x x]\n[2 x 17 x x x x x x 12 3 8 x 2 9]\n[x x 14 7 11 x x 10 9 3 7 16 x 7 1]\n[x 12 14 1 x x 3 12 x 7 x x 8 x x]\n[x 2 x 15 2 x 14 16 13 19 16 1 11 x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "7", "opt_solution": "[[5, 2], [4, 2], [3, 2], [3, 3], [3, 4], [3, 5], [3, 6], [4, 6], [4, 7], [5, 7], [5, 8], [5, 9], [6, 9], [6, 10], [6, 11], [7, 11], [7, 12], [7, 13], [7, 14], [8, 14]]", "opt_solution_cost": "182", "opt_solution_compute_t": "0.028976917266845703", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"12\", \"x\", \"18\", \"3\", \"2\", \"15\", \"6\", \"11\", \"13\", \"x\", \"7\", \"17\", \"x\"], [\"13\", \"x\", \"20\", \"13\", \"5\", \"2\", \"x\", \"x\", \"10\", \"12\", \"19\", \"19\", \"16\", \"x\", \"17\"], [\"12\", \"12\", \"7\", \"x\", \"x\", \"x\", \"9\", \"x\", \"x\", \"10\", \"10\", \"18\", \"4\", \"x\", \"x\"], [\"x\", \"14\", \"3\", \"13\", \"9\", \"2\", \"19\", \"19\", \"x\", \"x\", \"x\", \"4\", \"x\", \"2\", \"15\"], [\"x\", \"14\", \"2\", \"x\", \"3\", \"x\", \"10\", \"11\", \"x\", \"4\", \"x\", \"12\", \"4\", \"x\", \"x\"], [\"x\", \"9\", \"7\", \"16\", \"x\", \"x\", \"19\", \"17\", \"17\", \"14\", \"14\", \"12\", \"14\", \"19\", \"12\"], [\"2\", \"x\", \"x\", \"7\", \"15\", \"x\", \"x\", \"13\", \"x\", \"8\", \"1\", \"1\", \"x\", \"14\", \"19\"], [\"16\", \"x\", \"14\", \"x\", \"x\", \"6\", \"x\", \"x\", \"16\", \"x\", \"x\", \"9\", \"10\", \"18\", \"4\"], [\"3\", \"x\", \"x\", \"3\", \"x\", \"x\", \"x\", \"x\", \"9\", \"8\", \"x\", \"9\", \"14\", \"x\", \"14\"], [\"x\", \"x\", \"x\", \"4\", \"19\", \"x\", \"4\", \"15\", \"x\", \"x\", \"x\", \"17\", \"x\", \"x\", \"x\"], [\"16\", \"17\", \"x\", \"x\", \"13\", \"x\", \"18\", \"5\", \"x\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"2\", \"x\", \"17\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"12\", \"3\", \"8\", \"x\", \"2\", \"9\"], [\"x\", \"x\", \"14\", \"7\", \"11\", \"x\", \"x\", \"10\", \"9\", \"3\", \"7\", \"16\", \"x\", \"7\", \"1\"], [\"x\", \"12\", \"14\", \"1\", \"x\", \"x\", \"3\", \"12\", \"x\", \"7\", \"x\", \"x\", \"8\", \"x\", \"x\"], [\"x\", \"2\", \"x\", \"15\", \"2\", \"x\", \"14\", \"16\", \"13\", \"19\", \"16\", \"1\", \"11\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"12\", \"x\", \"18\", \"3\", \"2\", \"15\", \"6\", \"11\", \"13\", \"x\", \"7\", \"17\", \"x\"], [\"13\", \"x\", \"20\", \"13\", \"5\", \"2\", \"x\", \"x\", \"10\", \"12\", \"19\", \"19\", \"16\", \"x\", \"17\"], [\"12\", \"12\", \"7\", \"x\", \"x\", \"x\", \"9\", \"x\", \"x\", \"10\", \"10\", \"18\", \"4\", \"x\", \"x\"], [\"x\", \"14\", \"3\", \"13\", \"9\", \"2\", \"19\", \"19\", \"x\", \"x\", \"x\", \"4\", \"x\", \"2\", \"15\"], [\"x\", \"14\", \"2\", \"x\", \"3\", \"x\", \"10\", \"11\", \"x\", \"4\", \"x\", \"12\", \"4\", \"x\", \"x\"], [\"x\", \"9\", \"7\", \"16\", \"x\", \"x\", \"19\", \"17\", \"17\", \"14\", \"14\", \"12\", \"14\", \"19\", \"12\"], [\"2\", \"x\", \"x\", \"7\", \"15\", \"x\", \"x\", \"13\", \"x\", \"8\", \"1\", \"1\", \"x\", \"14\", \"19\"], [\"16\", \"x\", \"14\", \"x\", \"x\", \"6\", \"x\", \"x\", \"16\", \"x\", \"x\", \"9\", \"10\", \"18\", \"4\"], [\"3\", \"x\", \"x\", \"3\", \"x\", \"x\", \"x\", \"x\", \"9\", \"8\", \"x\", \"9\", \"14\", \"x\", \"14\"], [\"x\", \"x\", \"x\", \"4\", \"19\", \"x\", \"4\", \"15\", \"x\", \"x\", \"x\", \"17\", \"x\", \"x\", \"x\"], [\"16\", \"17\", \"x\", \"x\", \"13\", \"x\", \"18\", \"5\", \"x\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"2\", \"x\", \"17\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"12\", \"3\", \"8\", \"x\", \"2\", \"9\"], [\"x\", \"x\", \"14\", \"7\", \"11\", \"x\", \"x\", \"10\", \"9\", \"3\", \"7\", \"16\", \"x\", \"7\", \"1\"], [\"x\", \"12\", \"14\", \"1\", \"x\", \"x\", \"3\", \"12\", \"x\", \"7\", \"x\", \"x\", \"8\", \"x\", \"x\"], [\"x\", \"2\", \"x\", \"15\", \"2\", \"x\", \"14\", \"16\", \"13\", \"19\", \"16\", \"1\", \"11\", \"x\", \"x\"]], [5, 2], [8, 14], 5, 7]", "A*_args": "[\"[['x', 'x', '12', 'x', '18', '3', '2', '15', '6', '11', '13', 'x', '7', '17', 'x'], ['13', 'x', '20', '13', '5', '2', 'x', 'x', '10', '12', '19', '19', '16', 'x', '17'], ['12', '12', '7', 'x', 'x', 'x', '9', 'x', 'x', '10', '10', '18', '4', 'x', 'x'], ['x', '14', '3', '13', '9', '2', '19', '19', 'x', 'x', 'x', '4', 'x', '2', '15'], ['x', '14', '2', 'x', '3', 'x', '10', '11', 'x', '4', 'x', '12', '4', 'x', 'x'], ['x', '9', '7', '16', 'x', 'x', '19', '17', '17', '14', '14', '12', '14', '19', '12'], ['2', 'x', 'x', '7', '15', 'x', 'x', '13', 'x', '8', '1', '1', 'x', '14', '19'], ['16', 'x', '14', 'x', 'x', '6', 'x', 'x', '16', 'x', 'x', '9', '10', '18', '4'], ['3', 'x', 'x', '3', 'x', 'x', 'x', 'x', '9', '8', 'x', '9', '14', 'x', '14'], ['x', 'x', 'x', '4', '19', 'x', '4', '15', 'x', 'x', 'x', '17', 'x', 'x', 'x'], ['16', '17', 'x', 'x', '13', 'x', '18', '5', 'x', '14', 'x', 'x', 'x', 'x', 'x'], ['2', 'x', '17', 'x', 'x', 'x', 'x', 'x', 'x', '12', '3', '8', 'x', '2', '9'], ['x', 'x', '14', '7', '11', 'x', 'x', '10', '9', '3', '7', '16', 'x', '7', '1'], ['x', '12', '14', '1', 'x', 'x', '3', '12', 'x', '7', 'x', 'x', '8', 'x', 'x'], ['x', '2', 'x', '15', '2', 'x', '14', '16', '13', '19', '16', '1', '11', 'x', 'x']]\", \"(5, 2)\", \"(8, 14)\", \"5\", \"7\"]"}
{"diff_sorted_id": "91", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 15x15. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 5 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (14, 2) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (1, 9). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 1 0 0 0 1 0 0 1 1 0 1 1 0\n1 1 0 1 1 1 0 1 0 0 0 1 1 0 0\n0 1 0 0 1 1 1 1 0 0 0 0 1 0 0\n0 1 1 1 1 0 1 1 0 1 0 1 0 1 1\n0 1 1 0 0 1 0 0 0 0 0 1 1 1 1\n0 0 0 1 0 1 0 1 1 0 1 1 1 1 1\n1 0 0 1 0 0 0 1 1 1 0 1 0 1 1\n1 1 1 1 0 0 0 0 1 1 0 1 0 1 1\n0 1 0 1 0 0 0 0 1 1 0 1 0 1 1\n1 0 1 1 0 0 0 0 1 1 1 1 1 1 1\n0 1 1 1 0 0 1 1 0 1 1 1 1 1 1\n1 1 1 0 0 0 1 1 0 0 0 1 1 0 0\n0 0 0 1 0 0 1 1 1 1 1 1 1 1 1\n0 0 0 1 1 1 1 1 1 1 1 1 1 0 0\n0 0 0 0 0 1 1 0 0 0 1 0 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[[14, 2], [13, 2], [12, 2], [11, 3], [10, 4], [9, 4], [8, 4], [7, 4], [6, 4], [6, 5], [5, 6], [4, 6], [4, 7], [3, 8], [2, 8], [1, 9]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.03218722343444824", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1], [0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1], [0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1]]\", 5]", "is_correct_args": "[\"[[0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1], [0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1], [0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1]]\", [14, 2], [1, 9], 5]", "A*_args": "[\"[[0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1], [0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1], [1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1], [1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1], [0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1]]\", \"(14, 2)\", \"(1, 9)\", \"5\"]"}
{"diff_sorted_id": "91", "problem_statement": "Given 9 labeled water jugs with capacities 51, 75, 112, 122, 54, 129, 31, 127, 113 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 338, 431, 493, 550 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "7", "opt_solution": "[[\"+\", 75, 4], [\"+\", 112, 4], [\"+\", 112, 4], [\"+\", 122, 4], [\"+\", 129, 4], [\"+\", 112, 3], [\"+\", 127, 3], [\"+\", 127, 3], [\"+\", 127, 3], [\"+\", 51, 2], [\"+\", 122, 2], [\"+\", 129, 2], [\"+\", 129, 2], [\"+\", 112, 1], [\"+\", 113, 1], [\"+\", 113, 1]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.05792498588562012", "solution_depth": "16", "max_successor_states": "72", "num_vars_per_state": "3", "is_feasible_args": "[[51, 75, 112, 122, 54, 129, 31, 127, 113], [338, 431, 493, 550]]", "is_correct_args": "[[51, 75, 112, 122, 54, 129, 31, 127, 113], [338, 431, 493, 550]]", "A*_args": "[\"[51, 75, 112, 122, 54, 129, 31, 127, 113]\", \"[338, 431, 493, 550]\"]"}
{"diff_sorted_id": "92", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[92, 79, 74, 46, 64, 44], [39, 59, 75, 26, 47, 73], [29, 53, 56, '_', 16, 17]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[26, 47, 73, 44, 64, 73, 16, 17, 44, 64, 73, 46, 74, 75, 56, 53, 29, 39, 59, 56, 53, 26, 17, 16, 46, 73, 64, 44]", "opt_solution_cost": "28", "opt_solution_compute_t": "0.7006855010986328", "solution_depth": "28", "max_successor_states": "4", "num_vars_per_state": "18", "is_feasible_args": "[[[92, 79, 74, 46, 64, 44], [39, 59, 75, 26, 47, 73], [29, 53, 56, \"_\", 16, 17]]]", "is_correct_args": "[[[92, 79, 74, 46, 64, 44], [39, 59, 75, 26, 47, 73], [29, 53, 56, \"_\", 16, 17]]]", "A*_args": "[\"[[92, 79, 74, 46, 64, 44], [39, 59, 75, 26, 47, 73], [29, 53, 56, '_', 16, 17]]\"]"}
{"diff_sorted_id": "92", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: shrew, bedark, curcas, bender, hocker   The initial board: [['e', 's', '_', 'r', 'k', 'w'], ['b', 'c', 'd', 'd', 'r', 'a'], ['c', 'u', 'e', 'c', 'e', 's'], ['b', 'r', 'n', 'h', 'e', 'a'], ['h', 'o', 'e', 'k', 'r', 'r']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[\"down-right\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"down-right\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "28", "opt_solution_compute_t": "23.219958066940308", "solution_depth": "28", "max_successor_states": "4", "num_vars_per_state": "30", "is_feasible_args": "[[[\"e\", \"s\", \"_\", \"r\", \"k\", \"w\"], [\"b\", \"c\", \"d\", \"d\", \"r\", \"a\"], [\"c\", \"u\", \"e\", \"c\", \"e\", \"s\"], [\"b\", \"r\", \"n\", \"h\", \"e\", \"a\"], [\"h\", \"o\", \"e\", \"k\", \"r\", \"r\"]]]", "is_correct_args": "[[[\"e\", \"s\", \"_\", \"r\", \"k\", \"w\"], [\"b\", \"c\", \"d\", \"d\", \"r\", \"a\"], [\"c\", \"u\", \"e\", \"c\", \"e\", \"s\"], [\"b\", \"r\", \"n\", \"h\", \"e\", \"a\"], [\"h\", \"o\", \"e\", \"k\", \"r\", \"r\"]], [\"shrew\", \"bedark\", \"curcas\", \"bender\", \"hocker\"]]", "A*_args": "[\"[['e', 's', '_', 'r', 'k', 'w'], ['b', 'c', 'd', 'd', 'r', 'a'], ['c', 'u', 'e', 'c', 'e', 's'], ['b', 'r', 'n', 'h', 'e', 'a'], ['h', 'o', 'e', 'k', 'r', 'r']]\", \"['shrew', 'bedark', 'curcas', 'bender', 'hocker']\"]"}
{"diff_sorted_id": "92", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'F'. Our task is to visit city R and city S excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from S and R, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  I H R E G S W Q C A B F J V L \nI 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 \nH 1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 \nR 0 1 0 1 1 0 1 0 0 0 1 0 0 1 1 \nE 0 1 0 0 0 0 0 1 1 0 0 0 0 0 0 \nG 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 \nS 1 0 0 0 0 0 1 1 0 0 0 0 1 0 1 \nW 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 \nQ 1 0 0 0 0 1 0 0 1 1 1 0 1 0 0 \nC 1 1 1 0 1 0 1 0 0 1 0 1 1 1 0 \nA 1 1 0 0 0 0 1 0 0 0 0 0 0 0 0 \nB 0 0 0 1 0 1 1 0 0 1 0 0 0 0 1 \nF 1 1 0 0 0 0 0 0 0 0 0 0 0 0 1 \nJ 0 0 0 1 0 1 1 0 0 0 1 0 0 0 0 \nV 0 0 0 1 1 0 0 1 0 1 1 0 0 0 0 \nL 0 0 0 1 1 0 0 1 0 0 0 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[\"F\", \"H\", \"S\", \"J\", \"S\", \"Q\", \"C\", \"R\", \"W\", \"R\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.05547213554382324", "solution_depth": "10", "max_successor_states": "15", "num_vars_per_state": "18", "is_feasible_args": "[[[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]], [\"I\", \"H\", \"R\", \"E\", \"G\", \"S\", \"W\", \"Q\", \"C\", \"A\", \"B\", \"F\", \"J\", \"V\", \"L\"], \"R\", \"S\"]", "is_correct_args": "[[[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]], [\"I\", \"H\", \"R\", \"E\", \"G\", \"S\", \"W\", \"Q\", \"C\", \"A\", \"B\", \"F\", \"J\", \"V\", \"L\"], \"F\", \"R\", \"S\"]", "A*_args": "[\"[[0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1], [0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0], [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0]]\", \"['I', 'H', 'R', 'E', 'G', 'S', 'W', 'Q', 'C', 'A', 'B', 'F', 'J', 'V', 'L']\", \"['F']\", \"['R', 'S']\"]"}
{"diff_sorted_id": "92", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [19, 11, 35, 3, 12, 23, 42, 45, 8, 12, 32, 82, 39, 12, 45, 12, 40, 38, 28, 6, 32, 37, 39, 9, 43, 12, 38, 4, 42, 44, 41, 37, 83, 5, 38], such that the sum of the chosen coins adds up to 466. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {37: 6, 43: 18, 32: 16, 4: 4, 83: 4, 8: 5, 23: 18, 12: 6, 82: 16, 44: 20, 39: 1, 19: 8, 35: 7, 38: 11, 11: 3, 42: 5, 45: 12, 3: 1, 6: 2, 41: 3, 28: 18, 40: 2, 9: 6, 5: 4}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "22", "opt_solution": "[3, 39, 83, 42, 40, 6, 37, 37, 39, 41, 45, 42, 12]", "opt_solution_cost": "54", "opt_solution_compute_t": "0.05336928367614746", "solution_depth": "13", "max_successor_states": "35", "num_vars_per_state": "35", "is_feasible_args": "[[19, 11, 35, 3, 12, 23, 42, 45, 8, 12, 32, 82, 39, 12, 45, 12, 40, 38, 28, 6, 32, 37, 39, 9, 43, 12, 38, 4, 42, 44, 41, 37, 83, 5, 38]]", "is_correct_args": "[[19, 11, 35, 3, 12, 23, 42, 45, 8, 12, 32, 82, 39, 12, 45, 12, 40, 38, 28, 6, 32, 37, 39, 9, 43, 12, 38, 4, 42, 44, 41, 37, 83, 5, 38], {\"37\": 6, \"43\": 18, \"32\": 16, \"4\": 4, \"83\": 4, \"8\": 5, \"23\": 18, \"12\": 6, \"82\": 16, \"44\": 20, \"39\": 1, \"19\": 8, \"35\": 7, \"38\": 11, \"11\": 3, \"42\": 5, \"45\": 12, \"3\": 1, \"6\": 2, \"41\": 3, \"28\": 18, \"40\": 2, \"9\": 6, \"5\": 4}, 466]", "A*_args": "[\"[19, 11, 35, 3, 12, 23, 42, 45, 8, 12, 32, 82, 39, 12, 45, 12, 40, 38, 28, 6, 32, 37, 39, 9, 43, 12, 38, 4, 42, 44, 41, 37, 83, 5, 38]\", \"{37: 6, 43: 18, 32: 16, 4: 4, 83: 4, 8: 5, 23: 18, 12: 6, 82: 16, 44: 20, 39: 1, 19: 8, 35: 7, 38: 11, 11: 3, 42: 5, 45: 12, 3: 1, 6: 2, 41: 3, 28: 18, 40: 2, 9: 6, 5: 4}\", \"466\"]"}
{"diff_sorted_id": "92", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Blue', 'Red', 'Red', 'Blue'], ['Green', 'Red', 'Green', 'Green', 'Blue', 'Red'], ['Green', 'Blue', 'Green', 'Blue', 'Blue', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[1, 2], [1, 0], [1, 2], [1, 2], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [0, 2], [0, 1], [0, 2], [0, 2], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [1, 2], [1, 0], [2, 1], [2, 1], [2, 1], [2, 0], [2, 0], [1, 2], [1, 2], [0, 1]]", "opt_solution_cost": "35", "opt_solution_compute_t": "174.02124547958374", "solution_depth": "35", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Red\", \"Green\", \"Blue\", \"Red\", \"Red\", \"Blue\"], [\"Green\", \"Red\", \"Green\", \"Green\", \"Blue\", \"Red\"], [\"Green\", \"Blue\", \"Green\", \"Blue\", \"Blue\", \"Red\"]], 9]", "is_correct_args": "[[[\"Red\", \"Green\", \"Blue\", \"Red\", \"Red\", \"Blue\"], [\"Green\", \"Red\", \"Green\", \"Green\", \"Blue\", \"Red\"], [\"Green\", \"Blue\", \"Green\", \"Blue\", \"Blue\", \"Red\"]], 9]", "A*_args": "[\"[['Red', 'Green', 'Blue', 'Red', 'Red', 'Blue'], ['Green', 'Red', 'Green', 'Green', 'Blue', 'Red'], ['Green', 'Blue', 'Green', 'Blue', 'Blue', 'Red']]\", \"9\"]"}
{"diff_sorted_id": "92", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 31 to 86 (31 included in the range but 86 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['85' '73' '59' 'x']\n ['x' 'x' '66' '70']\n ['x' '59' 'x' 'x']\n ['40' '41' '79' '82']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "11", "opt_solution": "[[0, 0, 30], [0, 3, 6], [1, 0, 29], [1, 2, 12], [1, 3, 7], [2, 1, 16], [2, 2, 17], [3, 0, 8], [3, 1, 9], [3, 2, 18]]", "opt_solution_cost": "308", "opt_solution_compute_t": "15.29494833946228", "solution_depth": "10", "max_successor_states": "55", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '28', '11', ''], ['', '27', '', ''], ['15', '', '', '46'], ['', '', '', '50']]\", 6, 61]", "is_correct_args": "[\"[['', '28', '11', ''], ['', '27', '', ''], ['15', '', '', '46'], ['', '', '', '50']]\", 6, 61]", "A*_args": "[\"[['', '28', '11', ''], ['', '27', '', ''], ['15', '', '', '46'], ['', '', '', '50']]\", \"6\", \"61\"]"}
{"diff_sorted_id": "92", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 41 to 92. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 240, 266, None for columns 1 to 2 respectively, and the sums of rows must be None, 298, 222, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 299. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '41' '67' 'x']\n ['x' '73' 'x' '91']\n ['x' '43' 'x' '76']\n ['80' 'x' 'x' '86']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "7", "opt_solution": "[[0, 0, 42], [0, 3, 87], [1, 0, 45], [1, 2, 89], [2, 0, 44], [2, 2, 59], [3, 1, 83], [3, 2, 51]]", "opt_solution_cost": "1057", "opt_solution_compute_t": "14.704439878463745", "solution_depth": "8", "max_successor_states": "36", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '41', '67', ''], ['', '73', '', '91'], ['', '43', '', '76'], ['80', '', '', '86']]\", 4, 41, 92]", "is_correct_args": "[\"[['', '41', '67', ''], ['', '73', '', '91'], ['', '43', '', '76'], ['80', '', '', '86']]\", 41, 92, [1, 3], [1, 3], [240, 266], [298, 222], 299]", "A*_args": "[\"[['', '41', '67', ''], ['', '73', '', '91'], ['', '43', '', '76'], ['80', '', '', '86']]\", \"41\", \"92\", \"[None, 240, 266, None]\", \"[None, 298, 222, None]\", \"299\"]"}
{"diff_sorted_id": "92", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (7, 14) to his destination workshop at index (2, 4), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 6, and district 3 covering rows 7 to 14. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[15 1 x 3 x 9 15 8 17 x x 6 x 12 3]\n[x x x 14 x 7 18 6 14 2 19 15 x x x]\n[4 3 x 10 8 4 16 13 6 x 18 10 14 x x]\n[x x x 10 x 14 10 7 x x x 4 2 19 3]\n[5 x 10 x 18 12 20 15 x x 11 11 1 10 19]\n[8 x 13 x x x 16 7 3 x x 2 18 11 x]\n[12 x 15 x x 6 x x x x 18 3 14 3 6]\n[x 6 13 19 19 x 7 12 18 5 x 1 4 18 11]\n[5 x 18 x 12 4 3 7 x 16 1 x 16 2 x]\n[x x x x 18 x x 14 15 1 x x 9 x x]\n[x 13 x 7 7 x x 16 10 x x x x 8 x]\n[x x 19 18 8 18 x x 12 x 13 x 17 12 7]\n[x x x x 7 7 13 17 x x x x x 9 5]\n[9 x 14 x 9 x 8 x x x 17 4 12 12 12]\n[8 1 11 x x x x x 15 x x 2 16 x 15]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "7", "opt_solution": "[[7, 14], [6, 14], [6, 13], [5, 13], [4, 13], [4, 12], [3, 12], [3, 11], [2, 11], [1, 11], [1, 10], [1, 9], [1, 8], [1, 7], [1, 6], [1, 5], [2, 5], [2, 4]]", "opt_solution_cost": "140", "opt_solution_compute_t": "0.030504465103149414", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"15\", \"1\", \"x\", \"3\", \"x\", \"9\", \"15\", \"8\", \"17\", \"x\", \"x\", \"6\", \"x\", \"12\", \"3\"], [\"x\", \"x\", \"x\", \"14\", \"x\", \"7\", \"18\", \"6\", \"14\", \"2\", \"19\", \"15\", \"x\", \"x\", \"x\"], [\"4\", \"3\", \"x\", \"10\", \"8\", \"4\", \"16\", \"13\", \"6\", \"x\", \"18\", \"10\", \"14\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"10\", \"x\", \"14\", \"10\", \"7\", \"x\", \"x\", \"x\", \"4\", \"2\", \"19\", \"3\"], [\"5\", \"x\", \"10\", \"x\", \"18\", \"12\", \"20\", \"15\", \"x\", \"x\", \"11\", \"11\", \"1\", \"10\", \"19\"], [\"8\", \"x\", \"13\", \"x\", \"x\", \"x\", \"16\", \"7\", \"3\", \"x\", \"x\", \"2\", \"18\", \"11\", \"x\"], [\"12\", \"x\", \"15\", \"x\", \"x\", \"6\", \"x\", \"x\", \"x\", \"x\", \"18\", \"3\", \"14\", \"3\", \"6\"], [\"x\", \"6\", \"13\", \"19\", \"19\", \"x\", \"7\", \"12\", \"18\", \"5\", \"x\", \"1\", \"4\", \"18\", \"11\"], [\"5\", \"x\", \"18\", \"x\", \"12\", \"4\", \"3\", \"7\", \"x\", \"16\", \"1\", \"x\", \"16\", \"2\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\", \"14\", \"15\", \"1\", \"x\", \"x\", \"9\", \"x\", \"x\"], [\"x\", \"13\", \"x\", \"7\", \"7\", \"x\", \"x\", \"16\", \"10\", \"x\", \"x\", \"x\", \"x\", \"8\", \"x\"], [\"x\", \"x\", \"19\", \"18\", \"8\", \"18\", \"x\", \"x\", \"12\", \"x\", \"13\", \"x\", \"17\", \"12\", \"7\"], [\"x\", \"x\", \"x\", \"x\", \"7\", \"7\", \"13\", \"17\", \"x\", \"x\", \"x\", \"x\", \"x\", \"9\", \"5\"], [\"9\", \"x\", \"14\", \"x\", \"9\", \"x\", \"8\", \"x\", \"x\", \"x\", \"17\", \"4\", \"12\", \"12\", \"12\"], [\"8\", \"1\", \"11\", \"x\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\", \"x\", \"2\", \"16\", \"x\", \"15\"]]]", "is_correct_args": "[[[\"15\", \"1\", \"x\", \"3\", \"x\", \"9\", \"15\", \"8\", \"17\", \"x\", \"x\", \"6\", \"x\", \"12\", \"3\"], [\"x\", \"x\", \"x\", \"14\", \"x\", \"7\", \"18\", \"6\", \"14\", \"2\", \"19\", \"15\", \"x\", \"x\", \"x\"], [\"4\", \"3\", \"x\", \"10\", \"8\", \"4\", \"16\", \"13\", \"6\", \"x\", \"18\", \"10\", \"14\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"10\", \"x\", \"14\", \"10\", \"7\", \"x\", \"x\", \"x\", \"4\", \"2\", \"19\", \"3\"], [\"5\", \"x\", \"10\", \"x\", \"18\", \"12\", \"20\", \"15\", \"x\", \"x\", \"11\", \"11\", \"1\", \"10\", \"19\"], [\"8\", \"x\", \"13\", \"x\", \"x\", \"x\", \"16\", \"7\", \"3\", \"x\", \"x\", \"2\", \"18\", \"11\", \"x\"], [\"12\", \"x\", \"15\", \"x\", \"x\", \"6\", \"x\", \"x\", \"x\", \"x\", \"18\", \"3\", \"14\", \"3\", \"6\"], [\"x\", \"6\", \"13\", \"19\", \"19\", \"x\", \"7\", \"12\", \"18\", \"5\", \"x\", \"1\", \"4\", \"18\", \"11\"], [\"5\", \"x\", \"18\", \"x\", \"12\", \"4\", \"3\", \"7\", \"x\", \"16\", \"1\", \"x\", \"16\", \"2\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\", \"14\", \"15\", \"1\", \"x\", \"x\", \"9\", \"x\", \"x\"], [\"x\", \"13\", \"x\", \"7\", \"7\", \"x\", \"x\", \"16\", \"10\", \"x\", \"x\", \"x\", \"x\", \"8\", \"x\"], [\"x\", \"x\", \"19\", \"18\", \"8\", \"18\", \"x\", \"x\", \"12\", \"x\", \"13\", \"x\", \"17\", \"12\", \"7\"], [\"x\", \"x\", \"x\", \"x\", \"7\", \"7\", \"13\", \"17\", \"x\", \"x\", \"x\", \"x\", \"x\", \"9\", \"5\"], [\"9\", \"x\", \"14\", \"x\", \"9\", \"x\", \"8\", \"x\", \"x\", \"x\", \"17\", \"4\", \"12\", \"12\", \"12\"], [\"8\", \"1\", \"11\", \"x\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\", \"x\", \"2\", \"16\", \"x\", \"15\"]], [7, 14], [2, 4], 2, 6]", "A*_args": "[\"[['15', '1', 'x', '3', 'x', '9', '15', '8', '17', 'x', 'x', '6', 'x', '12', '3'], ['x', 'x', 'x', '14', 'x', '7', '18', '6', '14', '2', '19', '15', 'x', 'x', 'x'], ['4', '3', 'x', '10', '8', '4', '16', '13', '6', 'x', '18', '10', '14', 'x', 'x'], ['x', 'x', 'x', '10', 'x', '14', '10', '7', 'x', 'x', 'x', '4', '2', '19', '3'], ['5', 'x', '10', 'x', '18', '12', '20', '15', 'x', 'x', '11', '11', '1', '10', '19'], ['8', 'x', '13', 'x', 'x', 'x', '16', '7', '3', 'x', 'x', '2', '18', '11', 'x'], ['12', 'x', '15', 'x', 'x', '6', 'x', 'x', 'x', 'x', '18', '3', '14', '3', '6'], ['x', '6', '13', '19', '19', 'x', '7', '12', '18', '5', 'x', '1', '4', '18', '11'], ['5', 'x', '18', 'x', '12', '4', '3', '7', 'x', '16', '1', 'x', '16', '2', 'x'], ['x', 'x', 'x', 'x', '18', 'x', 'x', '14', '15', '1', 'x', 'x', '9', 'x', 'x'], ['x', '13', 'x', '7', '7', 'x', 'x', '16', '10', 'x', 'x', 'x', 'x', '8', 'x'], ['x', 'x', '19', '18', '8', '18', 'x', 'x', '12', 'x', '13', 'x', '17', '12', '7'], ['x', 'x', 'x', 'x', '7', '7', '13', '17', 'x', 'x', 'x', 'x', 'x', '9', '5'], ['9', 'x', '14', 'x', '9', 'x', '8', 'x', 'x', 'x', '17', '4', '12', '12', '12'], ['8', '1', '11', 'x', 'x', 'x', 'x', 'x', '15', 'x', 'x', '2', '16', 'x', '15']]\", \"(7, 14)\", \"(2, 4)\", \"2\", \"6\"]"}
{"diff_sorted_id": "92", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 15x15. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 5 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (10, 0) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (1, 12). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 1 1 1 0 1 1 1 1 1 0 0 0 0\n1 1 0 0 1 1 1 1 0 1 1 0 0 0 1\n1 1 1 0 0 1 1 0 1 0 0 1 0 0 0\n0 0 0 0 0 0 0 0 0 1 0 0 0 1 0\n0 0 0 0 1 1 1 0 0 0 0 0 0 1 0\n0 1 0 0 1 0 1 0 0 1 0 0 0 1 1\n1 0 0 0 1 1 0 0 1 1 0 1 0 1 0\n1 0 0 0 0 1 1 0 1 0 0 1 1 1 1\n0 1 0 1 0 0 0 0 1 1 1 0 1 1 0\n1 0 1 1 1 0 0 0 1 1 0 0 1 1 1\n0 1 0 1 0 1 0 1 1 1 0 1 0 1 0\n1 1 0 0 0 1 0 1 1 1 1 0 1 1 1\n1 0 1 1 1 1 1 0 1 1 1 0 0 0 1\n0 1 1 1 0 0 0 1 1 1 1 0 0 1 1\n0 1 1 1 1 1 1 1 1 0 1 1 0 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[[10, 0], [9, 1], [8, 2], [7, 2], [7, 3], [6, 3], [5, 3], [4, 3], [3, 4], [3, 5], [3, 6], [3, 7], [3, 8], [2, 9], [2, 10], [1, 11], [1, 12]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.029998064041137695", "solution_depth": "17", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1], [0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1], [0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1]]\", 5]", "is_correct_args": "[\"[[1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1], [0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1], [0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1]]\", [10, 0], [1, 12], 5]", "A*_args": "[\"[[1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1], [1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1], [1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0], [1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1], [0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1], [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1], [0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1]]\", \"(10, 0)\", \"(1, 12)\", \"5\"]"}
{"diff_sorted_id": "92", "problem_statement": "Given 9 labeled water jugs with capacities 143, 34, 117, 130, 50, 142, 144, 150, 29, 78 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 307, 316, 325, 622 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "7", "opt_solution": "[[\"+\", 143, 4], [\"+\", 150, 4], [\"+\", 150, 4], [\"+\", 150, 4], [\"+\", 29, 4], [\"+\", 78, 3], [\"+\", 117, 3], [\"+\", 130, 3], [\"+\", 143, 2], [\"+\", 144, 2], [\"+\", 29, 2], [\"+\", 130, 1], [\"+\", 143, 1], [\"+\", 34, 1]]", "opt_solution_cost": "14", "opt_solution_compute_t": "0.04768729209899902", "solution_depth": "14", "max_successor_states": "80", "num_vars_per_state": "3", "is_feasible_args": "[[143, 34, 117, 130, 50, 142, 144, 150, 29, 78], [307, 316, 325, 622]]", "is_correct_args": "[[143, 34, 117, 130, 50, 142, 144, 150, 29, 78], [307, 316, 325, 622]]", "A*_args": "[\"[143, 34, 117, 130, 50, 142, 144, 150, 29, 78]\", \"[307, 316, 325, 622]\"]"}
{"diff_sorted_id": "93", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[94, 87, 69, 81, 4, 79], ['_', 35, 86, 61, 57, 75], [41, 18, 65, 9, 53, 55]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[94, 87, 69, 86, 65, 18, 35, 69, 87, 94, 69, 65, 61, 57, 4, 79, 75, 55, 53, 4, 55, 53]", "opt_solution_cost": "22", "opt_solution_compute_t": "0.032526254653930664", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "18", "is_feasible_args": "[[[94, 87, 69, 81, 4, 79], [\"_\", 35, 86, 61, 57, 75], [41, 18, 65, 9, 53, 55]]]", "is_correct_args": "[[[94, 87, 69, 81, 4, 79], [\"_\", 35, 86, 61, 57, 75], [41, 18, 65, 9, 53, 55]]]", "A*_args": "[\"[[94, 87, 69, 81, 4, 79], ['_', 35, 86, 61, 57, 75], [41, 18, 65, 9, 53, 55]]\"]"}
{"diff_sorted_id": "93", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: helen, adelea, bumble, iodism, trullo   The initial board: [['d', 'h', '_', 'l', 'e', 'n'], ['a', 'a', 'e', 'b', 'e', 'u'], ['m', 'u', 'i', 'b', 'e', 'e'], ['i', 'o', 'd', 'm', 's', 'l'], ['t', 'r', 'l', 'l', 'l', 'o']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[\"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\"]", "opt_solution_cost": "38", "opt_solution_compute_t": "502.2531027793884", "solution_depth": "38", "max_successor_states": "4", "num_vars_per_state": "30", "is_feasible_args": "[[[\"d\", \"h\", \"_\", \"l\", \"e\", \"n\"], [\"a\", \"a\", \"e\", \"b\", \"e\", \"u\"], [\"m\", \"u\", \"i\", \"b\", \"e\", \"e\"], [\"i\", \"o\", \"d\", \"m\", \"s\", \"l\"], [\"t\", \"r\", \"l\", \"l\", \"l\", \"o\"]]]", "is_correct_args": "[[[\"d\", \"h\", \"_\", \"l\", \"e\", \"n\"], [\"a\", \"a\", \"e\", \"b\", \"e\", \"u\"], [\"m\", \"u\", \"i\", \"b\", \"e\", \"e\"], [\"i\", \"o\", \"d\", \"m\", \"s\", \"l\"], [\"t\", \"r\", \"l\", \"l\", \"l\", \"o\"]], [\"helen\", \"adelea\", \"bumble\", \"iodism\", \"trullo\"]]", "A*_args": "[\"[['d', 'h', '_', 'l', 'e', 'n'], ['a', 'a', 'e', 'b', 'e', 'u'], ['m', 'u', 'i', 'b', 'e', 'e'], ['i', 'o', 'd', 'm', 's', 'l'], ['t', 'r', 'l', 'l', 'l', 'o']]\", \"['helen', 'adelea', 'bumble', 'iodism', 'trullo']\"]"}
{"diff_sorted_id": "93", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'M'. Our task is to visit city Y and city K excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from K and Y, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  C Q T K M B R D J A Y V O N P \nC 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 \nQ 1 0 0 1 0 1 1 1 0 0 1 1 0 1 0 \nT 1 0 0 0 0 0 1 0 0 0 0 0 0 1 0 \nK 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 \nM 0 0 1 0 0 1 0 0 0 1 0 0 0 1 0 \nB 0 0 0 0 0 0 0 1 0 1 0 1 0 0 0 \nR 0 0 0 0 0 0 0 0 1 0 0 1 1 0 0 \nD 0 0 0 1 0 1 0 0 1 1 0 0 1 1 0 \nJ 0 0 1 0 0 1 0 0 0 0 0 0 1 0 0 \nA 1 0 1 0 0 0 0 1 1 0 1 1 0 0 0 \nY 1 0 1 0 0 1 1 0 1 0 0 0 1 0 0 \nV 0 0 0 1 0 0 0 0 1 0 0 0 1 1 0 \nO 1 0 0 1 0 0 0 0 0 1 0 0 0 0 0 \nN 1 0 0 0 0 1 0 0 0 0 0 0 0 0 1 \nP 1 0 0 0 1 0 0 0 1 1 1 1 1 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[\"M\", \"A\", \"Y\", \"B\", \"D\", \"K\", \"P\", \"Y\", \"O\", \"K\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.10736274719238281", "solution_depth": "10", "max_successor_states": "15", "num_vars_per_state": "18", "is_feasible_args": "[[[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0], [1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0]], [\"C\", \"Q\", \"T\", \"K\", \"M\", \"B\", \"R\", \"D\", \"J\", \"A\", \"Y\", \"V\", \"O\", \"N\", \"P\"], \"Y\", \"K\"]", "is_correct_args": "[[[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0], [1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0]], [\"C\", \"Q\", \"T\", \"K\", \"M\", \"B\", \"R\", \"D\", \"J\", \"A\", \"Y\", \"V\", \"O\", \"N\", \"P\"], \"M\", \"Y\", \"K\"]", "A*_args": "[\"[[0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0], [0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0], [1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0]]\", \"['C', 'Q', 'T', 'K', 'M', 'B', 'R', 'D', 'J', 'A', 'Y', 'V', 'O', 'N', 'P']\", \"['M']\", \"['Y', 'K']\"]"}
{"diff_sorted_id": "93", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [43, 41, 23, 24, 40, 11, 12, 9, 32, 32, 6, 15, 16, 20, 6, 39, 9, 12, 4, 251, 43, 24, 27, 20, 39, 37, 7, 43, 9, 13, 45, 27, 9, 15, 41, 25], such that the sum of the chosen coins adds up to 471. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {9: 7, 32: 17, 24: 17, 15: 11, 4: 3, 39: 18, 41: 9, 25: 14, 27: 5, 40: 5, 43: 8, 11: 9, 20: 1, 45: 2, 16: 15, 251: 12, 37: 10, 13: 1, 23: 1, 7: 1, 12: 1, 6: 5}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "23", "opt_solution": "[7, 45, 20, 12, 23, 12, 251, 40, 20, 41]", "opt_solution_cost": "34", "opt_solution_compute_t": "0.04783797264099121", "solution_depth": "10", "max_successor_states": "36", "num_vars_per_state": "36", "is_feasible_args": "[[43, 41, 23, 24, 40, 11, 12, 9, 32, 32, 6, 15, 16, 20, 6, 39, 9, 12, 4, 251, 43, 24, 27, 20, 39, 37, 7, 43, 9, 13, 45, 27, 9, 15, 41, 25]]", "is_correct_args": "[[43, 41, 23, 24, 40, 11, 12, 9, 32, 32, 6, 15, 16, 20, 6, 39, 9, 12, 4, 251, 43, 24, 27, 20, 39, 37, 7, 43, 9, 13, 45, 27, 9, 15, 41, 25], {\"9\": 7, \"32\": 17, \"24\": 17, \"15\": 11, \"4\": 3, \"39\": 18, \"41\": 9, \"25\": 14, \"27\": 5, \"40\": 5, \"43\": 8, \"11\": 9, \"20\": 1, \"45\": 2, \"16\": 15, \"251\": 12, \"37\": 10, \"13\": 1, \"23\": 1, \"7\": 1, \"12\": 1, \"6\": 5}, 471]", "A*_args": "[\"[43, 41, 23, 24, 40, 11, 12, 9, 32, 32, 6, 15, 16, 20, 6, 39, 9, 12, 4, 251, 43, 24, 27, 20, 39, 37, 7, 43, 9, 13, 45, 27, 9, 15, 41, 25]\", \"{9: 7, 32: 17, 24: 17, 15: 11, 4: 3, 39: 18, 41: 9, 25: 14, 27: 5, 40: 5, 43: 8, 11: 9, 20: 1, 45: 2, 16: 15, 251: 12, 37: 10, 13: 1, 23: 1, 7: 1, 12: 1, 6: 5}\", \"471\"]"}
{"diff_sorted_id": "93", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Red', 'Green', 'Blue', 'Red'], ['Red', 'Blue', 'Green', 'Green', 'Blue', 'Blue'], ['Red', 'Blue', 'Blue', 'Green', 'Red', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[2, 1], [0, 1], [0, 2], [0, 1], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 2], [1, 0], [1, 0], [2, 1], [2, 1], [2, 0], [2, 0], [2, 1], [2, 1], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 2]]", "opt_solution_cost": "27", "opt_solution_compute_t": "151.82125544548035", "solution_depth": "27", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Red\", \"Green\", \"Red\", \"Green\", \"Blue\", \"Red\"], [\"Red\", \"Blue\", \"Green\", \"Green\", \"Blue\", \"Blue\"], [\"Red\", \"Blue\", \"Blue\", \"Green\", \"Red\", \"Green\"]], 9]", "is_correct_args": "[[[\"Red\", \"Green\", \"Red\", \"Green\", \"Blue\", \"Red\"], [\"Red\", \"Blue\", \"Green\", \"Green\", \"Blue\", \"Blue\"], [\"Red\", \"Blue\", \"Blue\", \"Green\", \"Red\", \"Green\"]], 9]", "A*_args": "[\"[['Red', 'Green', 'Red', 'Green', 'Blue', 'Red'], ['Red', 'Blue', 'Green', 'Green', 'Blue', 'Blue'], ['Red', 'Blue', 'Blue', 'Green', 'Red', 'Green']]\", \"9\"]"}
{"diff_sorted_id": "93", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 36 to 91 (36 included in the range but 91 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['38' 'x' '50' 'x']\n ['x' 'x' '64' '67']\n ['54' 'x' '71' '79']\n ['x' '59' '89' '90']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "11", "opt_solution": "[[0, 0, 62], [0, 1, 63], [0, 3, 76], [1, 1, 64], [2, 0, 52], [2, 1, 65]]", "opt_solution_cost": "916", "opt_solution_compute_t": "0.2937626838684082", "solution_depth": "6", "max_successor_states": "55", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '74', ''], ['61', '', '80', '88'], ['', '', '82', '89'], ['51', '75', '83', '90']]\", 50, 110]", "is_correct_args": "[\"[['', '', '74', ''], ['61', '', '80', '88'], ['', '', '82', '89'], ['51', '75', '83', '90']]\", 50, 110]", "A*_args": "[\"[['', '', '74', ''], ['61', '', '80', '88'], ['', '', '82', '89'], ['51', '75', '83', '90']]\", \"50\", \"110\"]"}
{"diff_sorted_id": "93", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 41 to 92. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 244, 295, None for columns 1 to 2 respectively, and the sums of rows must be None, 266, 261, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 265. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['53' '57' 'x' 'x']\n ['77' '78' 'x' '56']\n ['51' '62' '88' 'x']\n ['x' 'x' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 2, 61], [0, 3, 58], [1, 2, 55], [2, 3, 60], [3, 0, 90], [3, 1, 47], [3, 2, 91], [3, 3, 41]]", "opt_solution_cost": "1025", "opt_solution_compute_t": "1.733626127243042", "solution_depth": "8", "max_successor_states": "36", "num_vars_per_state": "16", "is_feasible_args": "[\"[['53', '57', '', ''], ['77', '78', '', '56'], ['51', '62', '88', ''], ['', '', '', '']]\", 4, 41, 92]", "is_correct_args": "[\"[['53', '57', '', ''], ['77', '78', '', '56'], ['51', '62', '88', ''], ['', '', '', '']]\", 41, 92, [1, 3], [1, 3], [244, 295], [266, 261], 265]", "A*_args": "[\"[['53', '57', '', ''], ['77', '78', '', '56'], ['51', '62', '88', ''], ['', '', '', '']]\", \"41\", \"92\", \"[None, 244, 295, None]\", \"[None, 266, 261, None]\", \"265\"]"}
{"diff_sorted_id": "93", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (4, 14) to his destination workshop at index (7, 1), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 4, district 2 covering rows 5 to 6, and district 3 covering rows 7 to 14. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x x x 2 19 x x 15 x x 2 17 18 18]\n[x x 2 18 3 17 1 x x x 6 x x 7 9]\n[x x 2 10 3 x 6 11 5 7 8 17 x 12 6]\n[x 14 13 9 3 x 18 x 17 16 14 8 9 x 13]\n[x x x 17 x 16 9 3 1 x 5 20 2 2 6]\n[8 x 8 x 5 19 12 19 7 1 5 4 11 13 16]\n[x 6 19 17 20 x x 14 14 x x 3 20 13 3]\n[12 14 7 1 15 x 8 8 x x x 15 x x x]\n[x 9 x x 4 7 7 x x 13 7 7 x 6 x]\n[x x x 11 10 x x x 5 x 7 14 x 19 x]\n[x 11 18 x 19 x 1 18 1 8 x x x 12 15]\n[19 x 7 x 9 3 x 7 12 13 19 13 x 9 x]\n[x 17 9 x 6 x 6 x x 11 x 19 x x x]\n[4 17 5 x 7 5 17 12 x 16 8 x x 17 x]\n[15 2 13 x 14 x x 17 x x 1 x 19 1 17]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "7", "opt_solution": "[[4, 14], [4, 13], [4, 12], [5, 12], [5, 11], [5, 10], [5, 9], [5, 8], [6, 8], [6, 7], [7, 7], [7, 6], [8, 6], [8, 5], [8, 4], [7, 4], [7, 3], [7, 2], [7, 1]]", "opt_solution_cost": "131", "opt_solution_compute_t": "0.028059959411621094", "solution_depth": "19", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"x\", \"x\", \"2\", \"19\", \"x\", \"x\", \"15\", \"x\", \"x\", \"2\", \"17\", \"18\", \"18\"], [\"x\", \"x\", \"2\", \"18\", \"3\", \"17\", \"1\", \"x\", \"x\", \"x\", \"6\", \"x\", \"x\", \"7\", \"9\"], [\"x\", \"x\", \"2\", \"10\", \"3\", \"x\", \"6\", \"11\", \"5\", \"7\", \"8\", \"17\", \"x\", \"12\", \"6\"], [\"x\", \"14\", \"13\", \"9\", \"3\", \"x\", \"18\", \"x\", \"17\", \"16\", \"14\", \"8\", \"9\", \"x\", \"13\"], [\"x\", \"x\", \"x\", \"17\", \"x\", \"16\", \"9\", \"3\", \"1\", \"x\", \"5\", \"20\", \"2\", \"2\", \"6\"], [\"8\", \"x\", \"8\", \"x\", \"5\", \"19\", \"12\", \"19\", \"7\", \"1\", \"5\", \"4\", \"11\", \"13\", \"16\"], [\"x\", \"6\", \"19\", \"17\", \"20\", \"x\", \"x\", \"14\", \"14\", \"x\", \"x\", \"3\", \"20\", \"13\", \"3\"], [\"12\", \"14\", \"7\", \"1\", \"15\", \"x\", \"8\", \"8\", \"x\", \"x\", \"x\", \"15\", \"x\", \"x\", \"x\"], [\"x\", \"9\", \"x\", \"x\", \"4\", \"7\", \"7\", \"x\", \"x\", \"13\", \"7\", \"7\", \"x\", \"6\", \"x\"], [\"x\", \"x\", \"x\", \"11\", \"10\", \"x\", \"x\", \"x\", \"5\", \"x\", \"7\", \"14\", \"x\", \"19\", \"x\"], [\"x\", \"11\", \"18\", \"x\", \"19\", \"x\", \"1\", \"18\", \"1\", \"8\", \"x\", \"x\", \"x\", \"12\", \"15\"], [\"19\", \"x\", \"7\", \"x\", \"9\", \"3\", \"x\", \"7\", \"12\", \"13\", \"19\", \"13\", \"x\", \"9\", \"x\"], [\"x\", \"17\", \"9\", \"x\", \"6\", \"x\", \"6\", \"x\", \"x\", \"11\", \"x\", \"19\", \"x\", \"x\", \"x\"], [\"4\", \"17\", \"5\", \"x\", \"7\", \"5\", \"17\", \"12\", \"x\", \"16\", \"8\", \"x\", \"x\", \"17\", \"x\"], [\"15\", \"2\", \"13\", \"x\", \"14\", \"x\", \"x\", \"17\", \"x\", \"x\", \"1\", \"x\", \"19\", \"1\", \"17\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"x\", \"x\", \"2\", \"19\", \"x\", \"x\", \"15\", \"x\", \"x\", \"2\", \"17\", \"18\", \"18\"], [\"x\", \"x\", \"2\", \"18\", \"3\", \"17\", \"1\", \"x\", \"x\", \"x\", \"6\", \"x\", \"x\", \"7\", \"9\"], [\"x\", \"x\", \"2\", \"10\", \"3\", \"x\", \"6\", \"11\", \"5\", \"7\", \"8\", \"17\", \"x\", \"12\", \"6\"], [\"x\", \"14\", \"13\", \"9\", \"3\", \"x\", \"18\", \"x\", \"17\", \"16\", \"14\", \"8\", \"9\", \"x\", \"13\"], [\"x\", \"x\", \"x\", \"17\", \"x\", \"16\", \"9\", \"3\", \"1\", \"x\", \"5\", \"20\", \"2\", \"2\", \"6\"], [\"8\", \"x\", \"8\", \"x\", \"5\", \"19\", \"12\", \"19\", \"7\", \"1\", \"5\", \"4\", \"11\", \"13\", \"16\"], [\"x\", \"6\", \"19\", \"17\", \"20\", \"x\", \"x\", \"14\", \"14\", \"x\", \"x\", \"3\", \"20\", \"13\", \"3\"], [\"12\", \"14\", \"7\", \"1\", \"15\", \"x\", \"8\", \"8\", \"x\", \"x\", \"x\", \"15\", \"x\", \"x\", \"x\"], [\"x\", \"9\", \"x\", \"x\", \"4\", \"7\", \"7\", \"x\", \"x\", \"13\", \"7\", \"7\", \"x\", \"6\", \"x\"], [\"x\", \"x\", \"x\", \"11\", \"10\", \"x\", \"x\", \"x\", \"5\", \"x\", \"7\", \"14\", \"x\", \"19\", \"x\"], [\"x\", \"11\", \"18\", \"x\", \"19\", \"x\", \"1\", \"18\", \"1\", \"8\", \"x\", \"x\", \"x\", \"12\", \"15\"], [\"19\", \"x\", \"7\", \"x\", \"9\", \"3\", \"x\", \"7\", \"12\", \"13\", \"19\", \"13\", \"x\", \"9\", \"x\"], [\"x\", \"17\", \"9\", \"x\", \"6\", \"x\", \"6\", \"x\", \"x\", \"11\", \"x\", \"19\", \"x\", \"x\", \"x\"], [\"4\", \"17\", \"5\", \"x\", \"7\", \"5\", \"17\", \"12\", \"x\", \"16\", \"8\", \"x\", \"x\", \"17\", \"x\"], [\"15\", \"2\", \"13\", \"x\", \"14\", \"x\", \"x\", \"17\", \"x\", \"x\", \"1\", \"x\", \"19\", \"1\", \"17\"]], [4, 14], [7, 1], 4, 6]", "A*_args": "[\"[['x', 'x', 'x', 'x', '2', '19', 'x', 'x', '15', 'x', 'x', '2', '17', '18', '18'], ['x', 'x', '2', '18', '3', '17', '1', 'x', 'x', 'x', '6', 'x', 'x', '7', '9'], ['x', 'x', '2', '10', '3', 'x', '6', '11', '5', '7', '8', '17', 'x', '12', '6'], ['x', '14', '13', '9', '3', 'x', '18', 'x', '17', '16', '14', '8', '9', 'x', '13'], ['x', 'x', 'x', '17', 'x', '16', '9', '3', '1', 'x', '5', '20', '2', '2', '6'], ['8', 'x', '8', 'x', '5', '19', '12', '19', '7', '1', '5', '4', '11', '13', '16'], ['x', '6', '19', '17', '20', 'x', 'x', '14', '14', 'x', 'x', '3', '20', '13', '3'], ['12', '14', '7', '1', '15', 'x', '8', '8', 'x', 'x', 'x', '15', 'x', 'x', 'x'], ['x', '9', 'x', 'x', '4', '7', '7', 'x', 'x', '13', '7', '7', 'x', '6', 'x'], ['x', 'x', 'x', '11', '10', 'x', 'x', 'x', '5', 'x', '7', '14', 'x', '19', 'x'], ['x', '11', '18', 'x', '19', 'x', '1', '18', '1', '8', 'x', 'x', 'x', '12', '15'], ['19', 'x', '7', 'x', '9', '3', 'x', '7', '12', '13', '19', '13', 'x', '9', 'x'], ['x', '17', '9', 'x', '6', 'x', '6', 'x', 'x', '11', 'x', '19', 'x', 'x', 'x'], ['4', '17', '5', 'x', '7', '5', '17', '12', 'x', '16', '8', 'x', 'x', '17', 'x'], ['15', '2', '13', 'x', '14', 'x', 'x', '17', 'x', 'x', '1', 'x', '19', '1', '17']]\", \"(4, 14)\", \"(7, 1)\", \"4\", \"6\"]"}
{"diff_sorted_id": "93", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 15x15. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 5 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (14, 10) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (2, 1). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 0 0 1 1 0 0 1 0 0 1 0 1 0\n1 0 1 1 1 1 1 1 1 1 1 1 1 1 0\n0 0 0 1 1 0 1 1 1 1 1 1 0 1 1\n0 1 1 1 0 1 0 0 1 0 0 1 1 0 1\n0 0 1 1 0 0 1 1 0 0 1 0 1 1 1\n0 1 0 1 1 0 1 1 0 0 0 0 1 0 0\n0 0 1 0 1 1 1 0 1 1 0 1 1 0 0\n0 0 0 1 1 0 1 1 0 0 1 1 1 0 0\n0 0 1 1 1 0 0 1 1 1 1 0 1 1 0\n0 0 0 1 1 1 1 0 0 1 1 1 0 1 1\n0 0 0 1 0 1 0 0 1 1 0 1 0 1 0\n1 1 0 0 0 1 1 1 1 0 1 1 0 1 0\n1 1 1 0 0 0 1 0 0 1 1 1 1 0 1\n0 1 1 1 1 0 0 0 1 1 0 1 1 0 1\n1 0 0 0 0 1 0 0 0 0 0 1 0 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[[14, 10], [14, 9], [14, 8], [13, 7], [13, 6], [12, 5], [11, 4], [11, 3], [10, 2], [9, 1], [8, 1], [7, 1], [6, 1], [6, 0], [5, 0], [4, 0], [3, 0], [2, 0], [2, 1]]", "opt_solution_cost": "19", "opt_solution_compute_t": "0.024536848068237305", "solution_depth": "19", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0], [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1], [0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1], [0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0], [0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0], [1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1], [0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0]]\", 5]", "is_correct_args": "[\"[[1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0], [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1], [0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1], [0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0], [0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0], [1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1], [0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0]]\", [14, 10], [2, 1], 5]", "A*_args": "[\"[[1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0], [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1], [0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1], [0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1], [0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0], [0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1], [0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0], [1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0], [1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1], [0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0]]\", \"(14, 10)\", \"(2, 1)\", \"5\"]"}
{"diff_sorted_id": "93", "problem_statement": "Given 9 labeled water jugs with capacities 39, 110, 41, 54, 47, 33, 136, 40, 100 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 192, 459, 473, 493 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "7", "opt_solution": "[[\"+\", 100, 4], [\"+\", 100, 4], [\"+\", 47, 4], [\"+\", 110, 4], [\"+\", 136, 4], [\"+\", 47, 3], [\"+\", 136, 3], [\"+\", 136, 3], [\"+\", 54, 3], [\"+\", 100, 3], [\"+\", 33, 2], [\"+\", 136, 2], [\"+\", 136, 2], [\"+\", 54, 2], [\"+\", 100, 2], [\"+\", 41, 1], [\"+\", 41, 1], [\"+\", 110, 1]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.06568336486816406", "solution_depth": "18", "max_successor_states": "72", "num_vars_per_state": "3", "is_feasible_args": "[[39, 110, 41, 54, 47, 33, 136, 40, 100], [192, 459, 473, 493]]", "is_correct_args": "[[39, 110, 41, 54, 47, 33, 136, 40, 100], [192, 459, 473, 493]]", "A*_args": "[\"[39, 110, 41, 54, 47, 33, 136, 40, 100]\", \"[192, 459, 473, 493]\"]"}
{"diff_sorted_id": "94", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[98, 30, 85, 44, 59, 40], [56, 68, 50, 61, 47, 15], [37, 48, 24, 81, 22, '_']]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[15, 40, 59, 44, 61, 50, 68, 30, 85, 68, 50, 81, 24, 48, 30, 50, 81, 47, 44, 61, 68, 81, 48, 24, 22, 15]", "opt_solution_cost": "26", "opt_solution_compute_t": "0.07562923431396484", "solution_depth": "26", "max_successor_states": "4", "num_vars_per_state": "18", "is_feasible_args": "[[[98, 30, 85, 44, 59, 40], [56, 68, 50, 61, 47, 15], [37, 48, 24, 81, 22, \"_\"]]]", "is_correct_args": "[[[98, 30, 85, 44, 59, 40], [56, 68, 50, 61, 47, 15], [37, 48, 24, 81, 22, \"_\"]]]", "A*_args": "[\"[[98, 30, 85, 44, 59, 40], [56, 68, 50, 61, 47, 15], [37, 48, 24, 81, 22, '_']]\"]"}
{"diff_sorted_id": "94", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: drunk, armure, diglot, caudal, mirach   The initial board: [['_', 'd', 'a', 'u', 'n', 'k'], ['a', 'r', 'm', 'r', 'r', 'e'], ['d', 'i', 'u', 'l', 'l', 't'], ['c', 'd', 'u', 'r', 'a', 'c'], ['m', 'i', 'g', 'a', 'o', 'h']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[\"down-right\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-right\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.9841225147247314", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "30", "is_feasible_args": "[[[\"_\", \"d\", \"a\", \"u\", \"n\", \"k\"], [\"a\", \"r\", \"m\", \"r\", \"r\", \"e\"], [\"d\", \"i\", \"u\", \"l\", \"l\", \"t\"], [\"c\", \"d\", \"u\", \"r\", \"a\", \"c\"], [\"m\", \"i\", \"g\", \"a\", \"o\", \"h\"]]]", "is_correct_args": "[[[\"_\", \"d\", \"a\", \"u\", \"n\", \"k\"], [\"a\", \"r\", \"m\", \"r\", \"r\", \"e\"], [\"d\", \"i\", \"u\", \"l\", \"l\", \"t\"], [\"c\", \"d\", \"u\", \"r\", \"a\", \"c\"], [\"m\", \"i\", \"g\", \"a\", \"o\", \"h\"]], [\"drunk\", \"armure\", \"diglot\", \"caudal\", \"mirach\"]]", "A*_args": "[\"[['_', 'd', 'a', 'u', 'n', 'k'], ['a', 'r', 'm', 'r', 'r', 'e'], ['d', 'i', 'u', 'l', 'l', 't'], ['c', 'd', 'u', 'r', 'a', 'c'], ['m', 'i', 'g', 'a', 'o', 'h']]\", \"['drunk', 'armure', 'diglot', 'caudal', 'mirach']\"]"}
{"diff_sorted_id": "94", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'I'. Our task is to visit city H and city R excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from R and H, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  X T R O M U I P Z F V H Q J B \nX 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 \nT 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 \nR 0 0 0 1 0 0 1 0 1 0 1 0 0 0 0 \nO 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 \nM 0 1 0 1 0 1 0 0 0 0 0 1 0 0 0 \nU 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 \nI 0 0 0 0 1 0 0 0 0 0 1 0 0 0 1 \nP 0 0 1 1 0 1 1 0 0 0 0 0 0 0 0 \nZ 0 1 0 1 0 0 1 0 0 0 0 0 0 0 0 \nF 0 1 1 0 0 0 0 1 1 0 0 0 0 0 0 \nV 0 0 0 1 0 0 1 0 0 0 0 0 0 0 0 \nH 1 0 0 0 1 0 0 0 1 1 1 0 1 0 0 \nQ 0 1 1 0 0 1 0 1 0 0 0 1 0 0 0 \nJ 1 0 1 1 1 0 0 1 1 1 0 0 1 0 0 \nB 1 1 0 0 0 1 0 1 1 1 1 1 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[\"I\", \"B\", \"H\", \"F\", \"R\", \"O\", \"M\", \"H\", \"Q\", \"R\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.04136967658996582", "solution_depth": "10", "max_successor_states": "15", "num_vars_per_state": "18", "is_feasible_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0], [0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0]], [\"X\", \"T\", \"R\", \"O\", \"M\", \"U\", \"I\", \"P\", \"Z\", \"F\", \"V\", \"H\", \"Q\", \"J\", \"B\"], \"H\", \"R\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0], [0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0]], [\"X\", \"T\", \"R\", \"O\", \"M\", \"U\", \"I\", \"P\", \"Z\", \"F\", \"V\", \"H\", \"Q\", \"J\", \"B\"], \"I\", \"H\", \"R\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1], [0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0], [0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0]]\", \"['X', 'T', 'R', 'O', 'M', 'U', 'I', 'P', 'Z', 'F', 'V', 'H', 'Q', 'J', 'B']\", \"['I']\", \"['H', 'R']\"]"}
{"diff_sorted_id": "94", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [21, 13, 10, 18, 21, 43, 42, 29, 14, 19, 9, 2, 15, 19, 32, 45, 24, 31, 25, 7, 21, 24, 29, 29, 4, 36, 29, 19, 29, 12, 3, 44, 40, 46, 33, 3, 28, 44, 25, 6, 36, 3, 4, 19, 31], such that the sum of the chosen coins adds up to 474. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {6: 3, 9: 7, 13: 11, 19: 11, 36: 17, 32: 11, 46: 1, 4: 3, 21: 14, 3: 1, 18: 5, 29: 18, 12: 9, 2: 2, 15: 14, 43: 11, 24: 5, 25: 15, 14: 10, 42: 11, 44: 7, 31: 11, 40: 2, 33: 10, 45: 20, 7: 6, 10: 3, 28: 5}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "24", "opt_solution": "[46, 44, 40, 28, 24, 2, 3, 3, 3, 33, 24, 18, 43, 42, 45, 44, 32]", "opt_solution_cost": "105", "opt_solution_compute_t": "0.08423256874084473", "solution_depth": "17", "max_successor_states": "45", "num_vars_per_state": "45", "is_feasible_args": "[[21, 13, 10, 18, 21, 43, 42, 29, 14, 19, 9, 2, 15, 19, 32, 45, 24, 31, 25, 7, 21, 24, 29, 29, 4, 36, 29, 19, 29, 12, 3, 44, 40, 46, 33, 3, 28, 44, 25, 6, 36, 3, 4, 19, 31]]", "is_correct_args": "[[21, 13, 10, 18, 21, 43, 42, 29, 14, 19, 9, 2, 15, 19, 32, 45, 24, 31, 25, 7, 21, 24, 29, 29, 4, 36, 29, 19, 29, 12, 3, 44, 40, 46, 33, 3, 28, 44, 25, 6, 36, 3, 4, 19, 31], {\"6\": 3, \"9\": 7, \"13\": 11, \"19\": 11, \"36\": 17, \"32\": 11, \"46\": 1, \"4\": 3, \"21\": 14, \"3\": 1, \"18\": 5, \"29\": 18, \"12\": 9, \"2\": 2, \"15\": 14, \"43\": 11, \"24\": 5, \"25\": 15, \"14\": 10, \"42\": 11, \"44\": 7, \"31\": 11, \"40\": 2, \"33\": 10, \"45\": 20, \"7\": 6, \"10\": 3, \"28\": 5}, 474]", "A*_args": "[\"[21, 13, 10, 18, 21, 43, 42, 29, 14, 19, 9, 2, 15, 19, 32, 45, 24, 31, 25, 7, 21, 24, 29, 29, 4, 36, 29, 19, 29, 12, 3, 44, 40, 46, 33, 3, 28, 44, 25, 6, 36, 3, 4, 19, 31]\", \"{6: 3, 9: 7, 13: 11, 19: 11, 36: 17, 32: 11, 46: 1, 4: 3, 21: 14, 3: 1, 18: 5, 29: 18, 12: 9, 2: 2, 15: 14, 43: 11, 24: 5, 25: 15, 14: 10, 42: 11, 44: 7, 31: 11, 40: 2, 33: 10, 45: 20, 7: 6, 10: 3, 28: 5}\", \"474\"]"}
{"diff_sorted_id": "94", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Green', 'Blue', 'Blue', 'Green', 'Blue'], ['Red', 'Green', 'Green', 'Blue', 'Green', 'Blue'], ['Red', 'Red', 'Blue', 'Red', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[1, 0], [2, 0], [2, 0], [2, 1], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 2], [1, 2], [1, 0], [1, 0], [1, 2], [1, 0], [1, 2], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [2, 0], [1, 2], [1, 0], [1, 0], [2, 1], [2, 0], [2, 0]]", "opt_solution_cost": "33", "opt_solution_compute_t": "79.31269884109497", "solution_depth": "33", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Red\", \"Green\", \"Blue\", \"Blue\", \"Green\", \"Blue\"], [\"Red\", \"Green\", \"Green\", \"Blue\", \"Green\", \"Blue\"], [\"Red\", \"Red\", \"Blue\", \"Red\", \"Green\", \"Red\"]], 9]", "is_correct_args": "[[[\"Red\", \"Green\", \"Blue\", \"Blue\", \"Green\", \"Blue\"], [\"Red\", \"Green\", \"Green\", \"Blue\", \"Green\", \"Blue\"], [\"Red\", \"Red\", \"Blue\", \"Red\", \"Green\", \"Red\"]], 9]", "A*_args": "[\"[['Red', 'Green', 'Blue', 'Blue', 'Green', 'Blue'], ['Red', 'Green', 'Green', 'Blue', 'Green', 'Blue'], ['Red', 'Red', 'Blue', 'Red', 'Green', 'Red']]\", \"9\"]"}
{"diff_sorted_id": "94", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 39 to 94 (39 included in the range but 94 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['91' '57' 'x' '45']\n ['41' '49' 'x' 'x']\n ['x' 'x' '49' 'x']\n ['x' '46' '47' '73']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "12", "opt_solution": "[[0, 0, 24], [1, 0, 23], [1, 1, 37], [1, 3, 72], [2, 0, 22], [3, 2, 54]]", "opt_solution_cost": "679", "opt_solution_compute_t": "0.5468931198120117", "solution_depth": "6", "max_successor_states": "55", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '36', '71', '79'], ['', '', '69', ''], ['', '50', '63', '70'], ['21', '53', '', '62']]\", 20, 80]", "is_correct_args": "[\"[['', '36', '71', '79'], ['', '', '69', ''], ['', '50', '63', '70'], ['21', '53', '', '62']]\", 20, 80]", "A*_args": "[\"[['', '36', '71', '79'], ['', '', '69', ''], ['', '50', '63', '70'], ['21', '53', '', '62']]\", \"20\", \"80\"]"}
{"diff_sorted_id": "94", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 41 to 92. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 267, 236, None for columns 1 to 2 respectively, and the sums of rows must be None, 270, 234, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 301. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['48' 'x' 'x' 'x']\n ['54' 'x' 'x' 'x']\n ['x' '64' '44' '83']\n ['82' '68' '51' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 1, 49], [0, 2, 52], [0, 3, 66], [1, 1, 86], [1, 2, 89], [1, 3, 41], [2, 0, 43], [3, 3, 42]]", "opt_solution_cost": "962", "opt_solution_compute_t": "2.9558627605438232", "solution_depth": "8", "max_successor_states": "36", "num_vars_per_state": "16", "is_feasible_args": "[\"[['48', '', '', ''], ['54', '', '', ''], ['', '64', '44', '83'], ['82', '68', '51', '']]\", 4, 41, 92]", "is_correct_args": "[\"[['48', '', '', ''], ['54', '', '', ''], ['', '64', '44', '83'], ['82', '68', '51', '']]\", 41, 92, [1, 3], [1, 3], [267, 236], [270, 234], 301]", "A*_args": "[\"[['48', '', '', ''], ['54', '', '', ''], ['', '64', '44', '83'], ['82', '68', '51', '']]\", \"41\", \"92\", \"[None, 267, 236, None]\", \"[None, 270, 234, None]\", \"301\"]"}
{"diff_sorted_id": "94", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (3, 2) to his destination workshop at index (7, 13), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 6, and district 3 covering rows 7 to 14. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 2 x 12 3 8 x 1 5 x x 14 x 5 x]\n[5 x x 9 19 10 10 x x 14 16 x x 17 x]\n[7 4 7 18 2 7 16 x 7 x 9 x x 6 x]\n[9 x 14 x x 14 7 9 18 11 14 8 13 14 15]\n[8 4 x 17 x 7 15 x x 19 x 10 x 12 13]\n[7 11 5 6 x 13 x x 15 4 9 17 19 6 8]\n[13 x x x x x x x 4 10 x 7 7 17 9]\n[x x 6 x x 17 12 11 x x x 10 15 14 x]\n[16 x 5 19 x 19 x 4 11 16 x x 12 x x]\n[x x 14 x x 19 x x 4 13 7 x x x 8]\n[x 4 x 13 7 14 x x 2 15 9 11 x x x]\n[x x x x x 19 x 6 2 x x x 4 7 x]\n[17 12 10 3 5 18 x x x 11 x 19 13 x x]\n[1 x 5 x 17 x 17 x 7 18 x x 8 x x]\n[x x x x x x 2 9 x 10 3 x x 15 2]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "7", "opt_solution": "[[3, 2], [2, 2], [2, 3], [2, 4], [2, 5], [3, 5], [3, 6], [3, 7], [3, 8], [3, 9], [3, 10], [3, 11], [4, 11], [5, 11], [6, 11], [6, 12], [7, 12], [7, 13]]", "opt_solution_cost": "185", "opt_solution_compute_t": "0.026812314987182617", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"2\", \"x\", \"12\", \"3\", \"8\", \"x\", \"1\", \"5\", \"x\", \"x\", \"14\", \"x\", \"5\", \"x\"], [\"5\", \"x\", \"x\", \"9\", \"19\", \"10\", \"10\", \"x\", \"x\", \"14\", \"16\", \"x\", \"x\", \"17\", \"x\"], [\"7\", \"4\", \"7\", \"18\", \"2\", \"7\", \"16\", \"x\", \"7\", \"x\", \"9\", \"x\", \"x\", \"6\", \"x\"], [\"9\", \"x\", \"14\", \"x\", \"x\", \"14\", \"7\", \"9\", \"18\", \"11\", \"14\", \"8\", \"13\", \"14\", \"15\"], [\"8\", \"4\", \"x\", \"17\", \"x\", \"7\", \"15\", \"x\", \"x\", \"19\", \"x\", \"10\", \"x\", \"12\", \"13\"], [\"7\", \"11\", \"5\", \"6\", \"x\", \"13\", \"x\", \"x\", \"15\", \"4\", \"9\", \"17\", \"19\", \"6\", \"8\"], [\"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"4\", \"10\", \"x\", \"7\", \"7\", \"17\", \"9\"], [\"x\", \"x\", \"6\", \"x\", \"x\", \"17\", \"12\", \"11\", \"x\", \"x\", \"x\", \"10\", \"15\", \"14\", \"x\"], [\"16\", \"x\", \"5\", \"19\", \"x\", \"19\", \"x\", \"4\", \"11\", \"16\", \"x\", \"x\", \"12\", \"x\", \"x\"], [\"x\", \"x\", \"14\", \"x\", \"x\", \"19\", \"x\", \"x\", \"4\", \"13\", \"7\", \"x\", \"x\", \"x\", \"8\"], [\"x\", \"4\", \"x\", \"13\", \"7\", \"14\", \"x\", \"x\", \"2\", \"15\", \"9\", \"11\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"19\", \"x\", \"6\", \"2\", \"x\", \"x\", \"x\", \"4\", \"7\", \"x\"], [\"17\", \"12\", \"10\", \"3\", \"5\", \"18\", \"x\", \"x\", \"x\", \"11\", \"x\", \"19\", \"13\", \"x\", \"x\"], [\"1\", \"x\", \"5\", \"x\", \"17\", \"x\", \"17\", \"x\", \"7\", \"18\", \"x\", \"x\", \"8\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"2\", \"9\", \"x\", \"10\", \"3\", \"x\", \"x\", \"15\", \"2\"]]]", "is_correct_args": "[[[\"x\", \"2\", \"x\", \"12\", \"3\", \"8\", \"x\", \"1\", \"5\", \"x\", \"x\", \"14\", \"x\", \"5\", \"x\"], [\"5\", \"x\", \"x\", \"9\", \"19\", \"10\", \"10\", \"x\", \"x\", \"14\", \"16\", \"x\", \"x\", \"17\", \"x\"], [\"7\", \"4\", \"7\", \"18\", \"2\", \"7\", \"16\", \"x\", \"7\", \"x\", \"9\", \"x\", \"x\", \"6\", \"x\"], [\"9\", \"x\", \"14\", \"x\", \"x\", \"14\", \"7\", \"9\", \"18\", \"11\", \"14\", \"8\", \"13\", \"14\", \"15\"], [\"8\", \"4\", \"x\", \"17\", \"x\", \"7\", \"15\", \"x\", \"x\", \"19\", \"x\", \"10\", \"x\", \"12\", \"13\"], [\"7\", \"11\", \"5\", \"6\", \"x\", \"13\", \"x\", \"x\", \"15\", \"4\", \"9\", \"17\", \"19\", \"6\", \"8\"], [\"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"4\", \"10\", \"x\", \"7\", \"7\", \"17\", \"9\"], [\"x\", \"x\", \"6\", \"x\", \"x\", \"17\", \"12\", \"11\", \"x\", \"x\", \"x\", \"10\", \"15\", \"14\", \"x\"], [\"16\", \"x\", \"5\", \"19\", \"x\", \"19\", \"x\", \"4\", \"11\", \"16\", \"x\", \"x\", \"12\", \"x\", \"x\"], [\"x\", \"x\", \"14\", \"x\", \"x\", \"19\", \"x\", \"x\", \"4\", \"13\", \"7\", \"x\", \"x\", \"x\", \"8\"], [\"x\", \"4\", \"x\", \"13\", \"7\", \"14\", \"x\", \"x\", \"2\", \"15\", \"9\", \"11\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"19\", \"x\", \"6\", \"2\", \"x\", \"x\", \"x\", \"4\", \"7\", \"x\"], [\"17\", \"12\", \"10\", \"3\", \"5\", \"18\", \"x\", \"x\", \"x\", \"11\", \"x\", \"19\", \"13\", \"x\", \"x\"], [\"1\", \"x\", \"5\", \"x\", \"17\", \"x\", \"17\", \"x\", \"7\", \"18\", \"x\", \"x\", \"8\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"2\", \"9\", \"x\", \"10\", \"3\", \"x\", \"x\", \"15\", \"2\"]], [3, 2], [7, 13], 2, 6]", "A*_args": "[\"[['x', '2', 'x', '12', '3', '8', 'x', '1', '5', 'x', 'x', '14', 'x', '5', 'x'], ['5', 'x', 'x', '9', '19', '10', '10', 'x', 'x', '14', '16', 'x', 'x', '17', 'x'], ['7', '4', '7', '18', '2', '7', '16', 'x', '7', 'x', '9', 'x', 'x', '6', 'x'], ['9', 'x', '14', 'x', 'x', '14', '7', '9', '18', '11', '14', '8', '13', '14', '15'], ['8', '4', 'x', '17', 'x', '7', '15', 'x', 'x', '19', 'x', '10', 'x', '12', '13'], ['7', '11', '5', '6', 'x', '13', 'x', 'x', '15', '4', '9', '17', '19', '6', '8'], ['13', 'x', 'x', 'x', 'x', 'x', 'x', 'x', '4', '10', 'x', '7', '7', '17', '9'], ['x', 'x', '6', 'x', 'x', '17', '12', '11', 'x', 'x', 'x', '10', '15', '14', 'x'], ['16', 'x', '5', '19', 'x', '19', 'x', '4', '11', '16', 'x', 'x', '12', 'x', 'x'], ['x', 'x', '14', 'x', 'x', '19', 'x', 'x', '4', '13', '7', 'x', 'x', 'x', '8'], ['x', '4', 'x', '13', '7', '14', 'x', 'x', '2', '15', '9', '11', 'x', 'x', 'x'], ['x', 'x', 'x', 'x', 'x', '19', 'x', '6', '2', 'x', 'x', 'x', '4', '7', 'x'], ['17', '12', '10', '3', '5', '18', 'x', 'x', 'x', '11', 'x', '19', '13', 'x', 'x'], ['1', 'x', '5', 'x', '17', 'x', '17', 'x', '7', '18', 'x', 'x', '8', 'x', 'x'], ['x', 'x', 'x', 'x', 'x', 'x', '2', '9', 'x', '10', '3', 'x', 'x', '15', '2']]\", \"(3, 2)\", \"(7, 13)\", \"2\", \"6\"]"}
{"diff_sorted_id": "94", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 15x15. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 5 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (13, 1) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (4, 13). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 0 1 1 0 0 0 1 1 0 0 1 1 1\n1 1 1 1 1 1 1 1 1 1 1 0 1 1 0\n1 1 0 1 1 1 1 0 0 0 0 1 1 1 1\n1 0 0 0 1 0 0 1 0 1 1 1 1 0 1\n0 0 1 0 0 0 0 0 1 1 0 0 1 0 0\n1 1 0 0 1 1 0 0 0 0 1 1 1 0 0\n1 1 1 0 0 1 0 1 1 0 0 0 0 0 0\n1 1 0 1 0 1 0 0 1 1 1 0 1 1 0\n0 1 1 1 0 1 0 1 0 0 0 0 0 0 1\n0 1 1 0 1 1 0 1 0 0 1 1 0 1 0\n0 1 1 0 0 0 0 0 0 1 0 0 0 1 1\n0 0 0 0 0 0 0 0 1 1 0 1 1 1 0\n0 0 0 0 0 0 0 0 1 0 1 0 0 1 0\n0 0 0 1 1 1 0 1 0 1 1 0 1 0 1\n1 0 1 1 0 1 1 0 1 0 1 1 0 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[[13, 1], [12, 2], [11, 3], [10, 4], [10, 5], [10, 6], [10, 7], [9, 8], [8, 8], [8, 9], [8, 10], [7, 11], [6, 11], [6, 12], [6, 13], [5, 13], [4, 13]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.023047924041748047", "solution_depth": "17", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1], [1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0], [1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0], [0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0], [0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0]]\", 5]", "is_correct_args": "[\"[[1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1], [1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0], [1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0], [0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0], [0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0]]\", [13, 1], [4, 13], 5]", "A*_args": "[\"[[1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0], [1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1], [1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0], [1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0], [0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0], [0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0]]\", \"(13, 1)\", \"(4, 13)\", \"5\"]"}
{"diff_sorted_id": "94", "problem_statement": "Given 9 labeled water jugs with capacities 81, 56, 41, 88, 137, 14, 149, 120, 87, 104 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 377, 456, 512, 541 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "7", "opt_solution": "[[\"+\", 81, 4], [\"+\", 149, 4], [\"+\", 149, 4], [\"+\", 81, 4], [\"+\", 81, 4], [\"+\", 81, 3], [\"+\", 120, 3], [\"+\", 149, 3], [\"+\", 81, 3], [\"+\", 81, 3], [\"+\", 41, 2], [\"+\", 137, 2], [\"+\", 149, 2], [\"+\", 88, 2], [\"+\", 41, 2], [\"+\", 120, 1], [\"+\", 120, 1], [\"+\", 137, 1]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.09543561935424805", "solution_depth": "18", "max_successor_states": "80", "num_vars_per_state": "3", "is_feasible_args": "[[81, 56, 41, 88, 137, 14, 149, 120, 87, 104], [377, 456, 512, 541]]", "is_correct_args": "[[81, 56, 41, 88, 137, 14, 149, 120, 87, 104], [377, 456, 512, 541]]", "A*_args": "[\"[81, 56, 41, 88, 137, 14, 149, 120, 87, 104]\", \"[377, 456, 512, 541]\"]"}
{"diff_sorted_id": "95", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[92, 72, 91, 79, 62, 24], [93, 67, 65, 63, 83, 74], [41, 34, 29, 27, 58, '_']]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[58, 27, 63, 65, 67, 72, 92, 93, 72, 67, 65, 83, 62, 24, 74, 62, 24, 79, 83, 63, 27, 24, 62, 58]", "opt_solution_cost": "24", "opt_solution_compute_t": "0.20434069633483887", "solution_depth": "24", "max_successor_states": "4", "num_vars_per_state": "18", "is_feasible_args": "[[[92, 72, 91, 79, 62, 24], [93, 67, 65, 63, 83, 74], [41, 34, 29, 27, 58, \"_\"]]]", "is_correct_args": "[[[92, 72, 91, 79, 62, 24], [93, 67, 65, 63, 83, 74], [41, 34, 29, 27, 58, \"_\"]]]", "A*_args": "[\"[[92, 72, 91, 79, 62, 24], [93, 67, 65, 63, 83, 74], [41, 34, 29, 27, 58, '_']]\"]"}
{"diff_sorted_id": "95", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: tuner, myrtol, soldan, elvira, herman   The initial board: [['y', 't', 's', 'n', 'a', 'r'], ['m', 'r', 'r', 't', 'o', 'e'], ['l', 'o', '_', 'd', 'l', 'n'], ['e', 'u', 'v', 'i', 'r', 'a'], ['h', 'e', 'l', 'm', 'a', 'n']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[\"up-left\", \"up-right\", \"down-right\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.4562370777130127", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "30", "is_feasible_args": "[[[\"y\", \"t\", \"s\", \"n\", \"a\", \"r\"], [\"m\", \"r\", \"r\", \"t\", \"o\", \"e\"], [\"l\", \"o\", \"_\", \"d\", \"l\", \"n\"], [\"e\", \"u\", \"v\", \"i\", \"r\", \"a\"], [\"h\", \"e\", \"l\", \"m\", \"a\", \"n\"]]]", "is_correct_args": "[[[\"y\", \"t\", \"s\", \"n\", \"a\", \"r\"], [\"m\", \"r\", \"r\", \"t\", \"o\", \"e\"], [\"l\", \"o\", \"_\", \"d\", \"l\", \"n\"], [\"e\", \"u\", \"v\", \"i\", \"r\", \"a\"], [\"h\", \"e\", \"l\", \"m\", \"a\", \"n\"]], [\"tuner\", \"myrtol\", \"soldan\", \"elvira\", \"herman\"]]", "A*_args": "[\"[['y', 't', 's', 'n', 'a', 'r'], ['m', 'r', 'r', 't', 'o', 'e'], ['l', 'o', '_', 'd', 'l', 'n'], ['e', 'u', 'v', 'i', 'r', 'a'], ['h', 'e', 'l', 'm', 'a', 'n']]\", \"['tuner', 'myrtol', 'soldan', 'elvira', 'herman']\"]"}
{"diff_sorted_id": "95", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'C'. Our task is to visit city E and city Q excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from Q and E, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  E K G C U A J O N R W M B H Q \nE 0 0 0 0 0 0 0 0 1 1 0 1 1 0 0 \nK 1 0 0 0 0 0 0 1 0 0 0 1 0 0 0 \nG 1 0 0 0 0 1 0 0 0 0 0 0 0 1 0 \nC 0 1 0 0 1 0 0 1 0 0 0 0 0 0 0 \nU 1 0 1 0 0 0 0 0 1 0 0 0 0 0 0 \nA 0 0 0 1 1 0 0 1 1 0 1 0 0 0 0 \nJ 0 0 0 0 0 1 0 1 0 0 0 0 1 0 1 \nO 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 \nN 0 1 1 0 1 0 1 0 0 0 0 0 0 0 1 \nR 0 0 1 0 0 0 1 1 0 0 0 1 1 0 1 \nW 1 0 1 1 0 1 1 0 0 0 0 1 0 1 0 \nM 0 0 0 1 1 1 0 1 0 0 0 0 0 0 0 \nB 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 \nH 1 1 0 0 0 1 0 0 0 0 0 1 1 0 0 \nQ 1 0 1 1 1 0 0 0 0 0 0 1 1 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[\"C\", \"O\", \"N\", \"Q\", \"E\", \"R\", \"Q\", \"E\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.034786224365234375", "solution_depth": "8", "max_successor_states": "15", "num_vars_per_state": "18", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0]], [\"E\", \"K\", \"G\", \"C\", \"U\", \"A\", \"J\", \"O\", \"N\", \"R\", \"W\", \"M\", \"B\", \"H\", \"Q\"], \"E\", \"Q\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0]], [\"E\", \"K\", \"G\", \"C\", \"U\", \"A\", \"J\", \"O\", \"N\", \"R\", \"W\", \"M\", \"B\", \"H\", \"Q\"], \"C\", \"E\", \"Q\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1], [1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0]]\", \"['E', 'K', 'G', 'C', 'U', 'A', 'J', 'O', 'N', 'R', 'W', 'M', 'B', 'H', 'Q']\", \"['C']\", \"['E', 'Q']\"]"}
{"diff_sorted_id": "95", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [26, 8, 19, 9, 36, 23, 42, 40, 13, 34, 40, 25, 11, 38, 10, 41, 19, 34, 91, 18, 14, 27, 14, 43, 42, 13, 2, 27, 90, 13, 3, 4, 44, 7, 48, 40, 35, 40, 10, 12, 25], such that the sum of the chosen coins adds up to 488. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {44: 20, 11: 4, 19: 3, 4: 4, 10: 3, 14: 9, 90: 18, 48: 12, 91: 5, 8: 4, 7: 5, 9: 5, 12: 2, 42: 18, 36: 6, 35: 10, 34: 12, 25: 7, 27: 1, 3: 2, 26: 15, 40: 8, 43: 1, 18: 8, 23: 1, 13: 3, 41: 8, 38: 13, 2: 2}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "25", "opt_solution": "[23, 27, 27, 12, 19, 91, 90, 36, 41, 40, 43, 10, 19, 10]", "opt_solution_cost": "63", "opt_solution_compute_t": "0.06218409538269043", "solution_depth": "14", "max_successor_states": "41", "num_vars_per_state": "41", "is_feasible_args": "[[26, 8, 19, 9, 36, 23, 42, 40, 13, 34, 40, 25, 11, 38, 10, 41, 19, 34, 91, 18, 14, 27, 14, 43, 42, 13, 2, 27, 90, 13, 3, 4, 44, 7, 48, 40, 35, 40, 10, 12, 25]]", "is_correct_args": "[[26, 8, 19, 9, 36, 23, 42, 40, 13, 34, 40, 25, 11, 38, 10, 41, 19, 34, 91, 18, 14, 27, 14, 43, 42, 13, 2, 27, 90, 13, 3, 4, 44, 7, 48, 40, 35, 40, 10, 12, 25], {\"44\": 20, \"11\": 4, \"19\": 3, \"4\": 4, \"10\": 3, \"14\": 9, \"90\": 18, \"48\": 12, \"91\": 5, \"8\": 4, \"7\": 5, \"9\": 5, \"12\": 2, \"42\": 18, \"36\": 6, \"35\": 10, \"34\": 12, \"25\": 7, \"27\": 1, \"3\": 2, \"26\": 15, \"40\": 8, \"43\": 1, \"18\": 8, \"23\": 1, \"13\": 3, \"41\": 8, \"38\": 13, \"2\": 2}, 488]", "A*_args": "[\"[26, 8, 19, 9, 36, 23, 42, 40, 13, 34, 40, 25, 11, 38, 10, 41, 19, 34, 91, 18, 14, 27, 14, 43, 42, 13, 2, 27, 90, 13, 3, 4, 44, 7, 48, 40, 35, 40, 10, 12, 25]\", \"{44: 20, 11: 4, 19: 3, 4: 4, 10: 3, 14: 9, 90: 18, 48: 12, 91: 5, 8: 4, 7: 5, 9: 5, 12: 2, 42: 18, 36: 6, 35: 10, 34: 12, 25: 7, 27: 1, 3: 2, 26: 15, 40: 8, 43: 1, 18: 8, 23: 1, 13: 3, 41: 8, 38: 13, 2: 2}\", \"488\"]"}
{"diff_sorted_id": "95", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Green', 'Green', 'Green', 'Red', 'Blue', 'Blue'], ['Blue', 'Red', 'Red', 'Red', 'Green', 'Green'], ['Blue', 'Green', 'Blue', 'Red', 'Red', 'Blue']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [2, 0], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [2, 0], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 2], [1, 0]]", "opt_solution_cost": "27", "opt_solution_compute_t": "145.94300484657288", "solution_depth": "27", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Green\", \"Green\", \"Green\", \"Red\", \"Blue\", \"Blue\"], [\"Blue\", \"Red\", \"Red\", \"Red\", \"Green\", \"Green\"], [\"Blue\", \"Green\", \"Blue\", \"Red\", \"Red\", \"Blue\"]], 9]", "is_correct_args": "[[[\"Green\", \"Green\", \"Green\", \"Red\", \"Blue\", \"Blue\"], [\"Blue\", \"Red\", \"Red\", \"Red\", \"Green\", \"Green\"], [\"Blue\", \"Green\", \"Blue\", \"Red\", \"Red\", \"Blue\"]], 9]", "A*_args": "[\"[['Green', 'Green', 'Green', 'Red', 'Blue', 'Blue'], ['Blue', 'Red', 'Red', 'Red', 'Green', 'Green'], ['Blue', 'Green', 'Blue', 'Red', 'Red', 'Blue']]\", \"9\"]"}
{"diff_sorted_id": "95", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 39 to 94 (39 included in the range but 94 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['71' 'x' '57' 'x']\n ['67' '68' 'x' '73']\n ['51' 'x' '72' 'x']\n ['50' 'x' '75' 'x']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "12", "opt_solution": "[[0, 0, 13], [0, 1, 14], [0, 2, 43], [0, 3, 47], [2, 1, 33], [3, 0, 28]]", "opt_solution_cost": "418", "opt_solution_compute_t": "1.5906620025634766", "solution_depth": "6", "max_successor_states": "55", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '', ''], ['25', '32', '40', '46'], ['27', '', '39', '42'], ['', '34', '38', '41']]\", 13, 73]", "is_correct_args": "[\"[['', '', '', ''], ['25', '32', '40', '46'], ['27', '', '39', '42'], ['', '34', '38', '41']]\", 13, 73]", "A*_args": "[\"[['', '', '', ''], ['25', '32', '40', '46'], ['27', '', '39', '42'], ['', '34', '38', '41']]\", \"13\", \"73\"]"}
{"diff_sorted_id": "95", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 41 to 92. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 262, 272, None for columns 1 to 2 respectively, and the sums of rows must be None, 291, 301, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 256. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['68' '50' '47' '65']\n ['x' '91' 'x' '71']\n ['x' 'x' 'x' '60']\n ['x' 'x' 'x' '84']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[1, 0, 42], [1, 2, 87], [2, 0, 88], [2, 1, 63], [2, 2, 90], [3, 0, 41], [3, 1, 58], [3, 2, 48]]", "opt_solution_cost": "1053", "opt_solution_compute_t": "13.726203918457031", "solution_depth": "8", "max_successor_states": "36", "num_vars_per_state": "16", "is_feasible_args": "[\"[['68', '50', '47', '65'], ['', '91', '', '71'], ['', '', '', '60'], ['', '', '', '84']]\", 4, 41, 92]", "is_correct_args": "[\"[['68', '50', '47', '65'], ['', '91', '', '71'], ['', '', '', '60'], ['', '', '', '84']]\", 41, 92, [1, 3], [1, 3], [262, 272], [291, 301], 256]", "A*_args": "[\"[['68', '50', '47', '65'], ['', '91', '', '71'], ['', '', '', '60'], ['', '', '', '84']]\", \"41\", \"92\", \"[None, 262, 272, None]\", \"[None, 291, 301, None]\", \"256\"]"}
{"diff_sorted_id": "95", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (5, 2) to his destination workshop at index (9, 13), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 4, district 2 covering rows 5 to 9, and district 3 covering rows 10 to 14. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x x x 9 x 14 17 x 13 3 x 13 10 18]\n[1 x 11 12 14 13 8 x 5 7 x x x x x]\n[3 x x 18 11 16 x x x x 1 x 15 12 10]\n[x 10 x 3 2 15 14 x x x 17 x 6 1 x]\n[8 10 x x x x 1 19 6 x 17 2 x x x]\n[x 6 15 2 17 2 11 5 9 x 12 15 x x 16]\n[x x 8 x 14 x 13 20 17 12 19 9 x x x]\n[13 10 1 4 11 3 15 x x 3 14 20 x 6 x]\n[x 11 16 9 19 18 12 2 x x 1 10 x x x]\n[x 13 18 18 7 x x x x 18 5 6 x 7 3]\n[x x x 18 6 16 10 18 9 19 x 3 5 3 4]\n[14 18 4 1 17 x 7 x 3 16 11 x 17 11 1]\n[x x 12 16 x 14 9 x x x 13 1 x x 19]\n[19 x 3 x 8 x x x 3 x x x 17 9 8]\n[15 x 2 8 9 13 x 14 x 6 x 19 x x 5]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "7", "opt_solution": "[[5, 2], [5, 3], [5, 4], [5, 5], [5, 6], [4, 6], [5, 6], [5, 7], [5, 8], [6, 8], [6, 9], [7, 9], [7, 10], [8, 10], [9, 10], [9, 11], [10, 11], [10, 12], [10, 13], [9, 13]]", "opt_solution_cost": "134", "opt_solution_compute_t": "0.029214859008789062", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"x\", \"x\", \"9\", \"x\", \"14\", \"17\", \"x\", \"13\", \"3\", \"x\", \"13\", \"10\", \"18\"], [\"1\", \"x\", \"11\", \"12\", \"14\", \"13\", \"8\", \"x\", \"5\", \"7\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"3\", \"x\", \"x\", \"18\", \"11\", \"16\", \"x\", \"x\", \"x\", \"x\", \"1\", \"x\", \"15\", \"12\", \"10\"], [\"x\", \"10\", \"x\", \"3\", \"2\", \"15\", \"14\", \"x\", \"x\", \"x\", \"17\", \"x\", \"6\", \"1\", \"x\"], [\"8\", \"10\", \"x\", \"x\", \"x\", \"x\", \"1\", \"19\", \"6\", \"x\", \"17\", \"2\", \"x\", \"x\", \"x\"], [\"x\", \"6\", \"15\", \"2\", \"17\", \"2\", \"11\", \"5\", \"9\", \"x\", \"12\", \"15\", \"x\", \"x\", \"16\"], [\"x\", \"x\", \"8\", \"x\", \"14\", \"x\", \"13\", \"20\", \"17\", \"12\", \"19\", \"9\", \"x\", \"x\", \"x\"], [\"13\", \"10\", \"1\", \"4\", \"11\", \"3\", \"15\", \"x\", \"x\", \"3\", \"14\", \"20\", \"x\", \"6\", \"x\"], [\"x\", \"11\", \"16\", \"9\", \"19\", \"18\", \"12\", \"2\", \"x\", \"x\", \"1\", \"10\", \"x\", \"x\", \"x\"], [\"x\", \"13\", \"18\", \"18\", \"7\", \"x\", \"x\", \"x\", \"x\", \"18\", \"5\", \"6\", \"x\", \"7\", \"3\"], [\"x\", \"x\", \"x\", \"18\", \"6\", \"16\", \"10\", \"18\", \"9\", \"19\", \"x\", \"3\", \"5\", \"3\", \"4\"], [\"14\", \"18\", \"4\", \"1\", \"17\", \"x\", \"7\", \"x\", \"3\", \"16\", \"11\", \"x\", \"17\", \"11\", \"1\"], [\"x\", \"x\", \"12\", \"16\", \"x\", \"14\", \"9\", \"x\", \"x\", \"x\", \"13\", \"1\", \"x\", \"x\", \"19\"], [\"19\", \"x\", \"3\", \"x\", \"8\", \"x\", \"x\", \"x\", \"3\", \"x\", \"x\", \"x\", \"17\", \"9\", \"8\"], [\"15\", \"x\", \"2\", \"8\", \"9\", \"13\", \"x\", \"14\", \"x\", \"6\", \"x\", \"19\", \"x\", \"x\", \"5\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"x\", \"x\", \"9\", \"x\", \"14\", \"17\", \"x\", \"13\", \"3\", \"x\", \"13\", \"10\", \"18\"], [\"1\", \"x\", \"11\", \"12\", \"14\", \"13\", \"8\", \"x\", \"5\", \"7\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"3\", \"x\", \"x\", \"18\", \"11\", \"16\", \"x\", \"x\", \"x\", \"x\", \"1\", \"x\", \"15\", \"12\", \"10\"], [\"x\", \"10\", \"x\", \"3\", \"2\", \"15\", \"14\", \"x\", \"x\", \"x\", \"17\", \"x\", \"6\", \"1\", \"x\"], [\"8\", \"10\", \"x\", \"x\", \"x\", \"x\", \"1\", \"19\", \"6\", \"x\", \"17\", \"2\", \"x\", \"x\", \"x\"], [\"x\", \"6\", \"15\", \"2\", \"17\", \"2\", \"11\", \"5\", \"9\", \"x\", \"12\", \"15\", \"x\", \"x\", \"16\"], [\"x\", \"x\", \"8\", \"x\", \"14\", \"x\", \"13\", \"20\", \"17\", \"12\", \"19\", \"9\", \"x\", \"x\", \"x\"], [\"13\", \"10\", \"1\", \"4\", \"11\", \"3\", \"15\", \"x\", \"x\", \"3\", \"14\", \"20\", \"x\", \"6\", \"x\"], [\"x\", \"11\", \"16\", \"9\", \"19\", \"18\", \"12\", \"2\", \"x\", \"x\", \"1\", \"10\", \"x\", \"x\", \"x\"], [\"x\", \"13\", \"18\", \"18\", \"7\", \"x\", \"x\", \"x\", \"x\", \"18\", \"5\", \"6\", \"x\", \"7\", \"3\"], [\"x\", \"x\", \"x\", \"18\", \"6\", \"16\", \"10\", \"18\", \"9\", \"19\", \"x\", \"3\", \"5\", \"3\", \"4\"], [\"14\", \"18\", \"4\", \"1\", \"17\", \"x\", \"7\", \"x\", \"3\", \"16\", \"11\", \"x\", \"17\", \"11\", \"1\"], [\"x\", \"x\", \"12\", \"16\", \"x\", \"14\", \"9\", \"x\", \"x\", \"x\", \"13\", \"1\", \"x\", \"x\", \"19\"], [\"19\", \"x\", \"3\", \"x\", \"8\", \"x\", \"x\", \"x\", \"3\", \"x\", \"x\", \"x\", \"17\", \"9\", \"8\"], [\"15\", \"x\", \"2\", \"8\", \"9\", \"13\", \"x\", \"14\", \"x\", \"6\", \"x\", \"19\", \"x\", \"x\", \"5\"]], [5, 2], [9, 13], 4, 9]", "A*_args": "[\"[['x', 'x', 'x', 'x', '9', 'x', '14', '17', 'x', '13', '3', 'x', '13', '10', '18'], ['1', 'x', '11', '12', '14', '13', '8', 'x', '5', '7', 'x', 'x', 'x', 'x', 'x'], ['3', 'x', 'x', '18', '11', '16', 'x', 'x', 'x', 'x', '1', 'x', '15', '12', '10'], ['x', '10', 'x', '3', '2', '15', '14', 'x', 'x', 'x', '17', 'x', '6', '1', 'x'], ['8', '10', 'x', 'x', 'x', 'x', '1', '19', '6', 'x', '17', '2', 'x', 'x', 'x'], ['x', '6', '15', '2', '17', '2', '11', '5', '9', 'x', '12', '15', 'x', 'x', '16'], ['x', 'x', '8', 'x', '14', 'x', '13', '20', '17', '12', '19', '9', 'x', 'x', 'x'], ['13', '10', '1', '4', '11', '3', '15', 'x', 'x', '3', '14', '20', 'x', '6', 'x'], ['x', '11', '16', '9', '19', '18', '12', '2', 'x', 'x', '1', '10', 'x', 'x', 'x'], ['x', '13', '18', '18', '7', 'x', 'x', 'x', 'x', '18', '5', '6', 'x', '7', '3'], ['x', 'x', 'x', '18', '6', '16', '10', '18', '9', '19', 'x', '3', '5', '3', '4'], ['14', '18', '4', '1', '17', 'x', '7', 'x', '3', '16', '11', 'x', '17', '11', '1'], ['x', 'x', '12', '16', 'x', '14', '9', 'x', 'x', 'x', '13', '1', 'x', 'x', '19'], ['19', 'x', '3', 'x', '8', 'x', 'x', 'x', '3', 'x', 'x', 'x', '17', '9', '8'], ['15', 'x', '2', '8', '9', '13', 'x', '14', 'x', '6', 'x', '19', 'x', 'x', '5']]\", \"(5, 2)\", \"(9, 13)\", \"4\", \"9\"]"}
{"diff_sorted_id": "95", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 15x15. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 5 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 13) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (13, 5). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 0 0 1 1 0 0 1 1 0 1 0 0 0\n1 1 0 0 0 1 0 0 1 0 0 0 1 0 0\n1 1 1 1 1 1 1 1 0 0 0 0 1 1 0\n0 0 0 1 1 0 0 0 1 0 0 0 0 0 1\n1 0 0 0 0 0 0 1 1 1 1 0 1 1 1\n0 1 0 0 0 0 1 1 0 1 0 0 1 1 1\n0 0 1 0 1 0 0 0 1 1 1 0 1 0 0\n1 1 0 1 1 0 0 1 1 1 1 1 1 0 1\n1 0 1 1 1 1 0 1 0 1 0 1 1 1 0\n1 0 1 1 0 1 0 0 0 1 1 1 1 1 1\n0 0 0 1 0 0 0 1 1 0 0 0 1 0 1\n0 0 0 1 1 0 0 0 1 0 1 1 1 1 0\n1 1 1 0 0 0 0 1 0 1 0 1 1 1 1\n1 0 0 1 0 0 1 1 0 1 0 1 1 0 1\n0 0 0 0 0 1 0 1 0 0 1 1 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[[0, 13], [0, 12], [1, 11], [2, 10], [2, 9], [2, 8], [3, 7], [3, 6], [4, 6], [4, 5], [5, 5], [6, 5], [7, 5], [8, 6], [9, 6], [10, 6], [11, 6], [12, 6], [13, 5]]", "opt_solution_cost": "19", "opt_solution_compute_t": "0.029097557067871094", "solution_depth": "19", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1], [0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], [0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1], [1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1], [0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0], [1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1], [1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1]]\", 5]", "is_correct_args": "[\"[[1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1], [0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], [0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1], [1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1], [0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0], [1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1], [1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1]]\", [0, 13], [13, 5], 5]", "A*_args": "[\"[[1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1], [0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1], [0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1], [1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0], [1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1], [0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0], [1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1], [1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1]]\", \"(0, 13)\", \"(13, 5)\", \"5\"]"}
{"diff_sorted_id": "95", "problem_statement": "Given 9 labeled water jugs with capacities 146, 45, 136, 13, 148, 17, 42, 137, 141, 31 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 307, 384, 555, 575 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "7", "opt_solution": "[[\"+\", 136, 4], [\"+\", 137, 4], [\"+\", 141, 4], [\"+\", 148, 4], [\"+\", 13, 4], [\"+\", 136, 3], [\"+\", 136, 3], [\"+\", 137, 3], [\"+\", 146, 3], [\"+\", 45, 2], [\"+\", 45, 2], [\"+\", 146, 2], [\"+\", 148, 2], [\"+\", 146, 1], [\"+\", 148, 1], [\"+\", 13, 1]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.049184560775756836", "solution_depth": "16", "max_successor_states": "80", "num_vars_per_state": "3", "is_feasible_args": "[[146, 45, 136, 13, 148, 17, 42, 137, 141, 31], [307, 384, 555, 575]]", "is_correct_args": "[[146, 45, 136, 13, 148, 17, 42, 137, 141, 31], [307, 384, 555, 575]]", "A*_args": "[\"[146, 45, 136, 13, 148, 17, 42, 137, 141, 31]\", \"[307, 384, 555, 575]\"]"}
{"diff_sorted_id": "96", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[99, 98, 87, 84, 72, 64], [60, 59, 19, 57, '_', 53], [33, 22, 18, 48, 16, 37]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "5", "opt_solution": "[53, 37, 16, 48, 18, 19, 57, 53, 48, 16]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.02994561195373535", "solution_depth": "10", "max_successor_states": "4", "num_vars_per_state": "18", "is_feasible_args": "[[[99, 98, 87, 84, 72, 64], [60, 59, 19, 57, \"_\", 53], [33, 22, 18, 48, 16, 37]]]", "is_correct_args": "[[[99, 98, 87, 84, 72, 64], [60, 59, 19, 57, \"_\", 53], [33, 22, 18, 48, 16, 37]]]", "A*_args": "[\"[[99, 98, 87, 84, 72, 64], [60, 59, 19, 57, '_', 53], [33, 22, 18, 48, 16, 37]]\"]"}
{"diff_sorted_id": "96", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: siena, locked, conche, celtic, blanco   The initial board: [['o', 's', 'n', 'e', 'd', 'a'], ['l', 'k', 'c', 'c', 'e', 'h'], ['t', 'o', '_', 'c', 'n', 'e'], ['c', 'i', 'l', 'a', 'i', 'c'], ['b', 'l', 'e', 'n', 'c', 'o']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[\"up-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"down-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.39241790771484375", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "30", "is_feasible_args": "[[[\"o\", \"s\", \"n\", \"e\", \"d\", \"a\"], [\"l\", \"k\", \"c\", \"c\", \"e\", \"h\"], [\"t\", \"o\", \"_\", \"c\", \"n\", \"e\"], [\"c\", \"i\", \"l\", \"a\", \"i\", \"c\"], [\"b\", \"l\", \"e\", \"n\", \"c\", \"o\"]]]", "is_correct_args": "[[[\"o\", \"s\", \"n\", \"e\", \"d\", \"a\"], [\"l\", \"k\", \"c\", \"c\", \"e\", \"h\"], [\"t\", \"o\", \"_\", \"c\", \"n\", \"e\"], [\"c\", \"i\", \"l\", \"a\", \"i\", \"c\"], [\"b\", \"l\", \"e\", \"n\", \"c\", \"o\"]], [\"siena\", \"locked\", \"conche\", \"celtic\", \"blanco\"]]", "A*_args": "[\"[['o', 's', 'n', 'e', 'd', 'a'], ['l', 'k', 'c', 'c', 'e', 'h'], ['t', 'o', '_', 'c', 'n', 'e'], ['c', 'i', 'l', 'a', 'i', 'c'], ['b', 'l', 'e', 'n', 'c', 'o']]\", \"['siena', 'locked', 'conche', 'celtic', 'blanco']\"]"}
{"diff_sorted_id": "96", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'O'. Our task is to visit city J and city K excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from K and J, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  R J E Y A L T K C N B S Z X O \nR 0 0 0 0 0 1 0 1 1 0 0 1 0 0 0 \nJ 1 0 0 1 0 0 0 1 0 0 1 0 0 1 0 \nE 1 0 0 0 1 1 1 1 0 0 0 0 1 0 0 \nY 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 \nA 1 0 0 1 0 0 0 0 1 1 1 0 1 0 0 \nL 1 1 0 0 1 0 0 0 1 0 0 0 1 0 0 \nT 0 1 0 0 0 1 0 0 1 0 0 0 0 0 0 \nK 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 \nC 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 \nN 0 0 1 0 0 1 0 1 1 0 0 0 0 0 0 \nB 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 \nS 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 \nZ 1 1 0 0 0 0 0 1 1 1 1 1 0 0 0 \nX 1 1 0 1 1 1 0 0 0 0 0 1 0 0 0 \nO 0 0 0 0 1 0 1 0 0 1 1 1 1 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[\"O\", \"T\", \"J\", \"K\", \"X\", \"J\", \"K\"]", "opt_solution_cost": "7", "opt_solution_compute_t": "0.03685426712036133", "solution_depth": "7", "max_successor_states": "15", "num_vars_per_state": "18", "is_feasible_args": "[[[0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0], [1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0]], [\"R\", \"J\", \"E\", \"Y\", \"A\", \"L\", \"T\", \"K\", \"C\", \"N\", \"B\", \"S\", \"Z\", \"X\", \"O\"], \"J\", \"K\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0], [1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0]], [\"R\", \"J\", \"E\", \"Y\", \"A\", \"L\", \"T\", \"K\", \"C\", \"N\", \"B\", \"S\", \"Z\", \"X\", \"O\"], \"O\", \"J\", \"K\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0], [1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0], [1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0]]\", \"['R', 'J', 'E', 'Y', 'A', 'L', 'T', 'K', 'C', 'N', 'B', 'S', 'Z', 'X', 'O']\", \"['O']\", \"['J', 'K']\"]"}
{"diff_sorted_id": "96", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [22, 25, 37, 5, 46, 10, 23, 23, 3, 6, 34, 32, 34, 2, 3, 8, 4, 28, 32, 24, 15, 38, 17, 35, 9, 12, 12, 22, 34, 48, 39, 30, 7, 18, 10, 46, 30, 36, 49, 27, 22, 19, 9, 24, 43, 15], such that the sum of the chosen coins adds up to 463. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {18: 11, 17: 7, 7: 6, 43: 2, 22: 3, 24: 11, 9: 3, 36: 10, 46: 4, 10: 3, 39: 5, 5: 5, 35: 15, 28: 8, 15: 2, 34: 6, 27: 3, 38: 11, 30: 20, 23: 18, 25: 10, 12: 1, 4: 1, 49: 16, 37: 6, 48: 17, 2: 2, 8: 4, 3: 1, 6: 3, 19: 10, 32: 19}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "26", "opt_solution": "[46, 22, 27, 22, 43, 22, 12, 15, 15, 37, 39, 34, 49, 46, 34]", "opt_solution_cost": "66", "opt_solution_compute_t": "0.06879425048828125", "solution_depth": "15", "max_successor_states": "46", "num_vars_per_state": "46", "is_feasible_args": "[[22, 25, 37, 5, 46, 10, 23, 23, 3, 6, 34, 32, 34, 2, 3, 8, 4, 28, 32, 24, 15, 38, 17, 35, 9, 12, 12, 22, 34, 48, 39, 30, 7, 18, 10, 46, 30, 36, 49, 27, 22, 19, 9, 24, 43, 15]]", "is_correct_args": "[[22, 25, 37, 5, 46, 10, 23, 23, 3, 6, 34, 32, 34, 2, 3, 8, 4, 28, 32, 24, 15, 38, 17, 35, 9, 12, 12, 22, 34, 48, 39, 30, 7, 18, 10, 46, 30, 36, 49, 27, 22, 19, 9, 24, 43, 15], {\"18\": 11, \"17\": 7, \"7\": 6, \"43\": 2, \"22\": 3, \"24\": 11, \"9\": 3, \"36\": 10, \"46\": 4, \"10\": 3, \"39\": 5, \"5\": 5, \"35\": 15, \"28\": 8, \"15\": 2, \"34\": 6, \"27\": 3, \"38\": 11, \"30\": 20, \"23\": 18, \"25\": 10, \"12\": 1, \"4\": 1, \"49\": 16, \"37\": 6, \"48\": 17, \"2\": 2, \"8\": 4, \"3\": 1, \"6\": 3, \"19\": 10, \"32\": 19}, 463]", "A*_args": "[\"[22, 25, 37, 5, 46, 10, 23, 23, 3, 6, 34, 32, 34, 2, 3, 8, 4, 28, 32, 24, 15, 38, 17, 35, 9, 12, 12, 22, 34, 48, 39, 30, 7, 18, 10, 46, 30, 36, 49, 27, 22, 19, 9, 24, 43, 15]\", \"{18: 11, 17: 7, 7: 6, 43: 2, 22: 3, 24: 11, 9: 3, 36: 10, 46: 4, 10: 3, 39: 5, 5: 5, 35: 15, 28: 8, 15: 2, 34: 6, 27: 3, 38: 11, 30: 20, 23: 18, 25: 10, 12: 1, 4: 1, 49: 16, 37: 6, 48: 17, 2: 2, 8: 4, 3: 1, 6: 3, 19: 10, 32: 19}\", \"463\"]"}
{"diff_sorted_id": "96", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Red', 'Red', 'Green', 'Blue'], ['Green', 'Blue', 'Blue', 'Blue', 'Red', 'Red'], ['Green', 'Green', 'Green', 'Blue', 'Red', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[1, 2], [1, 0], [1, 0], [1, 0], [1, 2], [1, 2], [0, 1], [0, 1], [0, 1], [0, 1], [2, 1], [2, 1], [0, 2], [0, 1], [0, 1], [0, 2], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [1, 0], [1, 2], [1, 2], [1, 2], [1, 2], [0, 1], [0, 1]]", "opt_solution_cost": "31", "opt_solution_compute_t": "507.0654656887054", "solution_depth": "31", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Red\", \"Red\", \"Green\", \"Blue\"], [\"Green\", \"Blue\", \"Blue\", \"Blue\", \"Red\", \"Red\"], [\"Green\", \"Green\", \"Green\", \"Blue\", \"Red\", \"Red\"]], 9]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Red\", \"Red\", \"Green\", \"Blue\"], [\"Green\", \"Blue\", \"Blue\", \"Blue\", \"Red\", \"Red\"], [\"Green\", \"Green\", \"Green\", \"Blue\", \"Red\", \"Red\"]], 9]", "A*_args": "[\"[['Blue', 'Green', 'Red', 'Red', 'Green', 'Blue'], ['Green', 'Blue', 'Blue', 'Blue', 'Red', 'Red'], ['Green', 'Green', 'Green', 'Blue', 'Red', 'Red']]\", \"9\"]"}
{"diff_sorted_id": "96", "problem_statement": "We have a 4x4 numerical grid, with numbers ranging from 28 to 83 (28 included in the range but 83 is not included). The numbers in each row and column must be strictly increasing or decreasing. This means that either first > second > third > fourth or first < second < third < fourth in each row and column. If a grid cell is marked with an 'x', the number in that position is hidden. The objective is to replace the 'x's with unique integers from the given range, ensuring that each number only appears once in the grid. The replacements must maintain the consecutive order in each row and column. Additionally, the sum of the numbers in the topmost row plus the numbers in the rightmost column plus the numbers in the diagonal connecting the top-left corner of the grid to its bottom-right corner should be minimized. The solution should be given as a list of tuples in Python syntax. Each tuple should represent the replacement of a number with an  'x' number and contain three elements: the row index of the 'x', the column index  of the 'x' (both starting from 0), and the value of the number that replaces the 'x'. The initial state of the grid is as follows: \n\nGrid:\n [['81' '52' 'x' 'x']\n ['x' '50' '53' 'x']\n ['42' 'x' '54' '74']\n ['x' 'x' '56' '77']]", "problem_type": "consecutive_grid", "problem_category": "underdetermined_system", "relative_diff_score": "12", "opt_solution": "[[0, 0, 25], [0, 2, 64], [1, 0, 24], [2, 0, 23], [2, 1, 44], [2, 2, 46], [3, 2, 45]]", "opt_solution_cost": "696", "opt_solution_compute_t": "10.49123215675354", "solution_depth": "7", "max_successor_states": "55", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '58', '', '77'], ['', '49', '63', '70'], ['', '', '', '69'], ['22', '43', '', '68']]\", 22, 82]", "is_correct_args": "[\"[['', '58', '', '77'], ['', '49', '63', '70'], ['', '', '', '69'], ['22', '43', '', '68']]\", 22, 82]", "A*_args": "[\"[['', '58', '', '77'], ['', '49', '63', '70'], ['', '', '', '69'], ['22', '43', '', '68']]\", \"22\", \"82\"]"}
{"diff_sorted_id": "96", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 11 to 62. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 148, 109, None for columns 1 to 2 respectively, and the sums of rows must be None, 105, 115, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 134. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x' 'x']\n ['x' '52' '20' 'x']\n ['41' '13' 'x' 'x']\n ['54' 'x' '16' '11']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "8", "opt_solution": "[[0, 0, 14], [0, 1, 22], [0, 2, 24], [0, 3, 47], [1, 0, 15], [1, 3, 18], [2, 2, 49], [2, 3, 12], [3, 1, 61]]", "opt_solution_cost": "469", "opt_solution_compute_t": "202.49410438537598", "solution_depth": "9", "max_successor_states": "36", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '', ''], ['', '52', '20', ''], ['41', '13', '', ''], ['54', '', '16', '11']]\", 4, 11, 62]", "is_correct_args": "[\"[['', '', '', ''], ['', '52', '20', ''], ['41', '13', '', ''], ['54', '', '16', '11']]\", 11, 62, [1, 3], [1, 3], [148, 109], [105, 115], 134]", "A*_args": "[\"[['', '', '', ''], ['', '52', '20', ''], ['41', '13', '', ''], ['54', '', '16', '11']]\", \"11\", \"62\", \"[None, 148, 109, None]\", \"[None, 105, 115, None]\", \"134\"]"}
{"diff_sorted_id": "96", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (8, 13) to his destination workshop at index (3, 3), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 7, and district 3 covering rows 8 to 14. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 9 x 10 x 11 13 5 4 x x 19 13 x x]\n[x 6 3 8 18 8 1 5 2 x x 17 x x x]\n[x x 11 5 x 11 13 20 7 x x x x 15 4]\n[x 3 x 14 4 20 4 15 12 12 4 x 8 4 x]\n[4 1 x 9 17 x 17 x 11 16 6 12 x 18 x]\n[8 5 17 x x 1 x x x 19 14 2 1 x x]\n[11 9 x x 14 x x x x x x 2 12 4 16]\n[x x 2 x x 6 6 8 x 11 18 11 10 x x]\n[x x x 16 x 7 x x x x 7 11 18 9 17]\n[13 19 13 x 18 x 14 x 14 14 x x 20 15 15]\n[x x x x 17 x 8 x x x x x 6 11 x]\n[5 x 7 x 15 x x 19 1 x x 10 x x 18]\n[11 19 x 18 x 5 x 19 16 x x 13 x x 5]\n[8 16 6 13 1 x 14 4 x x x 1 x x 5]\n[x 19 5 x x x 12 5 9 16 11 9 14 x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "7", "opt_solution": "[[8, 13], [8, 12], [7, 12], [7, 11], [6, 11], [5, 11], [4, 11], [4, 10], [3, 10], [3, 9], [3, 8], [3, 7], [3, 6], [3, 5], [3, 4], [3, 3]]", "opt_solution_cost": "146", "opt_solution_compute_t": "0.02926325798034668", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"9\", \"x\", \"10\", \"x\", \"11\", \"13\", \"5\", \"4\", \"x\", \"x\", \"19\", \"13\", \"x\", \"x\"], [\"x\", \"6\", \"3\", \"8\", \"18\", \"8\", \"1\", \"5\", \"2\", \"x\", \"x\", \"17\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"11\", \"5\", \"x\", \"11\", \"13\", \"20\", \"7\", \"x\", \"x\", \"x\", \"x\", \"15\", \"4\"], [\"x\", \"3\", \"x\", \"14\", \"4\", \"20\", \"4\", \"15\", \"12\", \"12\", \"4\", \"x\", \"8\", \"4\", \"x\"], [\"4\", \"1\", \"x\", \"9\", \"17\", \"x\", \"17\", \"x\", \"11\", \"16\", \"6\", \"12\", \"x\", \"18\", \"x\"], [\"8\", \"5\", \"17\", \"x\", \"x\", \"1\", \"x\", \"x\", \"x\", \"19\", \"14\", \"2\", \"1\", \"x\", \"x\"], [\"11\", \"9\", \"x\", \"x\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"2\", \"12\", \"4\", \"16\"], [\"x\", \"x\", \"2\", \"x\", \"x\", \"6\", \"6\", \"8\", \"x\", \"11\", \"18\", \"11\", \"10\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"16\", \"x\", \"7\", \"x\", \"x\", \"x\", \"x\", \"7\", \"11\", \"18\", \"9\", \"17\"], [\"13\", \"19\", \"13\", \"x\", \"18\", \"x\", \"14\", \"x\", \"14\", \"14\", \"x\", \"x\", \"20\", \"15\", \"15\"], [\"x\", \"x\", \"x\", \"x\", \"17\", \"x\", \"8\", \"x\", \"x\", \"x\", \"x\", \"x\", \"6\", \"11\", \"x\"], [\"5\", \"x\", \"7\", \"x\", \"15\", \"x\", \"x\", \"19\", \"1\", \"x\", \"x\", \"10\", \"x\", \"x\", \"18\"], [\"11\", \"19\", \"x\", \"18\", \"x\", \"5\", \"x\", \"19\", \"16\", \"x\", \"x\", \"13\", \"x\", \"x\", \"5\"], [\"8\", \"16\", \"6\", \"13\", \"1\", \"x\", \"14\", \"4\", \"x\", \"x\", \"x\", \"1\", \"x\", \"x\", \"5\"], [\"x\", \"19\", \"5\", \"x\", \"x\", \"x\", \"12\", \"5\", \"9\", \"16\", \"11\", \"9\", \"14\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"9\", \"x\", \"10\", \"x\", \"11\", \"13\", \"5\", \"4\", \"x\", \"x\", \"19\", \"13\", \"x\", \"x\"], [\"x\", \"6\", \"3\", \"8\", \"18\", \"8\", \"1\", \"5\", \"2\", \"x\", \"x\", \"17\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"11\", \"5\", \"x\", \"11\", \"13\", \"20\", \"7\", \"x\", \"x\", \"x\", \"x\", \"15\", \"4\"], [\"x\", \"3\", \"x\", \"14\", \"4\", \"20\", \"4\", \"15\", \"12\", \"12\", \"4\", \"x\", \"8\", \"4\", \"x\"], [\"4\", \"1\", \"x\", \"9\", \"17\", \"x\", \"17\", \"x\", \"11\", \"16\", \"6\", \"12\", \"x\", \"18\", \"x\"], [\"8\", \"5\", \"17\", \"x\", \"x\", \"1\", \"x\", \"x\", \"x\", \"19\", \"14\", \"2\", \"1\", \"x\", \"x\"], [\"11\", \"9\", \"x\", \"x\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"2\", \"12\", \"4\", \"16\"], [\"x\", \"x\", \"2\", \"x\", \"x\", \"6\", \"6\", \"8\", \"x\", \"11\", \"18\", \"11\", \"10\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"16\", \"x\", \"7\", \"x\", \"x\", \"x\", \"x\", \"7\", \"11\", \"18\", \"9\", \"17\"], [\"13\", \"19\", \"13\", \"x\", \"18\", \"x\", \"14\", \"x\", \"14\", \"14\", \"x\", \"x\", \"20\", \"15\", \"15\"], [\"x\", \"x\", \"x\", \"x\", \"17\", \"x\", \"8\", \"x\", \"x\", \"x\", \"x\", \"x\", \"6\", \"11\", \"x\"], [\"5\", \"x\", \"7\", \"x\", \"15\", \"x\", \"x\", \"19\", \"1\", \"x\", \"x\", \"10\", \"x\", \"x\", \"18\"], [\"11\", \"19\", \"x\", \"18\", \"x\", \"5\", \"x\", \"19\", \"16\", \"x\", \"x\", \"13\", \"x\", \"x\", \"5\"], [\"8\", \"16\", \"6\", \"13\", \"1\", \"x\", \"14\", \"4\", \"x\", \"x\", \"x\", \"1\", \"x\", \"x\", \"5\"], [\"x\", \"19\", \"5\", \"x\", \"x\", \"x\", \"12\", \"5\", \"9\", \"16\", \"11\", \"9\", \"14\", \"x\", \"x\"]], [8, 13], [3, 3], 3, 7]", "A*_args": "[\"[['x', '9', 'x', '10', 'x', '11', '13', '5', '4', 'x', 'x', '19', '13', 'x', 'x'], ['x', '6', '3', '8', '18', '8', '1', '5', '2', 'x', 'x', '17', 'x', 'x', 'x'], ['x', 'x', '11', '5', 'x', '11', '13', '20', '7', 'x', 'x', 'x', 'x', '15', '4'], ['x', '3', 'x', '14', '4', '20', '4', '15', '12', '12', '4', 'x', '8', '4', 'x'], ['4', '1', 'x', '9', '17', 'x', '17', 'x', '11', '16', '6', '12', 'x', '18', 'x'], ['8', '5', '17', 'x', 'x', '1', 'x', 'x', 'x', '19', '14', '2', '1', 'x', 'x'], ['11', '9', 'x', 'x', '14', 'x', 'x', 'x', 'x', 'x', 'x', '2', '12', '4', '16'], ['x', 'x', '2', 'x', 'x', '6', '6', '8', 'x', '11', '18', '11', '10', 'x', 'x'], ['x', 'x', 'x', '16', 'x', '7', 'x', 'x', 'x', 'x', '7', '11', '18', '9', '17'], ['13', '19', '13', 'x', '18', 'x', '14', 'x', '14', '14', 'x', 'x', '20', '15', '15'], ['x', 'x', 'x', 'x', '17', 'x', '8', 'x', 'x', 'x', 'x', 'x', '6', '11', 'x'], ['5', 'x', '7', 'x', '15', 'x', 'x', '19', '1', 'x', 'x', '10', 'x', 'x', '18'], ['11', '19', 'x', '18', 'x', '5', 'x', '19', '16', 'x', 'x', '13', 'x', 'x', '5'], ['8', '16', '6', '13', '1', 'x', '14', '4', 'x', 'x', 'x', '1', 'x', 'x', '5'], ['x', '19', '5', 'x', 'x', 'x', '12', '5', '9', '16', '11', '9', '14', 'x', 'x']]\", \"(8, 13)\", \"(3, 3)\", \"3\", \"7\"]"}
{"diff_sorted_id": "96", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 15x15. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 5 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (3, 10) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (13, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 1 1 0 1 1 1 0 0 0 1 1 0\n0 1 1 0 1 0 1 0 1 1 1 1 1 0 0\n1 0 0 1 0 1 0 1 1 1 0 1 1 0 1\n1 0 0 1 0 0 1 1 1 1 0 0 1 0 0\n0 1 1 1 1 0 1 0 1 0 1 1 1 1 0\n0 0 0 0 1 1 1 1 1 0 1 0 1 1 1\n1 1 1 1 1 1 1 0 1 0 1 0 1 1 1\n1 1 1 1 0 1 1 1 0 0 0 1 1 0 1\n0 0 1 0 0 0 0 0 0 0 1 1 0 1 0\n0 0 0 0 0 0 0 0 0 1 1 0 1 0 0\n0 0 1 0 0 0 0 1 1 1 1 1 0 0 0\n0 0 1 1 1 1 0 0 0 0 1 1 1 0 0\n0 0 1 1 1 1 1 1 1 1 1 0 1 1 1\n0 1 0 1 1 1 1 0 0 0 1 0 0 1 0\n0 0 1 0 1 1 0 1 1 1 1 0 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[[3, 10], [4, 9], [5, 9], [6, 9], [7, 8], [8, 7], [8, 6], [8, 5], [8, 4], [9, 4], [9, 3], [9, 2], [10, 1], [11, 1], [12, 1], [13, 0]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.02433037757873535", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1], [0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1]]\", 5]", "is_correct_args": "[\"[[1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1], [0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1]]\", [3, 10], [13, 0], 5]", "A*_args": "[\"[[1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0], [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1], [0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0], [0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1]]\", \"(3, 10)\", \"(13, 0)\", \"5\"]"}
{"diff_sorted_id": "96", "problem_statement": "Given 9 labeled water jugs with capacities 90, 21, 104, 111, 97, 22, 34, 15, 62, 52 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 177, 263, 294, 462 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "7", "opt_solution": "[[\"+\", 52, 4], [\"+\", 62, 4], [\"+\", 111, 4], [\"+\", 111, 4], [\"+\", 104, 4], [\"+\", 22, 4], [\"+\", 90, 3], [\"+\", 90, 3], [\"+\", 52, 3], [\"+\", 62, 3], [\"+\", 90, 2], [\"+\", 111, 2], [\"+\", 62, 2], [\"+\", 52, 1], [\"+\", 104, 1], [\"+\", 21, 1]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.06696057319641113", "solution_depth": "16", "max_successor_states": "80", "num_vars_per_state": "3", "is_feasible_args": "[[90, 21, 104, 111, 97, 22, 34, 15, 62, 52], [177, 263, 294, 462]]", "is_correct_args": "[[90, 21, 104, 111, 97, 22, 34, 15, 62, 52], [177, 263, 294, 462]]", "A*_args": "[\"[90, 21, 104, 111, 97, 22, 34, 15, 62, 52]\", \"[177, 263, 294, 462]\"]"}
{"diff_sorted_id": "97", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[100, 96, 93, 82, 6, 19], [68, 53, 50, 9, '_', 24], [16, 15, 48, 10, 76, 74]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[6, 82, 93, 50, 48, 10, 76, 74, 24, 6, 74, 76, 9, 48, 50, 93, 82, 74, 76, 24, 6, 19, 74, 76, 24, 6]", "opt_solution_cost": "26", "opt_solution_compute_t": "1.0652458667755127", "solution_depth": "26", "max_successor_states": "4", "num_vars_per_state": "18", "is_feasible_args": "[[[100, 96, 93, 82, 6, 19], [68, 53, 50, 9, \"_\", 24], [16, 15, 48, 10, 76, 74]]]", "is_correct_args": "[[[100, 96, 93, 82, 6, 19], [68, 53, 50, 9, \"_\", 24], [16, 15, 48, 10, 76, 74]]]", "A*_args": "[\"[[100, 96, 93, 82, 6, 19], [68, 53, 50, 9, '_', 24], [16, 15, 48, 10, 76, 74]]\"]"}
{"diff_sorted_id": "97", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: burst, merril, monase, chivey, tilpah   The initial board: [['e', 'b', 'v', 'r', 'l', 't'], ['m', 'u', 'r', 'm', 'i', 'r'], ['h', 'o', 'a', 'a', '_', 'e'], ['c', 'n', 'i', 's', 'e', 's'], ['t', 'i', 'l', 'p', 'y', 'h']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[\"down-left\", \"up-left\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.3242766857147217", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "30", "is_feasible_args": "[[[\"e\", \"b\", \"v\", \"r\", \"l\", \"t\"], [\"m\", \"u\", \"r\", \"m\", \"i\", \"r\"], [\"h\", \"o\", \"a\", \"a\", \"_\", \"e\"], [\"c\", \"n\", \"i\", \"s\", \"e\", \"s\"], [\"t\", \"i\", \"l\", \"p\", \"y\", \"h\"]]]", "is_correct_args": "[[[\"e\", \"b\", \"v\", \"r\", \"l\", \"t\"], [\"m\", \"u\", \"r\", \"m\", \"i\", \"r\"], [\"h\", \"o\", \"a\", \"a\", \"_\", \"e\"], [\"c\", \"n\", \"i\", \"s\", \"e\", \"s\"], [\"t\", \"i\", \"l\", \"p\", \"y\", \"h\"]], [\"burst\", \"merril\", \"monase\", \"chivey\", \"tilpah\"]]", "A*_args": "[\"[['e', 'b', 'v', 'r', 'l', 't'], ['m', 'u', 'r', 'm', 'i', 'r'], ['h', 'o', 'a', 'a', '_', 'e'], ['c', 'n', 'i', 's', 'e', 's'], ['t', 'i', 'l', 'p', 'y', 'h']]\", \"['burst', 'merril', 'monase', 'chivey', 'tilpah']\"]"}
{"diff_sorted_id": "97", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'Q'. Our task is to visit city Y and city N excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from N and Y, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  R Y W H J A O N U E Q L P V X \nR 0 0 0 0 1 1 0 0 0 0 0 0 0 0 0 \nY 1 0 1 0 0 1 1 0 1 0 0 0 0 1 1 \nW 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 \nH 0 1 0 0 0 0 1 0 0 1 0 0 1 0 0 \nJ 0 1 1 1 0 0 1 0 1 0 0 1 0 0 0 \nA 0 0 1 0 0 0 0 1 0 1 0 0 0 0 0 \nO 1 0 1 0 0 0 0 0 0 0 0 0 0 1 0 \nN 1 1 0 0 0 1 0 0 0 1 0 0 1 0 0 \nU 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 \nE 0 1 1 0 0 0 1 0 0 0 0 0 0 0 1 \nQ 1 0 0 0 0 0 1 0 0 1 0 0 0 0 0 \nL 1 0 1 0 0 1 0 0 0 0 0 0 0 0 0 \nP 0 1 0 0 0 0 0 1 1 1 0 0 0 0 0 \nV 0 0 0 1 1 0 0 0 0 0 0 1 1 0 0 \nX 0 0 0 1 0 1 0 1 0 0 1 0 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[\"Q\", \"E\", \"Y\", \"A\", \"N\", \"Y\", \"X\", \"N\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.03821444511413574", "solution_depth": "8", "max_successor_states": "15", "num_vars_per_state": "18", "is_feasible_args": "[[[0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0]], [\"R\", \"Y\", \"W\", \"H\", \"J\", \"A\", \"O\", \"N\", \"U\", \"E\", \"Q\", \"L\", \"P\", \"V\", \"X\"], \"Y\", \"N\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0]], [\"R\", \"Y\", \"W\", \"H\", \"J\", \"A\", \"O\", \"N\", \"U\", \"E\", \"Q\", \"L\", \"P\", \"V\", \"X\"], \"Q\", \"Y\", \"N\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0]]\", \"['R', 'Y', 'W', 'H', 'J', 'A', 'O', 'N', 'U', 'E', 'Q', 'L', 'P', 'V', 'X']\", \"['Q']\", \"['Y', 'N']\"]"}
{"diff_sorted_id": "97", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [39, 3, 38, 10, 3, 5, 6, 14, 32, 7, 30, 28, 17, 9, 8, 13, 17, 41, 25, 6, 19, 36, 5, 36, 8, 38, 6, 19, 25, 3, 22, 18, 3, 21, 57, 37, 42, 30, 54, 13, 36, 6, 13, 17, 10, 4, 36], such that the sum of the chosen coins adds up to 452. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {37: 2, 38: 4, 30: 18, 39: 18, 14: 1, 18: 1, 4: 1, 10: 8, 21: 10, 6: 5, 42: 13, 32: 10, 25: 2, 17: 15, 13: 2, 9: 4, 22: 17, 7: 5, 3: 2, 54: 7, 19: 15, 8: 2, 36: 17, 28: 6, 5: 5, 41: 9, 57: 12}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "27", "opt_solution": "[38, 18, 25, 37, 4, 13, 13, 25, 8, 13, 57, 54, 38, 28, 8, 41, 32]", "opt_solution_cost": "70", "opt_solution_compute_t": "0.06327366828918457", "solution_depth": "17", "max_successor_states": "47", "num_vars_per_state": "47", "is_feasible_args": "[[39, 3, 38, 10, 3, 5, 6, 14, 32, 7, 30, 28, 17, 9, 8, 13, 17, 41, 25, 6, 19, 36, 5, 36, 8, 38, 6, 19, 25, 3, 22, 18, 3, 21, 57, 37, 42, 30, 54, 13, 36, 6, 13, 17, 10, 4, 36]]", "is_correct_args": "[[39, 3, 38, 10, 3, 5, 6, 14, 32, 7, 30, 28, 17, 9, 8, 13, 17, 41, 25, 6, 19, 36, 5, 36, 8, 38, 6, 19, 25, 3, 22, 18, 3, 21, 57, 37, 42, 30, 54, 13, 36, 6, 13, 17, 10, 4, 36], {\"37\": 2, \"38\": 4, \"30\": 18, \"39\": 18, \"14\": 1, \"18\": 1, \"4\": 1, \"10\": 8, \"21\": 10, \"6\": 5, \"42\": 13, \"32\": 10, \"25\": 2, \"17\": 15, \"13\": 2, \"9\": 4, \"22\": 17, \"7\": 5, \"3\": 2, \"54\": 7, \"19\": 15, \"8\": 2, \"36\": 17, \"28\": 6, \"5\": 5, \"41\": 9, \"57\": 12}, 452]", "A*_args": "[\"[39, 3, 38, 10, 3, 5, 6, 14, 32, 7, 30, 28, 17, 9, 8, 13, 17, 41, 25, 6, 19, 36, 5, 36, 8, 38, 6, 19, 25, 3, 22, 18, 3, 21, 57, 37, 42, 30, 54, 13, 36, 6, 13, 17, 10, 4, 36]\", \"{37: 2, 38: 4, 30: 18, 39: 18, 14: 1, 18: 1, 4: 1, 10: 8, 21: 10, 6: 5, 42: 13, 32: 10, 25: 2, 17: 15, 13: 2, 9: 4, 22: 17, 7: 5, 3: 2, 54: 7, 19: 15, 8: 2, 36: 17, 28: 6, 5: 5, 41: 9, 57: 12}\", \"452\"]"}
{"diff_sorted_id": "97", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Red', 'Red', 'Blue', 'Red', 'Blue', 'Green'], ['Red', 'Green', 'Blue', 'Blue', 'Green', 'Red'], ['Blue', 'Green', 'Green', 'Red', 'Blue', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[1, 0], [1, 0], [2, 1], [0, 1], [2, 1], [2, 1], [2, 0], [2, 0], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [0, 2], [1, 2], [1, 2], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [0, 1], [2, 1], [0, 1], [0, 2], [1, 0], [2, 1], [2, 0], [2, 0], [2, 0], [2, 0], [1, 2], [1, 2], [1, 2], [1, 0], [2, 1]]", "opt_solution_cost": "36", "opt_solution_compute_t": "382.4207499027252", "solution_depth": "36", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Red\", \"Red\", \"Blue\", \"Red\", \"Blue\", \"Green\"], [\"Red\", \"Green\", \"Blue\", \"Blue\", \"Green\", \"Red\"], [\"Blue\", \"Green\", \"Green\", \"Red\", \"Blue\", \"Green\"]], 9]", "is_correct_args": "[[[\"Red\", \"Red\", \"Blue\", \"Red\", \"Blue\", \"Green\"], [\"Red\", \"Green\", \"Blue\", \"Blue\", \"Green\", \"Red\"], [\"Blue\", \"Green\", \"Green\", \"Red\", \"Blue\", \"Green\"]], 9]", "A*_args": "[\"[['Red', 'Red', 'Blue', 'Red', 'Blue', 'Green'], ['Red', 'Green', 'Blue', 'Blue', 'Green', 'Red'], ['Blue', 'Green', 'Green', 'Red', 'Blue', 'Green']]\", \"9\"]"}
{"diff_sorted_id": "97", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 11 to 62. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 117, 160, None for columns 1 to 2 respectively, and the sums of rows must be None, 175, 114, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 114. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['58' '19' 'x' 'x']\n ['x' 'x' 'x' 'x']\n ['x' '22' 'x' '39']\n ['x' '16' '53' '29']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 2, 11], [0, 3, 14], [1, 0, 12], [1, 1, 60], [1, 2, 61], [1, 3, 42], [2, 0, 18], [2, 2, 35], [3, 0, 17]]", "opt_solution_cost": "506", "opt_solution_compute_t": "231.75803446769714", "solution_depth": "9", "max_successor_states": "36", "num_vars_per_state": "16", "is_feasible_args": "[\"[['58', '19', '', ''], ['', '', '', ''], ['', '22', '', '39'], ['', '16', '53', '29']]\", 4, 11, 62]", "is_correct_args": "[\"[['58', '19', '', ''], ['', '', '', ''], ['', '22', '', '39'], ['', '16', '53', '29']]\", 11, 62, [1, 3], [1, 3], [117, 160], [175, 114], 114]", "A*_args": "[\"[['58', '19', '', ''], ['', '', '', ''], ['', '22', '', '39'], ['', '16', '53', '29']]\", \"11\", \"62\", \"[None, 117, 160, None]\", \"[None, 175, 114, None]\", \"114\"]"}
{"diff_sorted_id": "97", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (9, 1) to his destination workshop at index (7, 14), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 5, district 2 covering rows 6 to 8, and district 3 covering rows 9 to 14. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[17 8 x 3 x 13 x x 14 11 x x x x x]\n[x x x 7 x x 13 x x x x x 16 x 13]\n[x x 2 x x 12 10 x x x 2 x x 5 17]\n[4 3 x 14 x x 16 x x x 1 x x x x]\n[9 x 18 11 19 5 x x x x x x 3 x x]\n[x 14 x 4 14 12 1 x 13 7 10 8 8 6 9]\n[7 10 x 18 15 8 13 14 15 x x x 13 x 17]\n[17 7 19 15 20 19 x 15 13 x 9 x 11 x 1]\n[x 9 6 17 14 x 16 x 19 11 x 14 11 x x]\n[x 18 8 2 14 2 4 x 4 4 4 x x 8 19]\n[x x 5 x x x 1 5 x 11 x x 1 14 x]\n[x x x x 5 x 10 x x x x 10 18 x 19]\n[x x 2 x 1 x x x x x x x x 6 16]\n[x 12 1 12 x x 15 7 18 15 13 19 x 2 x]\n[x 13 8 19 5 1 x 13 x x x 17 x 3 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "7", "opt_solution": "[[9, 1], [9, 2], [9, 3], [9, 4], [8, 4], [7, 4], [6, 4], [6, 5], [6, 6], [6, 7], [6, 8], [5, 8], [5, 9], [5, 10], [5, 11], [5, 12], [5, 13], [5, 14], [6, 14], [7, 14]]", "opt_solution_cost": "202", "opt_solution_compute_t": "0.027507543563842773", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"17\", \"8\", \"x\", \"3\", \"x\", \"13\", \"x\", \"x\", \"14\", \"11\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"7\", \"x\", \"x\", \"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"16\", \"x\", \"13\"], [\"x\", \"x\", \"2\", \"x\", \"x\", \"12\", \"10\", \"x\", \"x\", \"x\", \"2\", \"x\", \"x\", \"5\", \"17\"], [\"4\", \"3\", \"x\", \"14\", \"x\", \"x\", \"16\", \"x\", \"x\", \"x\", \"1\", \"x\", \"x\", \"x\", \"x\"], [\"9\", \"x\", \"18\", \"11\", \"19\", \"5\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"3\", \"x\", \"x\"], [\"x\", \"14\", \"x\", \"4\", \"14\", \"12\", \"1\", \"x\", \"13\", \"7\", \"10\", \"8\", \"8\", \"6\", \"9\"], [\"7\", \"10\", \"x\", \"18\", \"15\", \"8\", \"13\", \"14\", \"15\", \"x\", \"x\", \"x\", \"13\", \"x\", \"17\"], [\"17\", \"7\", \"19\", \"15\", \"20\", \"19\", \"x\", \"15\", \"13\", \"x\", \"9\", \"x\", \"11\", \"x\", \"1\"], [\"x\", \"9\", \"6\", \"17\", \"14\", \"x\", \"16\", \"x\", \"19\", \"11\", \"x\", \"14\", \"11\", \"x\", \"x\"], [\"x\", \"18\", \"8\", \"2\", \"14\", \"2\", \"4\", \"x\", \"4\", \"4\", \"4\", \"x\", \"x\", \"8\", \"19\"], [\"x\", \"x\", \"5\", \"x\", \"x\", \"x\", \"1\", \"5\", \"x\", \"11\", \"x\", \"x\", \"1\", \"14\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"5\", \"x\", \"10\", \"x\", \"x\", \"x\", \"x\", \"10\", \"18\", \"x\", \"19\"], [\"x\", \"x\", \"2\", \"x\", \"1\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"6\", \"16\"], [\"x\", \"12\", \"1\", \"12\", \"x\", \"x\", \"15\", \"7\", \"18\", \"15\", \"13\", \"19\", \"x\", \"2\", \"x\"], [\"x\", \"13\", \"8\", \"19\", \"5\", \"1\", \"x\", \"13\", \"x\", \"x\", \"x\", \"17\", \"x\", \"3\", \"x\"]]]", "is_correct_args": "[[[\"17\", \"8\", \"x\", \"3\", \"x\", \"13\", \"x\", \"x\", \"14\", \"11\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"7\", \"x\", \"x\", \"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"16\", \"x\", \"13\"], [\"x\", \"x\", \"2\", \"x\", \"x\", \"12\", \"10\", \"x\", \"x\", \"x\", \"2\", \"x\", \"x\", \"5\", \"17\"], [\"4\", \"3\", \"x\", \"14\", \"x\", \"x\", \"16\", \"x\", \"x\", \"x\", \"1\", \"x\", \"x\", \"x\", \"x\"], [\"9\", \"x\", \"18\", \"11\", \"19\", \"5\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"3\", \"x\", \"x\"], [\"x\", \"14\", \"x\", \"4\", \"14\", \"12\", \"1\", \"x\", \"13\", \"7\", \"10\", \"8\", \"8\", \"6\", \"9\"], [\"7\", \"10\", \"x\", \"18\", \"15\", \"8\", \"13\", \"14\", \"15\", \"x\", \"x\", \"x\", \"13\", \"x\", \"17\"], [\"17\", \"7\", \"19\", \"15\", \"20\", \"19\", \"x\", \"15\", \"13\", \"x\", \"9\", \"x\", \"11\", \"x\", \"1\"], [\"x\", \"9\", \"6\", \"17\", \"14\", \"x\", \"16\", \"x\", \"19\", \"11\", \"x\", \"14\", \"11\", \"x\", \"x\"], [\"x\", \"18\", \"8\", \"2\", \"14\", \"2\", \"4\", \"x\", \"4\", \"4\", \"4\", \"x\", \"x\", \"8\", \"19\"], [\"x\", \"x\", \"5\", \"x\", \"x\", \"x\", \"1\", \"5\", \"x\", \"11\", \"x\", \"x\", \"1\", \"14\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"5\", \"x\", \"10\", \"x\", \"x\", \"x\", \"x\", \"10\", \"18\", \"x\", \"19\"], [\"x\", \"x\", \"2\", \"x\", \"1\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"6\", \"16\"], [\"x\", \"12\", \"1\", \"12\", \"x\", \"x\", \"15\", \"7\", \"18\", \"15\", \"13\", \"19\", \"x\", \"2\", \"x\"], [\"x\", \"13\", \"8\", \"19\", \"5\", \"1\", \"x\", \"13\", \"x\", \"x\", \"x\", \"17\", \"x\", \"3\", \"x\"]], [9, 1], [7, 14], 5, 8]", "A*_args": "[\"[['17', '8', 'x', '3', 'x', '13', 'x', 'x', '14', '11', 'x', 'x', 'x', 'x', 'x'], ['x', 'x', 'x', '7', 'x', 'x', '13', 'x', 'x', 'x', 'x', 'x', '16', 'x', '13'], ['x', 'x', '2', 'x', 'x', '12', '10', 'x', 'x', 'x', '2', 'x', 'x', '5', '17'], ['4', '3', 'x', '14', 'x', 'x', '16', 'x', 'x', 'x', '1', 'x', 'x', 'x', 'x'], ['9', 'x', '18', '11', '19', '5', 'x', 'x', 'x', 'x', 'x', 'x', '3', 'x', 'x'], ['x', '14', 'x', '4', '14', '12', '1', 'x', '13', '7', '10', '8', '8', '6', '9'], ['7', '10', 'x', '18', '15', '8', '13', '14', '15', 'x', 'x', 'x', '13', 'x', '17'], ['17', '7', '19', '15', '20', '19', 'x', '15', '13', 'x', '9', 'x', '11', 'x', '1'], ['x', '9', '6', '17', '14', 'x', '16', 'x', '19', '11', 'x', '14', '11', 'x', 'x'], ['x', '18', '8', '2', '14', '2', '4', 'x', '4', '4', '4', 'x', 'x', '8', '19'], ['x', 'x', '5', 'x', 'x', 'x', '1', '5', 'x', '11', 'x', 'x', '1', '14', 'x'], ['x', 'x', 'x', 'x', '5', 'x', '10', 'x', 'x', 'x', 'x', '10', '18', 'x', '19'], ['x', 'x', '2', 'x', '1', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', '6', '16'], ['x', '12', '1', '12', 'x', 'x', '15', '7', '18', '15', '13', '19', 'x', '2', 'x'], ['x', '13', '8', '19', '5', '1', 'x', '13', 'x', 'x', 'x', '17', 'x', '3', 'x']]\", \"(9, 1)\", \"(7, 14)\", \"5\", \"8\"]"}
{"diff_sorted_id": "97", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 15x15. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 5 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (4, 14) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (11, 0). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 1 0 1 1 0 1 0 1 0 1 0 0\n1 0 0 0 1 1 0 1 1 1 1 1 1 0 0\n1 0 0 0 0 1 0 1 1 1 1 0 0 1 1\n1 1 0 1 1 0 0 1 1 1 1 1 0 0 1\n0 1 1 0 0 0 1 1 1 0 1 1 1 1 0\n1 1 1 0 0 1 1 1 0 0 1 1 0 0 0\n0 1 0 0 1 1 0 0 0 0 1 1 0 0 1\n1 1 0 0 0 0 0 0 0 0 0 0 1 1 0\n1 0 0 0 0 0 1 0 1 0 0 0 1 0 1\n1 0 0 0 0 0 1 1 1 0 0 1 1 1 1\n1 0 0 0 1 1 0 1 1 0 1 1 0 0 1\n0 0 1 1 1 1 1 0 1 1 0 1 1 0 1\n1 0 0 0 1 1 0 1 0 1 0 1 1 1 0\n0 1 1 0 1 0 0 1 1 0 1 0 1 1 0\n0 1 0 1 0 1 1 0 0 1 1 0 0 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[[4, 14], [5, 13], [5, 12], [6, 12], [7, 11], [7, 10], [7, 9], [7, 8], [7, 7], [7, 6], [7, 5], [7, 4], [7, 3], [8, 3], [9, 2], [10, 1], [11, 0]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.02439427375793457", "solution_depth": "17", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0], [1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1], [1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1], [0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0], [1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1], [1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0], [0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0], [0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1]]\", 5]", "is_correct_args": "[\"[[1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0], [1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1], [1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1], [0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0], [1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1], [1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0], [0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0], [0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1]]\", [4, 14], [11, 0], 5]", "A*_args": "[\"[[1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0], [1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1], [1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1], [0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0], [1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0], [0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0], [1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1], [1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1], [0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0], [0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0], [0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1]]\", \"(4, 14)\", \"(11, 0)\", \"5\"]"}
{"diff_sorted_id": "97", "problem_statement": "Given 9 labeled water jugs with capacities 59, 104, 79, 23, 20, 60, 14, 15, 119, 105 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 215, 403, 420, 504 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "7", "opt_solution": "[[\"+\", 14, 4], [\"+\", 119, 4], [\"+\", 119, 4], [\"+\", 119, 4], [\"+\", 119, 4], [\"+\", 14, 4], [\"+\", 105, 3], [\"+\", 105, 3], [\"+\", 105, 3], [\"+\", 105, 3], [\"+\", 60, 2], [\"+\", 105, 2], [\"+\", 119, 2], [\"+\", 119, 2], [\"+\", 119, 1], [\"-\", 23, 1], [\"+\", 119, 1]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.03369307518005371", "solution_depth": "17", "max_successor_states": "80", "num_vars_per_state": "3", "is_feasible_args": "[[59, 104, 79, 23, 20, 60, 14, 15, 119, 105], [215, 403, 420, 504]]", "is_correct_args": "[[59, 104, 79, 23, 20, 60, 14, 15, 119, 105], [215, 403, 420, 504]]", "A*_args": "[\"[59, 104, 79, 23, 20, 60, 14, 15, 119, 105]\", \"[215, 403, 420, 504]\"]"}
{"diff_sorted_id": "98", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[89, 88, 62, 57, 79, 53], [92, 48, 61, 67, 78, 14], [32, 63, 27, '_', 19, 54]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[19, 54, 14, 78, 67, 61, 62, 88, 89, 92, 48, 63, 32, 48, 63, 62, 61, 57, 79, 67, 78, 53, 67, 78, 54, 14]", "opt_solution_cost": "26", "opt_solution_compute_t": "0.06994152069091797", "solution_depth": "26", "max_successor_states": "4", "num_vars_per_state": "18", "is_feasible_args": "[[[89, 88, 62, 57, 79, 53], [92, 48, 61, 67, 78, 14], [32, 63, 27, \"_\", 19, 54]]]", "is_correct_args": "[[[89, 88, 62, 57, 79, 53], [92, 48, 61, 67, 78, 14], [32, 63, 27, \"_\", 19, 54]]]", "A*_args": "[\"[[89, 88, 62, 57, 79, 53], [92, 48, 61, 67, 78, 14], [32, 63, 27, '_', 19, 54]]\"]"}
{"diff_sorted_id": "98", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: rafty, lapped, angina, lanose, acnida   The initial board: [['a', 'r', 'o', 'f', 'n', 'y'], ['l', 'g', 'p', 'p', 'e', 'a'], ['a', 'n', 'n', 'i', '_', 'a'], ['l', 't', 'n', 'd', 's', 'e'], ['a', 'c', 'a', 'i', 'd', 'a']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[\"down-left\", \"up-left\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "28", "opt_solution_compute_t": "5.565536260604858", "solution_depth": "28", "max_successor_states": "4", "num_vars_per_state": "30", "is_feasible_args": "[[[\"a\", \"r\", \"o\", \"f\", \"n\", \"y\"], [\"l\", \"g\", \"p\", \"p\", \"e\", \"a\"], [\"a\", \"n\", \"n\", \"i\", \"_\", \"a\"], [\"l\", \"t\", \"n\", \"d\", \"s\", \"e\"], [\"a\", \"c\", \"a\", \"i\", \"d\", \"a\"]]]", "is_correct_args": "[[[\"a\", \"r\", \"o\", \"f\", \"n\", \"y\"], [\"l\", \"g\", \"p\", \"p\", \"e\", \"a\"], [\"a\", \"n\", \"n\", \"i\", \"_\", \"a\"], [\"l\", \"t\", \"n\", \"d\", \"s\", \"e\"], [\"a\", \"c\", \"a\", \"i\", \"d\", \"a\"]], [\"rafty\", \"lapped\", \"angina\", \"lanose\", \"acnida\"]]", "A*_args": "[\"[['a', 'r', 'o', 'f', 'n', 'y'], ['l', 'g', 'p', 'p', 'e', 'a'], ['a', 'n', 'n', 'i', '_', 'a'], ['l', 't', 'n', 'd', 's', 'e'], ['a', 'c', 'a', 'i', 'd', 'a']]\", \"['rafty', 'lapped', 'angina', 'lanose', 'acnida']\"]"}
{"diff_sorted_id": "98", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'D'. Our task is to visit city J and city X excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from X and J, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  B X F Q V D A J N M G H K T S \nB 0 1 1 1 1 0 1 0 0 0 0 0 1 0 0 \nX 0 0 0 0 1 0 0 0 0 1 0 1 1 0 0 \nF 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0 \nQ 0 0 0 0 0 0 0 1 0 1 0 0 0 0 0 \nV 0 0 0 0 0 0 0 1 1 1 1 1 0 1 0 \nD 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 \nA 0 1 0 1 1 0 0 0 0 0 0 0 0 1 0 \nJ 1 0 0 1 0 1 0 0 0 0 0 1 0 0 0 \nN 0 1 1 0 0 0 1 1 0 0 0 0 0 1 0 \nM 0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 \nG 1 0 0 1 0 1 0 0 1 1 0 1 0 0 0 \nH 0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 \nK 0 0 0 0 0 1 1 0 0 0 1 1 0 1 1 \nT 1 0 0 0 0 0 0 0 0 1 1 0 0 0 1 \nS 0 1 0 1 0 0 0 0 1 0 1 1 0 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[\"D\", \"B\", \"X\", \"K\", \"A\", \"X\", \"H\", \"J\", \"Q\", \"J\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.061826229095458984", "solution_depth": "10", "max_successor_states": "15", "num_vars_per_state": "18", "is_feasible_args": "[[[0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0]], [\"B\", \"X\", \"F\", \"Q\", \"V\", \"D\", \"A\", \"J\", \"N\", \"M\", \"G\", \"H\", \"K\", \"T\", \"S\"], \"J\", \"X\"]", "is_correct_args": "[[[0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0]], [\"B\", \"X\", \"F\", \"Q\", \"V\", \"D\", \"A\", \"J\", \"N\", \"M\", \"G\", \"H\", \"K\", \"T\", \"S\"], \"D\", \"J\", \"X\"]", "A*_args": "[\"[[0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0]]\", \"['B', 'X', 'F', 'Q', 'V', 'D', 'A', 'J', 'N', 'M', 'G', 'H', 'K', 'T', 'S']\", \"['D']\", \"['J', 'X']\"]"}
{"diff_sorted_id": "98", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [35, 14, 15, 111, 8, 4, 6, 37, 14, 33, 45, 32, 46, 41, 38, 19, 34, 14, 2, 4, 24, 36, 46, 33, 12, 2, 14, 28, 12, 21, 34, 26, 28, 27, 25, 4, 23, 43, 43, 20, 10, 13, 5, 36, 27, 36], such that the sum of the chosen coins adds up to 462. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {33: 16, 21: 14, 4: 1, 13: 9, 23: 8, 2: 2, 12: 2, 41: 15, 46: 6, 45: 2, 34: 16, 24: 15, 19: 4, 5: 4, 35: 14, 6: 6, 37: 13, 26: 16, 43: 20, 15: 13, 111: 2, 38: 1, 10: 7, 32: 13, 20: 14, 27: 15, 36: 14, 25: 8, 14: 2, 28: 10, 8: 4}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "28", "opt_solution": "[46, 38, 14, 111, 46, 14, 12, 4, 19, 14, 4, 45, 28, 14, 12, 4, 37]", "opt_solution_cost": "59", "opt_solution_compute_t": "0.07613182067871094", "solution_depth": "17", "max_successor_states": "46", "num_vars_per_state": "46", "is_feasible_args": "[[35, 14, 15, 111, 8, 4, 6, 37, 14, 33, 45, 32, 46, 41, 38, 19, 34, 14, 2, 4, 24, 36, 46, 33, 12, 2, 14, 28, 12, 21, 34, 26, 28, 27, 25, 4, 23, 43, 43, 20, 10, 13, 5, 36, 27, 36]]", "is_correct_args": "[[35, 14, 15, 111, 8, 4, 6, 37, 14, 33, 45, 32, 46, 41, 38, 19, 34, 14, 2, 4, 24, 36, 46, 33, 12, 2, 14, 28, 12, 21, 34, 26, 28, 27, 25, 4, 23, 43, 43, 20, 10, 13, 5, 36, 27, 36], {\"33\": 16, \"21\": 14, \"4\": 1, \"13\": 9, \"23\": 8, \"2\": 2, \"12\": 2, \"41\": 15, \"46\": 6, \"45\": 2, \"34\": 16, \"24\": 15, \"19\": 4, \"5\": 4, \"35\": 14, \"6\": 6, \"37\": 13, \"26\": 16, \"43\": 20, \"15\": 13, \"111\": 2, \"38\": 1, \"10\": 7, \"32\": 13, \"20\": 14, \"27\": 15, \"36\": 14, \"25\": 8, \"14\": 2, \"28\": 10, \"8\": 4}, 462]", "A*_args": "[\"[35, 14, 15, 111, 8, 4, 6, 37, 14, 33, 45, 32, 46, 41, 38, 19, 34, 14, 2, 4, 24, 36, 46, 33, 12, 2, 14, 28, 12, 21, 34, 26, 28, 27, 25, 4, 23, 43, 43, 20, 10, 13, 5, 36, 27, 36]\", \"{33: 16, 21: 14, 4: 1, 13: 9, 23: 8, 2: 2, 12: 2, 41: 15, 46: 6, 45: 2, 34: 16, 24: 15, 19: 4, 5: 4, 35: 14, 6: 6, 37: 13, 26: 16, 43: 20, 15: 13, 111: 2, 38: 1, 10: 7, 32: 13, 20: 14, 27: 15, 36: 14, 25: 8, 14: 2, 28: 10, 8: 4}\", \"462\"]"}
{"diff_sorted_id": "98", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Red', 'Blue', 'Red', 'Blue', 'Red'], ['Blue', 'Blue', 'Red', 'Green', 'Green', 'Green'], ['Green', 'Red', 'Green', 'Blue', 'Green', 'Red']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[0, 1], [0, 2], [0, 1], [0, 2], [0, 1], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [2, 0], [2, 1], [2, 0], [2, 0], [2, 0], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [0, 1], [0, 2], [0, 1], [0, 1], [2, 0]]", "opt_solution_cost": "29", "opt_solution_compute_t": "370.69857454299927", "solution_depth": "29", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Blue\", \"Red\", \"Blue\", \"Red\", \"Blue\", \"Red\"], [\"Blue\", \"Blue\", \"Red\", \"Green\", \"Green\", \"Green\"], [\"Green\", \"Red\", \"Green\", \"Blue\", \"Green\", \"Red\"]], 9]", "is_correct_args": "[[[\"Blue\", \"Red\", \"Blue\", \"Red\", \"Blue\", \"Red\"], [\"Blue\", \"Blue\", \"Red\", \"Green\", \"Green\", \"Green\"], [\"Green\", \"Red\", \"Green\", \"Blue\", \"Green\", \"Red\"]], 9]", "A*_args": "[\"[['Blue', 'Red', 'Blue', 'Red', 'Blue', 'Red'], ['Blue', 'Blue', 'Red', 'Green', 'Green', 'Green'], ['Green', 'Red', 'Green', 'Blue', 'Green', 'Red']]\", \"9\"]"}
{"diff_sorted_id": "98", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 33 to 84. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 189, 204, None for columns 1 to 2 respectively, and the sums of rows must be None, 229, 249, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 219. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['68' 'x' 'x' '76']\n ['74' 'x' 'x' 'x']\n ['x' 'x' '82' 'x']\n ['66' 'x' '35' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 1, 34], [0, 2, 48], [1, 1, 80], [1, 2, 39], [1, 3, 36], [2, 0, 46], [2, 1, 38], [2, 3, 83], [3, 1, 37], [3, 3, 33]]", "opt_solution_cost": "875", "opt_solution_compute_t": "49.4717218875885", "solution_depth": "10", "max_successor_states": "36", "num_vars_per_state": "16", "is_feasible_args": "[\"[['68', '', '', '76'], ['74', '', '', ''], ['', '', '82', ''], ['66', '', '35', '']]\", 4, 33, 84]", "is_correct_args": "[\"[['68', '', '', '76'], ['74', '', '', ''], ['', '', '82', ''], ['66', '', '35', '']]\", 33, 84, [1, 3], [1, 3], [189, 204], [229, 249], 219]", "A*_args": "[\"[['68', '', '', '76'], ['74', '', '', ''], ['', '', '82', ''], ['66', '', '35', '']]\", \"33\", \"84\", \"[None, 189, 204, None]\", \"[None, 229, 249, None]\", \"219\"]"}
{"diff_sorted_id": "98", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (9, 3) to his destination workshop at index (4, 14), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 3, district 2 covering rows 4 to 8, and district 3 covering rows 9 to 14. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 19 4 x 17 11 x x 18 7 x 8 20 x 1]\n[x 16 x 1 9 1 x 8 16 x 15 7 1 x x]\n[7 x 9 9 9 x 18 x 15 13 10 x 19 16 9]\n[x x x 6 x x 7 10 18 17 x 8 9 6 5]\n[4 17 x x 19 5 20 1 15 18 x x 5 8 2]\n[x x x 3 10 19 17 20 x x x 3 x 5 x]\n[x x x 3 8 2 x x 7 19 x x 1 19 9]\n[x 19 16 6 5 19 x x x 12 x 3 8 10 x]\n[13 2 x 18 x x 5 x x x 13 1 x x 6]\n[19 8 8 10 x x x 12 14 5 14 2 6 x x]\n[x x x 12 18 x x x x x x 16 x 19 x]\n[11 x 12 x x 5 x 15 8 x 9 x x x x]\n[9 x 4 x x x x 2 18 x 11 x 11 x 19]\n[13 x 17 1 x 14 x x x x 16 x 2 x x]\n[3 16 x x 3 11 x 15 x x x x x 16 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "7", "opt_solution": "[[9, 3], [8, 3], [7, 3], [6, 3], [6, 4], [6, 5], [5, 5], [4, 5], [4, 6], [4, 7], [3, 7], [3, 8], [2, 8], [2, 9], [2, 10], [1, 10], [1, 11], [1, 12], [2, 12], [3, 12], [3, 13], [3, 14], [4, 14]]", "opt_solution_cost": "212", "opt_solution_compute_t": "0.02391839027404785", "solution_depth": "23", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"19\", \"4\", \"x\", \"17\", \"11\", \"x\", \"x\", \"18\", \"7\", \"x\", \"8\", \"20\", \"x\", \"1\"], [\"x\", \"16\", \"x\", \"1\", \"9\", \"1\", \"x\", \"8\", \"16\", \"x\", \"15\", \"7\", \"1\", \"x\", \"x\"], [\"7\", \"x\", \"9\", \"9\", \"9\", \"x\", \"18\", \"x\", \"15\", \"13\", \"10\", \"x\", \"19\", \"16\", \"9\"], [\"x\", \"x\", \"x\", \"6\", \"x\", \"x\", \"7\", \"10\", \"18\", \"17\", \"x\", \"8\", \"9\", \"6\", \"5\"], [\"4\", \"17\", \"x\", \"x\", \"19\", \"5\", \"20\", \"1\", \"15\", \"18\", \"x\", \"x\", \"5\", \"8\", \"2\"], [\"x\", \"x\", \"x\", \"3\", \"10\", \"19\", \"17\", \"20\", \"x\", \"x\", \"x\", \"3\", \"x\", \"5\", \"x\"], [\"x\", \"x\", \"x\", \"3\", \"8\", \"2\", \"x\", \"x\", \"7\", \"19\", \"x\", \"x\", \"1\", \"19\", \"9\"], [\"x\", \"19\", \"16\", \"6\", \"5\", \"19\", \"x\", \"x\", \"x\", \"12\", \"x\", \"3\", \"8\", \"10\", \"x\"], [\"13\", \"2\", \"x\", \"18\", \"x\", \"x\", \"5\", \"x\", \"x\", \"x\", \"13\", \"1\", \"x\", \"x\", \"6\"], [\"19\", \"8\", \"8\", \"10\", \"x\", \"x\", \"x\", \"12\", \"14\", \"5\", \"14\", \"2\", \"6\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"12\", \"18\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"16\", \"x\", \"19\", \"x\"], [\"11\", \"x\", \"12\", \"x\", \"x\", \"5\", \"x\", \"15\", \"8\", \"x\", \"9\", \"x\", \"x\", \"x\", \"x\"], [\"9\", \"x\", \"4\", \"x\", \"x\", \"x\", \"x\", \"2\", \"18\", \"x\", \"11\", \"x\", \"11\", \"x\", \"19\"], [\"13\", \"x\", \"17\", \"1\", \"x\", \"14\", \"x\", \"x\", \"x\", \"x\", \"16\", \"x\", \"2\", \"x\", \"x\"], [\"3\", \"16\", \"x\", \"x\", \"3\", \"11\", \"x\", \"15\", \"x\", \"x\", \"x\", \"x\", \"x\", \"16\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"19\", \"4\", \"x\", \"17\", \"11\", \"x\", \"x\", \"18\", \"7\", \"x\", \"8\", \"20\", \"x\", \"1\"], [\"x\", \"16\", \"x\", \"1\", \"9\", \"1\", \"x\", \"8\", \"16\", \"x\", \"15\", \"7\", \"1\", \"x\", \"x\"], [\"7\", \"x\", \"9\", \"9\", \"9\", \"x\", \"18\", \"x\", \"15\", \"13\", \"10\", \"x\", \"19\", \"16\", \"9\"], [\"x\", \"x\", \"x\", \"6\", \"x\", \"x\", \"7\", \"10\", \"18\", \"17\", \"x\", \"8\", \"9\", \"6\", \"5\"], [\"4\", \"17\", \"x\", \"x\", \"19\", \"5\", \"20\", \"1\", \"15\", \"18\", \"x\", \"x\", \"5\", \"8\", \"2\"], [\"x\", \"x\", \"x\", \"3\", \"10\", \"19\", \"17\", \"20\", \"x\", \"x\", \"x\", \"3\", \"x\", \"5\", \"x\"], [\"x\", \"x\", \"x\", \"3\", \"8\", \"2\", \"x\", \"x\", \"7\", \"19\", \"x\", \"x\", \"1\", \"19\", \"9\"], [\"x\", \"19\", \"16\", \"6\", \"5\", \"19\", \"x\", \"x\", \"x\", \"12\", \"x\", \"3\", \"8\", \"10\", \"x\"], [\"13\", \"2\", \"x\", \"18\", \"x\", \"x\", \"5\", \"x\", \"x\", \"x\", \"13\", \"1\", \"x\", \"x\", \"6\"], [\"19\", \"8\", \"8\", \"10\", \"x\", \"x\", \"x\", \"12\", \"14\", \"5\", \"14\", \"2\", \"6\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"12\", \"18\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"16\", \"x\", \"19\", \"x\"], [\"11\", \"x\", \"12\", \"x\", \"x\", \"5\", \"x\", \"15\", \"8\", \"x\", \"9\", \"x\", \"x\", \"x\", \"x\"], [\"9\", \"x\", \"4\", \"x\", \"x\", \"x\", \"x\", \"2\", \"18\", \"x\", \"11\", \"x\", \"11\", \"x\", \"19\"], [\"13\", \"x\", \"17\", \"1\", \"x\", \"14\", \"x\", \"x\", \"x\", \"x\", \"16\", \"x\", \"2\", \"x\", \"x\"], [\"3\", \"16\", \"x\", \"x\", \"3\", \"11\", \"x\", \"15\", \"x\", \"x\", \"x\", \"x\", \"x\", \"16\", \"x\"]], [9, 3], [4, 14], 3, 8]", "A*_args": "[\"[['x', '19', '4', 'x', '17', '11', 'x', 'x', '18', '7', 'x', '8', '20', 'x', '1'], ['x', '16', 'x', '1', '9', '1', 'x', '8', '16', 'x', '15', '7', '1', 'x', 'x'], ['7', 'x', '9', '9', '9', 'x', '18', 'x', '15', '13', '10', 'x', '19', '16', '9'], ['x', 'x', 'x', '6', 'x', 'x', '7', '10', '18', '17', 'x', '8', '9', '6', '5'], ['4', '17', 'x', 'x', '19', '5', '20', '1', '15', '18', 'x', 'x', '5', '8', '2'], ['x', 'x', 'x', '3', '10', '19', '17', '20', 'x', 'x', 'x', '3', 'x', '5', 'x'], ['x', 'x', 'x', '3', '8', '2', 'x', 'x', '7', '19', 'x', 'x', '1', '19', '9'], ['x', '19', '16', '6', '5', '19', 'x', 'x', 'x', '12', 'x', '3', '8', '10', 'x'], ['13', '2', 'x', '18', 'x', 'x', '5', 'x', 'x', 'x', '13', '1', 'x', 'x', '6'], ['19', '8', '8', '10', 'x', 'x', 'x', '12', '14', '5', '14', '2', '6', 'x', 'x'], ['x', 'x', 'x', '12', '18', 'x', 'x', 'x', 'x', 'x', 'x', '16', 'x', '19', 'x'], ['11', 'x', '12', 'x', 'x', '5', 'x', '15', '8', 'x', '9', 'x', 'x', 'x', 'x'], ['9', 'x', '4', 'x', 'x', 'x', 'x', '2', '18', 'x', '11', 'x', '11', 'x', '19'], ['13', 'x', '17', '1', 'x', '14', 'x', 'x', 'x', 'x', '16', 'x', '2', 'x', 'x'], ['3', '16', 'x', 'x', '3', '11', 'x', '15', 'x', 'x', 'x', 'x', 'x', '16', 'x']]\", \"(9, 3)\", \"(4, 14)\", \"3\", \"8\"]"}
{"diff_sorted_id": "98", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 15x15. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 5 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (1, 2) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (12, 11). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 0 0 0 0 0 0 1 0 1 1 0 1 0\n1 1 0 0 0 1 0 0 1 1 0 0 1 1 1\n0 1 1 0 0 1 0 1 0 0 0 0 1 1 0\n0 1 1 1 0 1 0 0 0 0 0 0 0 0 1\n0 0 1 1 1 1 0 1 0 1 1 1 1 1 0\n1 1 1 1 0 1 0 1 0 1 1 0 1 1 1\n0 1 0 1 1 1 0 1 0 1 1 0 1 1 0\n1 0 0 0 1 0 1 1 0 1 1 1 1 1 1\n0 1 1 0 1 1 1 0 0 0 0 0 0 0 0\n1 1 0 1 1 1 1 1 0 0 1 0 0 0 1\n1 0 1 0 1 1 0 0 0 0 0 0 0 1 1\n1 1 0 1 0 1 1 0 1 1 0 1 0 1 1\n1 0 0 0 0 1 1 0 1 1 1 0 0 1 0\n1 0 0 1 1 1 1 1 0 1 1 0 0 0 0\n0 0 1 1 1 1 1 0 1 0 1 1 1 0 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[[1, 2], [1, 3], [1, 4], [0, 4], [0, 5], [1, 6], [2, 6], [3, 6], [3, 7], [4, 8], [5, 8], [6, 8], [7, 8], [8, 8], [9, 8], [10, 9], [11, 10], [12, 11]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.02712726593017578", "solution_depth": "18", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0], [1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1], [0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0], [1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1], [0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0], [1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1], [1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0], [1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0]]\", 5]", "is_correct_args": "[\"[[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0], [1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1], [0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0], [1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1], [0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0], [1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1], [1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0], [1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0]]\", [1, 2], [12, 11], 5]", "A*_args": "[\"[[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0], [1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1], [0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0], [1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1], [0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0], [1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1], [1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0], [1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0]]\", \"(1, 2)\", \"(12, 11)\", \"5\"]"}
{"diff_sorted_id": "98", "problem_statement": "Given 9 labeled water jugs with capacities 137, 100, 82, 25, 21, 101, 118, 117, 26, 131 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 272, 439, 458, 590 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "7", "opt_solution": "[[\"+\", 82, 4], [\"+\", 117, 4], [\"+\", 117, 4], [\"+\", 137, 4], [\"+\", 137, 4], [\"+\", 26, 3], [\"+\", 137, 3], [\"+\", 137, 3], [\"+\", 137, 3], [\"+\", 21, 3], [\"+\", 100, 2], [\"+\", 101, 2], [\"+\", 101, 2], [\"+\", 137, 2], [\"+\", 117, 1], [\"+\", 137, 1], [\"-\", 82, 1], [\"+\", 100, 1]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.05659294128417969", "solution_depth": "18", "max_successor_states": "80", "num_vars_per_state": "3", "is_feasible_args": "[[137, 100, 82, 25, 21, 101, 118, 117, 26, 131], [272, 439, 458, 590]]", "is_correct_args": "[[137, 100, 82, 25, 21, 101, 118, 117, 26, 131], [272, 439, 458, 590]]", "A*_args": "[\"[137, 100, 82, 25, 21, 101, 118, 117, 26, 131]\", \"[272, 439, 458, 590]\"]"}
{"diff_sorted_id": "99", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[92, 75, 100, 61, 43, 87], [64, 34, 55, 90, 20, 86], [36, '_', 32, 5, 42, 83]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[34, 64, 92, 75, 100, 61, 90, 20, 43, 87, 86, 83, 42, 5, 20, 55, 64, 92, 75, 100, 92, 64, 61, 90, 87, 86, 83, 42]", "opt_solution_cost": "28", "opt_solution_compute_t": "0.13985705375671387", "solution_depth": "28", "max_successor_states": "4", "num_vars_per_state": "18", "is_feasible_args": "[[[92, 75, 100, 61, 43, 87], [64, 34, 55, 90, 20, 86], [36, \"_\", 32, 5, 42, 83]]]", "is_correct_args": "[[[92, 75, 100, 61, 43, 87], [64, 34, 55, 90, 20, 86], [36, \"_\", 32, 5, 42, 83]]]", "A*_args": "[\"[[92, 75, 100, 61, 43, 87], [64, 34, 55, 90, 20, 86], [36, '_', 32, 5, 42, 83]]\"]"}
{"diff_sorted_id": "99", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: chank, hormic, tigtag, tornal, zythum   The initial board: [['o', 'c', 'a', 'a', 'n', 'k'], ['h', 'm', 'r', 'l', 'i', 'g'], ['h', 'i', 'o', 't', 'u', 'g'], ['t', 'n', 'r', 't', 'a', 'c'], ['z', 'y', 't', 'h', '_', 'm']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[\"up-right\", \"up-left\", \"up-left\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"down-right\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"up-right\", \"up-left\", \"down-left\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"down-left\", \"down-right\", \"up-right\", \"up-right\", \"up-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"down-left\", \"up-left\"]", "opt_solution_cost": "30", "opt_solution_compute_t": "13.15977692604065", "solution_depth": "30", "max_successor_states": "4", "num_vars_per_state": "30", "is_feasible_args": "[[[\"o\", \"c\", \"a\", \"a\", \"n\", \"k\"], [\"h\", \"m\", \"r\", \"l\", \"i\", \"g\"], [\"h\", \"i\", \"o\", \"t\", \"u\", \"g\"], [\"t\", \"n\", \"r\", \"t\", \"a\", \"c\"], [\"z\", \"y\", \"t\", \"h\", \"_\", \"m\"]]]", "is_correct_args": "[[[\"o\", \"c\", \"a\", \"a\", \"n\", \"k\"], [\"h\", \"m\", \"r\", \"l\", \"i\", \"g\"], [\"h\", \"i\", \"o\", \"t\", \"u\", \"g\"], [\"t\", \"n\", \"r\", \"t\", \"a\", \"c\"], [\"z\", \"y\", \"t\", \"h\", \"_\", \"m\"]], [\"chank\", \"hormic\", \"tigtag\", \"tornal\", \"zythum\"]]", "A*_args": "[\"[['o', 'c', 'a', 'a', 'n', 'k'], ['h', 'm', 'r', 'l', 'i', 'g'], ['h', 'i', 'o', 't', 'u', 'g'], ['t', 'n', 'r', 't', 'a', 'c'], ['z', 'y', 't', 'h', '_', 'm']]\", \"['chank', 'hormic', 'tigtag', 'tornal', 'zythum']\"]"}
{"diff_sorted_id": "99", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'L'. Our task is to visit city W and city P excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from P and W, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  R P Z U H T E W F M D L Y C G \nR 0 0 0 0 0 0 0 0 1 1 0 0 0 1 1 \nP 1 0 0 0 0 1 1 1 0 1 0 0 0 0 1 \nZ 0 0 0 0 1 0 1 0 0 1 1 0 1 0 0 \nU 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 \nH 1 0 0 1 0 0 1 0 1 1 0 1 1 1 0 \nT 0 0 0 1 1 0 0 0 0 0 1 0 0 0 0 \nE 0 0 0 0 0 1 0 0 0 0 1 0 0 0 1 \nW 1 0 1 0 1 0 1 0 0 0 0 0 1 0 1 \nF 0 0 1 1 1 0 0 1 0 1 0 0 0 0 0 \nM 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0 \nD 0 1 0 0 0 1 0 0 0 0 0 0 0 1 0 \nL 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 \nY 1 0 0 0 0 1 0 1 1 0 0 0 0 0 1 \nC 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 \nG 0 0 1 0 0 0 0 0 0 1 0 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[\"L\", \"U\", \"P\", \"W\", \"E\", \"D\", \"P\", \"W\"]", "opt_solution_cost": "8", "opt_solution_compute_t": "0.04042506217956543", "solution_depth": "8", "max_successor_states": "15", "num_vars_per_state": "18", "is_feasible_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]], [\"R\", \"P\", \"Z\", \"U\", \"H\", \"T\", \"E\", \"W\", \"F\", \"M\", \"D\", \"L\", \"Y\", \"C\", \"G\"], \"W\", \"P\"]", "is_correct_args": "[[[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]], [\"R\", \"P\", \"Z\", \"U\", \"H\", \"T\", \"E\", \"W\", \"F\", \"M\", \"D\", \"L\", \"Y\", \"C\", \"G\"], \"L\", \"W\", \"P\"]", "A*_args": "[\"[[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1], [1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0], [1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0], [0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1], [0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]]\", \"['R', 'P', 'Z', 'U', 'H', 'T', 'E', 'W', 'F', 'M', 'D', 'L', 'Y', 'C', 'G']\", \"['L']\", \"['W', 'P']\"]"}
{"diff_sorted_id": "99", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [37, 4, 1, 15, 2, 7, 8, 33, 35, 14, 47, 36, 41, 44, 13, 31, 3, 7, 27, 25, 26, 38, 10, 19, 7, 18, 32, 45, 29, 35, 44, 17, 40, 13, 14, 40, 28, 15, 23, 11, 7, 16, 7, 35, 31, 45, 14, 22, 7, 36, 31], such that the sum of the chosen coins adds up to 465. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {44: 2, 1: 1, 36: 14, 26: 2, 22: 10, 33: 13, 16: 12, 23: 1, 41: 6, 8: 6, 18: 3, 13: 5, 2: 2, 7: 5, 29: 13, 25: 19, 3: 1, 45: 12, 35: 13, 17: 6, 47: 13, 10: 8, 15: 14, 31: 13, 4: 2, 14: 2, 32: 11, 40: 3, 11: 4, 28: 7, 37: 12, 27: 11, 19: 17, 38: 18}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "29", "opt_solution": "[44, 40, 26, 14, 23, 14, 41, 40, 28, 14, 45, 44, 45, 47]", "opt_solution_cost": "69", "opt_solution_compute_t": "0.07292604446411133", "solution_depth": "14", "max_successor_states": "51", "num_vars_per_state": "51", "is_feasible_args": "[[37, 4, 1, 15, 2, 7, 8, 33, 35, 14, 47, 36, 41, 44, 13, 31, 3, 7, 27, 25, 26, 38, 10, 19, 7, 18, 32, 45, 29, 35, 44, 17, 40, 13, 14, 40, 28, 15, 23, 11, 7, 16, 7, 35, 31, 45, 14, 22, 7, 36, 31]]", "is_correct_args": "[[37, 4, 1, 15, 2, 7, 8, 33, 35, 14, 47, 36, 41, 44, 13, 31, 3, 7, 27, 25, 26, 38, 10, 19, 7, 18, 32, 45, 29, 35, 44, 17, 40, 13, 14, 40, 28, 15, 23, 11, 7, 16, 7, 35, 31, 45, 14, 22, 7, 36, 31], {\"44\": 2, \"1\": 1, \"36\": 14, \"26\": 2, \"22\": 10, \"33\": 13, \"16\": 12, \"23\": 1, \"41\": 6, \"8\": 6, \"18\": 3, \"13\": 5, \"2\": 2, \"7\": 5, \"29\": 13, \"25\": 19, \"3\": 1, \"45\": 12, \"35\": 13, \"17\": 6, \"47\": 13, \"10\": 8, \"15\": 14, \"31\": 13, \"4\": 2, \"14\": 2, \"32\": 11, \"40\": 3, \"11\": 4, \"28\": 7, \"37\": 12, \"27\": 11, \"19\": 17, \"38\": 18}, 465]", "A*_args": "[\"[37, 4, 1, 15, 2, 7, 8, 33, 35, 14, 47, 36, 41, 44, 13, 31, 3, 7, 27, 25, 26, 38, 10, 19, 7, 18, 32, 45, 29, 35, 44, 17, 40, 13, 14, 40, 28, 15, 23, 11, 7, 16, 7, 35, 31, 45, 14, 22, 7, 36, 31]\", \"{44: 2, 1: 1, 36: 14, 26: 2, 22: 10, 33: 13, 16: 12, 23: 1, 41: 6, 8: 6, 18: 3, 13: 5, 2: 2, 7: 5, 29: 13, 25: 19, 3: 1, 45: 12, 35: 13, 17: 6, 47: 13, 10: 8, 15: 14, 31: 13, 4: 2, 14: 2, 32: 11, 40: 3, 11: 4, 28: 7, 37: 12, 27: 11, 19: 17, 38: 18}\", \"465\"]"}
{"diff_sorted_id": "99", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Red', 'Red', 'Green', 'Blue', 'Green'], ['Blue', 'Red', 'Red', 'Red', 'Green', 'Green'], ['Blue', 'Red', 'Blue', 'Blue', 'Green', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[2, 1], [0, 1], [0, 2], [0, 2], [0, 2], [0, 1], [0, 2], [1, 0], [1, 0], [1, 0], [1, 0], [1, 0], [2, 0], [2, 0], [1, 2], [1, 2], [1, 0], [1, 0], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2], [0, 2], [0, 2], [1, 0], [1, 0], [2, 1]]", "opt_solution_cost": "33", "opt_solution_compute_t": "52.178091049194336", "solution_depth": "33", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Blue\", \"Red\", \"Red\", \"Green\", \"Blue\", \"Green\"], [\"Blue\", \"Red\", \"Red\", \"Red\", \"Green\", \"Green\"], [\"Blue\", \"Red\", \"Blue\", \"Blue\", \"Green\", \"Green\"]], 9]", "is_correct_args": "[[[\"Blue\", \"Red\", \"Red\", \"Green\", \"Blue\", \"Green\"], [\"Blue\", \"Red\", \"Red\", \"Red\", \"Green\", \"Green\"], [\"Blue\", \"Red\", \"Blue\", \"Blue\", \"Green\", \"Green\"]], 9]", "A*_args": "[\"[['Blue', 'Red', 'Red', 'Green', 'Blue', 'Green'], ['Blue', 'Red', 'Red', 'Red', 'Green', 'Green'], ['Blue', 'Red', 'Blue', 'Blue', 'Green', 'Green']]\", \"9\"]"}
{"diff_sorted_id": "99", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 30 to 86. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 239, 192, None for columns 1 to 2 respectively, and the sums of rows must be None, 220, 184, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 199. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' 'x' 'x' '67']\n ['62' 'x' '32' '77']\n ['66' 'x' '34' 'x']\n ['x' 'x' '73' '35']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 0, 31], [0, 1, 51], [0, 2, 53], [1, 1, 49], [2, 1, 54], [2, 3, 30], [3, 0, 46], [3, 1, 85]]", "opt_solution_cost": "845", "opt_solution_compute_t": "26.860548496246338", "solution_depth": "8", "max_successor_states": "36", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '', '', '67'], ['62', '', '32', '77'], ['66', '', '34', ''], ['', '', '73', '35']]\", 4, 30, 86]", "is_correct_args": "[\"[['', '', '', '67'], ['62', '', '32', '77'], ['66', '', '34', ''], ['', '', '73', '35']]\", 30, 86, [1, 3], [1, 3], [239, 192], [220, 184], 199]", "A*_args": "[\"[['', '', '', '67'], ['62', '', '32', '77'], ['66', '', '34', ''], ['', '', '73', '35']]\", \"30\", \"86\", \"[None, 239, 192, None]\", \"[None, 220, 184, None]\", \"199\"]"}
{"diff_sorted_id": "99", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (4, 14) to his destination workshop at index (8, 3), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 4, district 2 covering rows 5 to 7, and district 3 covering rows 8 to 14. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[7 6 11 x x x 19 x 9 15 12 8 10 15 5]\n[9 14 x x x x x x x x 18 2 11 x 10]\n[14 5 x x 4 4 12 x 18 x 17 11 3 18 19]\n[18 17 x 8 x x 9 x x 8 19 10 x x x]\n[7 x x 11 4 x x 10 1 2 3 12 8 12 15]\n[x 3 7 8 x x x x 4 16 13 19 14 10 13]\n[18 1 2 x 16 20 5 x 2 4 20 12 14 18 16]\n[1 x 1 x 15 19 11 9 19 16 x x x x 19]\n[x 8 x 1 7 x 2 3 x x x x 1 3 x]\n[6 16 x 3 x 18 x 2 18 x x 16 x x 8]\n[x 9 x 5 2 x x x x 17 x 6 18 14 x]\n[x x x x x x x 18 x x 3 x 10 x x]\n[x 2 15 x 5 15 18 8 19 x x x x x 10]\n[x x 4 x 7 2 2 x 19 x x x x x x]\n[17 x x x 5 x x x 4 1 18 x 9 2 8]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "7", "opt_solution": "[[4, 14], [4, 13], [4, 12], [4, 11], [4, 10], [4, 9], [4, 8], [5, 8], [6, 8], [7, 8], [7, 7], [7, 6], [7, 5], [7, 4], [8, 4], [8, 3]]", "opt_solution_cost": "125", "opt_solution_compute_t": "0.02839803695678711", "solution_depth": "16", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"7\", \"6\", \"11\", \"x\", \"x\", \"x\", \"19\", \"x\", \"9\", \"15\", \"12\", \"8\", \"10\", \"15\", \"5\"], [\"9\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"18\", \"2\", \"11\", \"x\", \"10\"], [\"14\", \"5\", \"x\", \"x\", \"4\", \"4\", \"12\", \"x\", \"18\", \"x\", \"17\", \"11\", \"3\", \"18\", \"19\"], [\"18\", \"17\", \"x\", \"8\", \"x\", \"x\", \"9\", \"x\", \"x\", \"8\", \"19\", \"10\", \"x\", \"x\", \"x\"], [\"7\", \"x\", \"x\", \"11\", \"4\", \"x\", \"x\", \"10\", \"1\", \"2\", \"3\", \"12\", \"8\", \"12\", \"15\"], [\"x\", \"3\", \"7\", \"8\", \"x\", \"x\", \"x\", \"x\", \"4\", \"16\", \"13\", \"19\", \"14\", \"10\", \"13\"], [\"18\", \"1\", \"2\", \"x\", \"16\", \"20\", \"5\", \"x\", \"2\", \"4\", \"20\", \"12\", \"14\", \"18\", \"16\"], [\"1\", \"x\", \"1\", \"x\", \"15\", \"19\", \"11\", \"9\", \"19\", \"16\", \"x\", \"x\", \"x\", \"x\", \"19\"], [\"x\", \"8\", \"x\", \"1\", \"7\", \"x\", \"2\", \"3\", \"x\", \"x\", \"x\", \"x\", \"1\", \"3\", \"x\"], [\"6\", \"16\", \"x\", \"3\", \"x\", \"18\", \"x\", \"2\", \"18\", \"x\", \"x\", \"16\", \"x\", \"x\", \"8\"], [\"x\", \"9\", \"x\", \"5\", \"2\", \"x\", \"x\", \"x\", \"x\", \"17\", \"x\", \"6\", \"18\", \"14\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\", \"3\", \"x\", \"10\", \"x\", \"x\"], [\"x\", \"2\", \"15\", \"x\", \"5\", \"15\", \"18\", \"8\", \"19\", \"x\", \"x\", \"x\", \"x\", \"x\", \"10\"], [\"x\", \"x\", \"4\", \"x\", \"7\", \"2\", \"2\", \"x\", \"19\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"17\", \"x\", \"x\", \"x\", \"5\", \"x\", \"x\", \"x\", \"4\", \"1\", \"18\", \"x\", \"9\", \"2\", \"8\"]]]", "is_correct_args": "[[[\"7\", \"6\", \"11\", \"x\", \"x\", \"x\", \"19\", \"x\", \"9\", \"15\", \"12\", \"8\", \"10\", \"15\", \"5\"], [\"9\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"18\", \"2\", \"11\", \"x\", \"10\"], [\"14\", \"5\", \"x\", \"x\", \"4\", \"4\", \"12\", \"x\", \"18\", \"x\", \"17\", \"11\", \"3\", \"18\", \"19\"], [\"18\", \"17\", \"x\", \"8\", \"x\", \"x\", \"9\", \"x\", \"x\", \"8\", \"19\", \"10\", \"x\", \"x\", \"x\"], [\"7\", \"x\", \"x\", \"11\", \"4\", \"x\", \"x\", \"10\", \"1\", \"2\", \"3\", \"12\", \"8\", \"12\", \"15\"], [\"x\", \"3\", \"7\", \"8\", \"x\", \"x\", \"x\", \"x\", \"4\", \"16\", \"13\", \"19\", \"14\", \"10\", \"13\"], [\"18\", \"1\", \"2\", \"x\", \"16\", \"20\", \"5\", \"x\", \"2\", \"4\", \"20\", \"12\", \"14\", \"18\", \"16\"], [\"1\", \"x\", \"1\", \"x\", \"15\", \"19\", \"11\", \"9\", \"19\", \"16\", \"x\", \"x\", \"x\", \"x\", \"19\"], [\"x\", \"8\", \"x\", \"1\", \"7\", \"x\", \"2\", \"3\", \"x\", \"x\", \"x\", \"x\", \"1\", \"3\", \"x\"], [\"6\", \"16\", \"x\", \"3\", \"x\", \"18\", \"x\", \"2\", \"18\", \"x\", \"x\", \"16\", \"x\", \"x\", \"8\"], [\"x\", \"9\", \"x\", \"5\", \"2\", \"x\", \"x\", \"x\", \"x\", \"17\", \"x\", \"6\", \"18\", \"14\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"18\", \"x\", \"x\", \"3\", \"x\", \"10\", \"x\", \"x\"], [\"x\", \"2\", \"15\", \"x\", \"5\", \"15\", \"18\", \"8\", \"19\", \"x\", \"x\", \"x\", \"x\", \"x\", \"10\"], [\"x\", \"x\", \"4\", \"x\", \"7\", \"2\", \"2\", \"x\", \"19\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"17\", \"x\", \"x\", \"x\", \"5\", \"x\", \"x\", \"x\", \"4\", \"1\", \"18\", \"x\", \"9\", \"2\", \"8\"]], [4, 14], [8, 3], 4, 7]", "A*_args": "[\"[['7', '6', '11', 'x', 'x', 'x', '19', 'x', '9', '15', '12', '8', '10', '15', '5'], ['9', '14', 'x', 'x', 'x', 'x', 'x', 'x', 'x', 'x', '18', '2', '11', 'x', '10'], ['14', '5', 'x', 'x', '4', '4', '12', 'x', '18', 'x', '17', '11', '3', '18', '19'], ['18', '17', 'x', '8', 'x', 'x', '9', 'x', 'x', '8', '19', '10', 'x', 'x', 'x'], ['7', 'x', 'x', '11', '4', 'x', 'x', '10', '1', '2', '3', '12', '8', '12', '15'], ['x', '3', '7', '8', 'x', 'x', 'x', 'x', '4', '16', '13', '19', '14', '10', '13'], ['18', '1', '2', 'x', '16', '20', '5', 'x', '2', '4', '20', '12', '14', '18', '16'], ['1', 'x', '1', 'x', '15', '19', '11', '9', '19', '16', 'x', 'x', 'x', 'x', '19'], ['x', '8', 'x', '1', '7', 'x', '2', '3', 'x', 'x', 'x', 'x', '1', '3', 'x'], ['6', '16', 'x', '3', 'x', '18', 'x', '2', '18', 'x', 'x', '16', 'x', 'x', '8'], ['x', '9', 'x', '5', '2', 'x', 'x', 'x', 'x', '17', 'x', '6', '18', '14', 'x'], ['x', 'x', 'x', 'x', 'x', 'x', 'x', '18', 'x', 'x', '3', 'x', '10', 'x', 'x'], ['x', '2', '15', 'x', '5', '15', '18', '8', '19', 'x', 'x', 'x', 'x', 'x', '10'], ['x', 'x', '4', 'x', '7', '2', '2', 'x', '19', 'x', 'x', 'x', 'x', 'x', 'x'], ['17', 'x', 'x', 'x', '5', 'x', 'x', 'x', '4', '1', '18', 'x', '9', '2', '8']]\", \"(4, 14)\", \"(8, 3)\", \"4\", \"7\"]"}
{"diff_sorted_id": "99", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 15x15. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 5 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (11, 1) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (2, 12). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 1 1 1 1 0 1 0 0 0 0 0 0 0\n0 1 0 0 1 0 0 0 0 1 1 1 1 1 0\n0 1 1 0 1 1 0 0 0 0 0 0 0 1 1\n0 1 1 0 1 0 0 0 0 0 0 0 0 0 0\n0 1 1 0 0 0 1 1 1 1 1 0 1 0 1\n0 0 1 0 0 1 0 1 1 0 1 1 0 1 1\n0 0 0 0 0 0 0 0 1 1 1 1 1 1 0\n0 1 1 1 1 0 0 1 0 1 1 0 0 1 1\n1 0 1 1 0 0 1 0 1 1 0 0 1 1 0\n1 0 1 1 1 1 1 1 1 0 1 1 0 1 1\n0 1 0 0 0 1 0 1 1 1 0 1 0 1 1\n0 0 1 0 1 0 1 1 0 1 1 1 1 1 1\n1 0 0 1 0 1 1 0 0 0 1 0 1 0 0\n1 1 0 1 0 0 1 0 1 1 0 0 0 1 1\n1 0 1 1 0 1 0 0 1 0 1 1 0 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[[11, 1], [10, 2], [9, 1], [8, 1], [7, 0], [6, 0], [6, 1], [6, 2], [6, 3], [6, 4], [5, 4], [4, 4], [4, 5], [3, 6], [3, 7], [3, 8], [3, 9], [3, 10], [3, 11], [2, 12]]", "opt_solution_cost": "20", "opt_solution_compute_t": "0.03243589401245117", "solution_depth": "20", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0], [0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1], [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1], [1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0], [1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1], [0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1], [0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0], [1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1], [1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0]]\", 5]", "is_correct_args": "[\"[[0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0], [0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1], [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1], [1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0], [1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1], [0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1], [0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0], [1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1], [1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0]]\", [11, 1], [2, 12], 5]", "A*_args": "[\"[[0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0], [0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1], [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1], [1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0], [1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1], [0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1], [0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0], [1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1], [1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0]]\", \"(11, 1)\", \"(2, 12)\", \"5\"]"}
{"diff_sorted_id": "99", "problem_statement": "Given 9 labeled water jugs with capacities 32, 73, 55, 68, 61, 107, 44, 45, 74, 113 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 203, 429, 433, 477 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "7", "opt_solution": "[[\"+\", 74, 4], [\"+\", 74, 4], [\"+\", 74, 4], [\"+\", 113, 4], [\"+\", 68, 4], [\"+\", 74, 4], [\"+\", 68, 3], [\"+\", 107, 3], [\"+\", 113, 3], [\"+\", 113, 3], [\"+\", 32, 3], [\"+\", 61, 2], [\"+\", 113, 2], [\"+\", 113, 2], [\"+\", 74, 2], [\"+\", 68, 2], [\"+\", 61, 1], [\"+\", 74, 1], [\"+\", 68, 1]]", "opt_solution_cost": "19", "opt_solution_compute_t": "0.048816680908203125", "solution_depth": "19", "max_successor_states": "80", "num_vars_per_state": "3", "is_feasible_args": "[[32, 73, 55, 68, 61, 107, 44, 45, 74, 113], [203, 429, 433, 477]]", "is_correct_args": "[[32, 73, 55, 68, 61, 107, 44, 45, 74, 113], [203, 429, 433, 477]]", "A*_args": "[\"[32, 73, 55, 68, 61, 107, 44, 45, 74, 113]\", \"[203, 429, 433, 477]\"]"}
{"diff_sorted_id": "100", "problem_statement": "In the 8-puzzle game, you are given a grid with numbered square tiles arranged randomly and one tile missing. The goal is to arrange the tiles in descending order by sliding them into the empty space. The tiles can move in 4 directions: left, right, up, and down.  Given the initial state of the puzzle below, where the empty spot is represented as \u201c_\u201d, provide the shortest list of tiles that need to be swapped with the empty spot to achieve the goal state. The goal state is when all tiles are in descending order, with the largest number in the top left corner, and the empty spot is in the bottom right corner. The solution should be a list of numbers in Python format, where each number represents the number on the tile that the empty spot is swapped with at each turn. Initial state of the puzzle: [[94, 91, 76, '_', 74, 29], [61, 93, 17, 37, 34, 44], [67, 32, 55, 19, 26, 69]]", "problem_type": "8_puzzle", "problem_category": "puzzle", "relative_diff_score": "6", "opt_solution": "[37, 17, 55, 19, 26, 34, 44, 29, 74, 44, 29, 69, 34, 29, 17, 26, 29, 17, 44, 37, 76, 55, 19, 29, 26, 19, 55, 91, 93, 61, 67, 32, 29, 26, 19, 44, 37, 74, 69, 34]", "opt_solution_cost": "40", "opt_solution_compute_t": "21.31004285812378", "solution_depth": "40", "max_successor_states": "4", "num_vars_per_state": "18", "is_feasible_args": "[[[94, 91, 76, \"_\", 74, 29], [61, 93, 17, 37, 34, 44], [67, 32, 55, 19, 26, 69]]]", "is_correct_args": "[[[94, 91, 76, \"_\", 74, 29], [61, 93, 17, 37, 34, 44], [67, 32, 55, 19, 26, 69]]]", "A*_args": "[\"[[94, 91, 76, '_', 74, 29], [61, 93, 17, 37, 34, 44], [67, 32, 55, 19, 26, 69]]\"]"}
{"diff_sorted_id": "100", "problem_statement": "In the game 'Sort the Chars', we are given a table of n by m dimensions. This table contains n words, each with m characters, except for the first word which has m - 1 characters. Each character is written on a separate tile. The objective of the game is to rearrange the characters such that row i spells the i-th word in the list, with the blank tile ('_') placed in the top left corner of the board in the end. We can rearrange the tiles by swapping the blank space with any of its 4 diagonal neighboring tiles. Given the list of words and initial state of the board below, where the black space is represented as '_', what is the shortest list of swap actions (reported in python syntax) that can sort the board into the given list of target words? The list must only include the 4 diagonal swap directions: up-right, down-right, up-left, or down-left, representing the direction in ehich the blank space was swpped in. Target words: katar, bonsai, sambar, mopane, voyeur   The initial board: [['o', 'k', 's', 't', 'a', 'r'], ['b', 'y', 'n', 'i', 'a', 'a'], ['s', 'a', '_', 'b', 'a', 'r'], ['m', 'o', 'p', 'e', 'n', 'u'], ['v', 'o', 'm', 'e', 'a', 'r']]", "problem_type": "8_puzzle_words", "problem_category": "puzzle", "relative_diff_score": "4", "opt_solution": "[\"down-right\", \"up-right\", \"up-left\", \"up-right\", \"down-right\", \"down-left\", \"down-left\", \"up-left\", \"up-left\", \"up-right\", \"down-right\", \"down-right\", \"down-left\", \"up-left\", \"up-left\", \"down-left\", \"down-right\", \"down-right\", \"up-right\", \"down-right\", \"up-right\", \"up-left\", \"up-left\", \"down-left\", \"down-left\", \"up-left\", \"up-right\", \"up-left\"]", "opt_solution_cost": "28", "opt_solution_compute_t": "19.604556798934937", "solution_depth": "28", "max_successor_states": "4", "num_vars_per_state": "30", "is_feasible_args": "[[[\"o\", \"k\", \"s\", \"t\", \"a\", \"r\"], [\"b\", \"y\", \"n\", \"i\", \"a\", \"a\"], [\"s\", \"a\", \"_\", \"b\", \"a\", \"r\"], [\"m\", \"o\", \"p\", \"e\", \"n\", \"u\"], [\"v\", \"o\", \"m\", \"e\", \"a\", \"r\"]]]", "is_correct_args": "[[[\"o\", \"k\", \"s\", \"t\", \"a\", \"r\"], [\"b\", \"y\", \"n\", \"i\", \"a\", \"a\"], [\"s\", \"a\", \"_\", \"b\", \"a\", \"r\"], [\"m\", \"o\", \"p\", \"e\", \"n\", \"u\"], [\"v\", \"o\", \"m\", \"e\", \"a\", \"r\"]], [\"katar\", \"bonsai\", \"sambar\", \"mopane\", \"voyeur\"]]", "A*_args": "[\"[['o', 'k', 's', 't', 'a', 'r'], ['b', 'y', 'n', 'i', 'a', 'a'], ['s', 'a', '_', 'b', 'a', 'r'], ['m', 'o', 'p', 'e', 'n', 'u'], ['v', 'o', 'm', 'e', 'a', 'r']]\", \"['katar', 'bonsai', 'sambar', 'mopane', 'voyeur']\"]"}
{"diff_sorted_id": "100", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'R'. Our task is to visit city N and city X excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from X and N, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  I A Y K F H W D L U N R Z V X \nI 0 0 0 0 1 0 0 1 1 0 1 1 0 0 1 \nA 1 0 0 1 0 0 0 0 0 0 1 1 0 0 0 \nY 0 0 0 0 0 0 1 0 0 0 0 1 1 0 1 \nK 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0 \nF 0 0 1 1 0 1 0 0 0 0 0 1 0 0 0 \nH 1 0 0 0 0 0 0 0 0 0 0 1 0 0 1 \nW 1 0 0 0 1 0 0 0 1 0 0 0 1 0 0 \nD 0 0 1 0 1 0 1 0 1 0 0 0 0 1 0 \nL 0 0 1 0 1 1 0 0 0 1 0 0 0 0 1 \nU 1 1 0 0 1 1 1 0 0 0 0 1 0 1 0 \nN 0 0 0 1 1 1 1 0 0 1 0 0 0 1 0 \nR 0 0 0 1 0 0 1 1 1 0 0 0 0 0 0 \nZ 0 1 1 1 0 1 0 0 0 0 0 0 0 0 0 \nV 0 1 0 0 1 0 0 0 0 0 0 1 1 0 0 \nX 0 1 1 1 1 0 1 0 1 1 0 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[\"R\", \"K\", \"N\", \"H\", \"X\", \"L\", \"X\", \"A\", \"N\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.15291357040405273", "solution_depth": "9", "max_successor_states": "15", "num_vars_per_state": "18", "is_feasible_args": "[[[0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0]], [\"I\", \"A\", \"Y\", \"K\", \"F\", \"H\", \"W\", \"D\", \"L\", \"U\", \"N\", \"R\", \"Z\", \"V\", \"X\"], \"N\", \"X\"]", "is_correct_args": "[[[0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0]], [\"I\", \"A\", \"Y\", \"K\", \"F\", \"H\", \"W\", \"D\", \"L\", \"U\", \"N\", \"R\", \"Z\", \"V\", \"X\"], \"R\", \"N\", \"X\"]", "A*_args": "[\"[[0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1], [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0], [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0], [0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0]]\", \"['I', 'A', 'Y', 'K', 'F', 'H', 'W', 'D', 'L', 'U', 'N', 'R', 'Z', 'V', 'X']\", \"['R']\", \"['N', 'X']\"]"}
{"diff_sorted_id": "100", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [19, 11, 3, 37, 9, 29, 42, 12, 2, 13, 15, 11, 25, 14, 31, 17, 24, 45, 5, 18, 42, 21, 28, 23, 26, 40, 27, 42, 12, 13, 16, 14, 31, 38, 9, 24, 27, 36, 13, 27, 15, 43, 9, 14, 34, 7, 15, 12, 31, 44], such that the sum of the chosen coins adds up to 449. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {37: 7, 45: 7, 29: 6, 27: 2, 2: 2, 40: 6, 13: 9, 17: 2, 9: 2, 15: 12, 36: 2, 26: 18, 44: 5, 42: 4, 38: 8, 43: 2, 12: 4, 24: 20, 28: 15, 16: 7, 21: 13, 23: 5, 19: 4, 25: 16, 3: 2, 18: 13, 34: 16, 31: 2, 5: 4, 14: 2, 7: 1, 11: 8}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "30", "opt_solution": "[27, 27, 31, 31, 14, 27, 31, 43, 42, 45, 44, 42, 36, 2, 7]", "opt_solution_cost": "41", "opt_solution_compute_t": "0.05939221382141113", "solution_depth": "15", "max_successor_states": "50", "num_vars_per_state": "50", "is_feasible_args": "[[19, 11, 3, 37, 9, 29, 42, 12, 2, 13, 15, 11, 25, 14, 31, 17, 24, 45, 5, 18, 42, 21, 28, 23, 26, 40, 27, 42, 12, 13, 16, 14, 31, 38, 9, 24, 27, 36, 13, 27, 15, 43, 9, 14, 34, 7, 15, 12, 31, 44]]", "is_correct_args": "[[19, 11, 3, 37, 9, 29, 42, 12, 2, 13, 15, 11, 25, 14, 31, 17, 24, 45, 5, 18, 42, 21, 28, 23, 26, 40, 27, 42, 12, 13, 16, 14, 31, 38, 9, 24, 27, 36, 13, 27, 15, 43, 9, 14, 34, 7, 15, 12, 31, 44], {\"37\": 7, \"45\": 7, \"29\": 6, \"27\": 2, \"2\": 2, \"40\": 6, \"13\": 9, \"17\": 2, \"9\": 2, \"15\": 12, \"36\": 2, \"26\": 18, \"44\": 5, \"42\": 4, \"38\": 8, \"43\": 2, \"12\": 4, \"24\": 20, \"28\": 15, \"16\": 7, \"21\": 13, \"23\": 5, \"19\": 4, \"25\": 16, \"3\": 2, \"18\": 13, \"34\": 16, \"31\": 2, \"5\": 4, \"14\": 2, \"7\": 1, \"11\": 8}, 449]", "A*_args": "[\"[19, 11, 3, 37, 9, 29, 42, 12, 2, 13, 15, 11, 25, 14, 31, 17, 24, 45, 5, 18, 42, 21, 28, 23, 26, 40, 27, 42, 12, 13, 16, 14, 31, 38, 9, 24, 27, 36, 13, 27, 15, 43, 9, 14, 34, 7, 15, 12, 31, 44]\", \"{37: 7, 45: 7, 29: 6, 27: 2, 2: 2, 40: 6, 13: 9, 17: 2, 9: 2, 15: 12, 36: 2, 26: 18, 44: 5, 42: 4, 38: 8, 43: 2, 12: 4, 24: 20, 28: 15, 16: 7, 21: 13, 23: 5, 19: 4, 25: 16, 3: 2, 18: 13, 34: 16, 31: 2, 5: 4, 14: 2, 7: 1, 11: 8}\", \"449\"]"}
{"diff_sorted_id": "100", "problem_statement": "The game of 'Sort It' begins with 3 tubes, each filled with 6 balls of different colors. The goal is to sort the balls by color, with each tube containing balls of only one color. Only one ball can be moved at a time, taken from the top of one tube and placed on top of another. The capacity of each tube (maximum number of balls we can fit in each tube) is 9 balls. It is not allowed to place a ball in a tube that already has 9 balls. The solution should be a list of tuples, each containing, first, the index of the tube from which a ball is taken and, second, the index of the tube to which it is moved, indexing from 0. Given the initial state of the tubes, represented by the lists below (with the leftmost item being the color of the topmost ball in each tube), what is the shortest list of move tuples that will result in all the balls being correctly sorted? [['Blue', 'Green', 'Red', 'Red', 'Blue', 'Green'], ['Blue', 'Red', 'Green', 'Green', 'Green', 'Red'], ['Blue', 'Blue', 'Blue', 'Red', 'Red', 'Green']]", "problem_type": "color_sorting", "problem_category": "sorting", "relative_diff_score": "10", "opt_solution": "[[0, 2], [1, 2], [0, 2], [0, 1], [0, 1], [2, 1], [0, 2], [0, 1], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [2, 0], [1, 2], [1, 2], [1, 0], [1, 2], [1, 2], [1, 2], [1, 2], [1, 2], [0, 1], [0, 1], [0, 1], [2, 0], [2, 0], [2, 0], [2, 1], [2, 1], [0, 2], [0, 2], [0, 2]]", "opt_solution_cost": "35", "opt_solution_compute_t": "125.36433982849121", "solution_depth": "35", "max_successor_states": "6", "num_vars_per_state": "18", "is_feasible_args": "[[[\"Blue\", \"Green\", \"Red\", \"Red\", \"Blue\", \"Green\"], [\"Blue\", \"Red\", \"Green\", \"Green\", \"Green\", \"Red\"], [\"Blue\", \"Blue\", \"Blue\", \"Red\", \"Red\", \"Green\"]], 9]", "is_correct_args": "[[[\"Blue\", \"Green\", \"Red\", \"Red\", \"Blue\", \"Green\"], [\"Blue\", \"Red\", \"Green\", \"Green\", \"Green\", \"Red\"], [\"Blue\", \"Blue\", \"Blue\", \"Red\", \"Red\", \"Green\"]], 9]", "A*_args": "[\"[['Blue', 'Green', 'Red', 'Red', 'Blue', 'Green'], ['Blue', 'Red', 'Green', 'Green', 'Green', 'Red'], ['Blue', 'Blue', 'Blue', 'Red', 'Red', 'Green']]\", \"9\"]"}
{"diff_sorted_id": "100", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 30 to 86. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 295, 204, None for columns 1 to 2 respectively, and the sums of rows must be None, 244, 251, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 237. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['32' '75' '36' 'x']\n ['x' '83' 'x' 'x']\n ['x' '77' '58' '44']\n ['x' '60' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "9", "opt_solution": "[[0, 3, 33], [1, 0, 35], [1, 2, 80], [1, 3, 46], [2, 0, 72], [3, 0, 47], [3, 2, 30], [3, 3, 31]]", "opt_solution_cost": "839", "opt_solution_compute_t": "14.697113037109375", "solution_depth": "8", "max_successor_states": "36", "num_vars_per_state": "16", "is_feasible_args": "[\"[['32', '75', '36', ''], ['', '83', '', ''], ['', '77', '58', '44'], ['', '60', '', '']]\", 4, 30, 86]", "is_correct_args": "[\"[['32', '75', '36', ''], ['', '83', '', ''], ['', '77', '58', '44'], ['', '60', '', '']]\", 30, 86, [1, 3], [1, 3], [295, 204], [244, 251], 237]", "A*_args": "[\"[['32', '75', '36', ''], ['', '83', '', ''], ['', '77', '58', '44'], ['', '60', '', '']]\", \"30\", \"86\", \"[None, 295, 204, None]\", \"[None, 244, 251, None]\", \"237\"]"}
{"diff_sorted_id": "100", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (4, 0) to his destination workshop at index (9, 11), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 4, district 2 covering rows 5 to 9, and district 3 covering rows 10 to 14. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 2 16 x 9 x 14 x 8 x 16 x x 4 8]\n[9 x 4 x x 7 11 x x 13 x x 6 11 x]\n[x x 10 14 x x 18 x x x x x 6 16 x]\n[x 14 x 1 x 7 5 16 x 19 x x 10 7 x]\n[1 3 x 19 7 2 17 x x 6 x x x 10 14]\n[14 x x x 12 x 16 5 8 12 17 2 19 x 5]\n[9 9 8 15 18 x 16 x 10 x x 14 x x x]\n[18 20 x x 11 2 17 6 x 18 8 x 6 16 x]\n[12 x x x x 7 14 4 8 12 3 x 15 13 2]\n[16 x x x 12 x 8 1 7 7 12 17 2 2 7]\n[x 13 3 3 1 x 6 14 20 8 x 4 10 17 x]\n[1 8 x 16 x x x 9 x x 10 x x 5 8]\n[x x 1 x x 6 x x x 7 16 x x x x]\n[14 x x 10 18 x 6 13 x x x x x 15 x]\n[x 8 2 x 17 x 12 16 11 4 4 x x 17 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "7", "opt_solution": "[[4, 0], [5, 0], [6, 0], [6, 1], [6, 2], [6, 3], [6, 4], [7, 4], [7, 5], [8, 5], [8, 6], [8, 7], [9, 7], [9, 8], [9, 9], [10, 9], [9, 9], [9, 10], [9, 11]]", "opt_solution_cost": "170", "opt_solution_compute_t": "0.028670310974121094", "solution_depth": "19", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"2\", \"16\", \"x\", \"9\", \"x\", \"14\", \"x\", \"8\", \"x\", \"16\", \"x\", \"x\", \"4\", \"8\"], [\"9\", \"x\", \"4\", \"x\", \"x\", \"7\", \"11\", \"x\", \"x\", \"13\", \"x\", \"x\", \"6\", \"11\", \"x\"], [\"x\", \"x\", \"10\", \"14\", \"x\", \"x\", \"18\", \"x\", \"x\", \"x\", \"x\", \"x\", \"6\", \"16\", \"x\"], [\"x\", \"14\", \"x\", \"1\", \"x\", \"7\", \"5\", \"16\", \"x\", \"19\", \"x\", \"x\", \"10\", \"7\", \"x\"], [\"1\", \"3\", \"x\", \"19\", \"7\", \"2\", \"17\", \"x\", \"x\", \"6\", \"x\", \"x\", \"x\", \"10\", \"14\"], [\"14\", \"x\", \"x\", \"x\", \"12\", \"x\", \"16\", \"5\", \"8\", \"12\", \"17\", \"2\", \"19\", \"x\", \"5\"], [\"9\", \"9\", \"8\", \"15\", \"18\", \"x\", \"16\", \"x\", \"10\", \"x\", \"x\", \"14\", \"x\", \"x\", \"x\"], [\"18\", \"20\", \"x\", \"x\", \"11\", \"2\", \"17\", \"6\", \"x\", \"18\", \"8\", \"x\", \"6\", \"16\", \"x\"], [\"12\", \"x\", \"x\", \"x\", \"x\", \"7\", \"14\", \"4\", \"8\", \"12\", \"3\", \"x\", \"15\", \"13\", \"2\"], [\"16\", \"x\", \"x\", \"x\", \"12\", \"x\", \"8\", \"1\", \"7\", \"7\", \"12\", \"17\", \"2\", \"2\", \"7\"], [\"x\", \"13\", \"3\", \"3\", \"1\", \"x\", \"6\", \"14\", \"20\", \"8\", \"x\", \"4\", \"10\", \"17\", \"x\"], [\"1\", \"8\", \"x\", \"16\", \"x\", \"x\", \"x\", \"9\", \"x\", \"x\", \"10\", \"x\", \"x\", \"5\", \"8\"], [\"x\", \"x\", \"1\", \"x\", \"x\", \"6\", \"x\", \"x\", \"x\", \"7\", \"16\", \"x\", \"x\", \"x\", \"x\"], [\"14\", \"x\", \"x\", \"10\", \"18\", \"x\", \"6\", \"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\"], [\"x\", \"8\", \"2\", \"x\", \"17\", \"x\", \"12\", \"16\", \"11\", \"4\", \"4\", \"x\", \"x\", \"17\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"2\", \"16\", \"x\", \"9\", \"x\", \"14\", \"x\", \"8\", \"x\", \"16\", \"x\", \"x\", \"4\", \"8\"], [\"9\", \"x\", \"4\", \"x\", \"x\", \"7\", \"11\", \"x\", \"x\", \"13\", \"x\", \"x\", \"6\", \"11\", \"x\"], [\"x\", \"x\", \"10\", \"14\", \"x\", \"x\", \"18\", \"x\", \"x\", \"x\", \"x\", \"x\", \"6\", \"16\", \"x\"], [\"x\", \"14\", \"x\", \"1\", \"x\", \"7\", \"5\", \"16\", \"x\", \"19\", \"x\", \"x\", \"10\", \"7\", \"x\"], [\"1\", \"3\", \"x\", \"19\", \"7\", \"2\", \"17\", \"x\", \"x\", \"6\", \"x\", \"x\", \"x\", \"10\", \"14\"], [\"14\", \"x\", \"x\", \"x\", \"12\", \"x\", \"16\", \"5\", \"8\", \"12\", \"17\", \"2\", \"19\", \"x\", \"5\"], [\"9\", \"9\", \"8\", \"15\", \"18\", \"x\", \"16\", \"x\", \"10\", \"x\", \"x\", \"14\", \"x\", \"x\", \"x\"], [\"18\", \"20\", \"x\", \"x\", \"11\", \"2\", \"17\", \"6\", \"x\", \"18\", \"8\", \"x\", \"6\", \"16\", \"x\"], [\"12\", \"x\", \"x\", \"x\", \"x\", \"7\", \"14\", \"4\", \"8\", \"12\", \"3\", \"x\", \"15\", \"13\", \"2\"], [\"16\", \"x\", \"x\", \"x\", \"12\", \"x\", \"8\", \"1\", \"7\", \"7\", \"12\", \"17\", \"2\", \"2\", \"7\"], [\"x\", \"13\", \"3\", \"3\", \"1\", \"x\", \"6\", \"14\", \"20\", \"8\", \"x\", \"4\", \"10\", \"17\", \"x\"], [\"1\", \"8\", \"x\", \"16\", \"x\", \"x\", \"x\", \"9\", \"x\", \"x\", \"10\", \"x\", \"x\", \"5\", \"8\"], [\"x\", \"x\", \"1\", \"x\", \"x\", \"6\", \"x\", \"x\", \"x\", \"7\", \"16\", \"x\", \"x\", \"x\", \"x\"], [\"14\", \"x\", \"x\", \"10\", \"18\", \"x\", \"6\", \"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"15\", \"x\"], [\"x\", \"8\", \"2\", \"x\", \"17\", \"x\", \"12\", \"16\", \"11\", \"4\", \"4\", \"x\", \"x\", \"17\", \"x\"]], [4, 0], [9, 11], 4, 9]", "A*_args": "[\"[['x', '2', '16', 'x', '9', 'x', '14', 'x', '8', 'x', '16', 'x', 'x', '4', '8'], ['9', 'x', '4', 'x', 'x', '7', '11', 'x', 'x', '13', 'x', 'x', '6', '11', 'x'], ['x', 'x', '10', '14', 'x', 'x', '18', 'x', 'x', 'x', 'x', 'x', '6', '16', 'x'], ['x', '14', 'x', '1', 'x', '7', '5', '16', 'x', '19', 'x', 'x', '10', '7', 'x'], ['1', '3', 'x', '19', '7', '2', '17', 'x', 'x', '6', 'x', 'x', 'x', '10', '14'], ['14', 'x', 'x', 'x', '12', 'x', '16', '5', '8', '12', '17', '2', '19', 'x', '5'], ['9', '9', '8', '15', '18', 'x', '16', 'x', '10', 'x', 'x', '14', 'x', 'x', 'x'], ['18', '20', 'x', 'x', '11', '2', '17', '6', 'x', '18', '8', 'x', '6', '16', 'x'], ['12', 'x', 'x', 'x', 'x', '7', '14', '4', '8', '12', '3', 'x', '15', '13', '2'], ['16', 'x', 'x', 'x', '12', 'x', '8', '1', '7', '7', '12', '17', '2', '2', '7'], ['x', '13', '3', '3', '1', 'x', '6', '14', '20', '8', 'x', '4', '10', '17', 'x'], ['1', '8', 'x', '16', 'x', 'x', 'x', '9', 'x', 'x', '10', 'x', 'x', '5', '8'], ['x', 'x', '1', 'x', 'x', '6', 'x', 'x', 'x', '7', '16', 'x', 'x', 'x', 'x'], ['14', 'x', 'x', '10', '18', 'x', '6', '13', 'x', 'x', 'x', 'x', 'x', '15', 'x'], ['x', '8', '2', 'x', '17', 'x', '12', '16', '11', '4', '4', 'x', 'x', '17', 'x']]\", \"(4, 0)\", \"(9, 11)\", \"4\", \"9\"]"}
{"diff_sorted_id": "100", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 15x15. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 5 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (2, 2) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (13, 14). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 1 1 0 0 0 0 1 0 0 1 1 0 0\n1 0 0 0 1 0 1 1 0 0 1 1 1 1 0\n1 0 0 0 1 0 0 0 0 0 0 0 1 1 1\n1 1 1 1 1 1 0 0 0 0 1 0 1 0 0\n1 1 0 1 1 1 1 1 0 0 0 0 1 0 0\n0 1 1 0 0 1 0 1 1 1 1 0 0 0 0\n0 1 1 0 0 1 1 0 0 1 0 0 0 0 1\n1 1 1 1 0 1 0 0 1 1 0 1 0 0 0\n1 0 1 0 0 1 1 0 1 0 1 0 0 0 0\n1 1 1 1 0 0 1 1 1 1 1 0 0 0 0\n1 1 0 0 0 1 0 0 1 0 1 1 1 0 0\n1 0 0 0 1 1 0 0 1 1 1 1 1 0 0\n0 0 0 1 1 0 0 1 0 0 0 1 0 1 0\n1 1 1 0 1 1 1 1 1 1 0 1 0 1 0\n1 1 1 1 1 0 1 0 0 1 1 0 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[[2, 2], [1, 3], [0, 4], [0, 5], [1, 5], [2, 5], [2, 6], [3, 6], [3, 7], [3, 8], [4, 8], [4, 9], [4, 10], [4, 11], [5, 11], [6, 11], [7, 12], [8, 12], [9, 12], [10, 13], [11, 13], [12, 14], [13, 14]]", "opt_solution_cost": "23", "opt_solution_compute_t": "0.03257179260253906", "solution_depth": "23", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0], [1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1]]\", 5]", "is_correct_args": "[\"[[1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0], [1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1]]\", [2, 2], [13, 14], 5]", "A*_args": "[\"[[1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0], [1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0], [1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1]]\", \"(2, 2)\", \"(13, 14)\", \"5\"]"}
{"diff_sorted_id": "100", "problem_statement": "Given 9 labeled water jugs with capacities 126, 120, 127, 110, 54, 39, 38, 47, 139, 99 liters, we aim to fill 4 unlabeled buckets, numbered 1 to 4 and arranged in a line in ascending order, with 219, 240, 312, 411 liters of water respectively. The amount of water in each unlabeled bucket can not at any point in time exceed the amount of water in the bucket placed after it. Jugs can only be filled to the top and emptied completely, and the unlabeled buckets cannot be overfilled. An action, represented as a tuple ('+', X, Y) or ('-', X, Y), involves adding to or removing water from the unlabeled bucket numbered Y, using the jug with capacity X. Determine the shortest sequence of actions needed to fill the buckets as specified, and present the solution as a list of action tuples in Python syntax.", "problem_type": "water_jug", "problem_category": "subset_sum", "relative_diff_score": "7", "opt_solution": "[[\"+\", 99, 4], [\"+\", 139, 4], [\"+\", 47, 4], [\"+\", 126, 4], [\"+\", 47, 3], [\"+\", 126, 3], [\"+\", 139, 3], [\"+\", 120, 2], [\"+\", 120, 2], [\"+\", 99, 1], [\"+\", 120, 1]]", "opt_solution_cost": "11", "opt_solution_compute_t": "0.045166015625", "solution_depth": "11", "max_successor_states": "80", "num_vars_per_state": "3", "is_feasible_args": "[[126, 120, 127, 110, 54, 39, 38, 47, 139, 99], [219, 240, 312, 411]]", "is_correct_args": "[[126, 120, 127, 110, 54, 39, 38, 47, 139, 99], [219, 240, 312, 411]]", "A*_args": "[\"[126, 120, 127, 110, 54, 39, 38, 47, 139, 99]\", \"[219, 240, 312, 411]\"]"}
{"diff_sorted_id": "101", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'P'. Our task is to visit city N and city I excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from I and N, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  S Z I R P T X B F A L M G N E \nS 0 1 0 0 1 0 0 1 0 1 1 0 0 0 1 \nZ 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 \nI 0 1 0 0 0 0 0 0 1 1 0 1 0 0 0 \nR 1 1 1 0 1 0 0 1 0 0 0 1 1 0 0 \nP 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 \nT 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 \nX 0 0 1 1 1 1 0 1 0 0 1 1 1 0 0 \nB 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 \nF 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 \nA 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 \nL 0 1 1 1 1 0 0 0 0 1 0 0 0 1 0 \nM 0 0 0 0 0 0 0 0 1 0 0 0 0 1 1 \nG 0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 \nN 0 0 0 1 1 0 0 1 0 0 0 1 1 0 0 \nE 0 0 0 1 0 1 0 0 0 1 0 0 1 1 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[\"P\", \"E\", \"N\", \"B\", \"N\", \"R\", \"I\", \"F\", \"X\", \"I\"]", "opt_solution_cost": "10", "opt_solution_compute_t": "0.16242361068725586", "solution_depth": "10", "max_successor_states": "15", "num_vars_per_state": "18", "is_feasible_args": "[[[0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0], [1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0]], [\"S\", \"Z\", \"I\", \"R\", \"P\", \"T\", \"X\", \"B\", \"F\", \"A\", \"L\", \"M\", \"G\", \"N\", \"E\"], \"N\", \"I\"]", "is_correct_args": "[[[0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0], [1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0]], [\"S\", \"Z\", \"I\", \"R\", \"P\", \"T\", \"X\", \"B\", \"F\", \"A\", \"L\", \"M\", \"G\", \"N\", \"E\"], \"P\", \"N\", \"I\"]", "A*_args": "[\"[[0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0], [1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0]]\", \"['S', 'Z', 'I', 'R', 'P', 'T', 'X', 'B', 'F', 'A', 'L', 'M', 'G', 'N', 'E']\", \"['P']\", \"['N', 'I']\"]"}
{"diff_sorted_id": "101", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [29, 25, 15, 12, 40, 23, 36, 22, 16, 24, 51, 34, 46, 29, 20, 14, 21, 27, 15, 31, 15, 17, 9, 42, 30, 45, 14, 14, 30, 16, 44, 32, 6, 15, 5, 41, 18, 43, 36, 31, 27, 26, 6, 44, 33, 23, 7, 19], such that the sum of the chosen coins adds up to 477. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {41: 15, 22: 3, 9: 4, 34: 9, 32: 11, 36: 5, 18: 5, 40: 9, 46: 11, 45: 17, 33: 3, 14: 9, 12: 12, 7: 2, 43: 14, 25: 18, 31: 9, 51: 8, 24: 18, 17: 3, 16: 5, 19: 10, 6: 6, 27: 15, 42: 7, 23: 2, 29: 2, 21: 13, 30: 7, 44: 4, 5: 2, 20: 11, 26: 12, 15: 8}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "31", "opt_solution": "[44, 36, 22, 23, 23, 29, 29, 33, 51, 44, 42, 36, 18, 31, 16]", "opt_solution_cost": "66", "opt_solution_compute_t": "0.06806683540344238", "solution_depth": "15", "max_successor_states": "48", "num_vars_per_state": "48", "is_feasible_args": "[[29, 25, 15, 12, 40, 23, 36, 22, 16, 24, 51, 34, 46, 29, 20, 14, 21, 27, 15, 31, 15, 17, 9, 42, 30, 45, 14, 14, 30, 16, 44, 32, 6, 15, 5, 41, 18, 43, 36, 31, 27, 26, 6, 44, 33, 23, 7, 19]]", "is_correct_args": "[[29, 25, 15, 12, 40, 23, 36, 22, 16, 24, 51, 34, 46, 29, 20, 14, 21, 27, 15, 31, 15, 17, 9, 42, 30, 45, 14, 14, 30, 16, 44, 32, 6, 15, 5, 41, 18, 43, 36, 31, 27, 26, 6, 44, 33, 23, 7, 19], {\"41\": 15, \"22\": 3, \"9\": 4, \"34\": 9, \"32\": 11, \"36\": 5, \"18\": 5, \"40\": 9, \"46\": 11, \"45\": 17, \"33\": 3, \"14\": 9, \"12\": 12, \"7\": 2, \"43\": 14, \"25\": 18, \"31\": 9, \"51\": 8, \"24\": 18, \"17\": 3, \"16\": 5, \"19\": 10, \"6\": 6, \"27\": 15, \"42\": 7, \"23\": 2, \"29\": 2, \"21\": 13, \"30\": 7, \"44\": 4, \"5\": 2, \"20\": 11, \"26\": 12, \"15\": 8}, 477]", "A*_args": "[\"[29, 25, 15, 12, 40, 23, 36, 22, 16, 24, 51, 34, 46, 29, 20, 14, 21, 27, 15, 31, 15, 17, 9, 42, 30, 45, 14, 14, 30, 16, 44, 32, 6, 15, 5, 41, 18, 43, 36, 31, 27, 26, 6, 44, 33, 23, 7, 19]\", \"{41: 15, 22: 3, 9: 4, 34: 9, 32: 11, 36: 5, 18: 5, 40: 9, 46: 11, 45: 17, 33: 3, 14: 9, 12: 12, 7: 2, 43: 14, 25: 18, 31: 9, 51: 8, 24: 18, 17: 3, 16: 5, 19: 10, 6: 6, 27: 15, 42: 7, 23: 2, 29: 2, 21: 13, 30: 7, 44: 4, 5: 2, 20: 11, 26: 12, 15: 8}\", \"477\"]"}
{"diff_sorted_id": "101", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 30 to 86. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 260, 216, None for columns 1 to 2 respectively, and the sums of rows must be None, 183, 217, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 214. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['70' 'x' '50' 'x']\n ['x' '39' '46' 'x']\n ['34' '60' 'x' '51']\n ['x' 'x' 'x' '68']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 1, 76], [0, 3, 30], [1, 0, 31], [1, 3, 67], [2, 2, 72], [3, 0, 78], [3, 1, 85], [3, 2, 48]]", "opt_solution_cost": "905", "opt_solution_compute_t": "50.447338819503784", "solution_depth": "8", "max_successor_states": "36", "num_vars_per_state": "16", "is_feasible_args": "[\"[['70', '', '50', ''], ['', '39', '46', ''], ['34', '60', '', '51'], ['', '', '', '68']]\", 4, 30, 86]", "is_correct_args": "[\"[['70', '', '50', ''], ['', '39', '46', ''], ['34', '60', '', '51'], ['', '', '', '68']]\", 30, 86, [1, 3], [1, 3], [260, 216], [183, 217], 214]", "A*_args": "[\"[['70', '', '50', ''], ['', '39', '46', ''], ['34', '60', '', '51'], ['', '', '', '68']]\", \"30\", \"86\", \"[None, 260, 216, None]\", \"[None, 183, 217, None]\", \"214\"]"}
{"diff_sorted_id": "101", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (7, 0) to his destination workshop at index (4, 13), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 4, district 2 covering rows 5 to 8, and district 3 covering rows 9 to 14. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 3 1 19 8 1 4 18 15 17 4 3 x 3 x]\n[x 11 x x x 12 x 19 15 4 x x x x x]\n[4 1 x 8 x 12 17 x 14 4 9 11 13 6 19]\n[2 x 6 14 15 x 18 9 x 10 10 x x 1 x]\n[x 11 x 8 x 5 x 8 7 6 x x 13 6 x]\n[x x x 17 x 13 x x x x 18 19 5 x x]\n[x 12 18 x x x 19 x 12 x 11 7 19 12 x]\n[6 6 x 6 4 x 18 x x 15 18 x 6 8 x]\n[10 10 x x 6 4 11 19 x 9 x 2 x 3 14]\n[x 18 14 10 x 1 x 6 x 15 x 6 x 14 x]\n[x x 7 10 x 2 x 7 14 4 11 x x x x]\n[12 x 6 x 8 5 6 6 8 x x x x 4 7]\n[x x 1 8 10 4 10 17 19 11 2 x x x 16]\n[x x x 17 8 19 x 14 x 17 17 5 7 6 7]\n[1 x 14 x 3 x 18 6 18 8 x 13 10 x x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "7", "opt_solution": "[[7, 0], [7, 1], [8, 1], [9, 1], [9, 2], [10, 2], [11, 2], [12, 2], [12, 3], [12, 4], [12, 5], [11, 5], [11, 6], [11, 7], [10, 7], [10, 8], [10, 9], [9, 9], [8, 9], [7, 9], [7, 10], [6, 10], [6, 11], [5, 11], [5, 12], [4, 12], [4, 13]]", "opt_solution_cost": "244", "opt_solution_compute_t": "0.02743220329284668", "solution_depth": "27", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"3\", \"1\", \"19\", \"8\", \"1\", \"4\", \"18\", \"15\", \"17\", \"4\", \"3\", \"x\", \"3\", \"x\"], [\"x\", \"11\", \"x\", \"x\", \"x\", \"12\", \"x\", \"19\", \"15\", \"4\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"4\", \"1\", \"x\", \"8\", \"x\", \"12\", \"17\", \"x\", \"14\", \"4\", \"9\", \"11\", \"13\", \"6\", \"19\"], [\"2\", \"x\", \"6\", \"14\", \"15\", \"x\", \"18\", \"9\", \"x\", \"10\", \"10\", \"x\", \"x\", \"1\", \"x\"], [\"x\", \"11\", \"x\", \"8\", \"x\", \"5\", \"x\", \"8\", \"7\", \"6\", \"x\", \"x\", \"13\", \"6\", \"x\"], [\"x\", \"x\", \"x\", \"17\", \"x\", \"13\", \"x\", \"x\", \"x\", \"x\", \"18\", \"19\", \"5\", \"x\", \"x\"], [\"x\", \"12\", \"18\", \"x\", \"x\", \"x\", \"19\", \"x\", \"12\", \"x\", \"11\", \"7\", \"19\", \"12\", \"x\"], [\"6\", \"6\", \"x\", \"6\", \"4\", \"x\", \"18\", \"x\", \"x\", \"15\", \"18\", \"x\", \"6\", \"8\", \"x\"], [\"10\", \"10\", \"x\", \"x\", \"6\", \"4\", \"11\", \"19\", \"x\", \"9\", \"x\", \"2\", \"x\", \"3\", \"14\"], [\"x\", \"18\", \"14\", \"10\", \"x\", \"1\", \"x\", \"6\", \"x\", \"15\", \"x\", \"6\", \"x\", \"14\", \"x\"], [\"x\", \"x\", \"7\", \"10\", \"x\", \"2\", \"x\", \"7\", \"14\", \"4\", \"11\", \"x\", \"x\", \"x\", \"x\"], [\"12\", \"x\", \"6\", \"x\", \"8\", \"5\", \"6\", \"6\", \"8\", \"x\", \"x\", \"x\", \"x\", \"4\", \"7\"], [\"x\", \"x\", \"1\", \"8\", \"10\", \"4\", \"10\", \"17\", \"19\", \"11\", \"2\", \"x\", \"x\", \"x\", \"16\"], [\"x\", \"x\", \"x\", \"17\", \"8\", \"19\", \"x\", \"14\", \"x\", \"17\", \"17\", \"5\", \"7\", \"6\", \"7\"], [\"1\", \"x\", \"14\", \"x\", \"3\", \"x\", \"18\", \"6\", \"18\", \"8\", \"x\", \"13\", \"10\", \"x\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"3\", \"1\", \"19\", \"8\", \"1\", \"4\", \"18\", \"15\", \"17\", \"4\", \"3\", \"x\", \"3\", \"x\"], [\"x\", \"11\", \"x\", \"x\", \"x\", \"12\", \"x\", \"19\", \"15\", \"4\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"4\", \"1\", \"x\", \"8\", \"x\", \"12\", \"17\", \"x\", \"14\", \"4\", \"9\", \"11\", \"13\", \"6\", \"19\"], [\"2\", \"x\", \"6\", \"14\", \"15\", \"x\", \"18\", \"9\", \"x\", \"10\", \"10\", \"x\", \"x\", \"1\", \"x\"], [\"x\", \"11\", \"x\", \"8\", \"x\", \"5\", \"x\", \"8\", \"7\", \"6\", \"x\", \"x\", \"13\", \"6\", \"x\"], [\"x\", \"x\", \"x\", \"17\", \"x\", \"13\", \"x\", \"x\", \"x\", \"x\", \"18\", \"19\", \"5\", \"x\", \"x\"], [\"x\", \"12\", \"18\", \"x\", \"x\", \"x\", \"19\", \"x\", \"12\", \"x\", \"11\", \"7\", \"19\", \"12\", \"x\"], [\"6\", \"6\", \"x\", \"6\", \"4\", \"x\", \"18\", \"x\", \"x\", \"15\", \"18\", \"x\", \"6\", \"8\", \"x\"], [\"10\", \"10\", \"x\", \"x\", \"6\", \"4\", \"11\", \"19\", \"x\", \"9\", \"x\", \"2\", \"x\", \"3\", \"14\"], [\"x\", \"18\", \"14\", \"10\", \"x\", \"1\", \"x\", \"6\", \"x\", \"15\", \"x\", \"6\", \"x\", \"14\", \"x\"], [\"x\", \"x\", \"7\", \"10\", \"x\", \"2\", \"x\", \"7\", \"14\", \"4\", \"11\", \"x\", \"x\", \"x\", \"x\"], [\"12\", \"x\", \"6\", \"x\", \"8\", \"5\", \"6\", \"6\", \"8\", \"x\", \"x\", \"x\", \"x\", \"4\", \"7\"], [\"x\", \"x\", \"1\", \"8\", \"10\", \"4\", \"10\", \"17\", \"19\", \"11\", \"2\", \"x\", \"x\", \"x\", \"16\"], [\"x\", \"x\", \"x\", \"17\", \"8\", \"19\", \"x\", \"14\", \"x\", \"17\", \"17\", \"5\", \"7\", \"6\", \"7\"], [\"1\", \"x\", \"14\", \"x\", \"3\", \"x\", \"18\", \"6\", \"18\", \"8\", \"x\", \"13\", \"10\", \"x\", \"x\"]], [7, 0], [4, 13], 4, 8]", "A*_args": "[\"[['x', '3', '1', '19', '8', '1', '4', '18', '15', '17', '4', '3', 'x', '3', 'x'], ['x', '11', 'x', 'x', 'x', '12', 'x', '19', '15', '4', 'x', 'x', 'x', 'x', 'x'], ['4', '1', 'x', '8', 'x', '12', '17', 'x', '14', '4', '9', '11', '13', '6', '19'], ['2', 'x', '6', '14', '15', 'x', '18', '9', 'x', '10', '10', 'x', 'x', '1', 'x'], ['x', '11', 'x', '8', 'x', '5', 'x', '8', '7', '6', 'x', 'x', '13', '6', 'x'], ['x', 'x', 'x', '17', 'x', '13', 'x', 'x', 'x', 'x', '18', '19', '5', 'x', 'x'], ['x', '12', '18', 'x', 'x', 'x', '19', 'x', '12', 'x', '11', '7', '19', '12', 'x'], ['6', '6', 'x', '6', '4', 'x', '18', 'x', 'x', '15', '18', 'x', '6', '8', 'x'], ['10', '10', 'x', 'x', '6', '4', '11', '19', 'x', '9', 'x', '2', 'x', '3', '14'], ['x', '18', '14', '10', 'x', '1', 'x', '6', 'x', '15', 'x', '6', 'x', '14', 'x'], ['x', 'x', '7', '10', 'x', '2', 'x', '7', '14', '4', '11', 'x', 'x', 'x', 'x'], ['12', 'x', '6', 'x', '8', '5', '6', '6', '8', 'x', 'x', 'x', 'x', '4', '7'], ['x', 'x', '1', '8', '10', '4', '10', '17', '19', '11', '2', 'x', 'x', 'x', '16'], ['x', 'x', 'x', '17', '8', '19', 'x', '14', 'x', '17', '17', '5', '7', '6', '7'], ['1', 'x', '14', 'x', '3', 'x', '18', '6', '18', '8', 'x', '13', '10', 'x', 'x']]\", \"(7, 0)\", \"(4, 13)\", \"4\", \"8\"]"}
{"diff_sorted_id": "101", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 15x15. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 5 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (0, 3) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (14, 11). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 0 0 0 0 1 0 1 0 1 0 1 0 0\n1 1 0 1 0 1 1 1 1 0 1 1 1 1 1\n1 1 0 0 0 1 1 1 1 0 1 1 1 0 0\n1 1 0 0 0 1 0 1 1 1 1 1 1 1 1\n1 0 0 0 0 0 1 0 1 1 1 0 0 1 0\n0 1 0 1 1 0 0 1 0 0 1 0 0 0 1\n1 1 1 0 0 0 1 1 1 0 1 1 0 0 1\n0 0 0 1 1 0 1 0 0 1 1 1 0 0 1\n1 0 0 1 1 0 1 0 1 0 1 0 1 0 1\n1 0 0 0 0 0 0 1 0 0 0 1 0 0 1\n0 0 1 0 0 0 1 0 0 1 1 0 0 1 1\n1 1 0 1 1 0 0 0 0 0 1 0 1 0 0\n1 0 0 1 1 1 1 0 0 0 0 1 1 1 1\n0 1 1 1 0 1 1 0 0 0 0 0 0 1 0\n0 1 0 1 0 1 0 0 0 0 0 0 0 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[[0, 3], [0, 4], [1, 4], [2, 4], [3, 4], [4, 4], [4, 5], [5, 5], [6, 5], [7, 5], [8, 5], [9, 5], [9, 6], [10, 7], [11, 8], [12, 9], [13, 10], [14, 11]]", "opt_solution_cost": "18", "opt_solution_compute_t": "0.027624130249023438", "solution_depth": "18", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0], [1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1], [1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0], [1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], [0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1], [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1], [1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1], [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1], [0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1]]\", 5]", "is_correct_args": "[\"[[1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0], [1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1], [1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0], [1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], [0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1], [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1], [1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1], [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1], [0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1]]\", [0, 3], [14, 11], 5]", "A*_args": "[\"[[1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0], [1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1], [1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0], [1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0], [0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1], [1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1], [0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1], [1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1], [0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1], [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1], [0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1]]\", \"(0, 3)\", \"(14, 11)\", \"5\"]"}
{"diff_sorted_id": "102", "problem_statement": "We have a map of cities, each represented by a letter, and they are connected by one-way roads. The adjacency matrix below shows the connections between the cities. Each row and column represents a city, and a '1' signifies a direct road from the city of the row to the city of the column. The travel time between any two directly connected cities is the same. Currently, we are located in city 'S'. Our task is to visit city T and city C excatly twice. Determine the quickest route that allows us to visit both these destination cities, ensuring that we stop at the two destinations twice on our path. The sequence in which we visit the destination cities is not important. However, apart from C and T, we can only visit each city once on our path. Provide the solution as a list of the city names on our path, including the start, in Python syntax.\n\n  M Y Q T E A J S V F W N Z C I \nM 0 1 0 0 1 0 0 0 0 0 0 0 0 0 1 \nY 0 0 0 0 1 0 0 0 0 0 1 0 1 0 0 \nQ 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 \nT 0 1 1 0 0 0 1 0 1 0 0 0 0 0 0 \nE 0 0 1 0 0 0 0 0 0 0 1 0 1 1 0 \nA 1 0 1 1 0 0 1 1 0 1 0 0 0 0 0 \nJ 1 1 0 1 0 0 0 0 0 1 0 0 0 0 0 \nS 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 \nV 0 1 1 1 0 0 0 1 0 0 0 0 1 0 0 \nF 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 \nW 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 \nN 1 0 1 1 1 0 0 0 0 1 0 0 0 0 1 \nZ 0 0 0 1 0 0 0 1 0 0 0 0 0 1 0 \nC 0 0 0 1 0 0 0 0 1 1 0 1 0 0 0 \nI 0 0 1 0 1 1 1 0 1 0 0 0 0 0 0 \n", "problem_type": "city_directed_graph", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[\"S\", \"J\", \"F\", \"C\", \"T\", \"V\", \"Z\", \"C\", \"T\"]", "opt_solution_cost": "9", "opt_solution_compute_t": "0.04518413543701172", "solution_depth": "9", "max_successor_states": "15", "num_vars_per_state": "18", "is_feasible_args": "[[[0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0], [0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0]], [\"M\", \"Y\", \"Q\", \"T\", \"E\", \"A\", \"J\", \"S\", \"V\", \"F\", \"W\", \"N\", \"Z\", \"C\", \"I\"], \"T\", \"C\"]", "is_correct_args": "[[[0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0], [0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0]], [\"M\", \"Y\", \"Q\", \"T\", \"E\", \"A\", \"J\", \"S\", \"V\", \"F\", \"W\", \"N\", \"Z\", \"C\", \"I\"], \"S\", \"T\", \"C\"]", "A*_args": "[\"[[0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0], [1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0], [0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0]]\", \"['M', 'Y', 'Q', 'T', 'E', 'A', 'J', 'S', 'V', 'F', 'W', 'N', 'Z', 'C', 'I']\", \"['S']\", \"['T', 'C']\"]"}
{"diff_sorted_id": "102", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [14, 29, 39, 40, 16, 35, 17, 37, 43, 30, 28, 26, 13, 13, 42, 30, 10, 7, 44, 5, 34, 7, 32, 11, 40, 35, 12, 34, 35, 38, 29, 42, 33, 26, 4, 36, 41, 35, 26, 34, 16, 6, 38, 13, 41, 23, 20], such that the sum of the chosen coins adds up to 449. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {11: 4, 10: 3, 41: 9, 34: 4, 7: 2, 17: 16, 29: 8, 37: 1, 44: 8, 30: 13, 32: 9, 20: 18, 23: 8, 6: 4, 5: 3, 14: 3, 13: 7, 35: 4, 33: 5, 39: 9, 40: 11, 28: 3, 4: 2, 43: 14, 42: 15, 38: 14, 16: 5, 36: 5, 12: 9, 26: 1}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "32", "opt_solution": "[26, 35, 26, 35, 26, 35, 34, 35, 34, 37, 36, 34, 28, 14, 10, 4]", "opt_solution_cost": "48", "opt_solution_compute_t": "0.08744978904724121", "solution_depth": "16", "max_successor_states": "47", "num_vars_per_state": "47", "is_feasible_args": "[[14, 29, 39, 40, 16, 35, 17, 37, 43, 30, 28, 26, 13, 13, 42, 30, 10, 7, 44, 5, 34, 7, 32, 11, 40, 35, 12, 34, 35, 38, 29, 42, 33, 26, 4, 36, 41, 35, 26, 34, 16, 6, 38, 13, 41, 23, 20]]", "is_correct_args": "[[14, 29, 39, 40, 16, 35, 17, 37, 43, 30, 28, 26, 13, 13, 42, 30, 10, 7, 44, 5, 34, 7, 32, 11, 40, 35, 12, 34, 35, 38, 29, 42, 33, 26, 4, 36, 41, 35, 26, 34, 16, 6, 38, 13, 41, 23, 20], {\"11\": 4, \"10\": 3, \"41\": 9, \"34\": 4, \"7\": 2, \"17\": 16, \"29\": 8, \"37\": 1, \"44\": 8, \"30\": 13, \"32\": 9, \"20\": 18, \"23\": 8, \"6\": 4, \"5\": 3, \"14\": 3, \"13\": 7, \"35\": 4, \"33\": 5, \"39\": 9, \"40\": 11, \"28\": 3, \"4\": 2, \"43\": 14, \"42\": 15, \"38\": 14, \"16\": 5, \"36\": 5, \"12\": 9, \"26\": 1}, 449]", "A*_args": "[\"[14, 29, 39, 40, 16, 35, 17, 37, 43, 30, 28, 26, 13, 13, 42, 30, 10, 7, 44, 5, 34, 7, 32, 11, 40, 35, 12, 34, 35, 38, 29, 42, 33, 26, 4, 36, 41, 35, 26, 34, 16, 6, 38, 13, 41, 23, 20]\", \"{11: 4, 10: 3, 41: 9, 34: 4, 7: 2, 17: 16, 29: 8, 37: 1, 44: 8, 30: 13, 32: 9, 20: 18, 23: 8, 6: 4, 5: 3, 14: 3, 13: 7, 35: 4, 33: 5, 39: 9, 40: 11, 28: 3, 4: 2, 43: 14, 42: 15, 38: 14, 16: 5, 36: 5, 12: 9, 26: 1}\", \"449\"]"}
{"diff_sorted_id": "102", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 36 to 92. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 279, 306, None for columns 1 to 2 respectively, and the sums of rows must be None, 315, 234, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 264. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['44' 'x' 'x' 'x']\n ['90' '52' 'x' '91']\n ['x' '58' 'x' '62']\n ['x' '80' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 1, 89], [0, 2, 59], [0, 3, 38], [1, 2, 82], [2, 0, 36], [2, 2, 78], [3, 0, 86], [3, 2, 87], [3, 3, 37]]", "opt_solution_cost": "1069", "opt_solution_compute_t": "51.39947175979614", "solution_depth": "9", "max_successor_states": "36", "num_vars_per_state": "16", "is_feasible_args": "[\"[['44', '', '', ''], ['90', '52', '', '91'], ['', '58', '', '62'], ['', '80', '', '']]\", 4, 36, 92]", "is_correct_args": "[\"[['44', '', '', ''], ['90', '52', '', '91'], ['', '58', '', '62'], ['', '80', '', '']]\", 36, 92, [1, 3], [1, 3], [279, 306], [315, 234], 264]", "A*_args": "[\"[['44', '', '', ''], ['90', '52', '', '91'], ['', '58', '', '62'], ['', '80', '', '']]\", \"36\", \"92\", \"[None, 279, 306, None]\", \"[None, 315, 234, None]\", \"264\"]"}
{"diff_sorted_id": "102", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (5, 0) to his destination workshop at index (7, 13), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 5, district 2 covering rows 6 to 6, and district 3 covering rows 7 to 14. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x 13 x x x x 3 4 x x 9 x 18 7 2]\n[1 10 17 x x x 11 13 x 10 x 9 13 x x]\n[x x 7 18 x x x x 7 x x x 1 x 16]\n[10 x x x 13 x 2 9 x x 8 x x 5 x]\n[x 7 12 x 1 18 14 x 7 x x 16 x x 19]\n[5 1 13 17 11 14 16 x 14 x 18 5 x 18 x]\n[x 15 19 4 x 13 x 5 x x 18 x 17 x x]\n[3 7 x x x 12 x x 17 4 x 13 19 3 10]\n[11 x x x x 2 2 19 13 4 7 17 16 x 17]\n[12 5 4 x x x x 12 8 11 x 17 14 19 2]\n[4 10 x x 6 11 16 17 x x 18 x 17 x x]\n[x x x x 11 9 18 17 12 x x x x x 1]\n[18 13 7 x x 5 4 13 x x 19 12 1 18 x]\n[15 x 17 x x x 17 x x x 10 x 15 16 x]\n[x x 11 15 x x 12 16 12 13 18 x 17 8 15]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "7", "opt_solution": "[[5, 0], [5, 1], [5, 2], [5, 3], [5, 4], [5, 5], [6, 5], [7, 5], [8, 5], [8, 6], [8, 7], [8, 8], [8, 9], [8, 10], [8, 11], [7, 11], [7, 12], [7, 13]]", "opt_solution_cost": "180", "opt_solution_compute_t": "0.028650999069213867", "solution_depth": "18", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"13\", \"x\", \"x\", \"x\", \"x\", \"3\", \"4\", \"x\", \"x\", \"9\", \"x\", \"18\", \"7\", \"2\"], [\"1\", \"10\", \"17\", \"x\", \"x\", \"x\", \"11\", \"13\", \"x\", \"10\", \"x\", \"9\", \"13\", \"x\", \"x\"], [\"x\", \"x\", \"7\", \"18\", \"x\", \"x\", \"x\", \"x\", \"7\", \"x\", \"x\", \"x\", \"1\", \"x\", \"16\"], [\"10\", \"x\", \"x\", \"x\", \"13\", \"x\", \"2\", \"9\", \"x\", \"x\", \"8\", \"x\", \"x\", \"5\", \"x\"], [\"x\", \"7\", \"12\", \"x\", \"1\", \"18\", \"14\", \"x\", \"7\", \"x\", \"x\", \"16\", \"x\", \"x\", \"19\"], [\"5\", \"1\", \"13\", \"17\", \"11\", \"14\", \"16\", \"x\", \"14\", \"x\", \"18\", \"5\", \"x\", \"18\", \"x\"], [\"x\", \"15\", \"19\", \"4\", \"x\", \"13\", \"x\", \"5\", \"x\", \"x\", \"18\", \"x\", \"17\", \"x\", \"x\"], [\"3\", \"7\", \"x\", \"x\", \"x\", \"12\", \"x\", \"x\", \"17\", \"4\", \"x\", \"13\", \"19\", \"3\", \"10\"], [\"11\", \"x\", \"x\", \"x\", \"x\", \"2\", \"2\", \"19\", \"13\", \"4\", \"7\", \"17\", \"16\", \"x\", \"17\"], [\"12\", \"5\", \"4\", \"x\", \"x\", \"x\", \"x\", \"12\", \"8\", \"11\", \"x\", \"17\", \"14\", \"19\", \"2\"], [\"4\", \"10\", \"x\", \"x\", \"6\", \"11\", \"16\", \"17\", \"x\", \"x\", \"18\", \"x\", \"17\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"11\", \"9\", \"18\", \"17\", \"12\", \"x\", \"x\", \"x\", \"x\", \"x\", \"1\"], [\"18\", \"13\", \"7\", \"x\", \"x\", \"5\", \"4\", \"13\", \"x\", \"x\", \"19\", \"12\", \"1\", \"18\", \"x\"], [\"15\", \"x\", \"17\", \"x\", \"x\", \"x\", \"17\", \"x\", \"x\", \"x\", \"10\", \"x\", \"15\", \"16\", \"x\"], [\"x\", \"x\", \"11\", \"15\", \"x\", \"x\", \"12\", \"16\", \"12\", \"13\", \"18\", \"x\", \"17\", \"8\", \"15\"]]]", "is_correct_args": "[[[\"x\", \"13\", \"x\", \"x\", \"x\", \"x\", \"3\", \"4\", \"x\", \"x\", \"9\", \"x\", \"18\", \"7\", \"2\"], [\"1\", \"10\", \"17\", \"x\", \"x\", \"x\", \"11\", \"13\", \"x\", \"10\", \"x\", \"9\", \"13\", \"x\", \"x\"], [\"x\", \"x\", \"7\", \"18\", \"x\", \"x\", \"x\", \"x\", \"7\", \"x\", \"x\", \"x\", \"1\", \"x\", \"16\"], [\"10\", \"x\", \"x\", \"x\", \"13\", \"x\", \"2\", \"9\", \"x\", \"x\", \"8\", \"x\", \"x\", \"5\", \"x\"], [\"x\", \"7\", \"12\", \"x\", \"1\", \"18\", \"14\", \"x\", \"7\", \"x\", \"x\", \"16\", \"x\", \"x\", \"19\"], [\"5\", \"1\", \"13\", \"17\", \"11\", \"14\", \"16\", \"x\", \"14\", \"x\", \"18\", \"5\", \"x\", \"18\", \"x\"], [\"x\", \"15\", \"19\", \"4\", \"x\", \"13\", \"x\", \"5\", \"x\", \"x\", \"18\", \"x\", \"17\", \"x\", \"x\"], [\"3\", \"7\", \"x\", \"x\", \"x\", \"12\", \"x\", \"x\", \"17\", \"4\", \"x\", \"13\", \"19\", \"3\", \"10\"], [\"11\", \"x\", \"x\", \"x\", \"x\", \"2\", \"2\", \"19\", \"13\", \"4\", \"7\", \"17\", \"16\", \"x\", \"17\"], [\"12\", \"5\", \"4\", \"x\", \"x\", \"x\", \"x\", \"12\", \"8\", \"11\", \"x\", \"17\", \"14\", \"19\", \"2\"], [\"4\", \"10\", \"x\", \"x\", \"6\", \"11\", \"16\", \"17\", \"x\", \"x\", \"18\", \"x\", \"17\", \"x\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"11\", \"9\", \"18\", \"17\", \"12\", \"x\", \"x\", \"x\", \"x\", \"x\", \"1\"], [\"18\", \"13\", \"7\", \"x\", \"x\", \"5\", \"4\", \"13\", \"x\", \"x\", \"19\", \"12\", \"1\", \"18\", \"x\"], [\"15\", \"x\", \"17\", \"x\", \"x\", \"x\", \"17\", \"x\", \"x\", \"x\", \"10\", \"x\", \"15\", \"16\", \"x\"], [\"x\", \"x\", \"11\", \"15\", \"x\", \"x\", \"12\", \"16\", \"12\", \"13\", \"18\", \"x\", \"17\", \"8\", \"15\"]], [5, 0], [7, 13], 5, 6]", "A*_args": "[\"[['x', '13', 'x', 'x', 'x', 'x', '3', '4', 'x', 'x', '9', 'x', '18', '7', '2'], ['1', '10', '17', 'x', 'x', 'x', '11', '13', 'x', '10', 'x', '9', '13', 'x', 'x'], ['x', 'x', '7', '18', 'x', 'x', 'x', 'x', '7', 'x', 'x', 'x', '1', 'x', '16'], ['10', 'x', 'x', 'x', '13', 'x', '2', '9', 'x', 'x', '8', 'x', 'x', '5', 'x'], ['x', '7', '12', 'x', '1', '18', '14', 'x', '7', 'x', 'x', '16', 'x', 'x', '19'], ['5', '1', '13', '17', '11', '14', '16', 'x', '14', 'x', '18', '5', 'x', '18', 'x'], ['x', '15', '19', '4', 'x', '13', 'x', '5', 'x', 'x', '18', 'x', '17', 'x', 'x'], ['3', '7', 'x', 'x', 'x', '12', 'x', 'x', '17', '4', 'x', '13', '19', '3', '10'], ['11', 'x', 'x', 'x', 'x', '2', '2', '19', '13', '4', '7', '17', '16', 'x', '17'], ['12', '5', '4', 'x', 'x', 'x', 'x', '12', '8', '11', 'x', '17', '14', '19', '2'], ['4', '10', 'x', 'x', '6', '11', '16', '17', 'x', 'x', '18', 'x', '17', 'x', 'x'], ['x', 'x', 'x', 'x', '11', '9', '18', '17', '12', 'x', 'x', 'x', 'x', 'x', '1'], ['18', '13', '7', 'x', 'x', '5', '4', '13', 'x', 'x', '19', '12', '1', '18', 'x'], ['15', 'x', '17', 'x', 'x', 'x', '17', 'x', 'x', 'x', '10', 'x', '15', '16', 'x'], ['x', 'x', '11', '15', 'x', 'x', '12', '16', '12', '13', '18', 'x', '17', '8', '15']]\", \"(5, 0)\", \"(7, 13)\", \"5\", \"6\"]"}
{"diff_sorted_id": "102", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 15x15. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 5 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (14, 13) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (2, 5). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 1 0 1 1 1 0 0 0 1 0 1 0 1 0\n0 1 0 0 1 0 0 0 0 1 0 1 1 1 0\n1 1 1 1 0 0 0 0 0 0 1 1 0 0 1\n1 1 1 1 0 0 1 1 0 1 1 1 1 0 0\n1 1 0 1 0 0 1 0 0 0 0 0 0 0 0\n1 0 1 0 1 1 1 0 1 1 0 1 0 0 1\n1 1 0 0 0 0 0 0 1 0 0 1 0 1 1\n0 1 1 1 1 1 0 0 1 1 0 1 0 1 1\n0 0 1 1 1 0 0 1 1 0 0 1 0 0 1\n1 1 1 1 1 0 1 0 0 1 1 0 0 0 0\n1 0 0 1 0 1 1 0 0 0 1 1 1 0 0\n0 0 0 1 0 0 1 1 0 1 0 0 0 0 0\n0 1 1 1 1 0 0 0 1 1 1 0 0 0 0\n1 1 1 1 1 1 0 0 0 1 1 0 0 0 0\n1 1 1 0 0 1 1 0 1 1 1 0 1 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[[14, 13], [13, 13], [12, 13], [11, 13], [10, 13], [9, 12], [9, 11], [8, 10], [7, 10], [6, 10], [5, 10], [4, 9], [3, 8], [2, 7], [2, 6], [2, 5]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.03172016143798828", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1], [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0], [1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1], [0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1], [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1]]\", 5]", "is_correct_args": "[\"[[1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1], [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0], [1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1], [0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1], [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1]]\", [14, 13], [2, 5], 5]", "A*_args": "[\"[[1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1], [1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0], [1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1], [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1], [0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1], [0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1], [1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0], [1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0], [1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1]]\", \"(14, 13)\", \"(2, 5)\", \"5\"]"}
{"diff_sorted_id": "103", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [40, 28, 46, 16, 13, 15, 38, 39, 3, 8, 40, 41, 18, 48, 16, 25, 39, 14, 47, 46, 31, 16, 41, 45, 9, 26, 33, 46, 17, 23, 6, 46, 7, 43, 10, 28, 47, 15, 35, 20, 32, 4, 32, 9, 48, 7, 34, 46, 10, 39, 44], such that the sum of the chosen coins adds up to 485. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {44: 6, 39: 15, 4: 2, 23: 11, 7: 2, 40: 10, 13: 10, 34: 8, 45: 9, 10: 3, 35: 18, 14: 2, 28: 5, 46: 12, 25: 3, 26: 18, 15: 11, 31: 2, 20: 15, 9: 7, 41: 13, 18: 16, 32: 11, 3: 3, 48: 20, 38: 4, 43: 6, 33: 9, 16: 13, 8: 4, 17: 1, 47: 17, 6: 5}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "33", "opt_solution": "[44, 38, 14, 25, 31, 28, 10, 4, 43, 34, 28, 45, 40, 10, 17, 33, 41]", "opt_solution_cost": "91", "opt_solution_compute_t": "0.0840153694152832", "solution_depth": "17", "max_successor_states": "51", "num_vars_per_state": "51", "is_feasible_args": "[[40, 28, 46, 16, 13, 15, 38, 39, 3, 8, 40, 41, 18, 48, 16, 25, 39, 14, 47, 46, 31, 16, 41, 45, 9, 26, 33, 46, 17, 23, 6, 46, 7, 43, 10, 28, 47, 15, 35, 20, 32, 4, 32, 9, 48, 7, 34, 46, 10, 39, 44]]", "is_correct_args": "[[40, 28, 46, 16, 13, 15, 38, 39, 3, 8, 40, 41, 18, 48, 16, 25, 39, 14, 47, 46, 31, 16, 41, 45, 9, 26, 33, 46, 17, 23, 6, 46, 7, 43, 10, 28, 47, 15, 35, 20, 32, 4, 32, 9, 48, 7, 34, 46, 10, 39, 44], {\"44\": 6, \"39\": 15, \"4\": 2, \"23\": 11, \"7\": 2, \"40\": 10, \"13\": 10, \"34\": 8, \"45\": 9, \"10\": 3, \"35\": 18, \"14\": 2, \"28\": 5, \"46\": 12, \"25\": 3, \"26\": 18, \"15\": 11, \"31\": 2, \"20\": 15, \"9\": 7, \"41\": 13, \"18\": 16, \"32\": 11, \"3\": 3, \"48\": 20, \"38\": 4, \"43\": 6, \"33\": 9, \"16\": 13, \"8\": 4, \"17\": 1, \"47\": 17, \"6\": 5}, 485]", "A*_args": "[\"[40, 28, 46, 16, 13, 15, 38, 39, 3, 8, 40, 41, 18, 48, 16, 25, 39, 14, 47, 46, 31, 16, 41, 45, 9, 26, 33, 46, 17, 23, 6, 46, 7, 43, 10, 28, 47, 15, 35, 20, 32, 4, 32, 9, 48, 7, 34, 46, 10, 39, 44]\", \"{44: 6, 39: 15, 4: 2, 23: 11, 7: 2, 40: 10, 13: 10, 34: 8, 45: 9, 10: 3, 35: 18, 14: 2, 28: 5, 46: 12, 25: 3, 26: 18, 15: 11, 31: 2, 20: 15, 9: 7, 41: 13, 18: 16, 32: 11, 3: 3, 48: 20, 38: 4, 43: 6, 33: 9, 16: 13, 8: 4, 17: 1, 47: 17, 6: 5}\", \"485\"]"}
{"diff_sorted_id": "103", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 36 to 92. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 295, 200, None for columns 1 to 2 respectively, and the sums of rows must be None, 234, 271, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 248. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['39' '47' 'x' 'x']\n ['x' 'x' 'x' '40']\n ['63' '82' '59' 'x']\n ['x' '78' 'x' 'x']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 2, 36], [0, 3, 42], [1, 0, 38], [1, 1, 88], [1, 2, 68], [2, 3, 67], [3, 0, 56], [3, 2, 37], [3, 3, 41]]", "opt_solution_cost": "881", "opt_solution_compute_t": "8.308101177215576", "solution_depth": "9", "max_successor_states": "36", "num_vars_per_state": "16", "is_feasible_args": "[\"[['39', '47', '', ''], ['', '', '', '40'], ['63', '82', '59', ''], ['', '78', '', '']]\", 4, 36, 92]", "is_correct_args": "[\"[['39', '47', '', ''], ['', '', '', '40'], ['63', '82', '59', ''], ['', '78', '', '']]\", 36, 92, [1, 3], [1, 3], [295, 200], [234, 271], 248]", "A*_args": "[\"[['39', '47', '', ''], ['', '', '', '40'], ['63', '82', '59', ''], ['', '78', '', '']]\", \"36\", \"92\", \"[None, 295, 200, None]\", \"[None, 234, 271, None]\", \"248\"]"}
{"diff_sorted_id": "103", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (2, 0) to his destination workshop at index (6, 14), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 2, district 2 covering rows 3 to 8, and district 3 covering rows 9 to 14. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[6 6 2 x 13 x x x x 11 x x x 3 x]\n[6 11 x 14 x x x 1 5 6 1 19 2 7 14]\n[16 4 12 13 17 4 x x x 14 x x 9 9 13]\n[x 11 6 14 x 16 x 1 10 18 11 x x 13 x]\n[x x 14 4 19 1 2 16 15 x 15 x x x x]\n[13 6 16 13 5 9 x 6 10 3 1 14 x 17 x]\n[x x 19 8 x 2 4 x x 4 9 13 13 11 5]\n[x 11 17 19 11 18 x 8 x x 17 17 13 9 15]\n[11 4 x 3 3 8 5 x x x 20 19 x x 12]\n[2 x x x x 16 7 13 4 x 7 16 x 5 1]\n[14 9 x x x x x x 19 x 14 20 11 16 x]\n[3 x 1 x 13 x 9 x 15 19 4 x x x 2]\n[x 8 x x x 6 x 16 x x x x 2 17 18]\n[x x 11 x x 14 6 x 15 x x 18 x x x]\n[8 x 5 1 7 14 x x x x 14 7 x 8 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "7", "opt_solution": "[[2, 0], [2, 1], [3, 1], [3, 2], [3, 3], [4, 3], [4, 4], [4, 5], [4, 6], [4, 7], [5, 7], [5, 8], [5, 9], [5, 10], [6, 10], [6, 11], [6, 12], [6, 13], [6, 14], [7, 14], [8, 14], [9, 14], [8, 14], [7, 14], [6, 14]]", "opt_solution_cost": "208", "opt_solution_compute_t": "0.028629302978515625", "solution_depth": "25", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"6\", \"6\", \"2\", \"x\", \"13\", \"x\", \"x\", \"x\", \"x\", \"11\", \"x\", \"x\", \"x\", \"3\", \"x\"], [\"6\", \"11\", \"x\", \"14\", \"x\", \"x\", \"x\", \"1\", \"5\", \"6\", \"1\", \"19\", \"2\", \"7\", \"14\"], [\"16\", \"4\", \"12\", \"13\", \"17\", \"4\", \"x\", \"x\", \"x\", \"14\", \"x\", \"x\", \"9\", \"9\", \"13\"], [\"x\", \"11\", \"6\", \"14\", \"x\", \"16\", \"x\", \"1\", \"10\", \"18\", \"11\", \"x\", \"x\", \"13\", \"x\"], [\"x\", \"x\", \"14\", \"4\", \"19\", \"1\", \"2\", \"16\", \"15\", \"x\", \"15\", \"x\", \"x\", \"x\", \"x\"], [\"13\", \"6\", \"16\", \"13\", \"5\", \"9\", \"x\", \"6\", \"10\", \"3\", \"1\", \"14\", \"x\", \"17\", \"x\"], [\"x\", \"x\", \"19\", \"8\", \"x\", \"2\", \"4\", \"x\", \"x\", \"4\", \"9\", \"13\", \"13\", \"11\", \"5\"], [\"x\", \"11\", \"17\", \"19\", \"11\", \"18\", \"x\", \"8\", \"x\", \"x\", \"17\", \"17\", \"13\", \"9\", \"15\"], [\"11\", \"4\", \"x\", \"3\", \"3\", \"8\", \"5\", \"x\", \"x\", \"x\", \"20\", \"19\", \"x\", \"x\", \"12\"], [\"2\", \"x\", \"x\", \"x\", \"x\", \"16\", \"7\", \"13\", \"4\", \"x\", \"7\", \"16\", \"x\", \"5\", \"1\"], [\"14\", \"9\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"19\", \"x\", \"14\", \"20\", \"11\", \"16\", \"x\"], [\"3\", \"x\", \"1\", \"x\", \"13\", \"x\", \"9\", \"x\", \"15\", \"19\", \"4\", \"x\", \"x\", \"x\", \"2\"], [\"x\", \"8\", \"x\", \"x\", \"x\", \"6\", \"x\", \"16\", \"x\", \"x\", \"x\", \"x\", \"2\", \"17\", \"18\"], [\"x\", \"x\", \"11\", \"x\", \"x\", \"14\", \"6\", \"x\", \"15\", \"x\", \"x\", \"18\", \"x\", \"x\", \"x\"], [\"8\", \"x\", \"5\", \"1\", \"7\", \"14\", \"x\", \"x\", \"x\", \"x\", \"14\", \"7\", \"x\", \"8\", \"x\"]]]", "is_correct_args": "[[[\"6\", \"6\", \"2\", \"x\", \"13\", \"x\", \"x\", \"x\", \"x\", \"11\", \"x\", \"x\", \"x\", \"3\", \"x\"], [\"6\", \"11\", \"x\", \"14\", \"x\", \"x\", \"x\", \"1\", \"5\", \"6\", \"1\", \"19\", \"2\", \"7\", \"14\"], [\"16\", \"4\", \"12\", \"13\", \"17\", \"4\", \"x\", \"x\", \"x\", \"14\", \"x\", \"x\", \"9\", \"9\", \"13\"], [\"x\", \"11\", \"6\", \"14\", \"x\", \"16\", \"x\", \"1\", \"10\", \"18\", \"11\", \"x\", \"x\", \"13\", \"x\"], [\"x\", \"x\", \"14\", \"4\", \"19\", \"1\", \"2\", \"16\", \"15\", \"x\", \"15\", \"x\", \"x\", \"x\", \"x\"], [\"13\", \"6\", \"16\", \"13\", \"5\", \"9\", \"x\", \"6\", \"10\", \"3\", \"1\", \"14\", \"x\", \"17\", \"x\"], [\"x\", \"x\", \"19\", \"8\", \"x\", \"2\", \"4\", \"x\", \"x\", \"4\", \"9\", \"13\", \"13\", \"11\", \"5\"], [\"x\", \"11\", \"17\", \"19\", \"11\", \"18\", \"x\", \"8\", \"x\", \"x\", \"17\", \"17\", \"13\", \"9\", \"15\"], [\"11\", \"4\", \"x\", \"3\", \"3\", \"8\", \"5\", \"x\", \"x\", \"x\", \"20\", \"19\", \"x\", \"x\", \"12\"], [\"2\", \"x\", \"x\", \"x\", \"x\", \"16\", \"7\", \"13\", \"4\", \"x\", \"7\", \"16\", \"x\", \"5\", \"1\"], [\"14\", \"9\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"19\", \"x\", \"14\", \"20\", \"11\", \"16\", \"x\"], [\"3\", \"x\", \"1\", \"x\", \"13\", \"x\", \"9\", \"x\", \"15\", \"19\", \"4\", \"x\", \"x\", \"x\", \"2\"], [\"x\", \"8\", \"x\", \"x\", \"x\", \"6\", \"x\", \"16\", \"x\", \"x\", \"x\", \"x\", \"2\", \"17\", \"18\"], [\"x\", \"x\", \"11\", \"x\", \"x\", \"14\", \"6\", \"x\", \"15\", \"x\", \"x\", \"18\", \"x\", \"x\", \"x\"], [\"8\", \"x\", \"5\", \"1\", \"7\", \"14\", \"x\", \"x\", \"x\", \"x\", \"14\", \"7\", \"x\", \"8\", \"x\"]], [2, 0], [6, 14], 2, 8]", "A*_args": "[\"[['6', '6', '2', 'x', '13', 'x', 'x', 'x', 'x', '11', 'x', 'x', 'x', '3', 'x'], ['6', '11', 'x', '14', 'x', 'x', 'x', '1', '5', '6', '1', '19', '2', '7', '14'], ['16', '4', '12', '13', '17', '4', 'x', 'x', 'x', '14', 'x', 'x', '9', '9', '13'], ['x', '11', '6', '14', 'x', '16', 'x', '1', '10', '18', '11', 'x', 'x', '13', 'x'], ['x', 'x', '14', '4', '19', '1', '2', '16', '15', 'x', '15', 'x', 'x', 'x', 'x'], ['13', '6', '16', '13', '5', '9', 'x', '6', '10', '3', '1', '14', 'x', '17', 'x'], ['x', 'x', '19', '8', 'x', '2', '4', 'x', 'x', '4', '9', '13', '13', '11', '5'], ['x', '11', '17', '19', '11', '18', 'x', '8', 'x', 'x', '17', '17', '13', '9', '15'], ['11', '4', 'x', '3', '3', '8', '5', 'x', 'x', 'x', '20', '19', 'x', 'x', '12'], ['2', 'x', 'x', 'x', 'x', '16', '7', '13', '4', 'x', '7', '16', 'x', '5', '1'], ['14', '9', 'x', 'x', 'x', 'x', 'x', 'x', '19', 'x', '14', '20', '11', '16', 'x'], ['3', 'x', '1', 'x', '13', 'x', '9', 'x', '15', '19', '4', 'x', 'x', 'x', '2'], ['x', '8', 'x', 'x', 'x', '6', 'x', '16', 'x', 'x', 'x', 'x', '2', '17', '18'], ['x', 'x', '11', 'x', 'x', '14', '6', 'x', '15', 'x', 'x', '18', 'x', 'x', 'x'], ['8', 'x', '5', '1', '7', '14', 'x', 'x', 'x', 'x', '14', '7', 'x', '8', 'x']]\", \"(2, 0)\", \"(6, 14)\", \"2\", \"8\"]"}
{"diff_sorted_id": "103", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 15x15. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 5 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (10, 1) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (3, 14). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 1 0 0 1 1 1 1 1 0 1 1 0 1\n0 1 1 1 1 0 1 1 1 1 1 0 0 1 1\n0 1 1 1 1 1 1 1 1 1 0 0 1 1 1\n1 0 1 0 0 1 1 1 0 1 1 1 0 0 0\n1 1 1 1 0 1 1 0 0 1 1 0 0 1 0\n1 1 1 1 0 0 0 0 0 0 1 0 0 1 1\n1 0 1 1 0 1 0 0 0 0 0 0 1 1 1\n1 0 0 0 1 1 0 1 1 1 1 0 0 1 0\n0 1 0 1 1 0 1 1 0 1 0 1 1 1 0\n0 0 0 0 0 0 0 0 0 0 1 1 0 0 1\n1 0 1 1 1 0 0 0 1 1 1 0 1 1 1\n1 1 1 1 0 1 1 1 0 0 0 0 0 0 1\n1 0 1 1 0 0 0 1 0 1 0 0 1 1 1\n1 1 0 1 1 0 1 1 0 1 1 0 1 0 1\n0 1 0 1 1 1 0 0 1 0 0 0 1 1 0", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[[10, 1], [9, 2], [9, 3], [9, 4], [8, 5], [7, 6], [6, 6], [6, 7], [6, 8], [6, 9], [6, 10], [6, 11], [5, 12], [4, 12], [3, 13], [3, 14]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.03287553787231445", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1], [0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1], [1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0], [1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1], [1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1], [1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0], [0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1], [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1], [0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0]]\", 5]", "is_correct_args": "[\"[[0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1], [0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1], [1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0], [1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1], [1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1], [1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0], [0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1], [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1], [0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0]]\", [10, 1], [3, 14], 5]", "A*_args": "[\"[[0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1], [0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1], [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1], [1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0], [1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0], [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1], [1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1], [1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0], [0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1], [1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1], [1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1], [0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0]]\", \"(10, 1)\", \"(3, 14)\", \"5\"]"}
{"diff_sorted_id": "104", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [18, 23, 23, 36, 27, 10, 25, 14, 6, 43, 6, 31, 5, 43, 3, 13, 16, 8, 11, 6, 39, 44, 41, 28, 12, 8, 1, 14, 22, 23, 11, 24, 37, 9, 2, 31, 27, 10, 9, 38, 37, 4, 4, 17, 18, 36, 18, 32, 3, 12, 4, 42, 8, 4, 4, 16, 30, 40, 13, 41], such that the sum of the chosen coins adds up to 441. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {6: 4, 18: 3, 38: 1, 23: 2, 16: 8, 12: 2, 4: 2, 24: 13, 28: 17, 30: 17, 1: 1, 9: 9, 27: 8, 11: 4, 37: 16, 41: 19, 13: 3, 31: 8, 44: 8, 22: 7, 43: 13, 10: 3, 17: 8, 36: 7, 39: 3, 25: 17, 40: 10, 8: 6, 32: 16, 14: 4, 2: 1, 42: 3, 3: 2, 5: 2}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "34", "opt_solution": "[42, 38, 12, 23, 23, 39, 36, 18, 12, 23, 18, 10, 13, 13, 43, 36, 18, 14, 10]", "opt_solution_cost": "69", "opt_solution_compute_t": "0.11116838455200195", "solution_depth": "19", "max_successor_states": "60", "num_vars_per_state": "60", "is_feasible_args": "[[18, 23, 23, 36, 27, 10, 25, 14, 6, 43, 6, 31, 5, 43, 3, 13, 16, 8, 11, 6, 39, 44, 41, 28, 12, 8, 1, 14, 22, 23, 11, 24, 37, 9, 2, 31, 27, 10, 9, 38, 37, 4, 4, 17, 18, 36, 18, 32, 3, 12, 4, 42, 8, 4, 4, 16, 30, 40, 13, 41]]", "is_correct_args": "[[18, 23, 23, 36, 27, 10, 25, 14, 6, 43, 6, 31, 5, 43, 3, 13, 16, 8, 11, 6, 39, 44, 41, 28, 12, 8, 1, 14, 22, 23, 11, 24, 37, 9, 2, 31, 27, 10, 9, 38, 37, 4, 4, 17, 18, 36, 18, 32, 3, 12, 4, 42, 8, 4, 4, 16, 30, 40, 13, 41], {\"6\": 4, \"18\": 3, \"38\": 1, \"23\": 2, \"16\": 8, \"12\": 2, \"4\": 2, \"24\": 13, \"28\": 17, \"30\": 17, \"1\": 1, \"9\": 9, \"27\": 8, \"11\": 4, \"37\": 16, \"41\": 19, \"13\": 3, \"31\": 8, \"44\": 8, \"22\": 7, \"43\": 13, \"10\": 3, \"17\": 8, \"36\": 7, \"39\": 3, \"25\": 17, \"40\": 10, \"8\": 6, \"32\": 16, \"14\": 4, \"2\": 1, \"42\": 3, \"3\": 2, \"5\": 2}, 441]", "A*_args": "[\"[18, 23, 23, 36, 27, 10, 25, 14, 6, 43, 6, 31, 5, 43, 3, 13, 16, 8, 11, 6, 39, 44, 41, 28, 12, 8, 1, 14, 22, 23, 11, 24, 37, 9, 2, 31, 27, 10, 9, 38, 37, 4, 4, 17, 18, 36, 18, 32, 3, 12, 4, 42, 8, 4, 4, 16, 30, 40, 13, 41]\", \"{6: 4, 18: 3, 38: 1, 23: 2, 16: 8, 12: 2, 4: 2, 24: 13, 28: 17, 30: 17, 1: 1, 9: 9, 27: 8, 11: 4, 37: 16, 41: 19, 13: 3, 31: 8, 44: 8, 22: 7, 43: 13, 10: 3, 17: 8, 36: 7, 39: 3, 25: 17, 40: 10, 8: 6, 32: 16, 14: 4, 2: 1, 42: 3, 3: 2, 5: 2}\", \"441\"]"}
{"diff_sorted_id": "104", "problem_statement": "In the magic square problem, a 4x4 grid is filled with unique integers ranging from 36 to 92. Some numbers are already given, while others are unknown and represented as 'x'. The sums of columns must be None, 300, 191, None for columns 1 to 2 respectively, and the sums of rows must be None, 214, 240, None for rows 1 to 2 respectively, where None means that we do not have any constraints on the sum of the numbers in the row or column at that index.  Also, the sum of the numbers in the diagonal from the top right to the bottom left corner of the grid should equal 249. The goal is to find unique integers (ie each number can be in the final grid only once) in the given range to replace with \u2018x\u2019s in the grid below such that the sum of the specified rows, columns, and diagonal equals the given amounts and the sum of all of the numbers in the grid is as low as possible. The solution should be provided as a list of tuples in Python syntax. Each tuple should contain three numbers for each 'x' position: the row index, the column index (both starting from 0), and the value of the unique integer replaced with 'x' at that position.\n\nGrid:\n [['x' '69' 'x' 'x']\n ['x' '62' 'x' 'x']\n ['x' '82' '40' 'x']\n ['x' '87' '78' '80']]", "problem_type": "magic_square", "problem_category": "underdetermined_system", "relative_diff_score": "10", "opt_solution": "[[0, 0, 38], [0, 2, 36], [0, 3, 39], [1, 0, 41], [1, 2, 37], [1, 3, 74], [2, 0, 42], [2, 3, 76], [3, 0, 91]]", "opt_solution_cost": "972", "opt_solution_compute_t": "599.0436754226685", "solution_depth": "9", "max_successor_states": "36", "num_vars_per_state": "16", "is_feasible_args": "[\"[['', '69', '', ''], ['', '62', '', ''], ['', '82', '40', ''], ['', '87', '78', '80']]\", 4, 36, 92]", "is_correct_args": "[\"[['', '69', '', ''], ['', '62', '', ''], ['', '82', '40', ''], ['', '87', '78', '80']]\", 36, 92, [1, 3], [1, 3], [300, 191], [214, 240], 249]", "A*_args": "[\"[['', '69', '', ''], ['', '62', '', ''], ['', '82', '40', ''], ['', '87', '78', '80']]\", \"36\", \"92\", \"[None, 300, 191, None]\", \"[None, 214, 240, None]\", \"249\"]"}
{"diff_sorted_id": "104", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (7, 2) to his destination workshop at index (4, 14), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 4, district 2 covering rows 5 to 8, and district 3 covering rows 9 to 14. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[x x 7 18 11 4 9 x 15 x x x 1 x x]\n[x x 14 x 10 x x x 8 x x 16 1 x x]\n[17 17 x x x x x 7 6 12 x x x 7 x]\n[x x x x 10 x x 18 1 11 4 x 13 10 16]\n[x x x 12 1 x x x 2 7 1 x 2 x 5]\n[x x 8 x 12 x x 5 17 x 2 x 4 10 18]\n[x x 4 19 1 x 18 7 x 10 3 x 19 16 19]\n[6 12 15 16 5 9 16 18 10 15 5 x 5 14 x]\n[x 16 8 17 12 11 16 8 9 9 7 4 5 20 3]\n[19 17 15 x x 17 x 3 2 2 11 7 8 16 1]\n[13 4 17 x x x x 5 x 18 16 15 19 4 x]\n[11 x x x x 12 x x x x x x 19 x x]\n[18 x x x 9 19 x 16 6 x 9 3 16 15 x]\n[x x x 10 x x 4 3 x 3 x 16 18 x 12]\n[x 13 x x x x x 10 5 x 17 x x 7 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "7", "opt_solution": "[[7, 2], [7, 3], [7, 4], [7, 5], [8, 5], [8, 6], [8, 7], [9, 7], [9, 8], [9, 9], [8, 9], [8, 10], [8, 11], [8, 12], [7, 12], [6, 12], [5, 12], [5, 13], [5, 14], [4, 14]]", "opt_solution_cost": "158", "opt_solution_compute_t": "0.03071141242980957", "solution_depth": "20", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"x\", \"x\", \"7\", \"18\", \"11\", \"4\", \"9\", \"x\", \"15\", \"x\", \"x\", \"x\", \"1\", \"x\", \"x\"], [\"x\", \"x\", \"14\", \"x\", \"10\", \"x\", \"x\", \"x\", \"8\", \"x\", \"x\", \"16\", \"1\", \"x\", \"x\"], [\"17\", \"17\", \"x\", \"x\", \"x\", \"x\", \"x\", \"7\", \"6\", \"12\", \"x\", \"x\", \"x\", \"7\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"10\", \"x\", \"x\", \"18\", \"1\", \"11\", \"4\", \"x\", \"13\", \"10\", \"16\"], [\"x\", \"x\", \"x\", \"12\", \"1\", \"x\", \"x\", \"x\", \"2\", \"7\", \"1\", \"x\", \"2\", \"x\", \"5\"], [\"x\", \"x\", \"8\", \"x\", \"12\", \"x\", \"x\", \"5\", \"17\", \"x\", \"2\", \"x\", \"4\", \"10\", \"18\"], [\"x\", \"x\", \"4\", \"19\", \"1\", \"x\", \"18\", \"7\", \"x\", \"10\", \"3\", \"x\", \"19\", \"16\", \"19\"], [\"6\", \"12\", \"15\", \"16\", \"5\", \"9\", \"16\", \"18\", \"10\", \"15\", \"5\", \"x\", \"5\", \"14\", \"x\"], [\"x\", \"16\", \"8\", \"17\", \"12\", \"11\", \"16\", \"8\", \"9\", \"9\", \"7\", \"4\", \"5\", \"20\", \"3\"], [\"19\", \"17\", \"15\", \"x\", \"x\", \"17\", \"x\", \"3\", \"2\", \"2\", \"11\", \"7\", \"8\", \"16\", \"1\"], [\"13\", \"4\", \"17\", \"x\", \"x\", \"x\", \"x\", \"5\", \"x\", \"18\", \"16\", \"15\", \"19\", \"4\", \"x\"], [\"11\", \"x\", \"x\", \"x\", \"x\", \"12\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"19\", \"x\", \"x\"], [\"18\", \"x\", \"x\", \"x\", \"9\", \"19\", \"x\", \"16\", \"6\", \"x\", \"9\", \"3\", \"16\", \"15\", \"x\"], [\"x\", \"x\", \"x\", \"10\", \"x\", \"x\", \"4\", \"3\", \"x\", \"3\", \"x\", \"16\", \"18\", \"x\", \"12\"], [\"x\", \"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"10\", \"5\", \"x\", \"17\", \"x\", \"x\", \"7\", \"x\"]]]", "is_correct_args": "[[[\"x\", \"x\", \"7\", \"18\", \"11\", \"4\", \"9\", \"x\", \"15\", \"x\", \"x\", \"x\", \"1\", \"x\", \"x\"], [\"x\", \"x\", \"14\", \"x\", \"10\", \"x\", \"x\", \"x\", \"8\", \"x\", \"x\", \"16\", \"1\", \"x\", \"x\"], [\"17\", \"17\", \"x\", \"x\", \"x\", \"x\", \"x\", \"7\", \"6\", \"12\", \"x\", \"x\", \"x\", \"7\", \"x\"], [\"x\", \"x\", \"x\", \"x\", \"10\", \"x\", \"x\", \"18\", \"1\", \"11\", \"4\", \"x\", \"13\", \"10\", \"16\"], [\"x\", \"x\", \"x\", \"12\", \"1\", \"x\", \"x\", \"x\", \"2\", \"7\", \"1\", \"x\", \"2\", \"x\", \"5\"], [\"x\", \"x\", \"8\", \"x\", \"12\", \"x\", \"x\", \"5\", \"17\", \"x\", \"2\", \"x\", \"4\", \"10\", \"18\"], [\"x\", \"x\", \"4\", \"19\", \"1\", \"x\", \"18\", \"7\", \"x\", \"10\", \"3\", \"x\", \"19\", \"16\", \"19\"], [\"6\", \"12\", \"15\", \"16\", \"5\", \"9\", \"16\", \"18\", \"10\", \"15\", \"5\", \"x\", \"5\", \"14\", \"x\"], [\"x\", \"16\", \"8\", \"17\", \"12\", \"11\", \"16\", \"8\", \"9\", \"9\", \"7\", \"4\", \"5\", \"20\", \"3\"], [\"19\", \"17\", \"15\", \"x\", \"x\", \"17\", \"x\", \"3\", \"2\", \"2\", \"11\", \"7\", \"8\", \"16\", \"1\"], [\"13\", \"4\", \"17\", \"x\", \"x\", \"x\", \"x\", \"5\", \"x\", \"18\", \"16\", \"15\", \"19\", \"4\", \"x\"], [\"11\", \"x\", \"x\", \"x\", \"x\", \"12\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"19\", \"x\", \"x\"], [\"18\", \"x\", \"x\", \"x\", \"9\", \"19\", \"x\", \"16\", \"6\", \"x\", \"9\", \"3\", \"16\", \"15\", \"x\"], [\"x\", \"x\", \"x\", \"10\", \"x\", \"x\", \"4\", \"3\", \"x\", \"3\", \"x\", \"16\", \"18\", \"x\", \"12\"], [\"x\", \"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"10\", \"5\", \"x\", \"17\", \"x\", \"x\", \"7\", \"x\"]], [7, 2], [4, 14], 4, 8]", "A*_args": "[\"[['x', 'x', '7', '18', '11', '4', '9', 'x', '15', 'x', 'x', 'x', '1', 'x', 'x'], ['x', 'x', '14', 'x', '10', 'x', 'x', 'x', '8', 'x', 'x', '16', '1', 'x', 'x'], ['17', '17', 'x', 'x', 'x', 'x', 'x', '7', '6', '12', 'x', 'x', 'x', '7', 'x'], ['x', 'x', 'x', 'x', '10', 'x', 'x', '18', '1', '11', '4', 'x', '13', '10', '16'], ['x', 'x', 'x', '12', '1', 'x', 'x', 'x', '2', '7', '1', 'x', '2', 'x', '5'], ['x', 'x', '8', 'x', '12', 'x', 'x', '5', '17', 'x', '2', 'x', '4', '10', '18'], ['x', 'x', '4', '19', '1', 'x', '18', '7', 'x', '10', '3', 'x', '19', '16', '19'], ['6', '12', '15', '16', '5', '9', '16', '18', '10', '15', '5', 'x', '5', '14', 'x'], ['x', '16', '8', '17', '12', '11', '16', '8', '9', '9', '7', '4', '5', '20', '3'], ['19', '17', '15', 'x', 'x', '17', 'x', '3', '2', '2', '11', '7', '8', '16', '1'], ['13', '4', '17', 'x', 'x', 'x', 'x', '5', 'x', '18', '16', '15', '19', '4', 'x'], ['11', 'x', 'x', 'x', 'x', '12', 'x', 'x', 'x', 'x', 'x', 'x', '19', 'x', 'x'], ['18', 'x', 'x', 'x', '9', '19', 'x', '16', '6', 'x', '9', '3', '16', '15', 'x'], ['x', 'x', 'x', '10', 'x', 'x', '4', '3', 'x', '3', 'x', '16', '18', 'x', '12'], ['x', '13', 'x', 'x', 'x', 'x', 'x', '10', '5', 'x', '17', 'x', 'x', '7', 'x']]\", \"(7, 2)\", \"(4, 14)\", \"4\", \"8\"]"}
{"diff_sorted_id": "104", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 15x15. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 5 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (14, 1) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (2, 10). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n0 1 1 1 0 0 1 1 0 0 1 0 1 1 1\n1 1 1 1 0 1 1 1 1 1 1 1 0 0 0\n1 1 0 0 0 0 0 1 0 0 0 0 1 1 0\n1 1 1 1 1 1 1 0 0 0 0 1 0 1 1\n1 1 1 1 0 1 0 0 0 0 0 0 1 1 1\n0 1 0 0 0 0 0 0 0 1 0 1 1 1 1\n1 1 0 1 1 1 0 0 0 1 0 1 0 0 1\n1 1 1 0 1 0 0 1 1 1 1 0 1 1 1\n1 1 1 0 0 0 1 1 0 0 1 1 0 0 1\n1 1 0 0 0 1 0 1 1 1 0 1 1 0 1\n0 0 0 0 0 1 1 1 0 1 1 1 1 1 1\n0 1 0 0 1 1 1 0 1 1 0 1 0 0 0\n1 0 1 0 1 1 1 1 0 1 1 0 1 1 1\n0 0 0 1 0 0 0 1 1 1 1 1 1 1 1\n0 0 1 1 1 1 1 0 1 1 1 1 1 0 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[[14, 1], [13, 1], [12, 1], [11, 2], [10, 2], [9, 2], [9, 3], [8, 3], [8, 4], [7, 5], [6, 6], [5, 6], [5, 7], [4, 7], [4, 8], [3, 9], [2, 10]]", "opt_solution_cost": "17", "opt_solution_compute_t": "0.026737689971923828", "solution_depth": "17", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1], [1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1], [1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1], [0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1]]\", 5]", "is_correct_args": "[\"[[0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1], [1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1], [1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1], [0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1]]\", [14, 1], [2, 10], 5]", "A*_args": "[\"[[0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1], [1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1], [1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1], [1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1], [1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1], [1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1], [1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1], [0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1]]\", \"(14, 1)\", \"(2, 10)\", \"5\"]"}
{"diff_sorted_id": "105", "problem_statement": "In the 'taxed coin exchange' problem, you are required to choose a subset of coins from this list [26, 8, 34, 12, 20, 21, 35, 13, 28, 5, 16, 11, 24, 42, 16, 12, 34, 21, 27, 27, 20, 47, 9, 12, 38, 23, 43, 33, 26, 22, 38, 42, 20, 41, 47, 41, 24, 46, 35, 42, 9, 35, 13, 45, 24, 29, 45, 2, 41, 39, 24, 38, 39, 18, 5, 8, 36], such that the sum of the chosen coins adds up to 477. Each coin in the list is unique and can only be used once. Also coins carry a tax value. The tax values for each coin is {12: 8, 18: 6, 42: 8, 11: 9, 38: 13, 9: 9, 24: 15, 34: 1, 20: 5, 2: 2, 23: 2, 33: 12, 27: 8, 39: 11, 16: 1, 28: 12, 26: 11, 21: 7, 35: 7, 22: 19, 47: 9, 29: 12, 46: 3, 45: 9, 5: 1, 13: 13, 43: 8, 36: 11, 41: 4, 8: 8}, where the tax for coins of the same value is the same. Also, if the coin chosen is smaller than the previous one, it must have an even value, otherwise, if the coin is larger than or equal to the previous coin chosen, it must have an odd value. The objective is to determine which subset of coins should be selected to minimize the total tax paid. The solution should be presented as a list of numbers, representing the value of the coins chosen in order, with the first coins chosen being in index 0, formatted in Python syntax.", "problem_type": "coin_exchange", "problem_category": "subset_sum", "relative_diff_score": "35", "opt_solution": "[46, 34, 16, 23, 16, 35, 41, 41, 41, 43, 42, 45, 34, 20]", "opt_solution_cost": "58", "opt_solution_compute_t": "0.04893088340759277", "solution_depth": "14", "max_successor_states": "57", "num_vars_per_state": "57", "is_feasible_args": "[[26, 8, 34, 12, 20, 21, 35, 13, 28, 5, 16, 11, 24, 42, 16, 12, 34, 21, 27, 27, 20, 47, 9, 12, 38, 23, 43, 33, 26, 22, 38, 42, 20, 41, 47, 41, 24, 46, 35, 42, 9, 35, 13, 45, 24, 29, 45, 2, 41, 39, 24, 38, 39, 18, 5, 8, 36]]", "is_correct_args": "[[26, 8, 34, 12, 20, 21, 35, 13, 28, 5, 16, 11, 24, 42, 16, 12, 34, 21, 27, 27, 20, 47, 9, 12, 38, 23, 43, 33, 26, 22, 38, 42, 20, 41, 47, 41, 24, 46, 35, 42, 9, 35, 13, 45, 24, 29, 45, 2, 41, 39, 24, 38, 39, 18, 5, 8, 36], {\"12\": 8, \"18\": 6, \"42\": 8, \"11\": 9, \"38\": 13, \"9\": 9, \"24\": 15, \"34\": 1, \"20\": 5, \"2\": 2, \"23\": 2, \"33\": 12, \"27\": 8, \"39\": 11, \"16\": 1, \"28\": 12, \"26\": 11, \"21\": 7, \"35\": 7, \"22\": 19, \"47\": 9, \"29\": 12, \"46\": 3, \"45\": 9, \"5\": 1, \"13\": 13, \"43\": 8, \"36\": 11, \"41\": 4, \"8\": 8}, 477]", "A*_args": "[\"[26, 8, 34, 12, 20, 21, 35, 13, 28, 5, 16, 11, 24, 42, 16, 12, 34, 21, 27, 27, 20, 47, 9, 12, 38, 23, 43, 33, 26, 22, 38, 42, 20, 41, 47, 41, 24, 46, 35, 42, 9, 35, 13, 45, 24, 29, 45, 2, 41, 39, 24, 38, 39, 18, 5, 8, 36]\", \"{12: 8, 18: 6, 42: 8, 11: 9, 38: 13, 9: 9, 24: 15, 34: 1, 20: 5, 2: 2, 23: 2, 33: 12, 27: 8, 39: 11, 16: 1, 28: 12, 26: 11, 21: 7, 35: 7, 22: 19, 47: 9, 29: 12, 46: 3, 45: 9, 5: 1, 13: 13, 43: 8, 36: 11, 41: 4, 8: 8}\", \"477\"]"}
{"diff_sorted_id": "105", "problem_statement": "Using the provided matrix map of a city, where numbers represent travel time in minutes (all numbers are positive integers) and 'x' marks closed workshops, find the quickest route for Ben to travel from his current workshop at index (1, 11) to his destination workshop at index (7, 2), indexing from 0. Ben's car can move north, south, east, or west from a given crossroad, provided there's no x in that direction. Also, there are 3 districts in the city with district 1 covering rows 0 to 1, district 2 covering rows 2 to 9, and district 3 covering rows 10 to 14. Ben has to visit at least 1 workshop in each district on his path to the destination. The roads are bidirectional. The answer should be a list of tuples (in Python syntax) indicating the index of workshops on Ben's path. The start and end workshops must be included in the path.\n[18 15 x x 1 x x 5 8 18 18 2 x 11 8]\n[x 17 x x 2 x 16 9 7 13 16 17 x x x]\n[10 x 1 14 1 10 15 4 x x 8 11 10 x x]\n[19 x x 9 8 18 5 2 12 x 13 x x 15 11]\n[1 x 14 6 6 6 x x x 13 13 x x x x]\n[2 3 8 5 7 x x x 19 x 16 x x x x]\n[x x 17 18 x 19 x x x 7 8 17 x x x]\n[4 x 4 14 17 6 x 2 x x 15 6 x 18 10]\n[7 x 3 11 10 x x 12 x x 8 x x 10 x]\n[4 16 2 11 x x 14 x 13 x x x x x x]\n[14 20 7 14 x x x x x x 5 x 10 16 x]\n[1 14 x x x 4 14 19 x 18 x x 17 15 14]\n[x x 15 x 4 5 19 18 x 19 11 3 12 x 10]\n[1 x 1 x x 13 x 16 4 x x 8 x 9 x]\n[x x 12 11 7 x 8 14 3 x 11 x 14 13 x]", "problem_type": "traffic", "problem_category": "pathfinding", "relative_diff_score": "7", "opt_solution": "[[1, 11], [1, 10], [1, 9], [1, 8], [1, 7], [2, 7], [3, 7], [3, 6], [3, 5], [4, 5], [4, 4], [4, 3], [5, 3], [5, 2], [6, 2], [7, 2], [8, 2], [9, 2], [10, 2], [9, 2], [8, 2], [7, 2]]", "opt_solution_cost": "147", "opt_solution_compute_t": "0.028675556182861328", "solution_depth": "22", "max_successor_states": "4", "num_vars_per_state": "4", "is_feasible_args": "[[[\"18\", \"15\", \"x\", \"x\", \"1\", \"x\", \"x\", \"5\", \"8\", \"18\", \"18\", \"2\", \"x\", \"11\", \"8\"], [\"x\", \"17\", \"x\", \"x\", \"2\", \"x\", \"16\", \"9\", \"7\", \"13\", \"16\", \"17\", \"x\", \"x\", \"x\"], [\"10\", \"x\", \"1\", \"14\", \"1\", \"10\", \"15\", \"4\", \"x\", \"x\", \"8\", \"11\", \"10\", \"x\", \"x\"], [\"19\", \"x\", \"x\", \"9\", \"8\", \"18\", \"5\", \"2\", \"12\", \"x\", \"13\", \"x\", \"x\", \"15\", \"11\"], [\"1\", \"x\", \"14\", \"6\", \"6\", \"6\", \"x\", \"x\", \"x\", \"13\", \"13\", \"x\", \"x\", \"x\", \"x\"], [\"2\", \"3\", \"8\", \"5\", \"7\", \"x\", \"x\", \"x\", \"19\", \"x\", \"16\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"17\", \"18\", \"x\", \"19\", \"x\", \"x\", \"x\", \"7\", \"8\", \"17\", \"x\", \"x\", \"x\"], [\"4\", \"x\", \"4\", \"14\", \"17\", \"6\", \"x\", \"2\", \"x\", \"x\", \"15\", \"6\", \"x\", \"18\", \"10\"], [\"7\", \"x\", \"3\", \"11\", \"10\", \"x\", \"x\", \"12\", \"x\", \"x\", \"8\", \"x\", \"x\", \"10\", \"x\"], [\"4\", \"16\", \"2\", \"11\", \"x\", \"x\", \"14\", \"x\", \"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"14\", \"20\", \"7\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"5\", \"x\", \"10\", \"16\", \"x\"], [\"1\", \"14\", \"x\", \"x\", \"x\", \"4\", \"14\", \"19\", \"x\", \"18\", \"x\", \"x\", \"17\", \"15\", \"14\"], [\"x\", \"x\", \"15\", \"x\", \"4\", \"5\", \"19\", \"18\", \"x\", \"19\", \"11\", \"3\", \"12\", \"x\", \"10\"], [\"1\", \"x\", \"1\", \"x\", \"x\", \"13\", \"x\", \"16\", \"4\", \"x\", \"x\", \"8\", \"x\", \"9\", \"x\"], [\"x\", \"x\", \"12\", \"11\", \"7\", \"x\", \"8\", \"14\", \"3\", \"x\", \"11\", \"x\", \"14\", \"13\", \"x\"]]]", "is_correct_args": "[[[\"18\", \"15\", \"x\", \"x\", \"1\", \"x\", \"x\", \"5\", \"8\", \"18\", \"18\", \"2\", \"x\", \"11\", \"8\"], [\"x\", \"17\", \"x\", \"x\", \"2\", \"x\", \"16\", \"9\", \"7\", \"13\", \"16\", \"17\", \"x\", \"x\", \"x\"], [\"10\", \"x\", \"1\", \"14\", \"1\", \"10\", \"15\", \"4\", \"x\", \"x\", \"8\", \"11\", \"10\", \"x\", \"x\"], [\"19\", \"x\", \"x\", \"9\", \"8\", \"18\", \"5\", \"2\", \"12\", \"x\", \"13\", \"x\", \"x\", \"15\", \"11\"], [\"1\", \"x\", \"14\", \"6\", \"6\", \"6\", \"x\", \"x\", \"x\", \"13\", \"13\", \"x\", \"x\", \"x\", \"x\"], [\"2\", \"3\", \"8\", \"5\", \"7\", \"x\", \"x\", \"x\", \"19\", \"x\", \"16\", \"x\", \"x\", \"x\", \"x\"], [\"x\", \"x\", \"17\", \"18\", \"x\", \"19\", \"x\", \"x\", \"x\", \"7\", \"8\", \"17\", \"x\", \"x\", \"x\"], [\"4\", \"x\", \"4\", \"14\", \"17\", \"6\", \"x\", \"2\", \"x\", \"x\", \"15\", \"6\", \"x\", \"18\", \"10\"], [\"7\", \"x\", \"3\", \"11\", \"10\", \"x\", \"x\", \"12\", \"x\", \"x\", \"8\", \"x\", \"x\", \"10\", \"x\"], [\"4\", \"16\", \"2\", \"11\", \"x\", \"x\", \"14\", \"x\", \"13\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\"], [\"14\", \"20\", \"7\", \"14\", \"x\", \"x\", \"x\", \"x\", \"x\", \"x\", \"5\", \"x\", \"10\", \"16\", \"x\"], [\"1\", \"14\", \"x\", \"x\", \"x\", \"4\", \"14\", \"19\", \"x\", \"18\", \"x\", \"x\", \"17\", \"15\", \"14\"], [\"x\", \"x\", \"15\", \"x\", \"4\", \"5\", \"19\", \"18\", \"x\", \"19\", \"11\", \"3\", \"12\", \"x\", \"10\"], [\"1\", \"x\", \"1\", \"x\", \"x\", \"13\", \"x\", \"16\", \"4\", \"x\", \"x\", \"8\", \"x\", \"9\", \"x\"], [\"x\", \"x\", \"12\", \"11\", \"7\", \"x\", \"8\", \"14\", \"3\", \"x\", \"11\", \"x\", \"14\", \"13\", \"x\"]], [1, 11], [7, 2], 1, 9]", "A*_args": "[\"[['18', '15', 'x', 'x', '1', 'x', 'x', '5', '8', '18', '18', '2', 'x', '11', '8'], ['x', '17', 'x', 'x', '2', 'x', '16', '9', '7', '13', '16', '17', 'x', 'x', 'x'], ['10', 'x', '1', '14', '1', '10', '15', '4', 'x', 'x', '8', '11', '10', 'x', 'x'], ['19', 'x', 'x', '9', '8', '18', '5', '2', '12', 'x', '13', 'x', 'x', '15', '11'], ['1', 'x', '14', '6', '6', '6', 'x', 'x', 'x', '13', '13', 'x', 'x', 'x', 'x'], ['2', '3', '8', '5', '7', 'x', 'x', 'x', '19', 'x', '16', 'x', 'x', 'x', 'x'], ['x', 'x', '17', '18', 'x', '19', 'x', 'x', 'x', '7', '8', '17', 'x', 'x', 'x'], ['4', 'x', '4', '14', '17', '6', 'x', '2', 'x', 'x', '15', '6', 'x', '18', '10'], ['7', 'x', '3', '11', '10', 'x', 'x', '12', 'x', 'x', '8', 'x', 'x', '10', 'x'], ['4', '16', '2', '11', 'x', 'x', '14', 'x', '13', 'x', 'x', 'x', 'x', 'x', 'x'], ['14', '20', '7', '14', 'x', 'x', 'x', 'x', 'x', 'x', '5', 'x', '10', '16', 'x'], ['1', '14', 'x', 'x', 'x', '4', '14', '19', 'x', '18', 'x', 'x', '17', '15', '14'], ['x', 'x', '15', 'x', '4', '5', '19', '18', 'x', '19', '11', '3', '12', 'x', '10'], ['1', 'x', '1', 'x', 'x', '13', 'x', '16', '4', 'x', 'x', '8', 'x', '9', 'x'], ['x', 'x', '12', '11', '7', 'x', '8', '14', '3', 'x', '11', 'x', '14', '13', 'x']]\", \"(1, 11)\", \"(7, 2)\", \"1\", \"9\"]"}
{"diff_sorted_id": "105", "problem_statement": "Alex is at a trampoline park with a grid of mini trampolines, arranged in a square of 15x15. Some trampolines are broken and unusable. A map of the park is provided below, with 1 indicating a broken trampoline and 0 indicating a functional one. Alex can jump to any of the eight adjacent trampolines, as long as they are not broken. However, Alex must make excatly 5 diagonal jumps, no more, no less, on his path to his destination. He is currently on the trampoline at position (12, 2) (positions are counted from 0, left to right, top to bottom) and wants to reach the trampoline at position (3, 13). What is the shortest sequence of trampolines he should jump on to reach his destination (including the first and final trampolines)? The answer should be a list of tuples, in Python syntax, indicating the row and column of each trampoline Alex jumps on. \n1 0 0 1 1 1 1 1 0 0 1 0 0 1 0\n1 1 0 0 0 1 1 1 1 1 0 1 0 1 0\n0 1 0 1 1 0 1 1 1 1 1 1 1 1 1\n0 0 1 0 1 0 1 1 0 0 0 1 0 0 0\n1 1 0 0 1 1 0 1 0 0 0 0 0 1 0\n1 1 1 0 0 0 0 1 0 1 0 0 1 1 0\n0 0 1 0 0 0 0 0 0 0 0 0 0 1 0\n0 0 1 0 1 1 0 0 1 1 1 0 0 1 1\n0 0 0 0 0 1 0 1 1 1 1 1 0 1 1\n0 0 0 0 1 1 0 0 0 1 1 0 1 1 1\n0 0 0 0 1 1 1 1 1 0 1 0 1 0 0\n1 0 0 0 1 1 1 0 0 0 0 1 1 0 1\n1 0 0 1 0 0 1 1 1 0 1 0 0 0 1\n1 1 1 1 0 0 0 1 1 0 0 1 0 1 1\n1 1 1 1 1 0 1 1 1 1 0 1 1 1 1", "problem_type": "trampoline_matrix", "problem_category": "pathfinding", "relative_diff_score": "15", "opt_solution": "[[12, 2], [11, 3], [10, 3], [9, 3], [8, 3], [7, 3], [6, 4], [6, 5], [6, 6], [6, 7], [5, 8], [4, 9], [4, 10], [4, 11], [3, 12], [3, 13]]", "opt_solution_cost": "16", "opt_solution_compute_t": "0.03443431854248047", "solution_depth": "16", "max_successor_states": "8", "num_vars_per_state": "2", "is_feasible_args": "[\"[[1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0], [1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0], [1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0], [1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1], [1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1], [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1]]\", 5]", "is_correct_args": "[\"[[1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0], [1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0], [1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0], [1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1], [1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1], [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1]]\", [12, 2], [3, 13], 5]", "A*_args": "[\"[[1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0], [1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0], [1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0], [1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1], [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1], [0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0], [1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1], [1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1], [1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1]]\", \"(12, 2)\", \"(3, 13)\", \"5\"]"}
